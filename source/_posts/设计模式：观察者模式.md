---
title: 设计模式：观察者模式
date: 2019-04-14 17:10:27
tags: 设计模式
categories: 设计模式
---

### 观察者模式

观察者模式是由观察者和观察对象组成的， 观察对象维护一组观察者，这组观察者依赖观察对象， 当观察对象的状态发生变化的时候， 会自动通知这组观察者发生动作。

一个观察对象由属于自己的一组观察者， 观察对象的作用是注册， 删除观察者， 以及在合适的时机触发观察者。

在其他书籍中对于观察者模式的一些定义如下：

>"One or more observers are interested in the state of a subject and register their interest with the subject by attaching themselves. When something changes in our subject that the observer may be interested in, a notify message is sent which calls the update method in each observer. When the observer is no longer interested in the subject's state, they can simply detach themselves."

在观察者模式中， 存在下面四种组成部分：

* 观察对象：维护一组观察者， 可以新增 / 删除观察者， 通知观察者发生变化的逻辑
* 观察者： 提供一个当观察者对象状态发生变化的时候进行状态变化的一个接口
* 观察对象实例： 当相关状态发生变化的时候通知观察者,
* 观察者实例： 具体化一个数据改变的接口， 这个观察者实例是和观察对象相关联的

下面是一个观察者模式的模型：

```js
// 一组观察者， 扩展了一些删除， 添加观察者的一些方法
class ObserverList {
  constructor () {
    this.observers = [];
  }
  append(ob) {
    this.observers.push(ob);
  }
  delete(obIndex) {
    this.observers.splice(obIndex, 1);
  }
  get(obIndex) {
    return this.observers[obIndex];
  }
  clear() {
    this.observers = [];
  }
  count() {
    return this.observers.length;
  }
  getList() {
    return this.observers;
  }
}

// 观察者， 提供了一个 update 接口
class Observer {
  constructor (cb) {
    this.cb = cb;
  }
  update() {
    this.cb();
  }
}

// 观察者对象
class Subject {
  constructor() {
    // 维护一组观察者
    this.observerList = new ObserverList();
  }
  add(ob) {
    this.observerList.append(ob);
  }
  notify() {
    for (let ob of this.observerList.getList()) {
      ob.update();
    }
  }
  remove(obIndex) {
    this.observerList.delete(obIndex);
  }
}

const subject = new Subject();
const observer = new Observer(action);

const action = () => {
  console.log('hello world');
};

// 注册观察者
subject.add(observer);

// 通知与之依赖的观察者动作
subject.notify();

```

上面的观察者模式， 其实可以使用下面的图进行说明：

{% asset_img 图片 observer.jpg %}

在上面的代码中， 我们可以发现， 观察者和观察者对象之间是相互依赖的， 观察者对象维护者一组观察者， 观察者对象需要做的是通知相关观察者进行更新。

### 和发布/订阅模式的区别

上面的代码使用发布/订阅模式实现如下：

```js
class EventMananger {
  constructor() {
    this.events = {};
  }
  publish(event) {
    if (!this.events[event]) return false;
    let eventCount = this.events[event].length;
    while (eventCount--) {
      this.events[event][eventCount]();
    }
  }
  subscribe(event, fn) {
    (this.events[event] || (this.events[event] = [])).push(fn);
  }
}

const mananger = new EventMananger();

mananger.subscribe('action', action);

mananger.publish('action');
```

两者区别：

1. 对于观察者模式， 其订阅和发布消息是在同一个对象上面进行的（subject）， 对于发布订阅模式， 其角色有三种， 订阅者， 发布者 以及 中间存放方法的事件列表。
2. 发布订阅模式发布者和订阅者之间不存在耦合关系， 对于观察者模式， 观察者依赖观察对象， 这两者之间是松耦合关系
3. 发布订阅模式应用于跨应用的情况下， 当多个应用之间进行通信的时候， 可以使用这种模式是实现通信， 对于 观察者模式， 主要应用于单个应用的情况。

两种方式在 vue 中的应用：

在 vue 源码中的 `$emit`  `$on` 方法中使用了发布/订阅模式：`vm._events` 作为事件通道， 存放函数列表。

`$on`

订阅者

```js
Vue.prototype.$on = function (event, fn) {
  var vm = this;
  if (Array.isArray(event)) {
    for (var i = 0, l = event.length; i < l; i++) {
      vm.$on(event[i], fn);
    }
  } else {
    // 将相关函数存入到 vm._events 中
    // vm._events 作为事件列表方法事件
    (vm._events[event] || (vm._events[event] = [])).push(fn);
    // optimize hook:event cost by using a boolean flag marked at registration
    // instead of a hash lookup
    if (hookRE.test(event)) {
      vm._hasHookEvent = true;
    }
  }
  return vm
};
```



`$emit`

发布者

 ```js
Vue.prototype.$emit = function (event) {
  var vm = this;
  {
    var lowerCaseEvent = event.toLowerCase();
    if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
      tip(
        "Event \"" + lowerCaseEvent + "\" is emitted in component " +
        (formatComponentName(vm)) + " but the handler is registered for \"" + event + "\". " +
        "Note that HTML attributes are case-insensitive and you cannot use " +
        "v-on to listen to camelCase events when using in-DOM templates. " +
        "You should probably use \"" + (hyphenate(event)) + "\" instead of \"" + event + "\"."
      );
    }
  }
  var cbs = vm._events[event];
  if (cbs) {
    cbs = cbs.length > 1 ? toArray(cbs) : cbs;
    var args = toArray(arguments, 1);
    var info = "event handler for \"" + event + "\"";
    // 触发相应的函数方法
    for (var i = 0, l = cbs.length; i < l; i++) {
      invokeWithErrorHandling(cbs[i], vm, args, vm, info);
    }
  }
  return vm
};
 ```



