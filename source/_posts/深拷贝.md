---
title: 深拷贝
date: 2021/2/27 上午10:39:45
tags: 深拷贝
categories: js
---

深拷贝和浅拷贝的区别：

`浅拷贝` : 当对于一个对象进行浅拷贝的时候，会创建一个新的对象，新对象包含有旧对象的所有属性，当属性值为基本类型时，拷贝的就是这个基本类型的值，当属性值为引用类型的时候，拷贝的是这个引用类型的内存地址

`深拷贝`：将一个对象从内存中完整的拷贝出来，开辟一个新的区域存储新对象，并且修改新对象不会影响旧对象

###### 实现深拷贝

* 使用 `JSON.parse(JSON.stringify())`

  这种最简单的实现深拷贝的方法同时存在许多的缺点

  ```javascript
  
  let obj = {
    date: new Date(),
    nan: NaN,
    function: new Function(),
    undefined: undefined,
    regexp: new RegExp('\\w+'),
    symbol: Symbol('symbol')
  }
  
  function deepClone(obj) {
    return JSON.parse(JSON.stringify(obj))
  }
  
  let cloneObj = deepClone(obj)
  
  console.log(cloneObj)
  // 打印结果如下
  { date: '2021-02-26T07:22:37.173Z', nan: null, regexp: {} }
  ```

  使用这种方法进行深拷贝的时候，对于上面一些特殊的属性值，会出现拷贝异常的情况：

  * `undefined`, `symbol`, `函数` 会被忽略掉
  * `NaN` 会被转换为 `null`
  * `regexp` 会被转换为 空对象
  * `date` 对象会被转换为日期字符串

  同时，无法拷贝循环引用的对象

* 一种 `cloneDeep` 的方法：

  ```javascript
  function cloneDeep(value) {
    if(typeof value === 'object' && value !== null) {
      const isArray = Array.isArray(value)
      let result = isArray ? [] : {}
      if (isArray) {
        value.forEach(val => {
          result.push(cloneDeep(val))
        })
      } else {
        for (let k in value) {
          result[k] = cloneDeep(value[k])
        }
      }
      return result
    } else return value
  }
  ```

  



