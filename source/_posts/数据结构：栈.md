---
title: 数据结构：栈
date: 2019-09-28 17:05:33
tags: 栈
categories: 数据结构
---

栈是一种特殊的线性表，这种线性表仅允许在表尾（栈顶）进行插入和删除工作：

将可以被插入和删除元素的位置称为`栈顶`， 将另一端称为 `栈底`， 如果栈没有任何的元素， 这个栈被称为 `空栈`；

栈的数据元素的进出遵循后进先出的原则，简称为  *LIFO (Last In First Out)* 结构；

栈的插入被称为入栈， 栈的删除被称为出栈， 在程序中我们可以将其称为 `push` 和 `pop`;

在 js 中， 我们使用数组的 `push` 和 `pop` 方法模拟栈的入栈和出栈操作；

### 栈的应用

1. 递归

   我们将调用函数自身或者间接调用自身的函数称为 *递归*

    在每一层递归的过程中， 我们需要存储当前调用函数的局部变量， 参数值等数据信息存储到栈中，当递归返回之后， 再将这些数据从栈中弹出数据

2. 使用栈实现四则运算表达式

   如下面程序， 实现将一串运算表达式进行计算的代码：

   ```js
   // 对于逆波兰法表示的后缀表达式计算求值
   function RPNcompute(mathStrStack) {
     let stack = [];
     for (let num of mathStrStack) {
       if (Number.isNaN(+num)) {
         const num1 = stack.pop();
         const num2 = stack.pop();
         const total = num2 + num + num1;
         stack.push(eval(total));
       } else {
         stack.push(num);
       }
     }
     return stack.pop();
   }
   
   // 将中缀表达式转为后缀表达式
   function toPostFixExpression(expression) {
     let expressionArr = expression.split(' ');
     let stack = [];
     let outputStr = '';
     // 处理符号入栈与出栈
     function pushStack(s) {
       let result = '';
       if (!stack.length) {
         stack.push(s);
         return '';
       };
       while (stack.length) {
         let stackTopData = stack.pop();
         if (s === ')') {
           if (stackTopData === '(') break;
           result += stackTopData + ' ';
         } else if (['+', '-', '*', '/'].includes(s)){
           const isLower = ['+', '-'].includes(s);
           // 当栈顶元素优先级大于等于当前入栈元素时， 栈顶元素依次出栈
           if (['/', '*'].concat(isLower ? ['+', '-'] : []).includes(stackTopData)) {
             result += stackTopData + ' ';
             if (!stack.length) {
               stack.push(s);
               break;
             };
           } else {
             stack.push(stackTopData);
             stack.push(s);
             break;
           }
         } else {
           stack.push(stackTopData);
           stack.push(s);
           break;
         }
       }
       return result;
     }
     for (let num of expressionArr) {
       if (Number.isNaN(+num)) {
         outputStr += pushStack(num);
       } else {
         outputStr += `${num} `;
       }
     }
     return outputStr + stack.reverse().join(' ');
   }
   
   
   function compute(mathStr) {
     let stackArr = toPostFixExpression(mathStr).split(' ');
     return RPNcompute(stackArr);
   }
   // 示例：
   compute('9 + ( 3 - 1 ) * 3 + 10 / 2');
   // 20
   compute('9 + 3 * ( 2 + 2 / 2 ) - 10 / 5');
   // 16
   ```

关于 中缀表达式转后缀表达式（逆波兰）法规则如下:

从左到右遍历中缀表达式的每个数字和符号，如果是数字那么就输出，成为后缀表达式的一部分，如果是符号， 那么判断该符号与栈顶符号的优先级，是右括号或者优先级低于等于栈顶符号， 那么栈顶符号依次出栈并输出，并将当前符号进栈， 一直到最终输出后缀表达式为止。

运算符号优先级： 乘除 > 加减

对于后缀表达式的计算规则如下：

从左到右遍历后缀表达式的每个数字和符号，如果遇到数字那么就入栈，遇到是符号， 那么就将处于栈顶的两个数字出栈， 进行运算，并将运算结果入栈， 一直到最终获得到结果。

