<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[实现mechine函数]]></title>
    <url>%2F2019%2F04%2F01%2F%E5%AE%9E%E7%8E%B0mechine%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[机器可以按照一定的顺序对于零件进行加工， 在程序中， 我们也可以实现一个机器函数， 这个函数可以按照我们调用函数的顺序进行执行。 实现一个类似于 mechine 的函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * * @param &#123;String&#125; machineName 机器名称 * @description 机器函数 */function machine(machineName) &#123; let fnList = []; fnList.push(() =&gt; &#123; console.log(`start $&#123;machineName&#125;`); &#125;); const doFnMap = &#123; do(doName) &#123; console.log(`do $&#123;doName&#125;`); &#125;, // 执行机器函数 execute() &#123; const handleFn = () =&gt; &#123; if (fnList.length &gt; 0) &#123; const fnNow = fnList.shift(); const fnVal = fnNow(); if (fnVal instanceof Promise) &#123; fnVal.then(() =&gt; &#123; handleFn(); &#125;); &#125; else &#123; handleFn(); &#125; &#125; else &#123; console.log(`end $&#123;machineName&#125;`); &#125; &#125;; handleFn(); &#125;, // 执行机器前等待时间 waitFirst(time) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(`wait first $&#123;time&#125;s`); resolve(); &#125;, time * 1000); &#125;); &#125;, waitEnd(time) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(`wait end $&#123;time&#125;s`); resolve(); &#125;, time * 1000); &#125;); &#125;, // 执行过程中等待时间 wait: (time) =&gt; &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(`wait $&#123;time&#125;s`); resolve(); &#125;, time * 1000) &#125;) &#125; &#125;; let proxy; // proxy 代理拦截 // 获取到需要执行的函数名之后，将其放入执行函数队列数组 proxy = new Proxy(doFnMap, &#123; get: function (target, property) &#123; return (...args) =&gt; &#123; if (property !== 'execute') &#123; if (property === 'waitFirst') &#123; fnList.unshift(() =&gt; &#123; return target.waitFirst(args); &#125;); &#125; else &#123; fnList.push(() =&gt; &#123; return target[property](args); &#125;); &#125; return proxy; &#125; else &#123; return doFnMap.execute(); &#125; &#125;; &#125; &#125;); return proxy;&#125; 执行效果如下： 1machine('machine').waitFirst(3).do('eat').do('run').wait(5).do('sleep').execute() 执行结果： 上面代码的主要思路是， 通过使用 proxy 获取到每一次的动作， 将每一次的函数存放到一个函数list 数组中， 当执行 execute 的时候， 依次执行数组中的函数， 在执行过程中进行判断， 当判断为 wait或者 waitFirst 函数的时候， 等待 wait 或者 waitFirst 函数执行完毕之后执行： 12345678// 对于 wait 或者 waitFirst 函数执行完毕之后返回了一个 promiseif (fnVal instanceof Promise) &#123; fnVal.then(() =&gt; &#123; handleFn(); &#125;);&#125; else &#123; handleFn();&#125; 在执行过程中， 当调用执行方法的时候， 在代码中通过使用 proxy 进行拦截处理： 1234567891011121314151617181920proxy = new Proxy(doFnMap, &#123; get: function (target, property) &#123; return (...args) =&gt; &#123; if (property !== 'execute') &#123; if (property === 'waitFirst') &#123; fnList.unshift(() =&gt; &#123; return target.waitFirst(args); &#125;); &#125; else &#123; fnList.push(() =&gt; &#123; return target[property](args); &#125;); &#125; return proxy; &#125; else &#123; return doFnMap.execute(); &#125; &#125;; &#125; &#125;); 使用 Proxy 方法用于对一个对象的属性访问和获取进行拦截， 在上面的代码中， 使用 proxy 中的 get 方法，设置了当调用 doFnMap 中的方法的时候， 调用get 方法，在 get 方法中， 可以用来将将要执行的函数方法推入到函数数组列表中以及调整函数的执行顺序。]]></content>
      <categories>
        <category>代码集</category>
      </categories>
      <tags>
        <tag>mechine 函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式（五）：括号与正则符号优先级]]></title>
    <url>%2F2019%2F02%2F05%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[括号作用提供分组和分支结构分组和分支结构是括号中的基础使用， 作用是提供一个子表达式 分组使用括号进行分组， 用来表明括号内的所有字符是一个组合， 从而对于括号内的字符组合进行范围限定， 可以对于整个括号添加量词， 表明匹配括号内的元素进行整体量词限定： 123let str = 'abababc ab';let regex = /(ab)+/g;str.match(regex); // Array(2) ["ababab", "ab"] 分支结构我们在正则中使用 | 表明匹配 | 符号左边或者右边的正则， 使用括号包裹| 用来限定 | 的作用范围， 例如： 12345let str = 'ab ac';let regex = /a(b|c)/g;// 如果不加上括号 regex = /ab | c/g 那么匹配的是 ab 或者 c// 加上括号表明分支结构只有 b 和 cstr.match(regex); // ['ab', 'ac'] 在使用 match 的时候，添加全局标识符 g 加不加是不同的： 上面的代码如果不用添加 g 标识符， 那么返回结果如下：不会进行全局匹配， 只会匹配到 ab 就会返回。 12345&gt; let str = 'ab ac';&gt; let regex = /a(b|c)/;&gt; str.match(regex);&gt; // ['ab', 'b']&gt; 分组引用在正则中使用括号进行包裹正则表达式时， 正则引擎会对于正则表达式进行分组，正则引擎会在匹配过程中， 给每一个分组都开辟一个内存空间， 用来存储每一个分组匹配到的数据。 例如， 我们想要对于日期进行匹配： 123let date = &apos;2019-02-05&apos;;let regex = /(\d&#123;4&#125;-(\d&#123;2&#125;)-(\d&#123;2&#125;))/;date.match(regex); // [&quot;2018-02-02&quot;, &quot;2018&quot;, &quot;02&quot;, &quot;02&quot;] 这里使用 match 进行匹配的正则表达式中没有包含有标识符 g， 因此使用 match 与使用 exec 的返回结果是一样的。 符号的优先级在正则表达式中， 使用操作符进行操作的时候， 需要规定操作符的优先级， 用来表示操作符是谁先操作， 谁后操作， 在正则表达式中， 各种操作符的优先级如下： 从上到下： 描述符 操作符 转义符 \ 括号与方括号 (...) (?:...) (?=...) (?!...) [...] 量词限定符 {m} {m, n} {m, } ? * + 位置和序列 ^ $ \元字符 一般字符 管道符 ` ` 上面的操作符从上到下， 优先级从高到低； 示例： /ab?(c|de*)+|fg/ 上面的操作过程如下： 因为在正则中存在管道符 | 用于分割为 ab?(c|de*)+ 和 fg 两个部分， 先执行这两个部分： 执行 ab?(c|de*)+: 在这个过程中，先执行括号内的正则， 然后执行字符 a, b ? 以及 +, 在括号内 c|de* 的执行顺序中， 先执行 c, de*, 其中 * 是和 e 在一起的， 因此 * 限定的量词是 e; 如下： 匹配一个字符串， 字符串中的字符为 a , b, c 中的一个， 并且， 字符串的长度为 3 的倍数； 1let regexp = /([abc]&#123;3&#125;)+/; 这里是将量词 3 使用括号进行包裹 如下： 匹配一个 ipv4 的地址：IP4 的地址的结构为这种形式： 3位数.3位数.3位数.3位数 其中 3 位数的数字范围为 0 - 255， 因此， 对于一位数而言， 可以这样写： 1/0&#123;0,2&#125;\d+/ // 匹配 000 - 009 对于两位数而言， 进行匹配： 1/0?\d&#123;2&#125;/ 对于三位数而言， 需要进行匹配： 1/1\d&#123;2&#125;/ // 匹配 100 - 199 1/2[0-4]\d/ // 匹配 200 - 249 1/25[0-5]/ // 匹配 250 -255 上面的这几种匹配结构为或的关系， 因此， 上面几种结构使用管道符 | 进行连接： 1(0&#123;0,2&#125;\d|0?\d&#123;2&#125;|1\d&#123;2&#125;|2[0-4]\d|25[0-5]) 匹配. 号： 1/^((0&#123;0,2&#125;\d|0?\d&#123;2&#125;|1\d&#123;2&#125;|2[0-4]\d|25[0-5])\.)(0&#123;0,2&#125;\d|0?\d&#123;2&#125;|1\d&#123;2&#125;|2[0-4]\d|25[0-5])$/ 上面的也可以第二部分可以使用 \2 进行代替： 1/^((0&#123;0,2&#125;\d|0?\d&#123;2&#125;|1\d&#123;2&#125;|2[0-4]\d|25[0-5])\.)\2$/]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式（四）：匹配]]></title>
    <url>%2F2019%2F02%2F04%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6%EF%BC%8C-%E5%8C%B9%E9%85%8D%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[正则表达式中的位置匹配： 正则表达式是匹配模式， 要么匹配字符， 要么匹配位置 对于位置匹配， 这里的位置是字符之间的间隙， 进行位置匹配时， 使用正则表达式中存在下面几个‘锚’： ^ $ \b \B (?=p) (?!p) 字符 匹配含义 ^ 匹配字符串的开头 $ 匹配字符串的结尾 \b 单词边界， 具体就是 \w 与 \W 之间的位置, 以及字符串的开始位置和结尾位置 \B 是 /b 之外的位置 (?=P) p 是一个模式， 这个正则表达式匹配的是P 之前的位置， 或者当前位置之后的字符要匹配正则表达式 P (?!P) 这个与 (?=P) 意思相反， 是除了 (?=P) 之外的位置 ^ 以及 $用于匹配字符串开头或者字符串结尾的位置： 如下例子：将字符的开头和结尾添加特定的字符： 1234let str = &apos;hello&apos;;let regex = /^|$/g;let res = str.replace(regex, &apos;*&apos;);console.log(res); // &apos;*hello*&apos; 例如下面， 使用 replace 代替 trim 方法： 1234let str = ' hell o ';let regex = /^\s+|\s+$/g;let res = str.replace(regex, '');// hell o \b 以及 \B使用 \b 的作用是匹配单词边界之间的位置， 具体而言是 \w 以及 \W 之间的位置： \w: 匹配单词字符， 字符包括字母， 汉字， 下划线以及数字 示例如下： 1234let str = 'hel lo';let regex = /\b/g;let res = str.replace(regex, '#');// #hel# #lo# 使用 \B 则和 \b 相反， 匹配的位置是单词字符内的位置： 123regex = /\B/g;res = str.replace(regex, '#');// h#e#l l#o; (?=P) 以及 (?!P)使用 (?=P) 用来匹配特定字符前的位置, P 是一个正则表达式； 如下： 给单词中的 l 字符前面添加字符 #: 1234regex = /(?=l)/g;str = 'hello';let res = str.replace(regex, '#');// he#l#lo 给每一个单词字符前面添加一个字符 * 1234regex = /(?=\w)/g;str = &apos;hello&apos;;let res = str.replace(regex, &apos;*&apos;);// *h*e*l *l*o 使用 (?!P) 用来匹配除了匹配到的正则表达式 P 之前位置之外的其他位置： 例如上面的例子， 我们使用 (?!P) 来代替 (?=P): 1234567regex = /(?!l)/;str = 'hello';let res = str.replace(regex, '*');// *h*ell*o*// 当我们仅仅想匹配到单词内部的时候regex = /(?!l)(?!^)(?!$)/;// h*ell*o 这里的 (?!^)(?!$) 是匹配除了单词开头和结尾的位置， 这里可以使用 /B 来进行代替; regex = /(?!l)(\B)/ 如下， 给一个数字添加千位分隔符 ‘,’ 123let str = "12345678";let regex = /(?!^)(?=(\d&#123;3&#125;)+$))/g;let res = str.replace(regex, ','); // 12,345,678 分析： 给一个数字添加一个千位字符的时候， 我们需要在字符尾部向前查找三位字符， 在三位字符前面的位置处添加分隔符 ‘ ,’; 1(\d&#123;3&#125;)+$ // 匹配结尾处向前 3 个或者多个 3 字符倍数的字符 1(?=(\d&#123;3&#125;)+$) // 匹配 3 个字符或者 3 个字符倍数的字符前面的位置 1(?!^) // 匹配非开头的位置 如下， 给钱数添加人民币符号 ¥ 1234let number = '1234';let regex = /(?=^)/;let res = number.replace(regex, '¥ ');// ¥ 1234 如下： 判断一段字符中必须包含有数字： 12345let str = 'str123';let regex = /(?=.*[0-9])^/g;// 这里的 ^ 表示开头， 这个正则表达式表示开头的位置， 也就是开头之后的字符需要匹配 .*[0-9]// .*[0-9] 表示任意字符长度后面都需要一个数字， 也就是需要匹配到的字符串必须包含有数字let res = regex.test(str); // true 如下： 判断字符中不能全部为数字, 可以使用 ?!P 进行判断 判断字符中不能全部为数字的反义为全部为数字：那么判断全部为数字的正则表达式为： 12// 判断6位字符串中全部为数字let regex = /(?=[0-9]&#123;6&#125;)/ 因为 ?! 和 ?= 互为反义， 因此， 判断不能全部为数字的正则如下： 12345let regex = /(?![0-9]&#123;6&#125;)/let str = '123456';regex.test(str); // falsestr = 'a23456';regex.test(str); // true]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式（三）：一些例子]]></title>
    <url>%2F2019%2F01%2F27%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%B8%80%E4%BA%9B%E4%BE%8B%E5%AD%90%2F</url>
    <content type="text"><![CDATA[下面是使用正则表达式的一些示例： 实现密码输入以英文字母开头， 密码长度为 8 到 16 位， 密码限为字符， 数字和下划线。 1let pattern = /^[a-zA-a]\w&#123;7, 15&#125;/; 验证是否含有^%&amp;’’,;=?$”等字符 12let pattern = /[\^%&amp;$&quot;.&apos;=?]/;// &quot;\&quot; 用于转义 `^` 整数正则 1let pattern = /^-?\d+$/; 匹配数字， 小数点后最大两位小数 1let pattern = /^\d+/.?\d&#123;0, 2&#125;$/; 手机号码的匹配 1let pattern = /^1[34578]\d&#123;9&#125;$/; 匹配16进制颜色值 1234// 比如匹配如下的颜色// #ffbbad #Fc01DF #FFF #ffElet pattern = /[0-9a-fA-F]&#123;6&#125; | [0-9a-fA-F]&#123;3&#125;/;// 使用 | 用来表示正则表达式中分支结构 匹配 24 小时时间 123// 例如匹配 23:59 和 02:12// 使用 () 对于正则表达式进行分组使用， 在 （） 内使用 | 只会作用到括号内的正则内容let pattern = /^([01][0-9] | [2][0-4]):[0-5][0-9]/; 匹配日期 例如： 我们想要匹配 “YYYY-mm-dd” 的日期格式： 1let pattern = /^[0-9]&#123;4&#125;-([0][0-9] | [1][0-2])-(0[1-9] | [12][0-9] | [3][01])/; 匹配 innerHTML 中的类名 如果我们想要进行匹配这样一个innterHtml 中的类名： 1234567let innerHtml = '&lt;div class="content"&gt;&lt;div class="body"&gt;&lt;/div&gt;&lt;/div&gt;';pattern = /class=".*?"/i;test = innerHtml.match(pattern)[0];// class="content"// 使用 ？进行的是贪婪匹配， 会匹配尽量少的字符 对于字符串中的 trim 方法：使用正则表达式清除字符串两边的空格： 123let str = &apos; hello &apos;;let regex = /^\s+|\s+$/g;let res = str.replace(regex, &apos;&apos;); // hello]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式（二）：基础方法]]></title>
    <url>%2F2019%2F01%2F20%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[下面是一些正则表达式的一些常用方法： 正则表达式中的属性和方法创建了正则表达式之后， 返回的是一个正则表达式的实例，返回的实例中包含有正则的一些属性方法。 我们可以在 控制台中打印正则实例， 可以看到其继承的所有的属性和方法如下： 例如： 1234let pattern = /.at/g;let str = &apos;bat, cat&apos;;let matches = pattern.exec(str);console.log(&apos;lastIndex&apos;, pattern.lastIndex); // 3 一些属性 属性 含义 示例 lastIndex 下一次匹配在字符串中的起始位置, 当前匹配到字符串的下一个字符的位置 ， 注意， 当前缺少修饰符 g 的时候， 这个值始终是 0 上面的例子中， 匹配完了 bat 之后， 后面将要进行匹配的是 , 位置为 3 flags(es6) 获取当前正则的修饰符 g global 布尔值， 表示是否设置了 g 标志 pattern.global: true ignoreCase 布尔值， 表示是否设置了 i 标志 multiline 表示是否设置了 m sticky 表示是否这种了 y 标志 dotall es2018 表示是否含有 s 修饰符 source 表示当前的匹配字符串 “.at” Tips: 使用 lastIndex 是可以改变的， 使用 lastIndex 可以决定需要进行开始匹配的位置 1234567let pattern = new RegExp('.at', 'g');let str = "cat, bat";pattern.lastIndex = 4;let matches = pattern.exec(str);// matches// [ 'bat', index: 5, input: 'cat, bat', groups: undefined ] 一些方法RegExp.prototype.test使用 test 方法用于判断在一个字符串中是含有能够匹配的到字符： 示例： 123let pattern = /test/g;let str = 'test string';pattern.test(str); // true 123let pattern = /[cb]at/g;let str = "cat, bat";pattern.test(str); // true RegExp.prototype.exec 使用 exec 方法用于获取到匹配到的数组： 1234567let pattern = /.at/;let str = &quot;cat, bat&quot;;let matches = pattern.exec(str);// [ &apos;cat&apos;, index: 0, input: &apos;cat, bat&apos;, groups: undefined ]// 当前匹配到 字符串是 cat， 匹配的字符串在原字符串中的开始位置为 0， input： 当前被匹配的字符串为 // &apos;cat, bat&apos; 如果有匹配到值的话， 返回一个数组， 如果没有匹配到值， 返回 null; 使用 exec 方法返回的是一个数组，这个数组包含被匹配到的字符串，（在存在捕获组的情况下， 获取到的被匹配的字符串不止一个） 比如上面的代码中， 匹配到了 cat 但是这个数组实例上面还定义了一些属性, 例如上面的数组中包含了 index, input 以及 groups ， 这些属性表示的是被匹配到的字符串的相关信息， 这些属性的含义如下： index: index 表明匹配数组中第一个值在字符串中的位置。 input：input 表明当前匹配的字符串 groups: groups 是 es2018 中提出的一个新的方法 注意： 当正则表达式中包含有全局匹配 g 的时候，每次调用 exec 都会在上一次匹配的位置之后继续进行匹配, 当没有设置全局匹配 g 的时候， 多次调用 exec 只会调用第一次匹配到的信息。 1234567891011let pattern = new RegExp('.at', 'g');let str = "cat, bat, dat";let matches = pattern.exec(str);while(matches) &#123; console.log(pattern.lastIndex, matches[0]); matches = pattern.exec(str);&#125;// 3 'cat'// 8 'bat'// 13 'dat' 应用正则表达式的一些方法：String.prototype.matchstr.match(regexp) 接收一个正则表达式， 如果有匹配到的字符串， 将会返回一个数组， 数组的第一项是进行匹配的字符串， 后面几项是获取到的捕获组的结果， 如果没有匹配到的字符串， 那么将会返回 null。 注意， 在使用 match 方法的时候加不加标识符 g 是有区别的， 当正则中不含有 g 标识符的时候， 返回的结果是标准的匹配格式： 数组的第一个元素是整体匹配的内容，其他元素是分组捕获的内容， 如果加上了 g 符号， 那么返回的是包含有所有匹配的字符串内容： 例如下面这个例子： 123456789&gt; var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/g;&gt; var string = &quot;2017-06-12&quot;;&gt; console.log( string.match(regex) );&gt; // [&quot;2017-06-12&quot;] 没有获得到捕获组 括号内的匹配项&gt; // 当正则表达式中不含有 g 标识符的时候&gt; regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;&gt; // [&quot;2017-06-12&quot;, &quot;2017&quot;, &quot;06&quot;, &quot;12&quot;]`String.prototype.search`&gt; // 返回内容为整体匹配以及分组匹配的内容. l;` &gt; String.prototype.searchstr.search(regexp) 接收一个正则表达式， 返回在字符串中第一次被匹配到的位置， 如果没有匹配到， 返回 -1 12let str = &apos;hello world&apos;;str.search(/world/); // 6 使用 indexOf 方法也可以用来查找到字符串中的某一个字符， 相比 indexOf 方法， 个人认为 search 方法的优点在于可以借助于正则表达式中的一些功能， 比如， 我们可以不区分大小写的进行查找字符串中的某一个单词： 12let str = "search Word";str.search(/word/i); // 6 注意： 当我们使用 search 方法的时候， 当向 search中传入字符串的参数的时候， 字符串参数会被转换为正则表达式 如下： 123let str = "2019.02.05";str.search('.'); // 0// 因为上面的方法中转换为了 str.search(/./); 相当于匹配任意的字符， 从而匹配到第一个字符， 匹配到的位置为 0 String.prototype.replacestr.replace(regexp, replaceStr) 使用 replace 方法可以实现对于匹配到的字符串进行替换, 匹配过程中不会改变原来的进行匹配的字符串，返回值为进行匹配完成的字符串。 注意： 使用 replace 方法的时候 replaceStr 中使用 $1, $2 以及 $3 可以表示 RegExp.$1, RegExp.$2 RegExp.$3 如下， 转换日期的格式问题： 123let str = &apos;2018-02-02&apos;;let regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;str.replace(regex, &apos;$3/$2/$1&apos;); // 02/02/2018 如下， 隐藏手机号码中间四位的数字： 1234let str = &apos;15656568620&apos;;let regex = /(\d&#123;3&#125;)(\d&#123;4&#125;)(\d&#123;4&#125;)/;str.replace(regex, &apos;$1****$3&apos;);// 156****8620 使用 replace 可以实现更为强大的功能， 因为第二个参数的 replaceStr 可以有多个具有特殊含义的字符： 属性 描述符 $1 $2 … $99 匹配地 $1 , $2 … $99 分组捕获的文本 $&amp; 匹配到的子串文本 $` 匹配到的子串的左边文本 $’ 匹配到的子串的 $$ 表示美元符号 其他符号 符号本身 如下， 我们想要将一段金钱文字都添加上一个 $ 符号： 1234let str = '100, 200, 300';let regex = /(\d+)/;str.replace(regex, '$$ $&amp;');// $100, $200, $300 使用 replace 我们不仅仅可以实现对于一串字符串中某个字符的替换， 更强大的作用在于， 使用 replace 可以实现对于匹配到的字符串进行统一处理， 这样， 我们就无需手动查找字符串中的某个值，然后逐个替换了。 其他 使用 $1 $2 .. 可以获取到被匹配到的捕获组中的数据， $1 获取到第一个捕获组数据， $2 获取到第二个捕获组数据， 依次类推 例如： 123456str = '2018-02-02';regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;regex.test(str);RegExp.$1 // 2018RegExp.$2 // 02RegExp.$3 // 02 可以在正则中使用 \1 或者 \2 之类的表示引用分组 $1 $2 ….， 例如： 我们想要匹配如下的日期格式： 2019-02-05 2019.02.05 2019/02/05 我们注意到， 对于 - 或 . 或 / 是重复使用的， 因此， 我们可以在正则表达式中引用这个分组： 123let regex = /\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;(-|\/|\.)\d&#123;2&#125;/;let str = &apos;2019-02-05&apos;;regex.test(str); // true 但是上面的正则也可以匹配到 2019-02.05 这样的格式； 当匹配的字符串中出现重复匹配的内容， 并且匹配规则相同的时候， 我们可以使用分组引用： 1let regex = /\d&#123;4&#125;(-|/\|\.)\d&#123;2&#125;\1\d&#123;2&#125;/; 如下： 匹配 html 中的匹配标签： 12345678let html = "&lt;p&gt;我是一段文字&lt;/p&gt;";let regex = /&lt;([^&gt;]+)&gt;[\d\D]*&lt;\/\1&gt;/;regex.test(html); // true// 注： 这里的 [\d\D] 表示匹配 \d 或 \D, 也就是匹配任意的字符// 匹配含有 class 的元素属性html = "&lt;p class="content"&gt;我是一段文字&lt;/p&gt;";regex = /&lt;([^&gt;]+).*&gt;[\d\D]*&lt;\/\1&gt;/;regex.test(html) // true]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈 window.location 对象]]></title>
    <url>%2F2019%2F01%2F20%2F%E8%B0%88%E8%B0%88-window-location-%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[谈谈 window.location 对象window.location 是一个只读属性， 用于获取到页面文档的位置信息， 如果我们在浏览器控制台中打印， 那么打印出来的结果如下： 以我们在 页面 https://developer.mozilla.org/zh-CN/docs/Web/API/Window/location 下获取 window.location 为例： 1234567891011121314151617ancestorOrigins: DOMStringList &#123;length: 0&#125;assign: ƒ ()hash: &quot;&quot;host: &quot;developer.mozilla.org&quot;hostname: &quot;developer.mozilla.org&quot;href: &quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Window/location&quot;origin: &quot;https://developer.mozilla.org&quot;pathname: &quot;/zh-CN/docs/Web/API/Window/location&quot;port: &quot;&quot;protocol: &quot;https:&quot;reload: ƒ reload()replace: ƒ ()search: &quot;&quot;toString: ƒ toString()valueOf: ƒ valueOf()Symbol(Symbol.toPrimitive): undefined__proto__: Location 上面的这些值表明了在 window.location 中的一些属性和方法： 属性名 含义 示例 href 当前页面的url https://example.com:8080/page/childpage?pageId=1#identify host host 包含端口名 example.com:8080 hostname 不包含端口名 example.com pathname 路径名 /page/childpage origin 源网址 https://example.com:8080 是 网址在第一个 ‘/‘ 之前的部分 port 端口号 8080 protocol 协议名 https search 截取到的链接的 ？ 之后的字符串, 不包含标识符 # 之后的内容 ?pageId=1 hash 标识符 #identify 除了上面几种属性之外， 还包括一些方法： 123window.location.reload() // 对于当前页面进行重载操作window.location.replace(rul) // 对于当前页面进行替换window.location.assign(url) // 会触发页面重载并且跳转到指定的 url tips： 使用 replace 和 assign 不同的区别在于： 使用 replace 替换的当前页面不会保存到页面浏览会话历史中，因此当跳转完成之后， 点击浏览器的后退按钮， 是不会进入到使用 replace 的那个页面资源的。而使用 assign 会回到之前跳转的页面。]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>window.location</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blob 对象]]></title>
    <url>%2F2019%2F01%2F12%2FBlob%2F</url>
    <content type="text"><![CDATA[js 中的 blob 数据类型： Blob什么是 blob ？blob 代表了一个存放文d件数据的字节包， 使用 blob 可以代替 file， 我们可以在使用 file 的地方使用 blob 作为代替。同样， blob也有和 文件 file 类似的 size 和 MIME 属性。 在 blob 中可以存放二进制数据， 同时我们可以使用 arrayBuffer 进行读取数据。 创建 blob：123new Blob(array, [,options]);// array is an Array of ArrayBuffer, ArrayBufferView, Blob, DOMString objects, or a mix // of any of such objects, that will be put inside the Blob. DOMStrings are encoded as // UTF-8.// options 是可选的额外参数， 比如， 可以传递一个 type， 表示放入 blob 中的数据的 MIME 类型 如下， 将字符串保存到 blob 中， type 为 “text／plain” 1const blob = new Blob([&quot;hello world&quot;], &#123; type: &apos;text/plain&apos; &#125;); 读取blob如果我们直接打印出 blob 是不能打印出来的 1Blob(11) &#123;size: 11, type: "text/plain"&#125; 我们可以通过使用 FileReader 读取 blob 中的数据： FileReader 是 web 用来异步读取电脑上的文件或者blob数据的对象， 其对于从web端操作文件提供了一系列的方法， 具体内容查看 FileReader 123456const reader = new FileReader();reader.readAsText(blob);rader.onloadend = () =&gt; &#123; console.log("result", reader.result);&#125;;// result "hello world" 我们可以使用 blob来做什么？blob 提供了用于操作二进制数据的一些接口， 一些可以用来操作二进制数据的api 比如 file 对象， 都是建立在blob的对象基础之上的， 继承了blob 的一些属性和方法。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>blob</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端路由的实现]]></title>
    <url>%2F2019%2F01%2F12%2F%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前端路由的两种实现方式路由是什么？路由一种根据请求的内容来匹配相应执行代码的一种机制， 在前端应用上面来说， 就是通过不同的路径来请求不同的资源。 对于前端应用， 路由可以分为前端路由以及后端路由两种类型。 后端路由：在spa单页面应用出来之前， 最常用的一种渲染方式是服务端渲染（SSR）， 主要的方式是通过服务器返回页面上需要呈现的内容， 因此， 需要页面呈现什么的内容， 如何根据请求的不同路径返回不同的资源是由服务器端进行配置的，使用服务器端进行渲染有如下几个优缺点： 优点： 有利于 SEO 优化。 首屏加载速度快。 缺点： 每次请求都是渲染一个新的页面，页面重新进行刷新， 旧的页面会被丢失， 从而造成性能上的影响。 前端路由：前端路由是单页面应用中页面切换时的资源请求方式， 前端路由会通过url的改变匹配获取到请求参数，根据请求参数的不同 在一个页面中加载不同的资源， 通过这种方式，可以跳转到不同的页面并且不会刷新页面。 优点： 除了首屏之外的页面能够快速响应， 因为每次切换页面都只需要加载少量数据。 组件的复用度高， 提高页面加载性能。 前后端分离开发。 当页面进行切换的时候的 transiton 或者 animation 动画更容易被应用。 缺点： 首屏资源加载速度慢， 因为对于单页面应用， 页面渲染相关的逻辑位于js文件中，js 文件会在浏览器解析 html 之后加载， 因此会造成首屏加载时的白屏问题。 SEO 性能差。 首次加载比较慢， 因为整个网站的资源需要在首次加载页面的时候全部加载。 前端路由的实现方式：更新视图但不重新请求页面时前端路由的核心之一。 实现前端路由主要有两种模式， hash 以及 history 模式。 hash：hash 又被称作锚点， 本来用于放在 url 中指定网页中的位置， hash 指的是url 中 # 符号之后的字符， 这个值可以通过 window.localtion.hash 获取到值。 hash 值时用于浏览器端的， 对于服务器端没有作用， 不会包含在 http 请求中， 改变 hash 值不会重新加载页面。 可以通过使用监听 hashchange 监听 hash 值的改变： 1window.addEventListener('hashchange', func, false); 这样我们就可以在 hash 值发生变化的时候触发 func 函数， 从而更新视图。 history：history 模式主要是通过使用 window.history 只读属性从而对于浏览器历史记录栈进行读取信息和操作。 window.history 是指向浏览器历史记录栈的只读对象， 提供了操作浏览器历史记录栈的接口 window.history 提供了一些方法用于操作浏览器的页面行为： window.history.back(); : url 回退， 类似于点击浏览器上方的回退按钮。 window.history.forward(); url 前进， 类似于点击浏览器上方的前进按钮。 window.history.go(1): 前进到下一个页面。与 forward 相同。 window.history.go(-1): 回退到上一个页面， 和 back 相同。 在 HTML5 中， 新增了两个新的 API： pushState 和 replaceState. 12window.history.pushState(state, title, url);window.history.replaceState(state, title, url); 使用这两种方法修改浏览器历史记录栈之后， 虽然改变了当前的 url， 但是浏览器不会立即发送这个 url， 这就实现了更新视图但是不会请求页面的作用。 这两个 api 都有三个参数： 状态对象（state object）：一个JavaScript对象，与用pushState()方法创建的新历史记录条目关联。无论何时用户导航到新创建的状态，popstate事件都会被触发，并且事件对象的state属性都包含历史记录条目的状态对象的拷贝。 标题（title）：FireFox浏览器目前会忽略该参数，虽然以后可能会用上。考虑到未来可能会对该方法进行修改，传一个空字符串会比较安全。或者，你也可以传入一个简短的标题，标明将要进入的状态。 地址（URL）： 新的历史记录条目的地址。浏览器不会在调用pushState()方法后加载该地址，但之后，可能会试图加载，例如用户重启浏览器。新的URL不一定是绝对路径；如果是相对路径，它将以当前URL为基准；传入的URL与当前URL应该是同源的，否则，pushState()会抛出异常。该参数是可选的；不指定的话则为文档当前URL。 使用 pushState 用于增加一条新的历史记录， 使用 replaceState 将会替换掉当前的历史记录。 当活动历史记录中的条目更改的时候， 将会触发 popstate 事件， 例如点击浏览器的回退按钮， 当事件被触发的时候, 事件的 state 属性为使用 pushState 或者 replaceState 中传入的参数 state 12345const state = &#123; bar: 'foo' &#125;;window.history.pushState(state, '', 'route');window.addEventListener('popstate', function (e) &#123; console.log('state', e.state); // &#123; bar: 'foo' &#125;&#125;); 两种路由实现方式的区别： 使用 history 模式可以设置任意和当前 url 同源的 url ，但是使用 hash 只能设置 # 号之后的数值。 使用 history 的 pushState 可以设置相同的 url ，这个新的 url 也会被存放在记录中， 而 hash 值只有和之前的 url 不同才会被记录到 url 中。 在 pushState 中通过传入的 state 值可以添加任何类型的数据， 而 hash 值只可以添加短字符。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>route</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式（一）：理论基础部分]]></title>
    <url>%2F2018%2F12%2F15%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[在 js 中，利用正则表达式进行验证是我们经常会遇到的功能需求， 今天就讲解一些正则表达式的理论基础； 正则表达式是用来判断一段字符串是否匹配某一个规则， 通过正则表达式我们可以匹配到我们想要匹配的字符， 判断匹配字符是否存在， 一段字符串是否符合我们的匹配规则等等。 创建正则表达式的两种方式：创建两种正则表达式有两种方法： let reg = new RegExp(pattern[, flags]) let reg = /pattern/flags 上面两种方法创建正则除了包含有一个表达式 pattern 之外， 还包括一个可选的 flags 字段， 这个字段包含有几种字段： g： 全局匹配正则表达式 i： 表示不区分大小写， 匹配的时候忽略大小写的匹配。 m: 表示多行匹配， 即到达某一行文本结束的时候还会继续查找下一行中是否包含有与模式匹配的值 通过上面两种方法创建的正则表达式返回的都是一个正则对象， 这个正则对象中包含有正则表达式中的一些方法例如： exec, match test 等方法。 元字符正则表达式中的元字符是用来匹配一个位置或者字符集合中的一个字符， 元字符可以分为两种类型， 匹配位置的元字符和匹配字符的元字符； 匹配位置的元字符： 元字符 含义 ^ 匹配行的开始位置 $ 匹配行的结束位置 \b 可以用来匹配单词的开始或者结尾位置， 也就是单词的分界处 匹配字符的元字符： 元字符 含义 . 匹配除换行符之外的任意字符 \w 匹配单词字符（包括字母， 数字，下划线和汉字） \W 匹配任意的非单词字符（和 \w） 相反 \s 匹配任意的空白字符， 比如空格符， 制表符或者换行符 \S 匹配任意的非空白符 \d 用于匹配任意的数字 \D 用于匹配任意的非数字字符 字符类字符类是一个字符集合， 使用方括号 [] 定义， 表示匹配到方括号中的任意一个： 注意： 除了 - 以及 ^ (只能用在开头， 表示否定) 这两个特殊字符之外， 其他的的特殊字符没有任何特殊的含义 例如： 1/&lt;H[123456]&gt;/ 表示匹配 H1 H2 … H6 中的任意一个标签 在方括号中可以使用 - 用作连接符表示字符的范围： [0-9] 表示匹配 0 到 9 范围类的数字 [a-z] 表示匹配 a 到 z 范围内的小写字母 [a-zA-Z] 表示匹配 a到 z 或者 A 到 Z 范围内的英文字母 在方括号中当 ^ 符号位于开头的时候， 表示对于当前字符集表示否定， 匹配的是排除在当前字符集中的字符： 1/[^0-8]/.test(9); // true 要匹配上面的两个特殊符号， 那么需要我们使用反引号进行转义： 12/[a\-c]/.test('-');// true 限定符使用字符类方括号 [] 或者 元字符只能表示匹配单个字符， 如果我们想要匹配多个字符的时候， 我们可以使用限定符进行范围的限定： 限定符紧跟在单个字符后面，表示这个字符或者字符集重复的次数。 对于限定符有下面几种情况 ： 对于限定符也可分为贪婪匹配以及懒惰匹配， 下面的六种限定符为贪婪匹配， 懒惰匹配为在贪婪匹配后面添加 ? 表示懒惰匹配； 字符或者表达式 说明 {n} 重复 n 次 {n, } 表示至少重复 n 次 {n, m} 重复至少n 次， 至多 m 次 * 重复至少0次， 等同于 {0, } + 重复至少 1 次， 等同于 {1, } ? 重复 0 次 或者 1 例如： 12345const reg = /a.*b/;"aabab".match(reg); // aababconst reg = /a.&#123;0,1&#125;b/;"aabab".match(reg); // aab 使用贪婪匹配与懒惰匹配的区别在于， 使用贪婪匹配会尽可能多的匹配字符， 使用懒惰匹配则是查找到满足匹配条件的字符串中字符较少的字符。 例如： 12345678const reg1 = /a.+b/;const reg2 = /a.+?b/;const str = "avbaab";// 贪婪匹配str.match(reg1); // avbaab// 懒惰匹配str.match(reg2); // avb 替换在正则表达式中 | 用于表示当字符串匹配了 | 左边或者右边的规则的时候， 表示这个字符串匹配了当前的正则表达式， 类似于 js 中的 || 操作符， 当 | 左边的正则不匹配， 那么进行右边的正则匹配。 1let reg1 = \d&#123;5&#125; - \d&#123;3&#125; | d&#123;5&#125;; // 同时可以匹配 12345-678 或者 12345 注意： 使用 | 进行匹配的时候， 如果当左边的元素被匹配到的时候， 右边的元素将不会进行匹配。 12345&gt; let str = 'goodbye';&gt; // | 两边不能有空格&gt; let regex = /goodbye|good/g;&gt; str.match(regex); // ['goodbye']&gt; 分组使用 () 包裹起来的表达式在正则表达式中表示一个整体， 我们可以对这个整体进行限定符限制， 重复匹配 例如： 12// 匹配一个 ip 地址let reg = /(\d&#123;1,3&#125;\.)&#123;3&#125;/d&#123;1,3&#125;/; 总结在正则中使用 [] 以及 | 都有 “或者” 的意思， 这两者可以根据不同的请求可以选择使用， 具体的对比如下： 描述符 优点 缺点 [] 适合单个字符之间的匹配， 需要转义的特殊字符比较少（^ 和 -） 不能匹配多个字符结合的字符串，相对表达意思比较少， 只能表示匹配或者不匹配（使用^） 两种逻辑 竖直 可以匹配多个字符的字符串 当匹配正则中的特殊字符的时候需要进行转义]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 文件上传与下载]]></title>
    <url>%2F2018%2F10%2F31%2Fjs-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[前端实现的文件上传与下载操作： 上传在上传文件的操作中， 可以使用 formData 或者 fileReader 进行上传操作， 使用 fileReader 可以在本地将上传的文件转为二进制的数据格式； formData 是在 XMLHttpRequest 中的接口，可以用来实现模拟的表单提交， 当前端通过 ajax 向后端传递文件的时候， 使用 ajax 提交 formData 可以实现异步上传二进制文件 1&lt;input type=&quot;file&quot; onClick=&#123; this.uploadFile.bind(this) &#125; /&gt; 对于上传文件，可以通过两种方式进行上传，通过 filereader 或者通过 formData 都可以实现上传文件 FileReader:12345678uploadFile(fileInput) &#123; const file = fileInput.target.files[0]; // 获取到文件对象 const reader = new FileReader(); // 创建 fileReader 的实例 reader.readAsArrayBuffer(file); // 将file 读取为 ArrayBuffer reader.onload = function () &#123; // 当文件加载成功的时候调用 console.log(&quot;result&quot;, reader.result); &#125;&#125; 在 MDN 上面， 对于 FileReader 的描述如下: 123FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。其中File对象可以是来自用户在一个&lt;input&gt;元素上选择文件后返回的FileList对象,也可以来自拖放操作生成的 DataTransfer对象,还可以是来自在一个HTMLCanvasElement上执行mozGetAsFile()方法后返回结果。 使用 fileReader 接受的参数可以是一个 File 对象或者 Blob 对象， 使用上传文件的时候， 接收的是一个 fileList 对象。 构造函数1const reader = new FileReader(); // 创建一个新的 filereader 实例 相关方法reader.readAsArrayBuffer(file) : 将文件读取为 ArrayBuffer 的数据对象 ArrayBuffer 是一种二进制数组，通过 ArrayBuffer 中的一些语法可以实现使用数组的语法处理二进制数据 reader.readAsText(file, [encode]) : 读取文件内的内容作为字符串的形式输出，这个方法读取的是文件内的内容，其中的 encode 用于将 file 对象进行转换的编码格式; reader.readAsDataURL(file): 将文件读取为 DataUrl 相关属性reader.error: 表示在读取文件的时候发生的错误； reader.readyState: 表示当前上传文件的状态： 0: 表示当前文件尚未加载 1: 表示当前文件正在加载中 2: 表示当前文件已经完成加载 reader.result : 上传文件的内容，只有上传成功之后这个属性才有值 事件处理 事件名 描述 Onabort 当读取操作中断的时候触发 Onerror 当操作发生错误的时候触发 Onload 当读取操作完成的时候触发 Onloadstart 当开始进行读取的时候触发 Onloadend 当读取操作结束的时候触发 Onprogress 当读取的时候触发 FormData:12345678910uploadFile(fileInput) &#123; const file = fileInput.target.file[0]; const formData = new FormData(); formData.append(&quot;file&quot;, formData); axios(&#123; method: &quot;post&quot;, url: &apos;...&apos;, data: formData &#125;);&#125; 下载常用的下载操作是创建一个 a 标签， 通过 a 标签的 href 指向下载的文件链接，通过使用 download 属性来说明下载的文件名称: 1&lt;a href="" download="文件.txt"&gt;下载文件&lt;/a&gt; // download 表明下载的文件名, href 指向下载的文件的地址 在后端传递的文件进行下载的时候， 因为后端传递的是一个二进制的数据格式文件， 前端这边需要将二进制数据转为 a 标签的链接进行下载操作， 通过使用 window.URL.createObjectURL 转为链接。 window.URL.createObjectURL: 接受参数为一个 file 对象或者一个 blob 对象， 最后生成一个 url, 这个url指向参数中给定的对象。这个 URL 的生命周期和创建它的窗口中的 document 绑定，当不需要使用 URL 对象的时候， 可以通过 URL.revokeObjectURL 进行释放， 已获得最佳性能和内存使用情况。 在实际的开发中， 通常使用js 来创建下载标签， 代码如下: 123456789101112// name: 下载的文件名// blob 下载的文件的blob 二进制数据格式的文件function downloadFile (name, blob) &#123; var downloadElement = document.createElement('a'); var href = window.URL.createObjectURL(blob); //创建下载的链接 downloadElement.href = href; downloadElement.download = `$&#123;name&#125;.xlsx`; //下载后文件名 document.body.appendChild(downloadElement); downloadElement.click(); //点击下载 document.body.removeChild(downloadElement); //下载完成移除元素 window.URL.revokeObjectURL(href); //释放掉 URL 对象 &#125; 当接受到文件数据不为 blob 对象的时候, 可以通过使用 new Blob([data]) 转换为 blob 对象。 Blobblob 是 js 中的对象，可以存储大量的二进制编码格式的数据， 使用 blob, 当 input 标签 type 设为 file 的时候提交的 fileList 中的每一个 file 对象就是基于 blob 对象的； 构造函数new Blob(array, [,options]): array 中的值可能是 ArrayBuffer, ArrayBufferView, Blob, DOMString 对象， 或者这些对象的混合。 options 字段是可选的字段， 包含下面两种值： type: 表明将要放入 blob 中的数组内容的 MIME 类型 endings: 决定第一个参数的数据格式，可以取值为 “transparent” 或者 “native”（transparent的话不变，是默认值，native 的话按操作系统转换 方法Blob.slice([start[, end[, contentType]]]) 用于对 Blob 进行”切割”， 返回一个新的 Blob 对象， 包含特定字节范围内的数据 属性Blob.size: 在 Blob 数据对象中的字节大小。 Blob.type: Blob 数据对象中的 MIME 类型。 使用 Blob 存储的数据对象读取的唯一方式是通过使用 FileReader 进行读取， 通过使用 FileReader 中的 readAsDataURL 或者 readAsArrayBuffer 将 Blob 中的数据类型读取为 ArrayBuffer 或者 dataurl 的格式。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>fileReader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css modules: 前端模块化]]></title>
    <url>%2F2018%2F09%2F09%2Fcss-modules-%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[在 css 模块化的解决方案中， 存在两种解决方案， 一种是放弃使用 css, 使用 js 或者 json 的形式来重写 css, 这样写的好处在于方便利用 js 的模块化管理，缺点在于缺少 css 预处理器例如 less sass 等的支持，例如 react-style 属于这种解决方案。另外一种是依旧采用 css 的原生态写法， 但是通过 js 来进行管理依赖， 下面我们介绍的 css-modules 属于这种的写法。 css 模块化中的一些问题在 css 的模块化的过程中， 下面几种问题是需要解决的： 全局污染在 css 中， 样式 style 是属于全局范围内的， 因此当我们在全局范围内w为某一元素标签添加样式的时候， 这一样式会被应用到全局的所有的该标签下的元素上面，为了减少掉全局变量的污染，我们会采用提高元素优先级的方法进行样式覆盖， 例如添加 !important ，获取通过复杂选择器增大元素的权重值以及行内样式，这种通过提高元素优先级的方法实现的元素样式覆盖导致了无法重写元素样式， 丧失了l灵活性。 命名混乱混乱的命名方式会导致开发过程中的样式冲突， 样式混乱， 为后续开发带来了困难， 在这个问题上面， 有一种解决方式， 就是采用 BEM 的命名方式； 依赖管理不彻底在引入组件的时候， 组件应该相互独立， css 文件应该随着组件的引入按需加载，而不是引入所有的样式， 这样造成了模块的浪费。 实现变量共享在复杂的组件中, 可能需要通过 js 或者 css 同时进行操作样式，这种情况下可能会造成样式的冗余，现在的预处理器都不能实现变量在 css 与 js 之间的变量共享。 CSS modulescss modules 是一种模块化的解决方案，通过使用 js 文件引入管理， 同时， 在 css modules 中的 css 文件中的样式名被默认为局部样式，从而避免了局部样式的污染， 结合 webpack, 使用 css modules 应用的类名会被编译为一串字符， 从而避免 class 命名的重复。 下面是一些基本的语法: 基本语法引入与导出在需要使用 css 的组件中通过使用 import 的方法进行导入： index.css:1.btn &#123; /* btn 的相关样式 */ &#125; index.js: 123456import style from "./index.css";...render () &#123; return &lt;button className=&#123; style.btn &#125;&gt;&lt;/button&gt;&#125;... 最终生成：1&lt;button class=&quot;btn&quot;&gt;&lt;/button&gt; 通过使用 js 引入的方式还可以实现常量的共享功能：对于常量， 需要使用 :export关键字将 css 中的常量输出到 js 中: 12345@color: "red";:export &#123; color: @color;&#125; 123import style from "./index.css";style.color // "red" 全局与局部样式通过使用 :global 和 :local 样式可以将当前的样式声明为全局和局部样式： index.css:1234567891011121314151617.btn &#123; color: blue;&#125;// 等同于下面的 local:local(.btn) &#123; color: blue;&#125;// 声明为全局样式// 文件中所有类名为 `btn` 的元素都将应用这个样式:global &#123; .btn &#123; color: blue; &#125;&#125; 代码复用与样式组合在 css-modules 中使用 composes 来实现多个类名的组合， 例如， 当我们定义组件 Button 的时候， 我们需要定义基础配置， 大小以及类型样式， 可以这么写 12345678910111213141516171819.btn &#123; // 定义基础样式&#125;.btn-small &#123; // small 大小相关样式&#125;.btn-text &#123; // text btn 相关样式&#125;&lt;!-- 组合样式 --&gt;.btn-small-text &#123; compose: btn btn-small btn-text;&#125;// 或者当 btn 为全局样式 global-btn 的时候， 可以进行组合.btn-small-text &#123; composes: global-btn btn-small btn-text;&#125; 注意：使用 composes进行样式组合的时候， 需保证组合的样式名在composes之前已经存在了， 并且是单独的样式名， 没有嵌套关系 使用技巧 减少 class 嵌套, 使用单独 class 来定义样式，减少 class 层叠 使用 composes 类名组合来组合样式 不使用选择器， 仅仅使用 class 来定义样式 CSS modules 使用项目中使用 less 作为 css 预处理器，在 webpack 中 css-loader 支持 css modules, 相关配置如下: 1234567891011121314151617181920test: /\.less$/,use: [ &#123; loader: 'style-loader' &#125;, &#123; loader: 'css-loader', options: &#123; // 启用 css modules modules: true, // 定义最终编译之后的样式名称 // local: 应用的 class 名称 // hash: 编译时随机生成的 hash 值， 避免 class 名称重复 localIdentName: '[local]--[hash:base64:5]' &#125; &#125;, &#123; loader: 'less-loader' &#125;]]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css modules</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grid 布局（一）]]></title>
    <url>%2F2018%2F08%2F18%2Fgrid-%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[grid 布局是一种方便的用于创建网格布局的强大工具， 使用grid 布局可以很方便的构建网页结构， 本篇文章主要介绍grid 布局的基础知识。 基本属性使用 grid 布局实现一个九宫格: 123456&lt;div class="content"&gt; &lt;div class="item1"&gt;&lt;/div&gt; &lt;div class="item2"&gt;&lt;/div&gt; ... &lt;div class="item9"&gt;&lt;/div&gt;&lt;/div&gt; 1234567.content &#123; display: grid; width: 300px; height: 300px; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px;&#125; 实现的九宫格如下所示: display: grid使用 display: grid 的目的是用于声明当前元素使用 grid 布局构建; 常用值: grid: 生成一个块状网格 inline-grid: 生成一个内联网格 subgrid: 表示当前的网格容器继承自父级元素的网格容器 grid-template-columns, grid-template-rows这两个属性用于在声明 grid 的当前元素内部划分网格内容。后面的数值表明网格内容的长度大小， 数值之间的空格表示划分网格的网格线。 grid-template-columns : 用于在网格元素划分列， 后面的值表示划分列的宽度， 比如上面的九宫格代码中， 表示将当前的元素划分为 3 列， 且三列的宽度均是 100px; grid-template-row: 使用效果类似于 grid-template-columns, 是对于 grid 元素行的划分。比如上面的代码中表示将 grid 元素划分为三行， 并且三行的高度均为 100px; 常用值: &lt;track-name&gt;&lt;track-size&gt;&lt;track-name&gt;&lt;track-size&gt;... track-size: 表示网格内容的宽度，可取值: percentage 数值 auto: 网格宽度的剩余空间 fr: 表示等份网格容器中的可用空间 track-name: 表示网格之间网格线的名称 式例: 123.content &#123; grid-template-columns: [line-start] 50px [line1-start] 20% [line2-start] 1fr [line-end];&#125; 效果如下: 当 auto 和 fr 同时存在的时候， 优先级： auto &gt; fr, 这个时候 , 声明 auto 的那一列宽度为 0 grid-template-areas使用 grid-template-areas 用来定义网络模板； 常用值: grid-area-name : 由网格项的 grid-area 指定的网格区域名称 . 表示一个空的网格单元 none 表示不定义网格区域 例如下面实现的一个网页布局: 123456&lt;div class="content"&gt; &lt;div class="header"&gt;&lt;/div&gt; &lt;div class="menu"&gt;&lt;/div&gt; &lt;div class="body"&gt;&lt;/div&gt; &lt;div class="footer"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728.content &#123; width: 400px; height: 300px; display: grid; grid-template-columns: repeat(1fr); grid-template-rows: repeat(1fr); // 这里的 h, m , b, f是和下面声明的 `grid-area` 是一一对应的 grid-template-areas: "h h h h" "m . b b" "f f f f";&#125;.header &#123; grid-area: h; background-color: lightcoral;&#125;.menu &#123; grid-area: m; background-color: lightblue&#125;.body &#123; grid-area: b; background-color: lightslategray&#125;.footer &#123; grid-area: f; background-color: lightseagreen;&#125; 效果如下:]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>grid 布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解js中的线程，进程]]></title>
    <url>%2F2018%2F06%2F21%2F%E8%AF%A6%E8%A7%A3js%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[存在下面一段代码： 1234567891011setTimeout(function() &#123; console.log(1) &#125;, 0);new Promise(function(resolve)&#123; console.log(2); for(var i = 0; i &lt; 10000; i++) &#123; i === 9999 &amp;&amp; resolve() &#125; console.log(3);&#125;).then(function () &#123; console.log(4);&#125;);console.log(5); 上面的代码的执行顺序， 依次输出内容分别是什么？正确的答案是： 2， 3， 5 ，4， 1；在上面的代码中， 执行的代码顺序如下： 执行 promise 实例内部的代码， 输出 2; 顺序执行后面的代码 console.log(3), 输出 3; 执行 console.log(5)， 代码输出 5; 执行 resolve 函数， 执行 resolve 函数中的代码 console.log(4), 输出 4; 最后执行 setTimeout 中的代码， 代码执行 console.log(1) ， 输出 1;为什么会按照上面的顺序执行代码， 下面将要进行详细的讲解： js 中的线程在 js 中的线程和浏览器中的线程是不同的， 在 js 中是单线程， 而在浏览器是多线程的。js 的单线程是指所有的 js 代码都是在 js 引擎上面的一个主线程上面运行的，js 同时只能执行一个任务， 其他的任务则会排队进行等待执行。 虽然 js 是单线程的， 但并不是说 js 引擎就是单线程的， 实际上， js 引擎有多个线程， 一个主线程以及其他的后台配合主线程。 而在浏览器中， 还包括下面几类线程： js 引擎线程（例如 v8 引擎） UI 渲染线程 浏览器事件触发线程 定时触发器线程 http 请求线程 这些线程的作用分别是这样的： UI渲染线程用于渲染页面、解析 HTMl CSS， 创建 DOM 树。当页面元素发生重构或者回流的时候， 这个线程就会执行， 重新渲染页面。 js引擎用于执行 js 脚本代码，等待任务队列中的任务到来， 并且加以处理 浏览器事件触发线程用于控制用户， 响应交互，当 js 引擎执行代码遇到相关事件的时候， 会将对应的任务添加到事件线程中， 当任务符合触发条件被触发的时候， 触发的任务会被添加到任务队列的队尾， 等待 js 引擎执行完成主线程上面的任务之后执行。 定时触发器线程用于对于 setTimeout 或者 setInterval 进行计数, 因为 js引擎是单线程的， 所以自然计数的任务就不能有 js 引擎来完成， 而是由浏览器单独开出一个定时触发器线程用于计数， 当计数完毕之后， 会将计数完成之后的函数添加到任务队列尾部， 等待 js引擎执行完成主线程上面的任务之后执行。 http 请求线程， ajax 是委托给浏览器新开一个 http 线程 在上面的这些线程中， js 引擎的线程和UI渲染的线程是互斥的， 因此， 当js执行代码的时候会出现阻塞页面渲染的情况， 这也就是许多前端性能优化中都有提到的将js代码在html代码尾部加载的原因， 同时， 在 js 中操作dom会引发页面的重构或者回流， 这个时候UI渲染线程就会开始工作， 重新渲染页面， js 引擎的主线程就会被挂起，暂停代码执行， 从而影响页面性能， 这也是前端性能优化的一种方式：尽量减少js中直接对于dom的操作。 setTimeoutsetTimeout 在 js 中的作用是用来延迟代码执行， 规定代码在延迟多少时间之后执行回调函数代码，在上面关于线程的讲解中， 我们知道浏览器的定时触发器线程会在延迟时间达到之后将回调事件添加到js引擎中的任务队列中， 而在 js 引擎中， 引擎会在执行完成主线程上面的任务之后执行任务队列中的事件， 因此，当代码中存在 setTimeout 的时候， 内部的回调函数会在其他代码执行完毕之后才执行， 尽管我们将延迟时间设为0的情况也是如此： 有如下代码：12setTimeout(function () &#123; console.log(2) &#125;, 0);console.log(1); 执行结果： 1， 2 上面 setTimeout 中的函数会等到 console.log(1) 执行完成之后执行结果。 js 中的事件运行机制我们知道js是单线程运行的， 那么具体的运行机制是如何的？我们需要知道下面这些概念： js 中分为同步任务和异步任务 同步任务都是在主线程上面执行， 形成一个执行栈 在主线程之外， 事件触发线程管理着一个任务队列， 当异步任务有了运行结果时， 就在任务队列中添加一个事件 当执行栈中的所有的同步任务执行完毕之后， 任务队列中的任务将会添加到执行栈中， 开始执行 事件运行机制的详细图解如下： js 中的 macrotask 与 microtask在 js 中， 存在两种任务类型： macrotask(宏任务) 和 microtash (微任务)， 这两种任务类型的区别在于执行任务的时机是不同的。 macrotask: 宏任务可以理解为执行栈中执行的任务， 在执行任务期间不会中断任务， 浏览器为了能够使 js 内部task与 dom 能够有序的执行， 在执行完成任务之后会进行渲染， 1task ---&gt; 渲染 ---&gt; task microtask微任务会在宏任务执行完毕之后， 进行渲染之前执行 macrotask 与 microtask 中分别包含的几种任务类型： macrotask : 代码块， setTimeout, setInterval 等 microtask: Promise 了解了上面 macrotask 与 microtask 的概念之后， 之前我们那个代码执行的问题就明白了， 因为 setTimeout 属于 macrotask, 而 promise 属于 microtask, 在执行时间上 promise部分代码要早于 setTimeout, 所以先执行的代码是先执行 promise resove 中的代码， 之后在执行 setTimeout 中的代码。 参考链接从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理 JavaScript 运行机制详解：再谈Event Loop]]></content>
      <categories>
        <category>js理论基础</category>
      </categories>
      <tags>
        <tag>js运行机制，线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 中的函数式编程（译）]]></title>
    <url>%2F2018%2F06%2F16%2FJavaScript-%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%88%E8%AF%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在这篇文章中，我们将会学习到声明式， 纯函数， 不变性以及副作用。 什么是函数式编程？ 在计算机科学中，函数是编程是一种编程范例或者模式（一种构建计算机程序结构和元素的样式） 函数式编程将计算机运算视为数学概念中函数的计算。 函数式编程避免改变状态以及使用可变的数据。 上面的这些定义来自于维基百科， 在这篇文章中，我们尝试理解FP(函数式编程)的价值和意义。 其他主要的编程规范或模式： 过程式编程 面向对象的编程 元编程 命令式编程 声明式编程 过程式编程 基于程序调用的概念，简单包括计算机将要执行的一系列的计算过程， 在程序执行期间的任何时候，任何被设定的程序都有可能被调用，包括被其他的程序被调用或者自身调用，主要的过程式编程语言有COBOL, BASIC, C, ADA 和 GO 面向对象编程 基于对象的概念，对象中包含数据（属性）和程序（方法），这种模式更接近于函数式编程，一些重要的面向对象的语言包括：C++, Java, PHP, C#, Python, Ruby, Swift 等等。 元编程 具备将程序视为数据的能力，这意味着程序能够被设计成能够阅读，复制， 分析或者转换为其他程序，甚至在运行的时候修改自身。 命令模式 vs 声明模式 命令模式关心描述程序如何运行, 由计算机执行的命令组成 声明模式关心程序能够做什么而无需确定程序应该如何完成。 函数式编程遵循声明模式。 123456789101112131415var books = [ &#123;name:'JavaScript', pages:450&#125;, &#123;name:'Angular', pages:902&#125;, &#123;name:'Node', pages:732&#125;];/* Imperative Pattern */for (var i = 0; i &lt; books.length; i++) &#123; books[i].lastRead = new Date();&#125;/* Declarative Pattern */books.map((book)=&gt; &#123; book.lastReadBy = 'me'; return book;&#125;);console.log(books); 在上面的这一段代码中， 我们对于书籍数组中的每一本书添加了一个新的属性，这个过程通过两种不同的方法执行。 第一段中借用 for 循环，依据数组的长度进行迭代,接着将数组的指针计数器和数组的长度进行核对并且在每一次迭代中增加指针计数器，因此， 这更像程序/代码正在关心为了得到想要的输出结果如何进行运行操作。 第二段中的代码借助于原生Js数组中的 map 这个 map 方法将函数作为参数，这个函数获取到每一个元素，因此在这种情况下代码不是在描述程序如何运行，而是讨论需要达成什么 ，在这种情况后的 map 方法 关心实际的程序执行。 数学意义上的函数或者纯函数在数学中，函数是一系列输入值和合法的输出值之间的关系，这种特性反映了每一个输入组合都关联着一个确定的输出。 这函数式编程中，这种函数被称作纯函数，函数的输出结果仅仅取决于函数接收到的输入数据， 除了返回值之外， 函数不会改变输入的数据。 Math.random() 不是纯函数，因为每次调用的时候总会返回一个新的值。 Math.min(1, 2) 是纯函数的一个例子，对于相同的一组输入值总会返回新的值。 为什么要使用函数式编程 函数式编程中的纯函数确保了不会改变在其范围之外的数据。 其减少了复杂程度， 我们不需要关心程序如何怎样做， 而只需要关心程序做了什么。 易于测试，因为其不会取决于应用的状态，对于结果的验证也将会变得简单。 让代码更具有易读性。 函数式编程让代码更易于理解。 函数式编程的例子数组函数 在上面的代码中， 我们试图过滤出只有活跃的 meet-ups, 我们可以看到这个功能可以使用两种不同的方法实现，在这里， 第二种方法是函数式编程，其中的 filter() 方法关心”程序如何运行”，程序只关心输入也就是 meetups数组以及输出activeMeetupsFP 但是在第一种方法中程序也关心 for 循环如何运行代码。 相似的，下面的这些数组方法有助于实现函数式编程，减少代码的复杂度。 find reduce map some every 函数链函数链是用于调用多种方法的机制， 每一个方法返回一个对象， 允许在一个声明中调用链接在一起而无需变量来储存中间结果。 在上面的代码片段中， 我们想要打印出所有的活跃的 meetup 用户的总人数， 考虑到可能有10%的用户重复。 支持 FP 的库下面这些库中提供了一些让代码看起来更加声明式的有用函数。 RamadaJS UnderscoreJS lodash 副作用函数或者表达式除了返回一个值之外，在下面的几种情况下被认为产生了副作用： 如果其改变了其自身范围之外的程序状态， 或者与其调用的函数或者外部的程序有一个可以观察到的交互。 123456789101112131415let meetup = &#123;name:'JS',isActive:true,members:49&#125;;const scheduleMeetup = (date, place) =&gt; &#123; meetup.date = date; meetup.place = place; if (meetup.members &lt; 50) meetup.isActive = false;&#125;const publishMeetup = () =&gt; &#123; if (meetup.isActive) &#123; meetup.publish = true; &#125;&#125;scheduleMeetup('today','Bnagalore');publishMeetup();console.log(meetup); 上面的这段代码产生了副作用，因为函数 scheduleMeetup 的本来的作用是给 meetup 添加 date 和 place, 但是这个函数改变了 isActive 的值， 而这个 isActive 正是函数 publishMeetup 所依赖的。具有副作用的 publishMeetup 函数将不会得到理想的输出， 因为其输入的值在这个过程中被改变了。 在大型的程序中（真实的程序情况下）， 很难去 debug 副作用。 副作用不总是产生坏的影响，但是如果其产生的时候我们应该小心对待。 不变性在函数运行之后，不变性是十分重要的对于确保一个函数确实没有改变原来的数据而不是返回数据的新的副本。 例如， 如果数组以及对象在经历过多个函数之后， 如果我们不能保持不变性， 那么函数可能不会得到数组或者对象的原始值。 在可变的对象和数组的情况下，如果发生了一些错误对于我们来说是非常困难排除bug的。 支持不变性的库JavaScript默认没有对于使得对象或者数组不变提供任何的工具， 下面是一些可能帮助我们实现不变性的库: Seamless-immutable Immutable JS 总结函数式编程中主要的方面是纯函数和更小的功能， 函数不变性以及更少的副作用。 本文翻译至Functional Programming in JavaScript，实际上翻译之后才发现这里只是一些函数式编程基础知识，对于其他的函数式编程的更多特性并没有涉及，本文仅仅作为函数式编程的基本入门知识， 如果能帮到读者，那就再好不过了。]]></content>
      <categories>
        <category>翻译文集</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取数组中特定值的数组]]></title>
    <url>%2F2018%2F06%2F11%2F%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E4%B8%AD%E7%89%B9%E5%AE%9A%E5%80%BC%E7%9A%84%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[有如下题目： 根据指定元素，在数组里面找出类数组。比如数组 [2, 3, 5, 7] ，指定元素 5，则类数组是 [2,, 3] 和 [5]，因为上面两个数组的元素之和相加为5。 自己想了一下， 实现方法如下： 1234567891011121314151617181920212223242526/**** description 得到** arr 传入的数组** value 得到的类数组的值** maxLen 类数组的最大长度**/function compile(arr, value, maxLen = arr.length) &#123; if (!arr.length || !value) return; let result = []; let tempArr = []; const len = arr.length; let nowIndex = 0; while (nowIndex &lt; len) &#123; if (tempArr.length &gt; 0) &#123; let temp = []; for (let item of tempArr) &#123; temp.push([...item, arr[nowIndex]]); &#125; tempArr = [...tempArr, ...temp]; &#125; tempArr.push([arr[nowIndex]]); nowIndex++; &#125; result = tempArr.filter(arr =&gt; (arr.reduce((pev, now) =&gt; (pev = pev + now) &amp;&amp; pev, 0) === value) &amp;&amp; (arr.length &lt;= maxLen) ); return result;&#125; 实现的效果如下： 1compile([1, 2, 3], 5) // [2, 3]]]></content>
      <categories>
        <category>代码集</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阅读函数式编程（二）]]></title>
    <url>%2F2018%2F05%2F23%2F%E9%98%85%E8%AF%BB%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在上一篇文章中，我们了解了关于纯函数的概念， 纯函数的好处体现了函数式编程的一大优点： 没有副作用， 那么什么是函数式编程， 与命令式编程有什么不同， 函数式编程有什么优点，这篇文章想要深入了解下函数式编程的基本概念以及特点； 基本概念在 Wikipedia 上面， 这样解释函数式编程： In computer science, functional programming is a programming paradigm or pattern (a style of building the structure and elements of computer programs) Functional Programming treats computation as the evaluation of mathematical functions. Functional Programming avoids changing-state and mutable data. ​ 在计算机中， 函数式编程是是一种编程范例或者模式（一种构建计算机程序的结构和元素的类型）。 函数式编程将计算视作数学上函数的评估。 函数编程中避免改变状态以及变化的数据。 函数式编程与命令式编程最大的区别在于： 函数式编程关心数据的映射， 命令式编程关心解决问题的步骤。 这里的函数式编程之所以被称作函数，实际上类似于数学上函数的概念； 函数的定义： 设A，B是非空的数集，如果按照某种确定的对应关系f，使对于集合A中的任意一个数x，在集合B中都有唯一确定的数 y 和 x 对应，那么变称映射 f: A ===&gt; B 称为从集合 A 到 B 的一个映射 同样在函数式编程中， 函数式编程中的函数中， 每一个输入值都有一个唯一确定的输出值和输出值对应， 但是不同的输入值可以得到相同的输出值， 这种关系是一种映射关系。当然，对于函数编程而言，它不仅仅可以实现数据的映射， 还可以实现函数之间的映射。 例如：如果我们想要对于数组中的每一个数加1: 12345const arr = [1, 2, 3];for (let index in arr) &#123; arr[index] += 1;&#125;console.log("arr", arr); // [2, 3, 4] 或者使用 forEach, map 中数组中定义的方法： 1234// forEacharr.forEach(item =&gt; item += 1);// mapconst newArr = arr.map(item =&gt; item += 1); 注意：使用 map 以及 forEach 的方法都是对于一个数组进行遍历，接收的参数也是相同的， 但是， 这两个方法之间还是存在着一些区别的， 使用 map 不会改变原数组，但是会返回经过函数运算之后的新数组。对于使用 forEach 而言， 使用 forEach 不会改变原来的数组，返回值为 undefined。 从函数式编程的角度而言，使用 map 更能体现函数式编程的特点： 不会产生副作用； 在上面实现数组中每项加一的操作中， 使用两种代码实现的， 第一个代码中我们将想要计算机运行的步骤通过命令的方式写了下来，告诉计算机， 通过 for 循环循环这个数组，然后数组中的每一项进行加一操作， 而在第二种代码中， 我们通过类似于函数式编程的方式实现，我们不用关心这个过程是怎么实现的， 我们只要将这个数据转换的关系告诉函数就可以了，换句话说， 我们这里关心的是数据之间的映射。 几大特性对于函数式编程而言，存在下面几种特性： 高阶函数 没有副作用 函数柯里化 闭包 高阶函数高阶函数是这样一种函数： 函数被作为参数传入或者被作为返回值被返回的一类函数被称作高阶函数； 例如下面一段 polifill es6 中 promise 的代码中， 对于promise 返回成功状态或者失败状态的调用函数中是下面这样调用的： 123456789101112131415function Promise (executor) &#123; let that = this; that.status = PENDDING; that.value = void 0; that.handlerQueue = []; // 执行函数， 传递进入 value // executor(成功函数， 失败函数); executor(function (value) &#123; // 成功函数执行，传递进入 transition 状态: FULFILLED that.transition(FULFILLED, value); &#125;, function (value) &#123; // 失败函数执行， 传递进入 transition 状态: REJECTED that.transition(REJECTED, value); &#125;)&#125; 在上面的代码中， 这个 executor 函数是被作为参数传入到 Promise 函数中的， 同时这个 executor 也是接受两个函数作为参数， 一个是作为函数返回值为成功状态的函数， 另一个是作为函数返回值为失败状态的函数。 例如计算下面代码： 12345678910111213141516function getSum(a, b, sum = 0) &#123; if (a &lt; b - 1) &#123; return getSum(a + 1, b, sum + a + 1); &#125; else &#123; return sum; &#125;&#125;function getSquare(a, b, sum = 0) &#123; if (a &lt; b - 1) &#123; return getSquare(a + 1, b, sum + Math.pow(a + 1, 2)); &#125; else &#123; return sum; &#125;&#125;const sums = getSum(1, 4);const squareSums = getSquare(1, 4); 上面两段代码分别是求两个数之间的整数和以及平方和;（不包括这两个数） 实际上， 上面的两种方法都是进行函数求和的运算， 只是求和的过程是不一样的，上面的代码我们可以重写如下： 123456789function sumFn(a, b, cb, sum = 0) &#123; if (a &lt; b -1) &#123; return sumFn(a + 1, b, cb, cb(sum, a)); &#125; else &#123; return sum; &#125;&#125;const addSum = sumFn(1, 4, (sum, a) =&gt; sum + 1 + a);const squareSum = sumFn(1, 4, (sum, a) =&gt; sum + Math.pow(a + 1, 2)); 在上面的代码中， 我们抽取出了求和的函数， 通过向求和函数中的参数 cb 中传入一个函数进行求取。 我们可以看到， 在 sumFn 这个函数中， 函数的逻辑取决于传入的参数cb的逻辑， 通过传入函数为参数的这种形式， 将程序的粒度控制在函数的层面上面。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊js中的类]]></title>
    <url>%2F2018%2F05%2F15%2F%E8%81%8A%E8%81%8Ajs%E4%B8%AD%E7%9A%84%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[对于js 中类的使用，自己平常工作的时候也有用到， 但是只是一些浅显的知识，实际上， 在 js 中如何使用类， 对于类的更深一步的理解，还是有很多的东西需要进行了解, 纸上得来终觉浅， 绝知此事要躬行，作为一名程序员更重要的还是要多写， 多练， 在练习中不断成长。 实现类的机制在 js 中有两种方法： prototype 以及 es6 中class 关键字， 下面分别就这两种探讨一下 js 中类的形成： 使用 prototype 实现类什么是 prototype在 js 中创建对象的时候，对象中默认存在一个 prototype（在 Chrome, Safari, Firefox 中的对象上这个属性被称作 _proto_） 属性，这个属性是一个 指针，指向一个对象， 这个对象被称作原型对象， 原型对象上的属性是可以通过对象访问到的： 123let obj = &#123;&#125;;obj._proto_ = &#123; name: "张宁宁" &#125;;obj.name // 张宁宁 想要了解这个过程，我们需要知道当我们在使用 . 或者 [] 查找元素属性的时候，元素属性是如何被查找到的。 当在对象中查找某一个元素属性的时候， 会首先在对象本身上进行属性查找， 如果对象本身上没有查找到对象属性， 那么就会在对象的原型上进行查找。如果在对象本身上已经查找到了， 那么返回这个属性的值 上面的例子中， 虽然我们没有在 obj 上面定义一个 name 属性，但是我们在 obj 对象的原型上定义了一个 name 属性，因此还是可以查找到的。同样， 对于定义在 prototype 上的属性，使用 for in 操作符也是可以访问到的。 1234for (let key in obj) &#123; console.log(key);&#125;// name* 使用hasOwnProperty 方法可以判断定义的属性是在对象本身上面还是在原型上面。 注意： 使用 Object.keys 是不能获得到定义在对象原型上面的属性的。 1Object.keys(obj); // [] 了解原型链原型链的实现方式在 javascript 中，原型链是被用来实现继承的主要方法， 基本的原理如下： 使用原型链实现在 js 中继承的方式是让一个构造函数的原型对象等于另外一个构造函数的实例 我们知道，对于一个构造函数而言，存在一个原型对象， 该构造函数形成的实例包含一个指向原型对象的指针， 如果我们将这个原型对象变为另外一个构造函数的实例，那个同样在这个原型对象中包含一个指向另外一个构造函数的原型对象的指针，这样层层递进，从而形成了一条原型链。 代码实现： 12345678910111213function func1 () &#123; this.value = true;&#125;function func2 () &#123;&#125;func2.prototype.getValue = function () &#123; return this.value;&#125;func1.prototype = new func2()const instance = new func1();// 或者 const instance = Object.create(func1.prototype);// 使用 Object.create(obj) 会创建一个新对象， 并且对象内部的 prototype 指向 objinstance.getValue(); // true 上面的这个过程其实也可以说是我们重写了构造函数的原型; 原型链的终点对于一个原型链而言，是否原型链存在终点呢？实际上， 原型链的终点是存在的。 我们知道在 javascript 中， 存在下面几种基本类型： undefined, null , Boolean , Number, String 这五种基本类型和一种复杂的数据类型： Object. 实际上， 例如我们创建一个新的对象的时候， 创建的这个新的对象实际上是 Object 的实例。 1let newObj = new Object(); 这个时候， 这个对象的原型指向的是对象的原型； 例如我们在对象上经常使用的一些对象方法例如： Object.keys, Object.values 这些方法实际上是定义在对象的原型上面的。 12let obj = &#123;&#125;;obj._proto_ // Object.prototype 而对于 Object.prototype 上面，实际上也是存在一个 prototype 属性， 只不过这个属性指向的是 null; new 操作符我们使用 new 操作符用来创造一个构造函数， 或者可以说， 我们通过使用 new 标识符号将一个普通函数转变为一个构造函数: 使用 new 操作符创造构造函数的实例的时候发生的过程如下： 创建一个新对象。 将这个新对象的原型对象指向构造函数的原型 返回这个新对象。 在 高级程序设计 这本书中有这样一句话： 这两个对象( person 的实例)都有一个constructor(构造函数)属性，这个属性指向 person. 上面这句话第一次读的时候不好理解，看起来感觉像是 constructor 属性是定义在实例上面的，实际上， 这里在实例上能够获得 constructor 属性，其实这里是继承来自于构造函数的原型上面的，因为构造函数的原型上面有个 constructor 属性，这个属性指向构造函数。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>js 类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tooltip 的实现]]></title>
    <url>%2F2018%2F05%2F09%2Ftooltip-%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[在业务上实现了一个类似于 el-tooltip 的方法，类似于下面这种情况： 业务需求是对于弹窗的文字标签字段， 如果文字标签说明太长的时候， 而这个时候文字标签说明又有宽度限制， 这个时候需要实现一个类似于 el-tooltip 的实现方法，但是对于每一个标签上都添加上 el-tooltip 是不现实的，因此想要通过使用指令的方法，对于表单中的标签字段进行动态添加，实现这个指令的 toolTip.js 的具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176// 对于出现dialog 的情况， 都是在 el-dialog__wrapper 上进行滚动的import Util from "./util";const getScrollRoot = () =&gt; &#123; return document.documentElement.querySelector(".el-dialog__wrapper");&#125;;let instancePool = [];// 定义 tip instance 方法const instanceAction = () =&gt; &#123; const push = (instance) =&gt; &#123; instancePool.push(instance); &#125;; return &#123; pushInstance: push &#125;;&#125;;// 获取到绑定元素在当前页面上距离左边的距离const getElementViewLeft = (element) =&gt; &#123; let actualLeft = element.offsetLeft; let current = element.offsetParent; while (current !== null) &#123; actualLeft += current.offsetLeft; current = current.offsetParent; &#125; return actualLeft;&#125;;// 获取到绑定元素在当前页面上位置高度const getElementViewTop = (element) =&gt; &#123; let actualTop = element.offsetTop; let current = element.offsetParent; while (current !== null) &#123; actualTop += current.offsetTop; current = current.offsetParent; &#125; return actualTop;&#125;;function tooltip(el, opt) &#123; const items = el.querySelectorAll(".el-form-item"); for (const item of items) &#123; const target = item.firstChild; // 如果定义了一个 label 为空的时候的 form-item， label 部分为 before 元素， 但是还是可以这个时候 className 为 null if (target.className) &#123; // 将每一个需要显示标签的实例信息压入 instanceAction().pushInstance(&#123; tip: null, target, message: target.innerText, offset: 0, class: "vk-tooltip" &#125;); &#125; &#125; this.scrollListener = null; this.mouseenterListener = null; this.mouseleaveListener = null; this.init(); // target：传入的DOM // this.target = el; // tip：用来放初始化创建的tip元素 // this.tip = null; // this.message = (opt &amp;&amp; opt.msg) || this.target.innerText; // this.offset = (opt &amp;&amp; +opt.offset) || 0; // this.class = "vk-tooltip"; // instanceAction.push(); // this.init();&#125;tooltip.prototype = &#123; // 初始化tip，添加事件监听 init: function () &#123; const me = this; const root = getScrollRoot(); // 鼠标进入才创建标签 for (let instance of instancePool) &#123; const &#123; target, tip, message, offset &#125; = instance; // 滚动监听事件 // 鼠标移入监听事件 // 鼠标移除监听事件 if (message.length &lt; 6) continue; this.mouseenterListener = Util.listener(target, "mouseenter", () =&gt; &#123; instance = me.createTip(instance); instance.tip.style.opacity = 1; this.scrollListener = Util.listener(root, "scroll", () =&gt; &#123; me.setTipPlace(instance.tip, instance.target, instance.offset); instance.tip.style.opacity = 0; &#125;); this.scrollListener.listen(); &#125;); this.mouseenterListener.listen(); this.mouseleaveListener = Util.listener(target, "mouseleave", () =&gt; &#123; instance.tip.style.opacity = 0; this.scrollListener.remove(); &#125;); this.mouseleaveListener.listen(); &#125; &#125;, createTip(instance) &#123; const me = this; const poppup = "&lt;div class='triangle-down'&gt;&lt;/div&gt;"; const cache = document.getElementsByClassName(instance.class); // 如果存在一个tip标签则使用该标签 instance.tip = cache.length ? cache[0] : document.createElement("div"); instance.tip.className = instance.class; instance.tip.innerHTML = `$&#123;instance.message&#125;$&#123;poppup&#125;`; document.body.appendChild(instance.tip); if (!me.tip) &#123; me.tip = instance.tip; &#125; me.setTipPlace(instance.tip, instance.target, instance.offset); return instance; &#125;, // 设置tip显示的位置 setTipPlace: function (tip, target, offset) &#123; const root = getScrollRoot(); const distance = (tip.clientWidth - target.clientWidth) / 2; const pageX = `$&#123;getElementViewLeft(target) - root.scrollLeft - distance + offset&#125;px`; const pageY = `$&#123;getElementViewTop(target) - target.clientHeight - root.scrollTop&#125;px`; tip.style.left = pageX; tip.style.top = pageY; &#125;, clear: function () &#123; instancePool = []; if (this.tip) &#123; this.tip.parentNode.removeChild(this.tip); &#125; this.mouseenterListener.remove(); this.mouseleaveListener.remove(); this.mouseenterListener = null; this.mouseleaveListener = null; this.scrollListener = null; &#125;&#125;;export default tooltip;// /**// * @description 因为el的tooltip展示需要用到组件，这里用指令进行tooltip展示// * @example &lt;div v-tips&gt;此处为被缩略的文本内容&lt;/div&gt;// * @param opt v-tips="opt" 可以传入配置对象, msg 展示信息, offset X轴偏移量// * 在元素插入DOM时，创建tooltip实例。// */// Vue.directive("tips", &#123;// bind: (el) =&gt; &#123;// console.log(el);// &#125;,// // 当绑定元素插入到 DOM 中。// inserted: (el, &#123; value &#125;) =&gt; &#123;// // 暂时针对el-form的label标签，所以指定firsChild// this.instance = new VkTooltip(el.firstChild, value);// &#125;,// // 解除绑定的时候清除实例以及标签,清除事件监听// unbind: (el) =&gt; &#123;// this.instance.clear();// &#125;// &#125;);// Util listen 函数Util.listen = (target, eventType, callback) =&gt; &#123; if (target.addEventListener) &#123; return &#123; listen: &#123; target.addEventListener(eventType, callback, false); &#125;, remove: &#123; target.removeEventListener(eventType, callback, false); &#125; &#125; &#125; else if (target.attachEvent) &#123; listen: &#123; target.attachEvent('on' + eventType, callback); &#125;, remove: &#123; target.detachEvent('on' + eventType, callback); &#125; &#125;&#125; 使用的时候， 这个函数被作为指令在 main.js 中引入： 1234567891011import VKTooltip from "@/assets/js/tooltip";Vue.directive("tips", &#123; bind: (el) =&gt; &#123; &#125;, inserted: (el, &#123; value &#125;) =&gt; &#123; this.instance = new VKTooltip(el, value); &#125;, unbind: (el) =&gt; &#123; this. instance.clear(); &#125;&#125;); 关于在 vue.js 中自定义指令的使用， 可以查看vue.js 官网， 自定义指令 需要注意的知识点： 对于页面元素各个位置的理解 js 基础一定要熟悉]]></content>
      <categories>
        <category>代码集</category>
      </categories>
      <tags>
        <tag>toolTip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件监听代码]]></title>
    <url>%2F2018%2F05%2F06%2F%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[简单的事件监听函数，从 N3-components 组件代码中发现的： 123456789101112131415161718192021const EventListener = &#123; listen (listen, eventType, callback) &#123; // 如果存在 addEventListener if (target.addEventListener) &#123; target.addEventListener(eventType, callback, false); return &#123; remove () &#123; target.removeEventListener(eventType, callback, false); &#125; &#125; // 如果存在 attachEvent 事件 &#125; else if (target.attachEvent) &#123; target.attachEvent('on' + eventType); return &#123; remove () &#123; target.detachEvent('on' + eventType, callback); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>代码集</category>
      </categories>
      <tags>
        <tag>事件监听</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 知识总结]]></title>
    <url>%2F2018%2F04%2F29%2Fvue%20%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在项目开发中，发现对于 vue 的使用还有一些新的认识，在这段时间中使用到的知识点做一个总结： 计算属性和侦听器在 vue.js 中，通过使用 watch 以及 computed 这两个方法来进行侦听数据的变化，但是这两种方式对于数据侦听的处理是不同的，应用的场景也是不同的， 之前应用的时候总是习惯性的时候用 watch, 但是在一些情况下，使用 comnputed 要更好一些，这里先简单的介绍这两种方法的使用， 具体可见 vue.js 官方文档：计算属性和侦听器 watch: watch侦听器相对于 computed 而言更为通用，使用 watch 用来监听数据的变化， 定义在数据变化之后的行为，基本使用用法如下： 123456789101112// 监听某一个数据watch: &#123; value: function (newVal, oldVal) &#123; // some action &#125;&#125;// 监听对象中的某一个属性watch: &#123; "object.value"： function (newVal, oldVal) &#123; // some action &#125;&#125; 注意： 使用 watch 不能监听到对象的变化， 如果想要对于对象进行监听， 可以使用 deep: true: 12345678watch: &#123; object: &#123; handler: function (newVal, oldVal) &#123; // somn action &#125;, deep: true &#125;&#125; 如果想要回调在监听之后立即被调用， 可以设置 immediate:true ： 12345678910watch: &#123; object: &#123; // 回调函数立即被调用不管监听对象有没有被调用 handler: function (newVal, oldVal) &#123; // some action &#125;, deep: true, immediate: true &#125;&#125; computed: 在有些地方， 我们使用 computed 要比单纯的监听数据的变化要方便很多， 比如下面这种情况： 1234567891011121314data() &#123; person: &#123; name: "", age: "", sex: "" &#125;&#125;,computed: &#123; personMsg: function () &#123; // 这里可以监听到对象的变化 const &#123; name, age, sex &#125; = this.person; return `$&#123;name&#125; is a $&#123;age&#125; $&#123;sex&#125;`; &#125;&#125; 当上面代码中的 this.person 中的数据发生变化的时候， personMsg 就会实时的发生变化： 对于 computed 的使用， 注意下面两点： 对于上面代码中的计算属性： personMsg 的取值决定于 this.person 的值， 这里计算函数实际上拦截了计算属性的 getter 函数， 计算属性可以在模版中像其他 data 中的数据一样被使用 1&lt;div&gt;&#123;&#123; personMsg &#125;&#125;&lt;div&gt; 使用函数调用可以实现类似于计算属性相同的作用：不同的是计算属性可以进行缓存数据，之后只有当计算属性的依赖选项发生变化的时候， 计算属性才会求值， 如果依赖项没有发生变化，那么计算属性就不会发生再次求职。 12345methods: &#123; personMsg () &#123; return this.msg; &#125;&#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue 知识总结（一）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由目录搜索想到的多叉树向二叉树的转换]]></title>
    <url>%2F2018%2F04%2F21%2F%E7%94%B1%E7%9B%AE%E5%BD%95%E6%90%9C%E7%B4%A2%E6%83%B3%E5%88%B0%E7%9A%84%E5%A4%9A%E5%8F%89%E6%A0%91%E5%90%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[目录搜索在上个星期一轮迭代之后， 自己手上暂时还没有工作要做，在上一期迭代中， 需求表示目录太长了，用户不好操作，虽然这个问题通过添加滚动条解决了，但是我想着加一个搜索框实现对于目录的搜索， 效果如下： your browser does not support the video tag 如上面所示我们想要进行一个对于目录的搜索，其中目录部分的结构如下： 123456789&#123; children: [ children: [...], title: ..., ... ], title: ..., ...&#125; 这里 title 表示目录的名字， children 表示当前目录下的子目录，如果当前目录没有子目录， 那么 children 属性就不会存在。 html 部分： 1&lt;el-input v-model="searchContent"&gt;&lt;/el-input&gt; vue 部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152export default &#123; data () &#123; searchContent: "", originMenus: "" &#125;, watch： &#123; "route": function () &#123; // 这里用来保存原始数组 this.originMenus = Util.clone(this.menus); &#125;, "searchContent": function (val) &#123; if (val.trim().length === 0) &#123; this.menus = this.originMenus; &#125; else &#123; this.filterMenus(val, this.orginMenus); &#125; &#125;, methods: &#123; filterMenus(val, menus) &#123; const filterVal = val; // 深拷贝对象 const filterMenus = Util.clone(menus); const filterFn = theMenus =&gt; &#123; if (theMenus.children) &#123; let spliceIndex = 0; // 当我们想要对于一个数组进行条件判断并且删除数组中的元素的时候， 可以使用 Array.splice 进行操作 while (spliceIndex &lt; theMenus.children.length) &#123; if (Array.isArray(theMenus.children[spliceIndex].children) &amp;&amp;theMenus.children[spliceIndex].children.length !== 0) &#123; // 这里使用递归， 因为对于children 下的各个目录， 判断条件也是基本上一样的 filterFn(theMenus.children[spliceIndex]); // 如果当前目录下存在符合条件的， spliceIndex ++ 使用 continue 跳过当前的 while 循环 if (theMenus.children[spliceIndex].children.length !== 0) &#123; spliceIndex++; continue; &#125; &#125; // 这一部分， 如何实现有选择性的删除的？ // 使用 splice 用于数组的删除，如果满足某一个条件， splice 跳过条件删除 if (theMenus.children[spliceIndex] &amp;&amp; theMenus.children[spliceIndex].title &amp;&amp; theMenus.children[spliceIndex].title.indexOf(val) &gt; -1) &#123; spliceIndex++; &#125; else &#123; theMenus.children.splice(spliceIndex, 1); &#125; &#125; &#125; &#125;; filterFn(filterMenus); return filterMenus; &#125; &#125; &#125;&#125; 在上面的代码中， 使用到了 while 循环以及一些递归的东西。 由多叉树向二叉树的转换在上面的目录搜索中，其实自己想要将目录搜索转化为二叉树进行搜索的， 只不过后面发现没有必要，但是自己也是做了一个多叉树转化二叉树的函数。 二叉树二叉树是这样的一种树： 二叉树是 n ( n &gt;=0 ) 个结点的有限集合， 该集合或者为空集( 空二叉树 ), 或者有一个根节点和两棵互不相交的， 分别称为根节点和左子树和右子树的二叉树组成。 二叉树的特点每一个节点最多有两棵子树， 二叉树中每一个节点都是一个对象， 对于一个完整的二叉树而言， 每一个二叉树节点存在三个指针， 分别指向父母， 左孩子以及右孩子的指针， 每一个节点都是通过指针相互连接的， 连接指针的关系都是父子关系。 二叉树节点的代码定义： 12345678910111213141516node &#123; value: "", // 左孩子 left: &#123; left : &#123; ... &#125;, right ： &#123; ... &#125; &#125;, // 右孩子 right: &#123; ... &#125;&#125; 二叉树的遍历对于二叉树而言， 存在三种遍历方式： 前序遍历： 首先访问根节点， 然后遍历左子树， 最后遍历右子树。 中序遍历：首先遍历左子树， 然后访问根节点，最后遍历右子树。 后序遍历：首先遍历左子树， 然后遍历右子树， 最后访问根节点。 下面是三种遍历的示意图： 前序遍历： ​ 代码实现： 1234567function preOrder (node) &#123; if (node !== null) &#123; getNode(node); preOrder(node.left); preOrder(node.right); &#125;&#125; 中序遍历： 代码实现： 12345678910function inOrder (node) &#123; if (node !== null) &#123; // 先访问左子树 inOrder(node.left); // 访问根节点 getNode(node); // 访问右子树 inOrder(node.right); &#125;&#125; 后序遍历： 代码实现： 123456789function postOrder (node) &#123; if (node !== null) &#123; // 先访问左节点 postOrder(node.left); // 再访问右节点 postOrder(node.right); getNode(node); &#125;&#125; 使用二叉树的目的上面说了这么多， 那么我们为什么构建二叉树呢？二叉树相对于其它的数据结构而言具有什么优点呢？ 对于数组而言， 实现数组的搜索比较方便， 可以直接使用下标访问到， 但是如果对于数组进行删除和插入就比较麻烦了， 而对于链表而言， 插入和删除比较简单， 但是访问却相对来说慢了一些。 对于有序数组而言， 对于有序数组在查找的时候有较高的效率。而无序链表在插入的时候具有较高的灵敏性。而对于二叉树而言， 二叉树综合了上面两种数据结构的优点。 二叉查找树二叉查找数用来寻找到一组数组中的值的大小是非常有用的，因为二叉查找树在定义的时候定义到节点的左节点的值要小于右节点的值。 如下使用数组建立一个二叉查找树： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 构建左节点function setLeftNode(array, node) &#123; const len = array.length; if (len % 2 !== 0) &#123; if (array[(len - 1) / 2]) &#123; node.left = &#123; value: array[(len - 1) / 2] &#125;; &#125; return; &#125; if (array[len / 2]) &#123; node.left = &#123; value: array[len / 2] &#125;; &#125;&#125;// 构建右节点function setRightNode(array, node) &#123; const len = array.length; if (len % 2 !== 0) &#123; if (array[(len - 1) / 2]) &#123; node.right = &#123; value: array[(len - 1) / 2] &#125;; &#125; return; &#125; if (array[len / 2]) &#123; node.right = &#123; value: array[len / 2] &#125;; &#125;&#125;// 将数组转化为二叉树function arrayToTree(array, node) &#123; const len = array.length; array.sort(); node.value = (len % 2) !== 0 ? array[(len - 1) / 2] : array[len / 2]; const leftArr = array.slice(0, (len % 2) !== 0 ? (len - 1) / 2 : len / 2); const rightArr = array.slice(((len) % 2) !== 0 ? (len + 1) / 2 : ((len / 2) + 1), array.length); setLeftNode(leftArr, node); setRightNode(rightArr, node); (leftArr.length !== 0) &amp;&amp; arrayToTree(leftArr, node.left); (rightArr.length !== 0) &amp;&amp; arrayToTree(rightArr, node.right); return node;&#125; 123const arr = [1, 9, 2, 6, 3, 4, 7, 8];let tree = &#123;&#125;;console.log(arrayToTree(arr, tree)); 最终结果如下： 多叉树如果一个节点下面有多个节点， 那么可以称这样的数据结构为多叉树,这里可以类比二叉树中的两个子节点： 例如上面中的目录部分就是一个多叉树，根目录下面有多个子目录， 子目录下面还有可能有别的目录，如果将这样的多叉树转换为二叉树呢？只要记住一个转换原则就可以了： 多叉树向二叉树转换的原则是： 左孩子，右兄弟。也就是说，一颗转换完成的二叉树的任意一个节点的左节点都是在转换之前的多叉树中的子节点， 任意一个节点的右节点都是当前节点在转换之前的多叉树中的兄弟节点。 转化示意图如下： 转化代码： 123456789101112131415const treeRight = (tree, fatherChild) =&gt; &#123; if (fatherChild &amp;&amp; fatherChild.length !== 0) &#123; fatherChild.splice(0, 1); tree.right = fatherChild[0]; treeLeft(tree.right, fatherChild); treeRight(tree.right, fatherChild); &#125;&#125;;const treeLeft = (tree) =&gt; &#123; if (tree &amp;&amp; tree.children) &#123; tree.left = tree.children[0]; treeLeft(tree.left); treeRight(tree.left, tree.children); &#125;&#125;;]]></content>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vertical-align && line-height]]></title>
    <url>%2F2018%2F03%2F26%2Fvertical-align%2F</url>
    <content type="text"><![CDATA[vertical-align关于 vertical-align 的字面意思是垂直居中的意思， 其中 vertical-align 有下面几种支持的属性： 值 含义 baseline(初始值) 一个元素的基线和父元素的基线对齐 sub 将元素作为一个下标，该元素的基线会相当于父元素的基线降低 super 将元素作为一个上标， 该元素的基线会相当于父元素的基线升高 top 把对齐的子元素的顶端与父元素顶端对齐。 text-top 类似于使用 text-bottom ， 将元素行内文本的顶端与父元素的顶端对齐 middle 居中对齐，常用于图像的垂直居中 bottom 将元素行内框的低端与父元素的低端对齐 text-bottom 行内文本的底端与行框的低端对齐 百分数 将元素的基线相对于父元素的基线升高或者降低指定的量， 这里的百分数是指相对于该元素的 line-height 的百分数。 length 使用 length 用于将元素升高或者降低指定的距离 inherit 从父元素下继承属性 注意：这里的 vertical-align 影响的是行内元素， 行内块元素，以及表单元格的对齐，对于 块状元素不受 vertical-align 的影响。 vertical-align 作用效果在图像垂直居中的时候的作用： 123&lt;div class="wrap"&gt; &lt;img class="img" alt="这是一张图片"&gt;&lt;/div&gt; 我们知道对于行内元素的垂直居中我们可以使用 line-height = height 的方法实现垂直居中的效果， 但是对于图像而言使用这种方法是失效的，例如下面的代码： 12345678910.wrap &#123; width: 200px; height: 300px; line-height: 300px; background-color: blue;&#125;.img &#123; width: 50px; height: 50px;&#125; 结果如下： 如上图所示， 使用 line-height = height 并不能实现对于图片的垂直居中效果，为了实现图片的垂直居中， 在 img 元素上添加 vertical-align:middle 效果， 最终效果如下： 123.img &#123; vertical-align: middle;&#125; ​ 注意： 这里的 vertical-align 主要参照的是父元素的行高， 因此在设置 vertical-align: middle 的时候，需要将父元素的 line-height 设置为 父元素的 height 高度。 vertical-align:middlevertical-align: middle 经常用于图像的居中， 我们要注意的一点就是，当元素设置 vertical-align: middle 的时候，这个属性会将行内元素框的中点与父元素的基线上方 0.5ex 处的一个点进行对齐， 这里的 1ex 是相对于父元素的 font-size 进行定义的，例如下面这个例子： 123&lt;span class="allDemo"&gt; &lt;span class="demo1"&gt;我是一段文字&lt;/span&gt;&lt;span class="demo2"&gt;我是第二段文字&lt;/span&gt;&lt;/span&gt; 对于 demo1 进行 vertical-align: middle: 123456789101112.allDemo &#123; display: inline-block; background-color: lightslategray;&#125;.demo2 &#123; line-height: 100px; background-color: lightgreen;&#125;.demo1&#123; background-color: lightcoral; vertical-align: middle;&#125; 如上图所示， class = &quot;demo2&quot; 这段文字， vertical-align 默认是 baseline,其元素框底端是与行框的基线对齐的，demo1 相比于 demo2 元素而言， 元素下移， 这是 vertical-align: middle 之后的结果， 图示如下: 如果我们将父元素的 font-size 置为0， 我们将会看到下面的情况： 代码如下： 123.allDemo &#123; font-size: 0px &#125;;.demo1 &#123; font-size: 16px &#125;;.demo2 &#123; font-size: 16px &#125;; vertical-align 各属性作用位置如下： line-heightline-height 与 line box 之间的关系line-height 从字面意义上来讲， 是 行高 的意思，在页面上表现出来的就是一行文字的高度， 在介绍 line-height 之前，我们先来认识一下 line boxes 和 inline boxes 这两个东西。 line boxes 与 inline boxesinline boxes : 可以认为是包裹在 inline 元素外面的的一层外层， 例如 span 元素， img 图片元素等 inline 形式的元素，对于 inline 水平的元素，都会形成一层的 inline boxes 进行包裹。line boxex : 对于 line boxes 你可以认为 line boxes 用于包裹一行元素， 也就是说，对于一行 inline 水平的元素而言， 在外面有一个 line boxes 进行包裹， 如果一行有多个 inline 水平的元素，那么，这一行的 line boxes 就会包含有多个的 inline boxex。对于 line boxes 的元素的高度， 他的高度是获取该 box 下面的所有的 inline boxes 元素的高度 ， 比较获取他们中最大的高度， 最后这个最大的高度被认为是 line boxes 的最大高度。 这里 inline boxes 的高度是什么呢？ 就是今天我们要说的 line-height.行高具体来讲就是两行文字之间基线之间的距离：如下图所示：上面的图中红线就是表示所谓的基线， 关于我们另外一个css 的属性 vertical-align 改变的就是基线的高低大小。 使用 line-height 实现的垂直居中实现我们经常使用 line-height = height 实现行内元素的垂直居中效果， 这里的 height ， 更为确切的说是 我们将要居中 line boxes 的高度进行居中， 因为对于行高而言具有一个垂直居中的性质。 使用 line-height = height 在图片中垂直居中效果的失效。html:123&lt;div class="demo"&gt; &lt;img src="./picture.png" alt="垂直居中的图片" class="img"&gt;&lt;/div&gt; CSS:123456789.demo &#123; display: inline-block; line-height: 150px; height: 150px; background-color: lightblue;&#125;.img &#123; height: 50px;&#125; 最终结果如下： 并没有居中！ 对于图片元素而言， 使用 line-height = height 并不能实现元素的垂直居中，要想实现这种效果， 就需要 vertcial-align: middle 出马了。 但是使用 vertical-align:middle 就能保证万无一失了吗？ font-size: 0px 在图片居中时的应用在讲解 vertical-align:middle 的时候， 我们使用 vertical-align: middle 实现了图片的垂直居中， 但是这个垂直居中只是近似的， 并不是真正的垂直居中。 123&lt;div class="imgWrap"&gt; &lt;img src="img.png" class="img"&gt;&lt;/div&gt; 123456789.imgWrap &#123; line-height: 40px; background-color: lightblue;&#125;.img &#123; width: 50px; height: 30px; vertical-align: middle;&#125; 我们看到，这个时候使用 vertical-align:middle 并没有实现真正的垂直居中， 原因是什么呢？ 因为就如同我们刚才说的那样： 当元素设置 vertical-align: middle 的时候，这个属性会将行内元素框的中点与父元素的基线上方 0.5ex 处的一个点进行对齐 我们想要的结果是将行内元素框的中点和父元素的中点进行对齐，而使用 vertical-align 的时候并不是这样， 为了解决这个问题， 我们使用了font-size: 0这个属性。 代码如下： 123.imgWrap &#123; font-size: 0;&#125; 居中成功！ font-size: 0px 起的作用是： 基线和中线之间的距离是根据字母 x 的高度进行计算的， 通过设置 font-size 为0， 使得 基线和中线在同一水平线上，从而使得图片元素框的中线和父元素的中线重合， 实现垂直对齐效果。 使用 vertical-align:middle 对齐的不是父元素的基线， 而是基线上面 0.5ex 这样一个高度的点， 但是这个高度是由父元素的 font-size 来决定的， 这样就将这个高度置为 0 ， 从而使得图片中线和父元素基线对齐。 参考链接张鑫旭：css行高line-height的一些深入理解及应用]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>vertical-align &amp;&amp; line-height</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阅读函数式编程（一）]]></title>
    <url>%2F2018%2F03%2F20%2F%E9%98%85%E8%AF%BB%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[函数式编程的定义在 javascript 中， 函数被作为一等公民， 属于内置对象, 函数是对象中的一个子类型， 因此， 函数可以当作参数传递， 可以放到数组之中，本质上和普通的对象是一样的， 只不过相对于普通的对象而言， 函数可以被调用， 因此可以被称作可调用的对象。 在 js 中， 存在下面几种内置对象： String Number Boolean Object Function Array Date Regexp Error 这几种内置对象相当于语言中的类，可以通过使用 new 操作符进行调用。 使用函数式编程的目的在于： 我们希望去践行每一部分都能完美接合的理论，希望能以一种通用的、可组合的组件来表示我们的特定问题，然后利用这些组件的特性来解决这些问题。 使用纯函数什么是纯函数， 在介绍纯函数之前， 我们先看下关于纯函数的概念： 纯函数是这样一种函数，即相同的输入， 永远只能得到相同的输出，而且没有任何可以观察到的副作用。 对于有些函数而言，在函数执行的过程中发生了一些可能会影响外部状态的副作用， 包括下面几种： 外部状态发生了改变 读取文件 console.log 数据 发送请求 总而言之， 在函数执行的过程中， 函数与外部环境发生了交互的过程，代表这个函数存在副作用， 存在副作用的不纯函数容易产生 bug, 数据状态难以追踪， 并且增加我们的认知负荷， 因此， 在函数编写的过程中要尽量较少函数执行的时候对于外部环境的影响。 这里对于纯函数而言， 相同的输入总会得到相同的输出， 这里类似于数学中的函数的概念， 在数学中的函数的概念中， 存在一个映射的改变： 函数只是两种数值之间的关系， 尽管相同的输入只能得到相同的输出， 但是不同的输入也可以得到相同的输出 因为在纯函数中，相同的输入只能得到相同的输出， 因此对于输入值是一定的情况下，对于输出的值则是一定的， 这样的情况下， 我们所要关心的只是这个函数做了什么，而不同尽力了解函数实现的具体细节， 这样能够增强我们调试代码的便利性。 使用纯函数的好处 可缓存性 简单的一段代码如下： 12345678910111213let squareNumber = memorize(function (x) return &#123; x*x &#125;);squareNumber(4) =&gt; 16;squareNumber(4) =&gt; 16; // 从缓存中获取到的值// memorize 函数如下function memorize(f) &#123; let cacheData = &#123;&#125;; return function() &#123; let arg = JSON.stringify(arguments); cacheData[arg] = cacheData[arg] || f.apply(f, arguments); return cacheData[arg]; &#125;&#125; 上面的这种纯函数的可缓存性类似于在 js 中的闭包的效果， 可以将值保存在函数内部。 依赖明确， 易于调试 对于纯函数而言， 函数的依赖都是写在函数参数之中的， 更便于我们理解与调试， 对于纯函数而言， 与外部函数发生作用的仅仅是定义中传入的参数，函数内部则不会涉及到关于外部环境的变量。 引用透明性 如果一段代码可以替换成它执行之后得到的结果， 而且是在不改变整个程序行为的情况下被替换的， 那么， 我们说这段函数具有引用透明性。 例如对于类似下面这类的代码： 12345678910111213141516function isNewUser() &#123; // 判断是否是新用户&#125;function loginIn(user) &#123; // 用户登录&#125;function register(user) &#123; // 注册新用户&#125;function start(user) &#123; if (isNewUser(user)) &#123; register(user); return; &#125; loginIn(user);&#125; 在上面的代码中， 三个行为， 判断是否是新用户， 登录， 注册， 三个部分的逻辑封装在三个函数中， 从而更容易理解。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器渲染过程]]></title>
    <url>%2F2018%2F03%2F13%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[浏览器渲染过程以及原理浏览器渲染的过程对于浏览器而言， 浏览器请求， 加载， 渲染一个页面的时候，所要花费的时间主要在下面几个过程中: DNS 查询（DNS 根据服务器地址查找到IP地址） TCP 连接（用于连接客户端与服务器， 包含三次握手，四次挥手的过程） HTTP 请求以及响应（请求响应数据） 服务器响应（后端响应数据） 客户端渲染 对于第五个部分客户端渲染的过程中， 这一部分过程主要是渲染树的构建，布局，以及绘制， 具体而言， 主要是下面几个过程： 处理 HTML 标记并且构建 DOM 树。 处理 CSS 标记并且构建 CSSOM 树。 将 DOM 以及 CSSOM 合并为一个渲染树。 根据渲染树进行布局,以计算每个节点的几何信息。 将各个节点绘制到屏幕上去。 在上面的过程中，如果DOM或者CSSOM被修改,那个这个过程需要重复执行，重新在屏幕上进行渲染。 阻塞渲染在一个网页中， CSS被视为阻塞性的资源， 当 CSSOM 被构建的时候， 其他的内容将不会被处理， 因此， 只有当 CSSOM 构建完毕之后其他内容才可能被加载。对于 javascript 也是类似的效果， 当浏览器遇到一个 script 标记的时候，DOM 构建将会暂停，知道脚本完成执行。 使用 javascript 可以改变 DOM 以及 CSSOM， 而当 DOM 或者 CSSOM 被改变的时候， 这两个树均会重新进行绘制， 对于 CSSOM 因为是阻塞性资源, 在构建的时候， JavaScript 将会延迟执行， 直到CSSOM 构建完毕。 在实际使用的时候应该遵循下面两个原则： CSS资源要优于JavaScript 资源进行加载。 尽量避免使用 JavaScript 进行DOM 的操作。 解决渲染阻塞的几种方法CSS对于 CSS 而言， 浏览器解析 CSS 用于创建 CSSOM 树， 因此在 CSS 编写的过程中要注意对于 CSS 解析速度的影响： 提高CSS页面的加载速度 提高页面的加载速度主要是通过将样式尽量写在单独的文件里面， 将 CSS样式作为单独的文件进行引入， 这样做的目的不仅仅是减少页面体积， 并且可以利用 CSS 文件的缓存以及重用， 提高文件的加载速度。 少用 @import 用于引入 CSS 文件, 使用 @import 会影响 CSS 文件的加载速度。 加快解析速度， 提高解析性能。 减少css 样式的嵌套层数， 对于 CSS 的嵌套层数尽量不要超过三层, 过多的嵌套层数会影响到CSS的解析速度。]]></content>
      <tags>
        <tag>浏览器渲染</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this.nextTick in vue.js]]></title>
    <url>%2F2018%2F01%2F21%2Fthis-nextTick-in-vue-js%2F</url>
    <content type="text"><![CDATA[this.nextTick 的作用在 Vue.js 的官方文档中是这样描述 this.nextTick 的: 为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用. 在 vue.js 中, 使用 this.nextTick 的作用是更新 dom , 在 涉及关于在 vue.js 中 Dom 的操作中, 当我们想要操作被更新后的 DOM的时候，可以使用 this.nextTick 进行操作。 为什么采用 this.nextTick Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。 使用 this.nextTick 的两种情况: 在 created 阶段的时候， 这个时候 DOM 元素尚未挂载, 在这个钩子函数内操作 DOM 是无法找到 DOM 元素的， 这个时候使用 this.nextTick 类似于使用 mounted 的钩子函数， 这个时候所有的 DOM 元素挂载和渲染均已经完成，这个时候可以执行对于 DOM 元素的操作。 当我们想要对于数据发生变化之后的 DOM 元素之后执行一些操作的时候， 我们可以使用 this.nextTick(callback) 那么 callback 回调函数就会当 DOM 元素被更新之后被触发。 ​ 上图是 vue 实例的生命周期图。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>this.nextTick</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 中数据结构的实现]]></title>
    <url>%2F2018%2F01%2F13%2Fjs-%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[对于线性表而言， 使用链式的存储结构可以提高相对于使用线性表添加和删除节点的操作效率。 对于链表中的每一个元素，除了需要存储其本身的信息之外，还需要存储一个显示后面元素位置的信息。 单链表的实现实现单向链式列表的代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140function LinkedList() &#123; // 对于链表中的元素包含有 element 以及 next // element 表示数据 // next 表示指向下一个的指针 let Node = function (element) &#123; this.element = element; this.next = null; &#125;; let length = 0, head = null; // append 添加元素 this.append = function (element) &#123; let node = new Node(element), current; if (!head) &#123; head = node; &#125; else &#123; current = node; // 使用 while 进行循环操作 // 一直进行循环, current = current.next; while (current.next) &#123; current = current.next; &#125; current.next = node; &#125; length++; return current; &#125;; // this.insert 用于插入节点 this.insert = function (position, element) &#123; if (position &gt; 0 &amp;&amp; position &lt;= length) &#123; let node = new Node(element), currrent = head, previous, index = 0; if (position === 0) &#123; node.next = current; head = node; &#125; else &#123; while (index++ &lt; position) &#123; previous = current; current = current.next; &#125; node.next = current; previous.next = node; &#125;; length++; return true; &#125; else &#123; return null; &#125; &#125;; // 删除某一个位置处的元素 this.removeAt = function (position) &#123; if (position &gt; -1 &amp;&amp; position &lt; length) &#123; let current = head, previous, index = 0; if (position === 0) &#123; head = currrent.next; &#125; else &#123; while (index++ &lt; position) &#123; previous = current; current = current.next; &#125; // 在删除了某一个元素之后 // previous.next 指向 current.next previous.next = current.next; &#125;; length--; return current.element; &#125; else &#123; return null; &#125; &#125;; // 移除某一个节点 this.remove = function (element) &#123; let current = head, previous; if (element === current.element) &#123; head = current.next; length--; return true; &#125; previous = current; current = current.next; while(currrent) &#123; if (element === current.element) &#123; previous.next = current.next; length--; return true; &#125; else &#123; // 继续轮询下一个元素 previous = current; current = current.next; &#125; &#125; return false; &#125;; // this.remove 用于删除最后一个节点 this.remove = function () &#123; if (length &lt; 1) &#123; return false; &#125; let current = head, previous; if (length === 1) &#123; head = null; length--; return current.length; &#125; while(current.next !== null) &#123; previous = current; current.current.next; &#125; previous.next = null; length--; return current.element; &#125;; // indexOf 获取到索引值 this.indexOf = function (element) &#123; let current = head, index = 0; while(current) &#123; if (element === current.element) &#123; return index; &#125; index++; current = current.next; &#125; return false; &#125;; this.isEmpty = function () &#123; return length === 0; &#125;; this.size = function () &#123; return length; &#125;; this.toString = function () &#123; let current = head, str = ''; while(current) &#123; str+= current.element; currrent = current.next; &#125; return str; &#125; this.getHead = function () &#123; return head; &#125;&#125; 对于线性表的链式存储结构而言，链表中每一个节点包含数据域与指针域，相对于使用线性表的顺序存储结构而言， 在链表中数据的存储是没有特定的顺序的，在链表中， 节点之间的关系是通过其本身存储的指针来进行体现的。 指针表示的是线性表中的数据元素与数据元素之间的关系。 对于链表而言，我们想要获取到第 i 个元素的值比较麻烦的， 因为对于第 i 个元素 a ~i~ 的存储地址放在了链表中上一个节点中的指针域中，同理， 这个节点的存储地址有被放在了上上一个节点中的指针域中…..，如果要查找到这个元素，要使用下面的算法: 声明节点指向链表的第一个节点， 初始化 j 从 1 开始。 当 j &lt; i 的时候，遍历链表， 使 p 的指针向后移动， 不断指向下一个节点， j 累加 1; 如果链表末尾为空， 那么说明第 i 个元素不存在。 如果查找成功的话，返回查找到的数据。 对于上面的单链表程序而言， 我们可以添加一个获得相关位置的元素的方法: 123456789101112131415this.getEle = function (elementIndex) &#123; let current = head, index = 0; if (elementIndex &gt; 0 &amp;&amp; elementIndex &lt;= length) &#123; // while 内嵌 current = current.next 方法， 从头开始查询 while(current) &#123; if (index === elementIndex) &#123; return current.element; &#125; index++; current = current.next; &#125; &#125; else &#123; return null; &#125;&#125; 链表的使用相对于使用线表而言, 对于链表之间的数据关系是通过使用指针进行体现的 实现一个对象链表的实现； 12345678910111213141516171819202122function linkTable(array) &#123; let linkArray = []; const getLinks = (now, index, arr) =&gt; &#123; const len = arr.length; let pre = 0; let next = 0; pre = index - 1; next = index + 1; if (index === 0) &#123; pre = len - 1; &#125; if (index === len - 1) &#123; next = 0; &#125; linkArray.push(&#123; pre: arr[pre], current: now, next: arr[next] &#125;); &#125;; array.forEach((now, index, arr) =&gt; getLinks(now, index, arr));&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>js 链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js Timers]]></title>
    <url>%2F2017%2F12%2F19%2Fnode-js-Timers%2F</url>
    <content type="text"><![CDATA[TimersAPISsetImmediate(callback, args)callback : 在 node.js 事件循环之后被调用的函数。 args: 当 callback 函数被调用的时候传递的参数。 在 I / O 事件回调时间之后立即执行 callback 回调函数的执行。 如果 callback 不是一个 function , 会抛出一个 TypeError 错误。 123456setImmediate(function () &#123; console.log('事件稍后被执行');&#125;);console.log('事件立即被执行');// 事件立即被执行// 事件稍后被执行 setInterval(callback, delay, args)使用 setInterval 类似于使用 setInterval 方法, 在一定的时间间隔 delay 之后执行 callback 函数。 在官方给的例子中存在使用 util.promisly() 的一个变体。 123456const util = require('util');const setTimeoutPromise = util.promisify(setTimeout);setTimeoutPromise(4000, 'foobar').then((value) =&gt; &#123; console.log(value);&#125;);// after delay print 'foobar' canceling Timers使用 setImmediate setInterval 以及 setTimeout 每一个方法都会返回一个代表排列事件的对象, 这些能够用来取消 timer 防止被触发的操作。 clearImmediate, clearInterval, clearTimeout 用来清除通过使用 setImmedidate setInterval 以及 setTimeout 创建的定时器。 12345678910let immidate = setImmediate(function () &#123; console.log('事件之后被调用');&#125;);clearImmediate(immidate);// 清除事件， 事件之后不会调用clearInterval();// 清除间隔时间后的调用clearTimeout();// 清除一段时间之后的调用]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>Timers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js EventEmitter]]></title>
    <url>%2F2017%2F12%2F17%2Fnode-js-EventEmitter%2F</url>
    <content type="text"><![CDATA[EventEmitter基本构建许多的 node.js 核心的 API 是围绕事件异步模型进行构建的，特定种类的事件对象会周期性的触发命名的函数对象，从而导致函数对象被触发。 这些函数对象被称作 listeners; 所有的触发事件的对象属于 EventEmitter 类， 这些对象暴露有 emit 以及 on 方法。 12345678let eventEmitter = require('events');let myEmitter = new eventEmitter();// listenersmyEmitter.on('event', () =&gt; &#123; console.log('event');&#125;);// emittersmyEmitter.emit('event'); // event 向 lisitens 传递 arguments 以及 this 值1234567myEmitter.on('event', function (msg) &#123; console.log(`my name is $&#123;msg&#125;`); console.log('被传递的值', this);&#125;);myEmitter.emit('event', '张宁宁');// my name is 张宁宁// this 值指向的值是 eventEmitter 对象 handle event only once使用 once 函数的时候, 当使用 emit 的时候只会被触发一次 123456myEmitter.once(&apos;event&apos;, () =&gt; &#123; console.log(&apos;事件被触发一次&apos;);&#125;);myEmitter.emit(&apos;event&apos;);// &apos;事件触发一次&apos;myEmitter.emit(&apos;event&apos;); some APIEvent: newListener在监听器被加入到监听器队列之前，EventEmitter 实例会触发自己的 newListener 事件。 123456789101112131415const myEmitter = new EventEmitter();myEmitter.once('newListener', (event, listener) =&gt; &#123; if (event === 'event') &#123; myEmitter.on('event', () =&gt; &#123; console.log('B'); &#125;); &#125;&#125;);myEmitter.on('event', () =&gt; &#123; console.log('A');&#125;);myEmitter.emit('event');// B// A// 在触发 'event' 事件的时候先要触发事件 B 在触发事件 A EventEmitter.listenerCount(emitter, eventName)用来获得在 emitter 上面注册的 eventName 的次数。 1234let myEmitter = new EventEmitter();myEmitter.on('event', () =&gt; &#123;&#125;);myEmitter.on('event', () =&gt; &#123;&#125;);console.log(EventEmitter.listenerCount(myEmitter, 'event')); // 2 emitter.eventNames()用来获得 emitter 上面注册的 listeners 的事件列表。 1234let myEmitter = new EventEmitter();myEmitter.on('a', () =&gt; &#123;&#125;);myEmitter.on('b', () =&gt; &#123;&#125;);console.log(myEmitter.eventNames); // ['a', 'b'] emitter.listenerCount(eventName)eventName : the name of the event being listened for 作用和 EventEmitter.listenerCount(emitter, eventName) 是相同的。 emitter.listeners(eventName)用于获得 emitter 上 eventName 事件的注册函数。 1234567let myEmitter = new EventEmitter();myEmitter.on('event', () =&gt; &#123;&#125;);myEmitter.on('event', () =&gt; &#123;&#125;);// 使用 emitter.listeners(eventName)// 用于获得 emitter 上面的 eventName 上注册的函数console.log(myEmitter.listeners('event'));// [[Function], [Function]] emitter.on(eventName, listener)向一个被称作 eventName 的事件listener 的列表之中添加事件， 添加的事件被添加到 listener 列表的末尾。 注意，在添加事件的时候， 添加的事件只会按照顺序添加到时间列表数组的末尾，在这个过程中，不会进行判断事件是否已经添加了。 emitter.prependListener(eventName, listener)将 listener function 添加到事件队列的开头 1234567891011121314myEmitter.on('otherEvent', () =&gt; &#123; console.log('第一次');&#125;);myEmitter.prependListener('otherEvent', () =&gt; &#123; console.log('第三次');&#125;);myEmitter.on('otherEvent', () =&gt; &#123; console.log('第二次');&#125;);myEmitter.emit('otherEvent');// 第三次// 第一次// 第二次 emitter.prependOnceListener(eventName, listener)仅仅添加一次运行的函数到事件队列开始，第二次调用的时候会被移除 emitter.removeAllListeners([eventName])移除 eventName 事件上的所有函数。 emitter.removeListener(eventName, listener) removes the specified listener from the listener array for the event named eventName 使用 removeListener 的时候将会移除事件队列中至多一个instance (实例), 如果一个 单独的监听器被多次添加，那么使用 removeListener 需要多次调用才能被多次删除。 从被称作 eventName 的事件队列中移除掉特定的事件函数。 注意: 一旦时间被触发的时候, 在触发的时刻所有与之相关联的 listeners 将会被调用， 这表明， 在 listeners 被 emit 之后，在 listeners 中的最后一个函数被执行之前， 使用 removeListenr() 或者 removeAllListeners 都不会起作用 也就是说， 使用使用移除事件的时候是不会在 listeners 函数执行的过程中被调用的。 例子如下: 12345678910111213141516const callBackA = () =&gt; &#123; console.log('A'); myEmitter.removeListener('callback', callBackB);&#125;;const callBackB = () =&gt; &#123; console.log('B');&#125;;myEmitter.on('callback', callBackA);myEmitter.on('callback', callBackB);myEmitter.emit('callback'); // 这一次调用的时候是不会移除掉 B 的myEmitter.emit('callback');// 这一次调用的时候移除掉了 B// A B AmyEmitter.listeners() // [[Function: callbackA]] 因为对于 listeners 而言, 是通过使用内部的数组进行管理的, 当其中的 listener 被移除之后，会改变每一个注册的 listern 位置， 但是不会影响 listener 被调用的顺序， 但是通过使用 emitter.listeners() 返回的调用函数数组队列将会发生变化。]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>EventEmitter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js 源码分析(十六)]]></title>
    <url>%2F2017%2F12%2F16%2Funderscore-js-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E5%85%AD%2F</url>
    <content type="text"><![CDATA[underscore.js 源码分析(十六)isEmptyisEmpty(object) isElement 如果 object 是一个空对象， 或者 object 是一个字符串或者数组, 并且字符串或者数组的 length 为 0; 返回 true, 否则, 返回 false. 示例12_.isEmpty(&#123;&#125;); // true_.isEmpty(&#123; name: '张宁宁' &#125;); // false 源码分析123456789/** @description isEmpty 用来判断 Obj 是否为空*/function isEmpty (obj) &#123; if (obj == null) return true; if (isArray(obj) || isString(obj) || isArguments(obj)) return obj.length === 0; for (let key in obj) if (has(obj, key)) return false; return true;&#125; isElementisElement(obj) 如果 obj 是一个 dom 元素, 返回为 true; 对于 dom 元素 nodeType === 1 12345function isElement(obj) &#123; // 如果 obj 以及 obj.nodeType === 1 // 表示 obj 是一个节点对象 return !!(obj &amp;&amp; obj.nodeType === 1);&#125;; 判断函数使用判断函数用于判断函数的类型, 例如: isArray isObject isArguments isFunction isString isNumber …. 实现上面这几种方法的判断是使用 Array.prototype.toString.call 的方法进行判断的: 源码分析123456_.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function (name) &#123; _.['is' + name] = function (obj) &#123; // 通过使用 toString.call 来决定判断是属于哪一种类型 return toString.call(obj) === `[object $&#123;name&#125;]`; &#125;&#125;) 对于其他几个的判断: isObject1234_.isObject = function (obj) &#123; let type = typeof obj; return type === 'function' || type === 'object' &amp;&amp; !!obj;&#125;; isFinite用来判断给定的对象是否属于一个无限的数。 123_.isFinite = function () &#123; return isFinite(obj) &amp;&amp; !isNaN(parseFloat(obj));&#125; isNaN用来判断给定的值是否是 NaN 值, NaN is the only number which does not equal itself (NaN 是唯一一个和他自身不等的值) 12345_.isNaN = function(obj) &#123; // NaN !== NaN // NaN 是一个数字 return _.isNumber(obj) &amp;&amp; obj !== +obj;&#125; isBoolean用于判断是否是一个布尔值; 123_.isBoolean = function(obj) &#123; return obj === true || obj === false || toString.call(obj) === '[object, Boolean]';&#125; isNull123_.isNull = function (obj) &#123; return obj === null;&#125; isUndefined1234_.isUndefine = function (obj) &#123; // 这里通过使用 void 0 来代替 undefined 值 return obj === void 0;&#125;]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js 源码分析(十五)]]></title>
    <url>%2F2017%2F12%2F14%2Funderscore-js-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E4%BA%94%2F</url>
    <content type="text"><![CDATA[underscore.js 源码解析( 十五 )clone tap has matcher property propertyOf isEqual clone_.clone(object) 创建一个浅拷贝的 object 使用 _.clone 的源码如下: 12345_.clone = function (obj) &#123; if (!.isObject(obj)) return obj; // 对于 obj 是对象的, 分为数组和对象两种形式 return isArray(obj) ? obj.slice() : _.extend(&#123;&#125;, obj);&#125; tap_.tap(object, interceptor) interceptor 拦截器 使用 interceptor 的作用是用于对于传入的对象 object 进行 interceptor 操作, 并且操作完成之后返回 object 本身。 用于链式调用: 123456_.tap = function (obj, interceptor) &#123; // 对于对象应用 interceptor 函数作用 interceptor(obj); // 返回这个对象 return obj;&#125; has_.has(object, key) 用于判断对象是否包含有特定的属性 key , 在源码中有这样一句话, 等同于object.hasOwnProperty(key)，但是使用hasOwnProperty 函数的一个安全引用，以防意外覆盖。 什么是意外覆盖? 源码分析如下: 123_.has = function(obj, key) &#123; return obj != null &amp;&amp; hasOwnProperty.call(obj, key);&#125;; matchermatcher(attrs) 使用 matcher 函数是一个断言函数, 返回一个 true or false 来判断给定的对象中是否含有 attrs 中指定的键值对儿 示例: 12345let list = &#123; selected: true&#125;let hasSelected = _.matcher(&#123;selected: true&#125;);hasSelected(list); // true 源码分析源码如下: 123456_.matcher = _.matches = function(attrs) &#123; attrs = _.extendOwn(&#123;&#125;, attrs); return function (obj) &#123; return _.isMatch(obj, attrs); &#125;&#125; 其中 _.isMatch 源码如下: 12345678910111213_.isMatch = function (object, attrs) &#123; let keys = _.keys(attrs), length = keys.length; if (object === null) return !length; let obj = Object(object); for (let i = 0; i &lt; length; i++) &#123; let key = keys[i]; //如果 attrs 中的值和 obj 中的值不相等， 或者 key 不属于 obj 中 // 返回 false if (attrs[key] !== obj[key] || !(key in obj)) return false; &#125; // 返回 true return true;&#125; propertyproperty(key) 该方法返回一个函数，返回传入该函数的任何对象的 key 属性。 源码12345let property = function (key) &#123; return function (obj) &#123; return obj === null ? void 0 : obj[key]; &#125;&#125; propertyOf使用 propertyOf 与使用 property 相反。 propertyOf(object) 传入一个对象， 返回一个函数，这个函数接收一个属性，返回对象对应属性的值。 使用 propertyOf 12345_.propertyOf = function (obj) &#123; return obj == null ? function () &#123;&#125; : function (key) &#123; return obj[key]; &#125;&#125; isEqualisEqual(object, other) 使用 isEqual 用来判断两个对象是否相等。 因为不同的对象被放在了不同的内存空间中, 因此， 即使是属性和值均相等的对象也是不相同的, 如果对象的属性和值都是相同的，使用 isEqual 返回的是 true 12&#123;&#125; == &#123;&#125; // false_.isEqual(&#123;&#125;, &#123;&#125;); // true 在源码中使用 equal 进行判断: 123_.equal = function (a, b) &#123; return eq(a, b);&#125; 使用 eq 进行判断的源码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293var eq = function(a, b, aStack, bStack) &#123; // Identical objects are equal. `0 === -0`, but they aren't identical. // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal). if (a === b) return a !== 0 || 1 / a === 1 / b; // A strict comparison is necessary because `null == undefined`. // 如果 a 或者 b === undefined 返回 a === b if (a == null || b == null) return a === b; // Unwrap any wrapped objects. if (a instanceof _) a = a._wrapped; if (b instanceof _) b = b._wrapped; // Compare `[[Class]]` names. var className = toString.call(a); // 如果 a 的对象的类型不同于 b 的对象的类型， 返回的是 false if (className !== toString.call(b)) return false; switch (className) &#123; // Strings, numbers, regular expressions, dates, and booleans are compared by value. case '[object RegExp]': // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i') case '[object String]': // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is // equivalent to `new String("5")`. return '' + a === '' + b; case '[object Number]': // `NaN`s are equivalent, but non-reflexive. // Object(NaN) is equivalent to NaN // 当 a 是 NaN 的时候, 如果 b 也是 NaN 那么 !b !== b // false if (+a !== +a) return +b !== +b; // An `egal` comparison is performed for other numeric values. // 判断 +a === 0 ? return +a === 0 ? 1 / +a === 1 / b : +a === +b; case '[object Date]': case '[object Boolean]': // Coerce dates and booleans to numeric primitive values. Dates are compared by their // millisecond representations. Note that invalid dates with millisecond representations // of `NaN` are not equivalent. return +a === +b; &#125; var areArrays = className === '[object Array]'; // 如果不是一个数组 if (!areArrays) &#123; if (typeof a != 'object' || typeof b != 'object') return false; // Objects with different constructors are not equivalent, but `Object`s or `Array`s // from different frames are. var aCtor = a.constructor, bCtor = b.constructor; if (aCtor !== bCtor &amp;&amp; !(_.isFunction(aCtor) &amp;&amp; aCtor instanceof aCtor &amp;&amp; _.isFunction(bCtor) &amp;&amp; bCtor instanceof bCtor) &amp;&amp; ('constructor' in a &amp;&amp; 'constructor' in b)) &#123; return false; &#125; &#125; // Assume equality for cyclic structures. The algorithm for detecting cyclic // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`. // Initializing stack of traversed objects. // It's done here since we only need them for objects and arrays comparison. aStack = aStack || []; bStack = bStack || []; var length = aStack.length; while (length--) &#123; // Linear search. Performance is inversely proportional to the number of // unique nested structures. if (aStack[length] === a) return bStack[length] === b; &#125; // Add the first object to the stack of traversed objects. aStack.push(a); bStack.push(b); // Recursively compare objects and arrays. if (areArrays) &#123; // Compare array lengths to determine if a deep comparison is necessary. length = a.length; if (length !== b.length) return false; // Deep compare the contents, ignoring non-numeric properties. while (length--) &#123; if (!eq(a[length], b[length], aStack, bStack)) return false; &#125; &#125; else &#123; // Deep compare objects. var keys = _.keys(a), key; length = keys.length; // Ensure that both objects contain the same number of properties before comparing deep equality. if (_.keys(b).length !== length) return false; while (length--) &#123; // Deep compare each member key = keys[length]; if (!(_.has(b, key) &amp;&amp; eq(a[key], b[key], aStack, bStack))) return false; &#125; &#125; // Remove the first object from the stack of traversed objects. aStack.pop(); bStack.pop(); return true; &#125;; eq 函数使用 eq 函数进行比较的时候，进行比较的值有下面几种情况: 处理传递进比较的数值出现 0 === -0 的情况。这种情况用于单个数值的比较 因为 a === -0 但是他们是不相同的。 123// 当 a !== 0 || 1/a === 1 / b// 因为 1 / a === 1 / b (Infinity === -Infinity) // falseif (a === b) return a !== 0 || 1 / a === 1 / b; 处理 null == undefined 的情况 12// 当 a == null 或者 b == null 的时候， 返回 a === bif (a == null || b == null) return a === b; 使用 Object.toString 进行判断属于 Object 的哪一种类型。 123456789101112131415let className = toString.call(a);// 类型不同, 返回 falseif (className !== toString.call(b)) return false;switch (className) &#123; case '[object RegExp]': case '[object String]': return '' + a === '' +b; case '[object Number]': // 使用 NaN 进行比较 if (+a !== +a) return +b !== +b; return +a === 0 ? 1 / +a === 1 / b : +a === +b; case '[object Date]': case '[object Boolean]': return +a === +b;&#125; 对于数组和对象的之间进行比较，需要深度比较 当不是数组， 对象的情况: 12345678910111213141516171819var areArrays = className === '[object Array]';if (!areArray) &#123; if (typeof a !== 'object' || typeof b !== 'object') return false; var aCtor = a.constructor, bCtor = b.constructor; // 如果 aCtor !== bCtor if (aCtor !== bCtor &amp;&amp; !(_.isFunction(aCtor) &amp;&amp; aCtor instanceof aCtor &amp;&amp; _.isFunction(bCtor) &amp;&amp; bCtor isntanceof bCtor) &amp;&amp; ('constructor' in a &amp;&amp; 'constructor' in b)) &#123; return false; &#125;&#125;let length = aStack.length;while(length--) &#123; if (aStack[length] === a) return bStack[length] === b;&#125;// 将 a 压入到 aStack 数组中// 将 b 压入到 bStack 数组中// aStack bStack 主要用于多重数组的情况aStack.push(a);bStack.push(b); 进行比较对象或者数组: 12345678910111213141516171819202122// 比较数组if (areArrays) &#123; length = a.length; if (length !== b.length) return false; while (length--) &#123; if (!eq(a[length], b[length], aStack, bStack)) return false; &#125;&#125; else &#123;// 比较对象 let keys = _.keys(a), key; length = keys.length; // 如果两个对象的属性数目不相同 返回 false 不用进行深度遍历 if (_.keys(b).length !== length) return false; while (length--) &#123; key = keys[length]; if (!(_.has(b, key) &amp;&amp; eq(a[key], b[key], aStack, bStack))) return false; &#125;&#125;// 将存入的元素进行弹出aStack.pop();bStack.pop();return true; ​ ​]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js源码分析(十四)]]></title>
    <url>%2F2017%2F12%2F12%2Funderscore-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[underscore.js 源码分析(十四)extend extendOwn pick omit default extend_.extend(destination, *sources) 将多个对象 souces 覆盖到 destination 上面，返回被覆盖掉的 destination 上面。 使用 extend 类似于使用 Object.assign 用来将多个对象进行合并。 自己写的代码如下: 1234567891011function extend(destination) &#123; let sources = Array.prototyep.slice.call(arguments, 1); let len = sources.length; for (let i = 0; i &lt; len; i++) &#123; let currrentSource = sources[i]; let key = _.keys(currentSource); for (let index = 0; index &lt; keys.length; index++) &#123; destination[keys[index]] = currentScource[keys[index]]; &#125; &#125;&#125; 源码分析: 1234567891011121314151617181920let createAssigner = function (keysFunc, undefinedOnly) &#123; return function (obj) &#123; let length = arguments.length; // 进行边界处理 // 当传入一个参数的时候或者 obj === null 的时候, 返回 obj if (length &lt; 2 || obj === null) return obj; for (let index = 1; index &lt; length; index++) &#123; // 需要对于额外传入的参数进行循环的时候使用 arguments[index] 进行获得 let source = arguments[index]; keys = keysFunc(source); l = keys.length; for (let i = 0; i &lt; l; i++) &#123; let key = keys[i]; // 这里面使用了 undefinedOnly 如果 undefinedOnly 是 true 的时候 // 接下来判断 obj[key] 是否为 undefined(void 0) if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key]; &#125; &#125; &#125;&#125; extendOwn使用 extendOwn 实现的效果类似于使用 extends, 实现的效果是只是复制自己的属性到目标对象。 _.extendOwn(destination, *source) 复制 source 属性的值到 destination 只是复制自身的属性。(不包括继承的属性) 这个函数与 _.extend 的不同之处在于不会将 source 对象中继承到的属性复制到 destination 之中。 使用 extendOwn 与 extend 的不同在于: 源码不同 1234// 使用 _.allKeys 获得到包括自身和继承得到的属性_.extend = createAssigner(_.allKeys);// 使用 extendOwn 获得到仅仅包括自身的属性_.extendOwn = _.assign = createAssigner(_.keys); pick_.pick(object, *keys) 使用这个属性用于返回 object 副本, 过滤出 keys(有效的键组成的数组) 参数指定的属性值，或者接受一个判断函数，指定挑选哪一个 key 使用 pick 的源码如下。 123456789101112131415161718192021222324252627_.pick = function(object, oiteratee, context) &#123; let result = &#123;&#125;, obj = object, iteratee, keys; if (obj == null) return result; // 如果 oiteratee 是一个函数的话 if (_.isFunction(oiteratee)) &#123; // 使用 _.allKeys 获得到 obj 中的所有键 keys = _.allKeys(obj); iteratee = optiomizeCb(oiteratee, context); &#125; else &#123; // 如果 oiteratee 不是一个函数的时候 // 表示这时候用于筛选出对象 object 中包含 keys 的内容 // 效果是相同于 Array.prototype.slice.call(arguments, 1); 相识 keys = flatten(arguments, false, false, 1); // 返回在 obj 中的 key iteratee = function(value, key, obj) &#123; return key in obj; &#125;; obj = Object(obj); &#125; for (let i = 0; length = keys.length; i &lt; length; i++) &#123; let key = keys[i]; let value = obj[key]; // 这里通过使用不同的函数来实现对于不同情况下的处理条件 // 通过改变 iteratee 函数的不同来实现不同的处理流程 // if (iteratee(value, key, obj)) if (iteratee(value, key, obj)) result[key] = value; &#125; return result;&#125; 上面中有一个 flatten 函数, 使用 flatten 函数的目的是将多层嵌套的数组转化为一维数组。 flatten源码: 1234567891011121314151617let flatten = function(input, shallow, strict, startIndex) &#123; let output = [], idx = 0; for (let i = startIndex || 0, length = getLength(input); i &lt; length; i++) &#123; let value = input[i]; if (isArrayLike(value) &amp;&amp; (_.isArray(value) || _.isArguments(value))) &#123; if (!shallow) value = flatten(value, shallow, strict); let j = 0; len = value.length; output.length += len; while (j &lt; len) &#123; output[idex++] = value[j++]; &#125; &#125; else if (!strict) &#123; output[idx++] = value; &#125; &#125; return output;&#125; 自己写的函数: pick 12345678910111213141516171819202122function pick(obj, oiteratee) &#123; // 边界处理 如果 obj === null 或者 typeof obj !== 'object' // 返回一个空对象 if (obj === null || typeof obj !== 'object') &#123; return &#123;&#125;; &#125; let output = &#123;&#125;; let keys = Object.keys(obj); let len = keys.length; let iteratee; let choiceKeys = Array.prototype.slice.call(arguments, 1); if (typeof oiteratee === 'function') &#123; iteratee = oiteratee; &#125; else &#123; iteratee = function (value, key) &#123; retutn choiceKeys.includes(key); &#125;; &#125; for (let i = 0; i &lt; len; i++) &#123; let key = keys[i]; if (iteratee(obj[key], key)) output[key] = obj[key]; &#125; return output;&#125; omitomit(object, *keys) 使用 omit 函数的目的是与使用 pick 函数相反，返回一个 object 副本，过滤出除去 keys 中的属性值，或者接收一个判断函数，指定忽略哪一个 key 值。 omit 源码如下: 1234567891011_.omit = function (obj, iteratee, context) &#123; if (_.isFunction(iteratee)) &#123; iteratee = _.negate(iteratee); &#125; else &#123; let keys = _.map(flatten(arguments, false, false, 1), String); iteratee = function() &#123; return !_.contains(keys, key) &#125;; &#125; return _.pick(obj, iteratee, context);&#125; default_.defaults(object, *defaults) 使用 default 的目的是使用 default 对象填充 object 中的 undefined 属性，并且返回这个 object。 当 object 中存在 default 中的属性被填充的时候，使用 defaults 方法不会起作用。 使用 _.defaults 方法的时候源码如下: 1234// 使用 createAssigner(keysFunc, undefinedOnly);// 传递两个参数： keysFunc 表示对于键的处理函数// undefinedOnly 表示是否只是复制目标对象中值为 undefined 的属性_.default = createAssigner(_.allKeys, true); 在 createAssigner 的函数中使用 _.default 方法主要是使用下面的这句函数: 12// 当 undefinedOnly 为 true 的时候, 接下来进行判断 obj[key] === void 0 对象的属性是否为 undefinedif (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS: 未知高度内文本居中]]></title>
    <url>%2F2017%2F12%2F11%2FCSS-%E6%9C%AA%E7%9F%A5%E9%AB%98%E5%BA%A6%E5%86%85%E6%96%87%E6%9C%AC%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[在项目中遇到过单行文本出现垂直居中的问题， 对于已知高度使用 line-height = height 可以解决问题，对于未知高度，下面有几种方法。 例如下面的 HTML 以及 CSS 如下: 1234&lt;div class=&quot;wrapper&quot;&gt; &lt;span class=&quot;first&quot;&gt;我是第一个需要居中的文字&lt;/span&gt; &lt;span class=&quot;second&quot;&gt;我是第二个需要居中的文字&lt;/span&gt;&lt;/div&gt; 1234567891011121314.wrapper &#123; width: 200px; height: 100px;&#125;.wrapper span &#123; width: 100%; display: inline-block;&#125;.first &#123; height: 30%;&#125;.second &#123; height: 70%;&#125; 我们期望得到下面的效果: 但是, 因为我们无法使用 line-height = height (你总不能计算高度 * 30% 吧， 愚蠢的做法), 我们得到这样的效果: 为了实现居中效果，我们可以采用下面的方式: 暴力 flex 1234.wrapper span &#123; display: flex; align-items: center;&#125; table]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>垂直居中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js 源码分析(十三)]]></title>
    <url>%2F2017%2F12%2F11%2Funderscore-js-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E4%B8%89%2F</url>
    <content type="text"><![CDATA[underscore.js 源码分析(十三)keys values pairs invert functions mapObject findKey keys(Object)使用 keys(Object) 用于获得 Object 的所有属性名称。 与 es6 中 Object.keys() 功能相同，不同的是做了兼容性处理。 12345678910111213function keys (obj) &#123; // 如果 obj 不存在? if (!obj || typeof obj !== 'object') return []; // 如果支持 Object.keys 方法, 返回 Object.keys(obj) if (Object.keys) return Object.keys(obj); // else 使用 for in 进行属性获取 let keys = []; for (let key in obj) &#123; keys.push(key); &#125; // 返回属性数组 return keys;&#125; values(Object)使用 values(Object) 用于获得对象的所有的属性名称。 类似于使用 Object.values 获取到对象的属性值。 123456789function values (obj) &#123; let keys = _.keys(obj); let length = keys.length; let values = new Array(length); for (let i = 0; i &lt; length; i++) &#123; values[i] = obj[keys[i]]; &#125; return values;&#125; pairs()使用 pairs() 用于将一个对象转化为键值对的形式。 自己写的函数: 12345678910function pairs (obj) &#123; let keys = _.keys(obj); let values = _.values(obj); let len = keys.length; let pairs = []; for (let i = 0; i &lt; len; i++) &#123; pairs.push([keys[i], values[i]]); &#125; return pairs;&#125; 源码分析: 123456789_.pairs = function(obj) &#123; var keys = _.keys(obj); var length = keys.length; var pairs = Array(length); for (var i = 0; i &lt; length; i++) &#123; pairs[i] = [keys[i], obj[keys[i]]]; &#125; return pairs; &#125;; invert()invert(object) 使用 invert 实现的是返回一个 object 的副本，在这个副本中, object 中的键和值互换。 源码: 12345678function invert(object) &#123; let result = &#123;&#125;; let keys = _.keys(object); for (let i = 0; i &lt; keys.length; i++) &#123; result[object[keys[i]]] = keys[i]; &#125; return result;&#125; functionsfunctions(object) 返回一个对象中所有的方法名，并且是已经经过排序的方法。 源码分析: 1234567_.functions = function (obj) &#123; let names = []; for (let key in obj) &#123; if (_.isFunction(obj[key])) names.push(obj[key]); &#125; return name.sort();&#125; mapObject类似于使用数组的 map 方法，不同的是这个方法针对的是对象的 map 方法, 使用 mapObject 用来对于对象的属性值进行操作， 实现的源码如下: 1234567891011_.mapObject = function(obj, iteratee, context) &#123; iteratee = cb(iteratee, context); let keys = _.keys(obj); length = keys.length; result = &#123;&#125;; currentKey; for (let index = 0; index &lt; length; index++) &#123; currentKey = keys[index]; results[currentKey] = iteratee(obj[currentKey], currentKey, obj); &#125; &#125; findKey_.findKey(obj, predicate, context) 使用 findKey 返回的是 obj 中第一个满足 predicate 函数的 key。 12345678let numbers = &#123; first: 5, second: 8&#125;;_.findKey(numbers, function (value) &#123; return value &gt; 2;&#125;);// 返回 first 源码分析findKey 源码: 123456789_.findKey = function (obj, predicate, context) &#123; predicate = cb(predicate, context); let keys = _.keys(obj), key; for (let i = 0; length = keys.length; i &lt; length; i++) &#123; key = keys[i]; // 如果条件满足, 返回 key if (predicate(obj[key], key, obj)) return key; &#125;&#125;]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js源码分析(十二)]]></title>
    <url>%2F2017%2F12%2F10%2Funderscore-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[underscore.js 源码分析(十二)wrap negate compose wrap实例_.wrap(function, wrapper) 使用 wrap 的目的在于将函数 function 作为第一个参数传递进入 wrapper 之中, 从而在 wrapper 中在不同的事件，不同的代码，根据不同的条件执行 function 函数。 实例: 1234567function hello(name) &#123; console.log(`hello my name is $&#123;name&#125;`);&#125;let sayHello = _.wrap(hello, function (func) &#123; func('张宁宁');&#125;);sayHello(); // hello my name is 张宁宁 源码分析使用 _.partial 函数实现的参数替换: 123_.wrap = function (func, wrapper) &#123; return _.partial(wrapper, func);&#125; negate返回 negate 的否定版本: 源码分析123456// predicate 迭代函数_.negate = function (predicate) &#123; return funciton () &#123; return !predicate.apply(this, arguments); &#125;&#125; composecompose(*functions) compose 用于函数的组合, 将一个函数的返回值作为另外一个函数的参数。 实例12345678function sayHello(word) &#123; console.log(`hello, my name UpperWorlds is $&#123;word&#125;`)&#125;function toUpper(word) &#123; return word.toUpperCase();&#125;let composeFn = _.compose(sayHello, toUpper);composeFn(&apos;zhangningning&apos;); // hello my name UpperWorlds is ZHANGNINGNING; 源码分析自己写的部分代码: 哪个好？？ 12345678function compose() &#123; let fns = Array.prototype.slice.call(arguments); reurn function (args) &#123; fns.reduceRight((preFn, nextFn) =&gt; &#123; return nextFn(preFn); &#125;, args); &#125;&#125; 源码如下: 123456789101112_.compose = function () &#123; let args = argumemts; let start = args.length - 1; return function () &#123; let i = start; // 使用 call 以及 apply 进行参数传递 let result = args[start].apply(this, arguments); // 使用 while 进行递减 while(i--) result = args[i].call(this, result); return result; &#125;&#125;]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js基础.基本服务器构建]]></title>
    <url>%2F2017%2F12%2F10%2Fnode-js%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[node.js 是 javascript 对于后端的应用, 下面是使用node.js 构建的一个基础的图片上传应用: 应用地址hello world: 基本组成这个基本的引用由下面几个部分组成: index.js : 作为各个模块的入口。 server.js 服务器模块。 router.js 用于路由的存放。 requireHandler.js 用于路由相关的动作 模块分析server.jsserver.js 用于创建 http 服务器。 一个基础的 http 服务器的构成。 12345678910111213let http = require('http');// request 是浏览器向服务器进行请求的相关信息function onRequest(request, response) &#123; // response 用于向对于发送信息的浏览器响应请求 // 规定返回响应的 头部信息 // 返回一个 http 状态码为 200 Content-type 为 text/plain 的 http 信息 response.writeHead(200, &#123;"Content-type": "text/plain"&#125;); // 使用 response.write 向响应的主体中发送内容 response.write(); // 结束响应请求 response.end();&#125;http.createServer(onRequest).listen(8888); 上面的创建的基础的 node.js 服务器用于监听 8888 端口。 node.js 是基于事件驱动的, 也就是我们说的 回调， 上面的服务器中， 只要在 8888 端口处监听到事件发生, 则进行回调 onRequest 函数。 在这个应用中，这样构建服务器模块: 1234567891011121314// 引入 http 模块let http = require('http');// 引入 url 模块let url = require('url');// 创建一个 start 函数用于开启服务器function start(route, handle) &#123; function onRequest(request, response) &#123; let pathname = url.parse(request.url).pathname; route(handle, pathname, response, request); &#125; http.createServer(onRequest).listen(8888);&#125;// 导出 start 模块export.start = start; router.js在 router.js 存放在对于根据不同的路由切换函数。 1234567891011121314function route(handle, pathname, response, request) &#123; if (typeof handle[pathname] === 'function') &#123; // 执行 handle[pathname] 函数 // handle[pathname] 函数接收两个参数 response, request // 这个启动的函数位于 requireHandler.js 中 handle[pathname](response, request); &#125; else &#123; // http 状态 404 not found Content-type 设置 text/plain response.writeHead(404, &#123; 'Content-type': 'text/plain' &#125;); response.write('404 not found'); response.end(); &#125;&#125;export.route = route; index.js使用 index.js 用于对于各个模块进行集中处理: 1234567891011121314151617// 导入 server, router, requestHandlers 模块// server: 服务器模块// router: 路由模块// requestHandlers： 相应路由的处理函数模块let server = require("./server.js");let router = require("./router");let requestHandlers = require("./requireHandlers");let handle = &#123;&#125;;// 对于不同的路由进行不同的函数配置handle['/'] = requestHandlers.start;handle['/start'] = requestHandlers.start;handle['/upload'] = requestHandlers.upload;handle['/show'] = requestHandlers.show;// 启动服务器server.start(router.route, handle); requireHandler.js这个模块用来个根据不同的路由进行不同的函数处理: 对于上传数据的不同处理都是放在了这里面: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162let fs = require('fs');// 使用 formidable 用于处理文件上传的问题let formidable = require('formidable');function start(response, request) &#123; var body = '&lt;html&gt;'+ '&lt;head&gt;'+ '&lt;meta http-equiv="Content-Type" '+ 'content="text/html; charset=UTF-8" /&gt;'+ '&lt;/head&gt;'+ '&lt;body&gt;'+ '&lt;form action="/upload" enctype="multipart/form-data" '+ 'method="post"&gt;'+ '&lt;input type="file" name="upload"&gt;'+ '&lt;input type="submit" value="Upload file" /&gt;'+ '&lt;/form&gt;'+ '&lt;/body&gt;'+ '&lt;/html&gt;'; response.writeHead(200, &#123;"Content-Type": "text/html"&#125;); response.write(body); response.end();&#125;function upload(response, request) &#123; let form = new formidable.IncomingForm(); form.parse(request, function (error, fields, files) &#123; var readStream=fs.createReadStream(files.upload.path); var writeStream=fs.createWriteStream(`./assets/$&#123;files.upload.name&#125;`); imgname = files.upload.name; readStream.pipe(writeStream); readStream.on('end',function()&#123; fs.unlinkSync(files.upload.path); &#125;); response.writeHead(200, &#123;"Content-Type": "text/html"&#125;); response.write('received image: &lt;br/&gt;'); console.log(files.upload.name); // src='/show' 调用 show 函数 response.write("&lt;img src='/show'/&gt;"); response.end(); &#125;);&#125;// show 函数用于文件显示function show(response, postData) &#123; // 读取文件 fs.readFile(`./assets/$&#123;imgname&#125;`, "binary", function (error, file) &#123; // 如果发生错误 if (error) &#123; response.writeHead(500, &#123;"Content-Type": "text/plain"&#125;); response.write(error + "\n"); response.end(); &#125; else &#123; response.writeHead(200, &#123;"Content-Type": "image/png"&#125;); response.write(file, "binary"); response.end(); &#125; &#125;)&#125;exports.start = start;exports.upload = upload;exports.show = show; 其他关于使用 response.write 的问题: 12response.write(chunk, [encoding]);// encoding 表示编码形式]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[while and do]]></title>
    <url>%2F2017%2F12%2F09%2Fwhile-and-do%2F</url>
    <content type="text"><![CDATA[运算符优先级关于运算符的优先级，存在下面的优先级级别: (因此当我们在表达式中出现下面这些情况的时候, 我们注意符号的优先级) . [ ] ( ) 提取属性与调用函数 （优先级 () &gt; .） delete new typeof + - ! 一元运算符 * / % 乘法， 除法, 求余 + - 加法/ 连接 减法 &gt;= &lt;= &gt; &lt; 不等式运算符 === !== 等式运算符 &amp;&amp; 逻辑与 ` ` 逻辑或 ?: 三元 使用运算符优先级中注意: &amp;&amp; &gt; || 下面是一些使用运算符的一些例子: 对于点号运算符以及加号运算符 123+"2.34567".toFixed(2);// 我们的本意是先想要将字符串 "2.34567" 转化为数字在利用 toFixed(2) 进行保留两位小数// 但是返回错误 uncaught TypeError "2.34567".toFixed(2) is not a function 上面是因为使用上面的表达式的时候 . 号的操作符优先级要高于 + 所以先计算的是字符串的 toFixed() 函数， 当然会出现错误， 解决办法， 添加 () 因为这时候括号的优先级要高于点号: 1(+"2.34567").toFixed(2) 逻辑与的操作符 &amp;&amp; 的操作符优先级要高于 || 的操作符优先级。 例如对于下面的这个程序而言: 12true || false &amp;&amp; false// 因为这里 &amp;&amp; 操作符的优先级要高于 || 因此这里会返回 true 注意: 这里对于 || 以及 &amp;&amp; 操作符的理解要正确: 这两个操作符返回的都是值，而不是 true 或者 `false [] == ![] 上面这个等式是一个很有意思的等式， 理解这个等式有助于我们加深对于于运算符优先级的理解， 并且在上面的这个公式中还有涉及到了隐式转换的一些知识点。 在上面这个过程中， 因为 ! 的优先级要高于 ==, 因此先执行 ! 进行类型转换， 因为这里 [] 是真值，(只要不属于假值的都是真值，你别看我这里是一个空数组) 通过使用布尔强制类型转换结果为 false 的被称作假值， 假值有下面几种： undefined, null, false, +0, -0 和 NaN, “ “ ps: 其他的类型不要进来 （[], {} : 你们看我干嘛？） 首先执行下面的操作： 1![] ===&gt; false 这个时候等号右边的值变成了 false,这个时候使用 == 会进行强制类型转换，将布尔值转换为数字 1Number(false) ===&gt; 0 这个时候 == 两边分别是 object 以及 number 类型的值， 这个时候需要将 obejct 转为数字： 1Number([].valueOf()) ===&gt; 0 因此， 上面的等式经过转换之后，变成了下面的这种： 10 === 0 // true]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>whileordo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js源码分析(十一)]]></title>
    <url>%2F2017%2F12%2F07%2Funderscore-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E4%B8%80%2F</url>
    <content type="text"><![CDATA[underscore.js 源码分析(十一)throttle debounce once after before throttle函数节流 _.throttle(function, wait, [options]) 使用 throttle 函数用于节流操作, 目的是对于重复执行的函数，最多每隔 wait 毫秒调用一次这个函数。 源码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** @description throttle 用于函数节流* @param func 运行的函数* @param wait 等待的毫秒数* @param options*/// previous 这里的意思的记录下上次记录下上次的时间_.throttle = function(func, wait, options) &#123; var context, args, result; var timeout = null; var previous = 0; if (!options) options = &#123;&#125;; var later = function() &#123; // 这里 previous 的作用 previous = options.leading === false ? 0 : _.now(); timeout = null; result = func.apply(context, args); if (!timeout) context = args = null; &#125;; return function() &#123; var now = _.now(); // 记录下被调用的时刻 if (!previous &amp;&amp; options.leading === false) previous = now; // 当 previous 等于 now 的时候 remaining = wait // 记录下等待的时间和 now - previous 的差值 // 不会执行下面的 if else 函数 var remaining = wait - (now - previous); context = this; args = arguments; // 如果 remaining &lt;= 0 // 第一次函数执行的时候被调用，因为这个时候 now &gt;&gt; wait remaining &lt;= 0 if (remaining &lt;= 0 || remaining &gt; wait) &#123; // 当超出等待时间之后调用的时候 // 返回调用的结果，清除 timeout if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; // 获取到 func 执行之后的结果 result = func.apply(context, args); if (!timeout) context = args = null; // 如果 timeout 为 null // 开启一个新的队列等待 // 如果 options.trailing === false, 表示禁用最后一次执行 &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123; // 如果没有超过等待时间 // remaining 时间之后调用 later函数 // 对于在一段时间内应用同一个函数的时候，只是改变的later 函数 timeout = setTimeout(later, remaining); &#125; return result; &#125;; &#125;; 首先，需要明白一点，函数式编程同样可以首先数据的共享。 1234567891011121314function getIndex() &#123; let index = 0; // return 返回的是一个函数 return function () &#123; index++; console.log(index); &#125;&#125;let getIndexFn = getIndex();// 因为在个过程中，通过getIndex 返回的是一个函数// 在 getIndex 中的 index 并没有发生变化， 因为 getIdnex 只是调用了一次getIndexFn(); // 1getIndexFn(); // 2 练习: 12345678910111213141516171819202122232425262728293031function throttle (func, wait, options) &#123; let context, args, result; let timeout = null; let previous = 0; if (!options) options = &#123;&#125;; let later = funciton () &#123; previous = options.leading === false ? 0 : now(); timeout = null; result = func.apply(context, args); &#125;; return funcion () &#123; let now = now(); if (!previous &amp;&amp; options.leading === false) previous = now; let remaining = wait - (now - previous); context = this; args = arguments; // 如果第一次执行 if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (timeout) &#123; cleatTimeout(timeout); timeout = null; &#125; previous = now; result = func.apply(context, args); if (!timeout) context = args = null; &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123; timeout = setTimeout(later, remaining); &#125; return result; &#125;&#125; debounce_.debounce(function, wait, [immediate]) debounce 函数用于函数防抖: 函数防抖的意思是将延迟函数的执行(真正的执行)在函数最后一次调用的时刻的 wait 毫秒之后进行执行。 当函数重复调用的时候，函数执行只是发生在最后一次调用的 wait 毫秒之后进行执行。 自己写的: 12345678910111213141516171819202122232425262728293031323334function debounce(func, wait, immediate) &#123; // 定义执行上下文, 参数， 结果 let context, args, result; let timeout = null; let previous 0; let remainding = 0; immediate = immediate || false; let later = function () &#123; result = func.apply(context, args); timeout = null; context = args = null; &#125;; return function () &#123; let now = _.now(); remainding = now - previous; context = this; args = arguments; // 保证使用 immediate 的时候立即执行函数 if (immediate &amp;&amp; remainding &gt; wait) &#123; previous = _.now(); result = func.apply(context, args); timeout = null; context = args = null; &#125; else if (!immediate) &#123; // if timeout // clearTimeout 进行清除 timeout if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; timeout = setTimeout(later, wait); &#125; &#125;&#125; 源码解析12345678910111213141516171819202122232425262728_.debounce = function(func, wait, immediate) &#123; let timeout, args, context, timestamp, result; let later = function () &#123; let last = _.now() - timestamp; if (last &lt; wait &amp;&amp; last &gt;= 0) &#123; timeout = setTimeout(later, wait - last); &#125; else &#123; timeout = null; if (!immediate) &#123; result = func.apply(context, args); if (!timeout) context = args = null; &#125; &#125; &#125;; return function () &#123; context = this; args = arguments; // 这里面继续调用的时候改变的只是这个 timestamp = _.now(); let callNow = imemediate &amp;&amp; !timeout; if (!timeout) timeout = setTimeout(later, wait); if (callNow) &#123; result = func.apply(context, args); context = args = null; &#125; return result; &#125;;&#125; 如下流程图如下: 12345678910111213141516171819st=&gt;start: bounce;init=&gt;operation: 初始化context, args, timeout, timeStamp, result, 定义later函数rt=&gt;operation: 记录当前调用时间 timeStamp = _.now(), callNow = imemediate &amp;&amp; !timeoutisTimeout=&gt;condition: !timeoutiscallNow=&gt;condition: callNow 为 truesetTimeout=&gt;operation: setTimeout(later, wait);cond=&gt;condition: Yes or No?replyFn=&gt;operation: 执行函数,result = func.apply(context, args);context = args = null;e=&gt;end: return resultst-&gt;init-&gt;rt-&gt;isTimeout-&gt;eisTimeout(yes, right)-&gt;setTimeout-&gt;iscallNowisTimeout(no)-&gt;iscallNowiscallNow(yes, right)-&gt;replyFn-&gt;eiscallNow(no)-&gt;econd(no)-&gt;iocond(yes)-&gt;e 关于 later 函数如下: 123456789101112let later = function () &#123; let last = now() - timestamp; if (last &lt; wait &amp;&amp; last &gt;= 0) &#123; timeout = setTimeout(later, last - wait); &#125; else &#123; timeout = null; if (!immediate) &#123; result = func.apply(context, args); if (!timeout) context = args = null; &#125; &#125;&#125; 这一部分实现的原理是: 假如使用 bounce 函数的程序被多次调用的时候，如果在函数被第一次调用之后的 wait 时间之内，函数被调用了第二次，程序会在函数调用第二次的时候记录下时间，这时候 wait 时间之后调用函数的时候，第一次调用的函数不会被触发，程序在 later 函数中继续延迟第二次调用函数距离上一次调用需要的时间，这样，最终，第二次函数也是和第一次函数调用的结果是相同点的，都是在延迟了wait 时间之后被调用。 once创建一个只能调用一次的函数。即使函数被调用一次，也只是返回第一次被调用的结果。 使用 once 是当 before 方法中 count 等于2的情况下进行执行的函数; 12// 向 befor 函数中传递参数为 2_.once = _.partial(_.before, 2); before_.before(count, function) 创建一个函数，调用不超过 count 次, 当count已经被达到的时候，最后一次调用的结果被记住并被返回。 自己写的: 12345678910111213141516/** @description before 用于返回 调用不超过 count 次数的函数调用* @param &#123;Numbet&#125; count 调用函数的次数* @param &#123;function&#125; func 被调用的函数*/function before(count, func) &#123; let index = 1; let memo; return function () &#123; if (index &lt; count) &#123; memo = func.apply(this, arguments); index++; &#125; return memo; &#125;&#125; 源码分析: 123456789101112_.before = function (times, func) &#123; let memo; return function () &#123; // --times if (--times &gt; 0) &#123; memo = func.apply(this, arguments); &#125; // 如果 times &lt;= 1 将 func 重置为 null if (times &lt;= 1) func = null; return memo; &#125;&#125; after_.after(count, function) 使用 _.after 的作用是创建一个函数，只有调用 count 次之后才能得到效果。 123456789101112/** @description after 用于表示 after 函数* @param &#123;Number&#125; 需要的调用次数* @param &#123;function&#125; func 规定调用次数之后的调用函数*/function after (times, func) &#123; return function () &#123; if (--times &lt; 1) &#123; return func.apply(this, arguments); &#125; &#125;&#125;]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise 原理]]></title>
    <url>%2F2017%2F12%2F05%2Fpromise%2F</url>
    <content type="text"><![CDATA[使用 promise 构建异步请求在 es6-promise 中已经说过了，下面这章想要探究一下使用 promise 的原理。 使用 promise 的实例如下: new Promise(function (resolve, reject) {....}) 对于 promise 的执行过程是这样的: executor 执行器: executor 是一个带有 resolve 和 reject 两个参数的函数, executor 函数 promise 构造函数执行的时候同步执行， 被传递 resolve 以及 reject 函数，executor 函数在 Promise 构造函数返回新建对象前被调用, resolve 和 reject 函数被调用的时候，分别将 promise 的状态改为 fullfilled(完成) 和 rejected(完成) executor 函数内部会执行异步操作，操作完成成功之后将 promise 状态改为 fullfiled 或者将发生错误的时候, 将 状态变为 rejected 对于一个 promise 对象具有下面三种状态: 123pending: 初始状态，不是成功就是失败 // pending 英文: 等待，表示处于等待异步处理结果的状态fufilled 等待结果操作成功完成rejected 表示等待操作结果失败 下面是通过使用 promise 进行调用的状态图: promise 代码构建 Promise 构造函数es6: 12345678910let p = new Promise((resovle, reject) =&gt; &#123; // 异步操作 if () &#123; // resolve(value) resolve(value); &#125; else &#123; // reject(value) reject(value); &#125;&#125;) 实际源码: 123456789101112131415function Promise (executor) &#123; let that = this; that.status = PENDDING; that.value = void 0; that.handlerQueue = []; // 执行函数， 传递进入 value // executor(成功函数， 失败函数); executor(function (value) &#123; // 成功函数执行，传递进入 transition 状态: FULFILLED that.transition(FULFILLED, value); &#125;, function (value) &#123; // 失败函数执行， 传递进入 transition 状态: REJECTED that.transition(REJECTED, value); &#125;)&#125; 改变状态函数es6: 123resolve(value);reject(value); 实际源码: 123456789Promise.prototpe.transition = function (status, value) &#123; if (this.status === PENDING) &#123; // 当处于 PENDDING 状态的时候执行函数 this.status = status; this.value = value; // 当成功或者失败的时候都会执行 this.process() 函数 this.process(); &#125;&#125; thenes6: 123p.then(onFulFilled, onRejected);// onFulFilled 成功之后执行的函数// onRejected 失败之后执行的函数 源码分析: 12345678910111213141516Promise.prototype.then = function (onFulfilled, onRejected) &#123; // thenPromise 是一个新的 Promise 对象 let thenPromsie = new Promise(function() &#123;&#125;); // 将执行的函数存入到 handlerQueue 数组之中 this.handlerQueue.push(&#123; // 成功函数 onFulfilled, // 失败函数 onRejected, thenPromise &#125;); // this.process() 执行函数 this.process(); // 返回 thenPromise 一个新的 promise 对象 return thenPromise;&#125; process处理函数用来执行成功时的回调函数以及失败的回调函数。 es6: 12345p.then(function () &#123; // 成功函数执行&#125;, function () &#123; // 失败函数执行&#125;) 源码如下: 12345678910111213141516171819202122232425262728293031// 使用 process 的主要目的是执行保存在 this.handlerQueue 中的函数Promise.prototype.process = function () &#123; let that = this; // 如果状态处于 PENDING 状态 返回 if (that.status === PENDING) &#123; return; &#125; while (that.handlerQueeu.length &gt; 0) &#123; let handler = that.handlerQueue.shift(); (function (handler) &#123; let handlerFn = that.status === FULFILLED ? handler.onFulfilled : handler.onRejected; // 如果 handlerFn 是一个函数 if (isFunction(handlerFn)) &#123; // 使用 callLater 回调函数执行 callLater(function () &#123; try &#123; // 执行 handlerFn 函数 let x = handlerFn(that.value); // 将 handler.thenPromise 以及 handlerFn 计算之后的 x 传入 resolve 函数 resolve(handler.thenPromise, x); &#125; catch (e) &#123; // 如果 catch error handler.thenPromise.transition(REJECTED, e); &#125; &#125;); &#125; else &#123; handler.thenPromise.transition(that.status, that.value); &#125; &#125;)(handler); &#125;&#125; resolveresovle 函数用于函数执行完毕之后改变状态: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function resovle(promise, x) &#123; if (promise === x) &#123; promise.transition(REJECTED, new TypeError()); // 如果 x 是一个 promise &#125; else if (isPromise(x)) &#123; // 调用 x 的 then 方法 x.then(function(value) &#123; promise.transition(FULFILLED, value); &#125;, function(reason) &#123; promise.transition(REJECTED, reason); &#125; ); // 如果函数执行之后的返回值是一个对象或者一个函数 &#125; else if (isObject(x) || isFunction(x)) &#123; try &#123; let then = x.then; // 如果 then 是一个函数 // 参数具有 then 方法的对象 if (isFunction(then)) &#123; let called = false; try &#123; then.call(x, function(y) &#123; if (!called) &#123; resolve(promise, y); called = true; &#125; &#125;, function (r) &#123; if (!called) &#123; promise.transition(REJECTED, r); called = true; &#125; &#125;); &#125; catch (e) &#123; if (!called) &#123; promise.transition(REJECTED, e); &#125; &#125; &#125; else &#123; promise.transition(FULFILLED, x); &#125; &#125; catch (e) &#123; promise.transition(REJECTED, x); &#125; // 如果 x 只是一个数值 &#125; else &#123; promise.transition(FULFILLED, x); &#125;&#125; promsie.resolve 对于 promise.resolve 的状态，存在下面几种情况: 如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。 如果参数是一个具有 then 方法的对象, 使用 promise.resolve 会将这个对象转化为 promise 对象，并且立即执行 thenable 对象的 then 方法。 如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。 如果不带参数, 直接返回一个 resolve 状态的 Promise 对象。 实现代码如下: 12345678910111213Promise.resolve = function(value) &#123; // 返回一个 new Promise return new Promise(function(resolve, reject) &#123; if (isThenable(value)) &#123; // 如果 value 是一个 then 对象 // 如果 value 具有 then 方法，执行下面的函数 value.then(resolve, reject); &#125; else &#123; // else 执行 resolve 函数 resolve(value); &#125; &#125;);&#125; promise.reject12345Promise.reject = function(reason) &#123; return new Promise(function(resolve, reject) &#123; reject(reason); &#125;&#125;&#125; 使用 Promise.reject 接收的参数 reason会被作为 error 传递 other123456789101112131415161718192021222324// 定义 promise 的三种状态// PENDING, FULFILLED REJECTEDlet PENDING = 0; FULFILLED = 1; REJECTED = 2;function isFunction(fn) &#123; return fn instanceof Function;&#125;function isObject(obj) &#123; return obj instanceof Object;&#125;function isPromise() &#123; return p instanceof Promise;&#125;function isThenable(obj) &#123; return obj &amp;&amp; isFunction(obj.then);&#125;// 借用 callLater 实现异步function callLater(fn) &#123; setTimeout(fn, 0);&#125;]]></content>
      <categories>
        <category>代码集</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js源码分析(十)]]></title>
    <url>%2F2017%2F12%2F05%2Funderscore-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%2F</url>
    <content type="text"><![CDATA[underscore.js 源码分析（十）使用underscore.js 的 function 部分 bind bindall partial memorize delay bind_.bind(func, obj, *arguments) 使用 bind 使用 bind 的目的是将函数 func 绑定到 obj 上面去，也就是说，这时候 func 中的 this 就指向了 obj, 其中 arguments 被作为传递给 func 的参数被传入到 func 之中。 ##### 实例如下 123456function greet(home) &#123; console.log(`hi my name is $&#123;this.name&#125;, my home is $&#123;home&#125;`);&#125;// 使用 _.bind 进行函数绑定_.bind(greet, &#123;name: '张宁宁'&#125;, '山东');// hi my name is 张宁宁, my home is 山东 关于使用 bind 的函数: 使用 bind 的函数 使用 bind 函数接收两个参数，第一个参数表示需要进行绑定的变量，第二个参数表示传递给函数的参数。 源码如下: 1234567891011121314151617181920_.bind = function(func, context) &#123; // 首先检查是否支持 es5 的bind 方法, 如果支持， 使用 nativeBind 进行绑定操 // nativeBind.appy // 对于 es5 支持的 bind 方法接收两个参数 // func 以及 参数 if (nativeBind &amp;&amp; func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1)); // 如果 func 不是一个函数的时候 // throw new TypeError('bind must be called on a function'); if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function'); // 使用 slice.call 用于截取 arguments // 通过使用 slice.call 方法截取传入函数的参数 var args = slice.call(arguments, 2); var bound = function () &#123; // 返回一个 executeBpund 函数 // 使用 args 数组的 concat 方法用于连接数组 // 分别传入的值是 func, bound, context, this, args return executeBound(func, bound, context, this, args.concat(slice.call(arguments))); &#125;; return bound; &#125;; 其中 executeBound 函数如下: 1234567891011121314// 这里面 boundFunc 是需要进行绑定的函数 var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) &#123; // 如果 boundFunc 不在 callingContext 的原型链上 // 使用 apply 方法进行绑定 // 如果 callingContext 不在 boundFunc 的原型链上 // 这里的 callingContext 是指的 this 值 // 返回将 context 绑定到 sourceFunc 上面 if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args); // 关于 baseCreate 函数 var self = baseCreate(sourceFunc.prototype); var result = sourceFunc.apply(self, args); if (_.isObject(result)) return result; return self; &#125;; 关于 baseCreate 函数如下: 123456789101112let Ctor = function () &#123;&#125;;let baseCreate = function(prototype) &#123; // 判断 prototype 是否是一个对象 if (!_.isObjject(prototype)) return &#123;&#125;; // 如果nativeCreate 存在的话, 返回 nativeCreate(prototype) 这个函数 if (nativeCreate) return nativeCreate(protoytpe); Ctor.prototype = prototype; // 创建一个函数的实例，这个函数的原型指向 prototype var result = new Ctor; Ctor.prototype = null; return result;&#125; 上面的 nativeCreate 返回的是这个 Object.create() 使用 Object.create 用来实现继承的关系 123456789// 使用 new 操作符的过程let obj = new Constructor();// 创建一个新的对象let obj = &#123;&#125;;// 执行原型链接obj._proto_ = Constructor.prototype;// 将这个构造函数的 this 值指向新创建的这个新对象Constructor.call(obj);// 这样在 obj 中我们就能愉快的使用在 Constructor 中通过 this 值创建的新对象了 partialpartial(function, *arguments) 局部应用一个函数填充在任意个数的 arguments。 实例123456function add(a, b) &#123; return a + b;&#125;let particalAdd = _.partial(add, 3);particalAdd(5); // 8// 这里的 5 填充了函数的第二个参数 b 自己写的函数: 12345678910function partial(fn) &#123; // 获取到传入到 partial 函数中的参数 let partialArgs = Array.prototype.slice.call(arguments, 1); // return 返回一个函数 return function(args) &#123; let fnArgs = Array.prototype.slice.call(arguments, 0); // 将参数传入，执行 fn fn(...partialArgs, ...fnArgs); &#125;&#125; 源码分析123456789101112131415_.partial = function(func) &#123; let boundArgs = slice.call(arguments, 1); return function bound () &#123; let position = 0; let args = boundArgs.slice(); let length = args.length; for (let i = 0; i &lt; length; i++) &#123; // 在数组中使用 position ++ if (args[i] === _) args[i] = arguments[position++]; &#125; whitle(position &lt; arguments.length) args.push(arguments[position++]); // 这时候的 args 中是包含了所有的参数 return executeBound(func, bound, this, this, args); &#125;&#125; 关于 executeBound 函数上面有解释，这个函数的作用是: Determines whether to execute a function as a constructor, or a normal function with the provided arguments 决定是否构建一个函数作为构造函数，或者运行一个给定参数的普通函数。 memoize 使用 memorize 用来缓存函数计算的结果。 delay 使用 delay 用来实现对于函数延迟执行，代码如下: 123456789101112function delay(func, wait) &#123; // 通过调用 Array.prototype.slice.call 的方法进行获得传递的参数 let args = Array.prototype.slice.call(arguments, 2); // 返回等待 wait 时间之后的函数 return setTimeout(() =&gt; &#123; // 自己写的 func(args); // 源码写的 // 使用 apply 的方法向函数 func 中传递 args 参数 return func.apply(null, args); &#125;, wait)&#125; defer defer(function, *arguments) 使用 defer 的目的在于延迟调用 function 直到当前的调用栈被清空为止，其中 arguments 会被作为 function 的参数进行传入。 类似于使用 setTimeout(function () {}, 0) 的延迟调用效果。 实现的源码如下: 1_.defer = _.partial(_.delay, _, 1);]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js 源码分析(九)]]></title>
    <url>%2F2017%2F12%2F04%2Funderscore-js-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B9%9D%2F</url>
    <content type="text"><![CDATA[underscore.js 源码分析sortedIndex findIndex findLastIndex range sortedIndexsortedIndex(list, value, [iteratee], context) 其中 list 是已经被排好序的数组，通过使用 soetedIndex 可以查找到 value 在已经排好序的 list 数组中的顺序。使用 二分法进行查找的。 使用二分法进行查找的 value 位置如下: 12345678910111213function sortIndex(array, obj, iteratee, context) &#123; iteratee = cb(iteratee, context, 1); // 获取到传入的 obj 的值 let value = iteratee(obj); let low = 0; // 定义 high 是数组的长度 array.length let high = array.length; while(low &lt; high) &#123; let mid = Math.floor((low + high) / 2); // 如果 array[mid] &gt; value value 在 low 和 mid 之间 if (itetatee(array[mid]) &gt; value) &gt; 0) mid = high; else low = mid + 1; &#125;&#125; findIndexfindIndex(array, predicate, [context]) 返回在array 中满足 predicate 函数为真的第一个元素的索引, 如果没有找到，返回 -1; findLastIndex类似于使用 findIndex 不同的是从数组的从后向前开始检索，返回的是第一个判断为真的值 使用 findIndex 以及 findLastIndex 的代码如下: 12345678910111213function getIndexFunc(dir) &#123; return function(array, predicate, context) &#123; predicate = cb(predicate, context); let length = array.length; let index = dir &gt; 0 ? 0 : length - 1; for (; index &gt;= 0 &amp;&amp; index &lt; length; index += dir) &#123; if (predicate(array[index], index, array)) return index; &#125; return - 1; &#125;&#125;let findIndex = getIndexFunc(1);let findLastIndex = getIndexFunc(-1); rangerange([start], stop, [step]) 使用 range 创建一个整数灵活编号的列表函数，返回一个从 start 到 stop 的整数的一个列表, 通过使用 step 来减少独占。 如果省略 start, start 默认从 0 开始，步进为 1; 自己写的代码: 1234567891011121314151617181920212223242526272829function range(start, stop, step) &#123; let args = arguments; let resultArray = []; let theStep = 1; let theStart = 0; if (args.length === 1) &#123; stop = args[0]; &#125; if (args.length === 2) &#123; theStart = args[0]; stop = args[1]; &#125; if (args.length === 3) &#123; theStart = args[0]; stop = args[1]; theStep = args[2]; &#125; // 太繁琐 if (theStart &lt; stop) &#123; for (let index = theStart; index &lt; stop; index = index + theStep) &#123; resultArray.push(index); &#125; &#125; else &#123; for (let index = theStart; index &gt; stop; index = index + theStep) &#123; resultArray.push(index); &#125; &#125; return resultArray;&#125; 源码: 1234567891011121314151617181920/** @description range 返回特定范围的数组* @param start &#123;Number&#125; 数组中开始的数字* @param stop &#123;Number&#125; 数组中结束的数字* @param step &#123;Nunber&#125; 步进*/function range(start, stop, step) &#123; if (arguments.length &lt;= 1) &#123; start = stop || 0; stop = 0; &#125; step = step || 1; let length = Math.max(Math.ceil((start - stop) / step), 0); let result = new Array(length); for (let index = 0; index &lt; length; index++, start += step) &#123; result[index] = start; &#125; return result;&#125;]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js源码分析(八)]]></title>
    <url>%2F2017%2F12%2F01%2Funderscore-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%85%AB%2F</url>
    <content type="text"><![CDATA[underscore.js 源码分析(八)zip unzip object indexOf lastIndexOf zip_.zip(*arrays) 使用 zip 的目的是将数组中相应位置的值结合在一起。将分离的数组归并为一个数组。 实例12_.zip(['张宁宁', '张艺苇'], ['男', '女'], ['山东', '河北']);=&gt; [['张宁宁', '男', '山东'] , ['张艺苇', '女', '河北']] 源码分析自己写的: 12345678910111213141516171819/** * @description 用于合成数组 * @param &#123;Object&#125; array 传入的多个数组 * @return &#123;Object&#125; 返回的经过合成之后的数组*/function zip(array) &#123; // 需要添加是否为 null if (array === null) return []; let args = Array.prototype.slice.call(arguments, 0); let result = []; array.map((item, index) =&gt; &#123; let arr = []; args.map((argItem) =&gt; &#123; arr.push(argItem[index]); &#125;) result.push(arr); &#125;); return result;&#125; 需要注意的几点: 对于传入的 array 需要进行判断，是否为 null 对于传入的参数一定要进行类型判断 123456789101112_.zip = function(array) &#123; if (array == null) return []; // 使用 _.max 获取到 arguments 中所有的数组个数 var length = _.max(arguments, 'length').length; // 使用 Array 生成 length 长度的数组 var results = Array(length); while (length-- &gt; 0) &#123; // 使用 pluck 用于萃取获得 arguments 的某种属性值 results[length] = _.pluck(arguments, length); &#125; return results; &#125;; unzip使用 unzip 的目的是将归并后的数组分解为串联的一系列的新数组。 ##### 实例 123_.unzip([['张宁宁', '张艺苇'], ['山东', '行唐']]);=&gt; ['张宁宁', '山东'] ['张艺苇', '行唐']// 返回的第一个元素中包含所有输入数组的第一个元素 实现代码如下: 1234_.unzip = function(array) &#123; // 返回使用 apply 压入的一个数组 return _.zip.apply(null, array);&#125;; object使用 object 用于将数组转化为对象的形式。 _.object(list, [values]) 传递一个单独的[key, value] 的列表，或者一个键的列表和一个值的列表。当传入 list 和 values 的时候， list 中的值会被作为返回对象的键, values 中的值会被作为返回对象的值。 实例12_.object(['moe', 'larry', 'curly'], [30, 40, 50]);=&gt; &#123;moe: 30, larry: 40, curly: 50&#125; 源码解析代码如下: 1234567891011121314151617181920/** * @description toObj 将键值数组组合为对象 * @param &#123;Array&#125; list 键数组 * @param &#123;Array&#125; values 值数组 * @return &#123;Object&#125; 组成的对象*/function toObj(list, values) &#123; if (list === null) return &#123;&#125;; let obj = &#123;&#125;; if (typeof values === 'undefined') &#123; list.map((item) =&gt; &#123; obj[item[0]] = item[1]; &#125;); &#125; else &#123; list.map((item, index) =&gt; &#123; obj[item] = values[index]; &#125;); &#125; return obj;&#125; indexOf_.indexOf(array, value, [isSorted]) 使用 indexOf 用于返回 value 在 array 中的索引值， 当传入第三个值为数字的时候，表示从第几个数字进行索引。 实例12_.indexOf([1, 2, 3 ,4 ,1],1, 1);=&gt; 5 源码分析1234567891011121314_.indexOf = function (array, item, isSorted) &#123; var i = 0; length = array &amp;&amp; array.length; // 使用判断数组的方法 // length = array &amp;&amp; array.length; if (typeof isSorted === 'number') &#123; i = isSorted &lt; 0 ? Math.max(0, length + isSorted) : isSorted; &#125; else if (isSorted &amp;&amp; length) &#123; // 如果传入的是一个 true, 使用更快的算法 i = _.sortedIndex(array, item); return array[i] === item ? i : -1; &#125; for (; i &lt; length; i++) if (array[i] === item) return i; return -1;&#125; 判断一个数组是否存在: length = array &amp;&amp; array.length 使用 Math.max 的妙用 例如: 123456Math.max(0, num);// 返回 num &gt; 0//相当于num &lt;= 0 ? 0 : num;//因此// 对于数字的判断比较，就不要使用三元运算符了，使用 `Math.max` 或者 `Math.min` 会更好些 例如下面的一个程序，用来获得一组数组中的最大的差值: 12345678910function getMaxProfit(arr) &#123; let minProfit = arr[0]; let maxProfit = 0; for (let i = 0; i &lt; arr.length; i ++) &#123; minProfit = Math.min(minProfit, arr[i]); let currentProfit = arr[i] - minProfit; maxProfit = Math.max(maxProfit, currentProfit); &#125; return maxProfit;&#125; lastIndexOf_.lastIndexOf(array, value, [fromIndex]) 返回 value 在 array 中从最后开始的索引值，传入的 fromIndex 将从给定的索引值进行搜索。 源码分析12345678910_.lastIndexOf = function(array, item, fromIndex) &#123; let index = array ? array.length : 0; if (typeof fromIndex === 'number') &#123; // 使用 Math.min 当 fromIndex + 1 &gt; index 的时候，要取 index index = fromIndex &lt; 0 ? index + fromIndex + 1 : Math.min(index, fromIndex + 1); &#125; // 使用 --index 因为最后一个元素的索引是 array.length - 1 while (--index &gt;= 0) if (array[index] === item) return index; return -1;&#125; sortIndex_.sortIndex(list, value, [iteratee], [context]) 使用 sortIndex 的目的在于使用二分法查找到 value 在 list 中的位置序号。 实例12_.sortedIndex([10, 20, 30, 40, 50], 35)// 3 源码分析使用二分法进行比较获得到元素在数组中的位置的。 1234567891011_.sortedIndex = function (array, obj, iteratee, context) &#123; iteratee = cb(iteratee, context, 1); let value = iteratee(obj); let low = 0; let high = array.length; while(low &lt; high) &#123; let mid = Math.floor((low + high) / 2); // 判断 value 在相对于 array 在左边还是在右边 if (_.comparator(iteratee(array[mid], value)) &lt; 0) low = mid + 1; else high = mid; &#125; return low;&#125; 使用二分法的原理是将数组中分为两个部分，判断 value 值在哪一个部分之内。]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js源码分析(七)]]></title>
    <url>%2F2017%2F11%2F28%2Funderscore-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%83%2F</url>
    <content type="text"><![CDATA[underscore.js 源码分析（七）flatten without union intersection uniq flatten实例使用 flatten 用来将多层嵌套的数组转化为一层，例如: 12list = [1, [3, 4]];_.flatten(list) // [1, 3, 4] 源码分析123_.flatten = function(array, shallow) &#123; return flatten(array, shallow, false); &#125;; 其中 flatten 函数如下: 123456789101112131415161718192021222324252627282930/**@description 用于将数组脱离嵌套*@params input 传入的数组*@params shallow &#123;Boolean&#125; 是否需要减少嵌套**/var flatten = function(input, shallow, strict, startIndex) &#123; var output = [], idx = 0, value; for (var i = startIndex || 0, length = input &amp;&amp; input.length; i &lt; length; i++) &#123; value = input[i]; // 这里使用了运算符嵌套表达式 // value存在并且value的length 大于等于0 并且 value 输入数组或者类数组对象 if (value &amp;&amp; value.length &gt;= 0 &amp;&amp; (_.isArray(value) || _.isArguments(value))) &#123; //flatten current level of array or arguments object // use recursion to get the value // use if to decide isRecursion // 这里使用 if 来决定是否需要进行递归 if (!shallow) value = flatten(value, shallow, strict); var j = 0, len = value.length; output.length += len; // 看这种优雅的写法 while (j &lt; len) &#123; // 将取到的值依次填入 output[idx++] = value[j++]; &#125; &#125; else if (!strict) &#123; output[idx++] = value; &#125; &#125; return output; &#125;; without实例_.without(array, values) 使用 _.without 用来所有 values 值后的 array 副本。 使用: 12_.without([1, 2, 3], 1)=&gt; [2, 3] 源码分析自己写的函数: 1234567891011function without(array, values) &#123; if (typeof values === 'undefined') return array; if (array &amp;&amp; array.length) &#123; let value = Array.prototype.slice.call(arguments, 1); array.filter((item) =&gt; &#123; return ~values.indexOf(item); &#125;); &#125; else &#123; return []; &#125;&#125; 上面的函数中存在错误: 结果或返回 undefined 原因: 使用 filter方法中的 return 只会跳出 filter 循环，不会跳出最终的函数循环。 低级错误 12345678910111213function without(array, values) &#123; if (typeof values === 'undefined') return array; if (array &amp;&amp; array.length) &#123; let value = Array.prototype.slice.call(arguments, 1); // 使用 filter 进行的筛选效果选出的是符合效果的值 let newArray = array.filter((item) =&gt; &#123; return value.indexOf(item) === -1; &#125;); return newArray; &#125; else &#123; return []; &#125;&#125; 使用源码分析如下: 12345_.without = function(array) &#123; // 向 difference 的函数中传入两个参数， array 以及 slice.call(arguments, 1); // array 是传入的需要进行删除的数组, slice.call() 获取到传入的第二个参数 return _.difference(array, slice.call(arguments, 1)); &#125;; 这里调用了 _.difference 的方法实现。 使用 _.difference 实现的函数代码如下: 123456789101112_.difference = function(array) &#123; // 获得到的 rest 函数 // 将 arguments 传入到 flatten 函数, 传入的参数是 startIndex: 1 // 表示获取到传入的 arguments 的第二个参数 var rest = flatten(arguments, true, true, 1); // 对于数组使用 filter 的方法 // !_.contains 对于每一个数组进行遍历处理 // 返回 rest 中没有包含 value 的值 return _.filter(array, function(value)&#123; return !_.contains(rest, value); &#125;); &#125;; union实例_.union(*arrays) 使用 union 用于返回传入的 arrays 的并集。按照顺序返回，可以传入一个或者多个的 arrays 数组。 源码分析123_.union = function() &#123; return _.uniq(flatten(arguments, true, true));&#125; 其中 _.uniq 函数如下: 1234567891011121314151617181920212223242526272829303132333435_.uniq = _.unique = function(array, isSorted, iteratee, context) &#123; if (array == null) return []; // 如果 isSorted isBoolean if (!_.isBoolean(isSorted)) &#123; context = iteratee; iteratee = isSorted; isSorted = false; &#125; // 如果 iteratee 不是null if (iteratee != null) iteratee = cb(iteratee, context); var result = []; var seen = []; for (var i = 0, length = array.length; i &lt; length; i++) &#123; var value = array[i], // 获取到返回的结果 computed = iteratee ? iteratee(value, i, array) : value; if (isSorted) &#123; // 如果 i !== 0 或者 seen 不等于 computed 将 value push 进入到 result 中 if (!i || seen !== computed) result.push(value); // 将computed 结果赋给 seen seen = computed; // 如果 iteratee 函数存在的话并且没有被排序 &#125; else if (iteratee) &#123; // 如果seen 中没有包含有 computed 结果 if (!_.contains(seen, computed)) &#123; // 将computed 结果推入到 seen 中 seen.push(computed); result.push(value); &#125; &#125; else if (!_.contains(result, value)) &#123; result.push(value); &#125; &#125; return result; &#125;; intersection_.intersection(arrays) 实例使用 _.intersection 用来返回传入多个数组的并集。 1_.intersection([1, 2, 3], [1, 2, 4], [10, 1, 2, 6]) // [1, 2] 返回传入的多个数组的并集。 源码分析1234567891011121314151617_.intersection = function(array) &#123; var result = []; var argsLength = arguments.length; for (var i = 0, length = getLength(array); i &lt; length; i++) &#123; var item = array[i]; // 使用 continue 是结束本次循环 // 用于判断传入的数组中是否有包含的相同的元素 if (_.contains(result, item)) continue; // 使用 break 是结束整个循环 for (var j = 1; j &lt; argsLength; j++) &#123; if (!_.contains(arguments[j], item)) break; &#125; // 当上次循环结束之后 j === argsLength 成立 if (j === argsLength) result.push(item); &#125; return result; &#125;; 基本的思路是对于第一个传入的数组中的值进行遍历，根据第一个数组中的值, 遍历其他的数组，判断其他的数组中是否含有这个值。如果含有这个值的时候，将这个值存入一个result数组，最后将这个 result 数组返回。 要点: 两次循环, 使用结束循环的方式是不一样的。 使用 break 的时候， 结束的是整个循环 使用 continue 的时候, 结束的是当前的循环 关于 contain 函数 使用 contain 用来判断在一个数组中是否包含有某一个元素: 在 es6 中使用 Array.includes(item) 来判断 item 是否包含在 Array 之中。 difference实例_.difference(array, *others) 使用 difference 获取到来自于 array 但是不存在于 others 中的数组元素。 源码分析自己写的代码: 1234567function difference(array, other) &#123; let rest = Array.prototype.slice.call(arguments, 1); let newArr = array.filter((item) =&gt; &#123; return other.indexOf(item) === -1; &#125;); return newArr;&#125; 源码如下: 123456_.difference = function(array) &#123; var rest = flatten(arguments, true, true, 1); return _.filter(array, function(value)&#123; return !_.contains(rest, value); &#125;); &#125;;]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js 源码解析(六)]]></title>
    <url>%2F2017%2F11%2F27%2Funderscore-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%85%AD%2F</url>
    <content type="text"><![CDATA[underscore.js 源码解析(六)first initial last rest compact first实例_.first(array, [n]) n 是可选的, 表示选择数组中的前 n 个元素， 当我们没有传递 n 的时候，我们获得的是数组的第一个元素 array[0]。 使用 first 用来获取到数组中的第一个元素。 12let list = [1, 2, 3, 4];_.first(list) // 1 源码分析使用 _.first 实现的源码如下: 12345678_.first = _.head = _.take = function(array, n, guard) &#123; // 如果 array 为null 返回 undefined if (array == null) return void 0; // 如果没有明确传入的 参数 n 返回数组的第一项 array[0] if (n == null || guard) return array[0]; // 使用 _.initial 用于返回数组的前 n 个元素 return _.initial(array, array.length - n); &#125;; 注意: 如何判断 null? 如果使用 typeof 判断 null 会返回 object , 实现判断是否为 null 的简单方法是进行判断: 123if (obj == null) &#123; // isnull&#125; 这里使用了一个 _.initial 用于获取到数组的相关值: _.initial使用 _.initial 的目的在于返回数组中前 n 个元素，不包括第 n 个元素 源码如下:123_.initial = function(array, n, guard) &#123; return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));&#125;; _.last使用 _.last 用于返回数组中的最后一个元素。 源码分析123456_.last = function(array, n, guard) &#123; if (array == null) return void 0; if (n == null || guard) return array[array.length - 1]; // 调用 rest函数， 当 n !== null 的时候 return _.rest(array, Math.max(0, array.length - n)); &#125;; _.rest使用 _.rest 函数用于返回数组中剩下的元素。 源码分析123_.rest = _.tail = _.drop = function(array, n, guard) &#123; return slice.call(array, n == null || guard ? 1 : n); &#125;; 使用 slice.call 其实是 Array.prototype.slice.call() 的方法 Array.slice(start, end) // 用于裁剪数组，裁剪的数组包括 start 不包括 end compact使用 compact 用于去除所有为 假值 的数组成员 关于假值: false, undefined null 0 以及 &quot;&quot; 被称为假值, 因为强制类型转换会被转换为 false。 源码如下: 1234_.compact = function(array) &#123; // 在 filter 的函数中 return _.filter(array, _.identity);&#125;; 因为在上面的代码中，函数 _.filter 中存在一个判断: 123if (someFn) &#123; // doSomething&#125; 这里会对位于 if 框内的元素someFn进行强制类型转换。]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js 源码分析(五)]]></title>
    <url>%2F2017%2F11%2F26%2Funderscore-js-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[### underscore.js 源码解析（五） sample toArray size partition _.sample_.sample(list, [n]) 用于产生一个随机样本, 传递的参数 n 表示从 list 中返回 n 个随机元素。 源码分析12345678910_.sample = function(obj, n, guard) &#123; if (n == null || guard) &#123; if (obj.length !== +obj.length) obj = _.values(obj); // 返回使用 _.random 获得的随机数 return obj[_.random(obj.length - 1)]; &#125; // 使用 slice 用来分割数组 // 使用 Math.max() 用来返回最大值 return _.shuffle(obj).slice(0, Math.max(0, n)); &#125;; 通过使用 Math.max() 用来获得一组数中的最大值。 1234Math.max(value1, value2, value3, value4...)// 获取到 value1, value2, value3, value4... 等一组数中的最大值Math.min(value1, value2, value3, value4...)// 获取到 value1, value1.. 中的最小值 使用 Array.slice 用来进行分割数组 Array.slice(start, end) 分割的数组中包括 start 不包括 end toArray##### 实例 _.toArray(list) 如果 list 是一个可以迭代的对象, 可以将 list 转化为一个数组。 源码分析123456789101112_.toArray = function(obj) &#123; // 如果 obj 不存在, 返回一个空的数组 if (!obj) return []; // 如果 obj 是一个真正的数组, 返回 slice.call(obj), // Object.prototype.slice if (_.isArray(obj)) return slice.call(obj); // 如果 obj 是一个类数组对象 // 类数组对象属于对象，但是有 length if (obj.length === +obj.length) return _.map(obj, _.identity); // 返回 obj 是一个对象 return _.values(obj); &#125;; 当我们判断一个对象是否是数组或者对象的时候我们要分为几种情况: 使用 obj.length 进行判断的时候: 对象是数组: 使用 Array.isArray 进行判断，当 这个判断不支持的时候，使用 Object.prototype.toString 进行判断。 123function isArray(obj) &#123; return Array.isArray(obj) || Object.prototype.toString.call(obj) ==== '[object Array]';&#125; 对象是类数组对象 对于类数组对象也有 length 属性，因此当我们判断类数组对象不是数组的时候，接下来进行判断: 123if (obj.length === +obj.length) &#123; // 判断得到是类数组对象&#125; 当得到的类型是对象的时候 1234// 对于对象而言: obj.length: undefined// +obj.length: NaNif (obj.length !== +obj.length) &#123;&#125; size_.size(list) 用于返回 list 的长度 当 list 是数组的时候，返回的是数组的长度，当 list 是对象的时候，返回的是对象的长度。 实例123456let person = &#123; name: '张宁宁', age: 23, sex: 'female'&#125;;_.size(person) // 3 源码分析使用_.size 进行判断的数组数量的方法十分简单，判断传入的是对象或者是数组，对象的话返回的是键的值，对于数组返回的是数组的长度。 1234567function size(list) &#123; if (list == null) return 0; // 判断 list 是否是对象或者数组 // list 是数组，返回 list 的length // list 是对象, 返回的是 Object.keys(list) 的长度 return list.length === +list.length ? list.length : Object.keys(list).length;&#125; partition_.partition(array, predicate) 实例使用 partition 的目的在于拆分一个数组为两个数组，拆分之后的数组中第一个数组是满足 predicate 函数的数组， 拆分之后的第二个数组是不满足 predicate 函数的数组。 predicate : 断言，断定，宣布，宣讲，使基于 源码分析123456789101112_.partition = function(obj, predicate, context) &#123; predicate = cb(predicate, context); // 定义两个数组，分别用来存放成功的数组和失败的数组 var pass = [], fail = []; _.each(obj, function(value, key, object) &#123; // predicate 返回 true : pass.push(obj) // predicate 返回 false : fail.push(obj) (predicate(value, key, object) ? pass : fail).push(obj); &#125;); // 返回一个二维数组 return [[pass], [fail]];&#125;;]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js源码分析(四)]]></title>
    <url>%2F2017%2F11%2F23%2Funderscore-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[underscore.js 源码分析(四)_.min _.sortBy _.groupBy _.indexBy _.countBy _.min_.min(list, [iteratee], [context]) 类似于使用 _.max 这个函数用于获取到 list 中的最小值, 其中 iteratee 是作为的筛选的依据。 源码如下: 123456789101112131415161718192021222324_.min = function(obj, iteratee, context) &#123; var result = Infinity, lastComputed = Infinity, value, computed; if (iteratee == null &amp;&amp; obj != null) &#123; obj = obj.length === +obj.length ? obj : _.values(obj); for (var i = 0, length = obj.length; i &lt; length; i++) &#123; value = obj[i]; if (value &lt; result) &#123; // 和使用 _.max 的没有什么不同，不同的是这里筛选的是最小值 result = value; &#125; &#125; &#125; else &#123; iteratee = cb(iteratee, context); _.each(obj, function(value, index, list) &#123; computed = iteratee(value, index, list); if (computed &lt; lastComputed || computed === Infinity &amp;&amp; result === Infinity) &#123; result = value; lastComputed = computed; &#125; &#125;); &#125; return result; &#125;; _.sortBy_.sortBy(list, iteratee, [context]) 使用 _.sortBy 返回的是一个经过排序之后的数组。排序的依据是根据 iteratee 函数进行判断的。 返回的是进行排序之后的数组的副本，原来的数组并没有进行了改变。 实例源码分析123456789101112_.sortBy = function(obj, iteratee, context) &#123; iteratee = cb(iteratee, context); return _.pluck(_.map(obj, function(value, index, list) &#123; return &#123; value: value, index: index, criteria: iteratee(value, index, list) &#125;; &#125;).sort(function(left, right) &#123; return _.comparator(left.criteria, right.criteria) || left.index - right.index; &#125;), 'value'); &#125;; 在 _.sortBy 函数中存在着多个的函数，下面一一进行分析。 _.pluck 函数，这个函数用于获取到对象数组中包含有过相关属性的所有的对象。 看来是用 _.map... 这个方法返回的是一个对象数组。 1234// _.pluck 函数用于return _.pluck(_.map(obj, function(value, index, list) &#123; // balabala&#125;), 'value') 在 _.map... 中执行了两步操作: 调用了使用的 _.map 方法以及接下来调用 sort 方法。 1234567891011121314// _.map 方法 obj 是一个对象数组// 返回的是一个数组，数组中包含有对象// value: 对象的值// index: 对象的键// criteria: 对象运行iteratee 之后返回的值_.map(obj, function(value, index, list) &#123; return &#123; // 对象中返回了三个值 // &#123;value: '', index: '', criteria: ''&#125; value: value, index: index, criteria: iteratee(value, index, list) &#125;&#125;) 对于使用 _.map 方法返回的一个新的数组对象之后， 对于这个新的对象数组执行 sort 方法。 关于数组的 sort 方法: 关于使用数组的 sort 方法 12Array.sort(sortBy);// sortBy 是一个用来进行排序依据的函数 使用 sort() 方法的时候，如果不传递 sortBy 的时候，使用数组的 sort 方法默认的是按照字符编码的顺序进行排序 例如: 123let a = [1, 2, 4, 23];// 在原来的数组上进行的改变，并没有生成一个新的数组a.sort() // [1, 2, 23, 4] sortBy 是用来进行排序的函数: sortBy 接收两个参数，用来对于这两个参数进行比较。 接下来执行的是 sort 函数 12345.sort(function(left, right) &#123; // 在使用 comparator 之后进行比较 left.index - right.index // 为什么呢？ return _.comparator(left.criteria, right.criteria) || left.index - right.index;&#125;) 这个函数的作用是对于上面返回的数组对象进行 sort 排序。 返回的是 _.comparator(left.criteria, right.criteria) 或者 left.index - right.index。 看来是用进行比较。 其中 _.comparator 的方法。 1234567891011121314// 传入要进行比较的函数参数 a, b_.comparator = function(a, b) &#123; // 如果 a === b 返回 0 if (a === b) return 0; // 判断 a &gt;= a b &gt;= b // 为什么呢？ var isAComparable = a &gt;= a, isBComparable = b &gt;= b; // 如果其中一个为 true if (isAComparable || isBComparable) &#123; if (isAComparable &amp;&amp; !isBComparable) return -1; if (isBComparable &amp;&amp; !isAComparable) return 1; &#125; return a &gt; b ? 1 : (b &gt; a) ? -1 : 0; &#125;; _.groupBy实例_.groupBy(list, iteratee, [context]) 将一个集合分为多个的集合，通过使用 iteratee 函数进行分组，如果 iteratee 是一个字符串而不是一个函数的时候，将这个 iteratee 作为元素的属性名来进行分组。 如下: 1234_.groupBy([1, 2, 4], function(num) &#123;return num % 2;&#125;) // &#123; 0: [2, 4], 1: [1] &#125;// 返回一个对象// 对象的属性是函数中返回的值// 相应属性的值是 list 数组中运行函数得到的相应属性的集合 源码解析123_.groupBy = group(function(result, value, key) &#123; if (_.has(result, key)) result[key].push(value); else result[key] = [value]; &#125;); 在上面的函数中，存在两个函数: group 以及 _.has 关于使用 group 函数: 1234567891011121314151617// 接收一个 behavior 作为参数var group = function(behavior) &#123; // 返回一个函数，这个函数就是返回的 _.groupBy return function(obj, iteratee, context) &#123; // 定义 result 是一个对象 var result = &#123;&#125;; iteratee = cb(iteratee, context); _.each(obj, function(value, index) &#123; // 对于使用 obj 进行遍历, 获取到 key // 将 list 中的 value, index 传入 var key = iteratee(value, index, obj); // 执行 behavior 函数 behavior(result, value, key); &#125;); return result; &#125;; &#125;; 在上面的函数中 behavior 函数是在 _.groupBy 中的函数是下面的这个: 1if (_.has(result, key)) result[key].push(value); else result[key] = [value]; 使用 _.has 方法用来判断对象 result 中是否含有属性 key: _.has 方法如下: 1234let _.has = function (obj, key) &#123; // 当obj 不是null 并且 对象 Obj 中包含有属性 key 的时候 返回 true return obj !== null &amp;&amp; Object.prototype.hasOwnProperty.call(obj, key);&#125; #### _.indexBy _.indexBy(list, iteratee, [context]) 使用 _.indexBy 用来返回在列表中每一个元素键的 iteratee 函数。 返回一个每一项索引的对象。 使用 _.indexBy 和使用 _.groupBy 的区别在于: 使用 _.indexBy 你需要知道键值对是唯一的，比如: 12345678&gt;let list = [&#123;name: '张宁宁', age: 20&#125;, &#123;name: '张宁宁', age: 50&#125;];&gt;_.indexBy(list, function(value) &#123; return value.name &#125;);&gt;=&gt;&gt;&#123;张宁宁:&#123;name: "张宁宁", age: 50&#125;&#125;&gt;_.groupBy(list, function(value) &#123; return value.name &#125;);&gt;=&gt;&gt;&#123;张宁宁:[&#123;name: '张宁宁', age: 20&#125;, &#123;name: '张宁宁', age: 50&#125;]&#125;;&gt; 实例1234567let list = [&#123;name: '张三', age: 12&#125;， &#123;name: '李四', age: 13&#125;];_.indexBy(list, 'age');=&gt; &#123; '12': &#123;name: '张三', age: 12&#125;, '13': &#123;name: '李四', age: 13&#125;&#125; 源码解析类似于使用 _.groupBy 的源码, 使用 _.indexBy 的源码如下: 123_.indexBy = group(function(result, value, key) &#123; result[key] = value;&#125;); _.countBy_.countBy(list, iteratee, [context]) 返回各组中对象的数量的计数。返回在该组中值的数目。 实例1234let list = [&#123;name: '张宁宁', age: 20&#125;, &#123;name: '张宁宁', age: 50&#125;];_.countBy(list, function(value) &#123; return value.age &#125;);=&gt;&#123; 20: 1, 50: 1 &#125; 源码如下12345let _.countBy = group(function(result, value, key) &#123; // 如果在 result 中存在 key result[key] ++ // 否则 将 result[key] = 1; if (_.has(result, key)) result[key] ++; else result[key] = 1; &#125;) 其中 group 函数； shuffle实例用来返回一个随机乱序的副本。并没有改变 list 的值。 123let list = [1, 2, 3, 4, 5, 6];_.shuffle(list)[2,6,3,1,5,4] 源码分析使用 _.shuffle 的源码如下: 123456789101112131415161718_.shuffle = function(obj) &#123; // 获取到数组的值或者对象的值 var set = obj &amp;&amp; obj.length === +obj.length ? obj : _.values(obj); // var length = set.length var length = set.length; // shuffled 是一个数组 var shuffled = Array(length); for (var index = 0, rand; index &lt; length; index++) &#123; // 通过使用 _.randow获得到rand 随机数 rand = _.random(0, index); if (rand !== index) shuffled[index] = shuffled[rand]; // 将 index 的值赋给这个随机数组 // 将set[index] 传入到 shuffled 中 shuffled[rand] = set[index]; &#125; // 返回生成的随机数组 return shuffled;&#125;; 对于使用 _.random 的函数如下: 123456789// 这个函数的目的是用来生成_.random = function (min, max) &#123; if (max == null) &#123; max = min; min = 0; &#125; // 加了一个 1 表示生成的数中可以包括 max return min + Math.floor(Math.random() * (max - min + 1));&#125; Math.floor : 向下取整 Math.random 用于生成 0 - 1 之间的随机数; 注意: 使用的是生成 min 和 max 之间的值得时候: min : inclusive 包括 max : exclusive 不包括 12Math.random() * (max - min) + min// 生成 位于 max 与 min 之间的数， 包括 min 但不包括 max 在 shuffle 函数中，使用了一个分牌算法： 12345678for (var index = 0, rand; index &lt; length; index++) &#123; // 通过使用 _.randow获得到rand 随机数 rand = _.random(0, index); if (rand !== index) shuffled[index] = shuffled[rand]; // 将 index 的值赋给这个随机数组 // 将set[index] 传入到 shuffled 中 shuffled[rand] = set[index]; &#125; 使用 分牌算法的原理如下: 存在两个数组 a 和 b 现在想要将 a 中的元素随机生成到 b 中 12345a--&gt;b: indexnote left of a: a 中遍历b--&gt;b:根据 a 中的index b[index] = b[rand],\n取到自身的 b[rand] 值b--&gt;a: rand(随机生成的\n位于(0, index) 之间的数值)a--b: 将得到的 rand 随机数\n b[rand] = a[index],填补刚才 b取到的自身的 rand 如上图所示的算法: 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js源码分析(三)]]></title>
    <url>%2F2017%2F11%2F22%2Funderscore-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[### underscore.js 源码分析(三) _.some _.contains _.invoke _.pluck _.max _.some实例_.some(list, [predicate], [context]) 遍历 list 中的元素, 只要其中有一个元素通过 predicate , 那么就返回为 true 源码分析12345678910111213_.some = _.any = function(obj, predicate, context) &#123; if (obj == null) return false; predicate = cb(predicate, context); var keys = obj.length !== +obj.length &amp;&amp; _.keys(obj), length = (keys || obj).length, index, currentKey; for (index = 0; index &lt; length; index++) &#123; currentKey = keys ? keys[index] : index; // 如果 obj 中其中的一个元素进行 predicate 检验的结果为 true 返回为true if (predicate(obj[currentKey], currentKey, obj)) return true; &#125; return false;&#125;; _.contains实例_.contains(list, value, [fromIndex]) 如果在 list 中包含有 value 值，那么返回为 true fromIndex 表示开始进行检索的位置。 如果 list 是数组, 检查数组中是否包含有对应的 value 值 如果 list 是对象, 检查对象中的值是否有存在的 value 值 自己写的代码: 123456789function contain(obj, value, fromIndex) &#123; if (obj == null) return false; let list = obj; if (obj.length !== +obj.length) &#123; list = obj.values(); &#125; // 为了保证代码的健壮性，添加 typeof fromIndex === 'number' &amp;&amp; fromIndex 的判断 return list.indexOf(value, typeof fromIndex === 'number' &amp;&amp; fromIndex) &gt;= 0;&#125; 源码分析1234567_.contains = _.includes = _.include = function(obj, target, fromIndex) &#123; if (obj == null) return false; // 使用 _.values 获得到对象的值 if (obj.length !== +obj.length) obj = _.values(obj); // 使用 `_.indexOf` 获取到索引 return _.indexOf(obj, target, typeof fromIndex == 'number' &amp;&amp; fromIndex) &gt;= 0;&#125;; _.invoke 计算机术语中: invoke : [ɪnˈvoʊk] 乞求，借助于 调用【计算机】 实例_.invoke(list, methodName, *arguments) 在 list 的每一个元素上执行 methodName 方法。 argument 用于将使用 _.invoke 调用 methodName 方法的时候传递的函数。 12345678let list = [[1, 4, 3]];_.invoke(list, 'sort') // [1, 3 ,4]// 这个函数的作用是将 执行 list 元素中的数组 [1, 4, 3] 方法 sort// 同样 我们可以使用别的函数,这个时候 argument 会被作为 methodName 函数的参数，// 而 函数 print 中的 this 值指向的是 list 中的元素function print() &#123; console.log(this); // [1, 4, 3]&#125; 源码分析实现这个功能的源码如下: 123456789101112_.invoke = function(obj, method) &#123; // 使用 Array.slice.call 返回一个子数组 // 第二个参数 2 表示截取从传入参数的第二个处进行截取 var args = slice.call(arguments, 2); var isFunc = _.isFunction(method); // 对于 obj 进行遍历 return _.map(obj, function(value) &#123; // 通过使用 apply 方法， 将 value 作为 func 的 this 值， 同时传入截取的参数 // 进行判断是否是函数 method 或者 内置的 method 方法 return (isFunc ? method : value[method]).apply(value, args); &#125;); &#125;; 这是一个用于进行调用绑定的函数。 _.pluck pluck 拔掉，摘，拉 _.pluck(list, propertyName) 实例使用 _.pluck 用于获取到数组对象中的对应属性的所有的值。 对于对象中不存在的属性返回 undefined 123var stooges = [&#123;name: 'moe', age: 40&#125;, &#123;name: 'larry', age: 50&#125;, &#123;name: 'curly', age: 60&#125;];_.pluck(stooges, 'name');=&gt; ["moe", "larry", "curly"] 自己写的一个 pluck 函数如下： 123456789101112function pluck(list, name) &#123; let props = []; list.map((obj) =&gt; &#123; if (Object.keys(obj).indexOf(name) &gt;= 0) &#123; props.push(obj[name]); &#125; else &#123; // 这里使用 void 0 代替 undefined props.push(void 0); &#125; &#125;); return props; &#125; 源码分析1234_.pluck = function(obj, key) &#123; // 使用 _.map， 对于 obj 中的数组对象成员执行 _.property 方法 return _.map(obj, _.property(key));&#125;; 1234567_.property = function(key) &#123; // 返回一个函数， 参数 obj 接收到的是 _.property()(obj) 这个的值 return function(obj) &#123; // 传入的 obj 是否为 null 是 返回 undefined 否则 返回 obj[key] return obj == null ? void 0 : obj[key]; &#125;; &#125;; _.max_.max(list, [iteratee], [context]) 返回 list 中的最大值。 123456789101112131415161718192021222324252627282930313233_.max = function(obj, iteratee, context) &#123; // 将 result 初始化为 -infinity lastComputed 初始化为 infinity var result = -Infinity, lastComputed = -Infinity, value, computed; // 当 interaee 为null 不传参数,采用 obj 中内置的方法名称来做 // 并且 obj 不等于 null 的时候 if (iteratee == null &amp;&amp; obj != null) &#123; // obj 为数组 ? 数组 : 对象的值 obj = obj.length === +obj.length ? obj : _.values(obj); for (var i = 0, length = obj.length; i &lt; length; i++) &#123; // 进行遍历值 value = obj[i]; // 比较大小，将最大的那个值赋给 result 参数 if (value &gt; result) &#123; result = value; &#125; &#125; &#125; else &#123; iteratee = cb(iteratee, context); // 使用 foreach 对于 obj 进行计算 _.each(obj, function(value, index, list) &#123; // 进行计算之后返回计算结果 computed = iteratee(value, index, list); // 如果计算结果大于上一次计算结果， 将最大的值赋给 result // 将最大的结果赋予 lastComputed if (computed &gt; lastComputed || computed === -Infinity &amp;&amp; result === -Infinity) &#123; result = value; lastComputed = computed; &#125; &#125;); &#125; return result; &#125;; 在js 中关于运算符优先级的问题: 逻辑 &amp;&amp; (与) 大于 逻辑 或|| 上面有一段程序如下: if (computed &gt; lastComputed || computed === -Infinity &amp;&amp; result === -Infinity) 这段话翻译为中文就是 如果满足 computed === -Infinity &amp;&amp; result === -Infinity 或者 computed &gt; lastComputd 的时候，进行动作。]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js源码分析(二)]]></title>
    <url>%2F2017%2F11%2F20%2Funderscore-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[underscore.js 源码分析(二)_.filter _.where _.findWhere _.reject _.every _.filter实例_.filter(list, predicate, [context]) 遍历 list 值, 返回通过 predicate 函数返回为真的值数组。 代码如下: 12345list = [1, 2, 5, 6];function toFilter(num) &#123; return num % 2 === 0;&#125;console.log('通过过滤的数组', _.filter(list, toFilter)); // [2, 6] 源码分析使用 _.filter() 的源码如下所示: 1234567891011_.filter = _.select = function(obj, predicate, context) &#123; var results = []; // 判断 `obj` 是否为 null 是返回空数组 if (obj == null) return results; predicate = cb(predicate, context); // 使用 `each` 函数对于数组中的每一个列表进行遍历 _.each(obj, function(value, index, list) &#123; if (predicate(value, index, list)) results.push(value); &#125;); return results;&#125;; _.where实例_.where(list, propertries) list: 数组 propertries : 需要进行检索的键值对(一个对象) 遍历 list 中的每一个值， 返回一个数组，这个数组中包含含有 propertries 中属性的所有的键值对。 用法: 12list = [&#123;name: '张宁宁', age: 18&#125;, &#123;name: '张宁宁', age: 70&#125;];console.log(_.where(list, &#123;name: '张宁宁', age: 18&#125;)); // [&#123;name: '张宁宁', age: 18&#125;] #####源码分析 自己写的代码: 123456789101112131415161718192021222324function where(list, sObj) &#123; let results = []; let flag = false; if (list == null) &#123; return results; &#125; for (let obj of list) &#123; for (let key in obj) &#123; if (Object.keys(sObj).includes(key)) &#123; if (sObj[key] === obj[key]) &#123; flag = true; &#125; else &#123; flag = false; &#125; &#125; else &#123; flag = false; &#125; &#125; if (flag) &#123; results.push(obj); &#125; &#125; return results;&#125; _where() 源代码如下所示: 123_.where = function(obj, attrs) &#123; return _.filter(obj, _.matches(attrs));&#125;; 使用 _filter 筛选出 obj 对象中适合函数 _.matches 的键值对儿。 _.match() 方法的源码如下所示: 123456789101112131415161718192021_.matches = function(attrs) &#123; // 获取到对象的键值对儿, 是 [key, value] 的形式 var pairs = _.pairs(attrs), length = pairs.length; // 返回一个函数，接收 obj 参数 return function(obj) &#123; // 如果 obj == null 返回 !length // 为什么不直接返回false ? if (obj == null) return !length; // 创建一个新对象 obj = new Object(obj); for (var i = 0; i &lt; length; i++) &#123; var pair = pairs[i], key = pair[0]; // 两种情况， 不存在键或者键存在，值不相等， 两种情况发生一种情况 // 返回 false if (pair[1] !== obj[key] || !(key in obj)) return false; &#125; // 返回 true return true; &#125;;&#125;; 对于返回一个函数的这种形式: 1234567function name() &#123; return function (obj)&#123; // dosomething &#125;&#125;// 调用的时候这样调用name()(); // to dosomething _.findWhere实例_findWhere(list, properties) 遍历整个 list 返回匹配整个 properties 参数所列出的所有键值对儿的第一个值。 源码分析12345_.findWhere = function(obj, attrs) &#123; // 通过使用 _.matches(attrs) 返回了一个函数 // 通过使用 _.find 方法调用了这个函数 return _.find(obj, _.matches(attrs));&#125;; 通过调用 _.find 函数返回通过第一次获得匹配的对象。 _.reject实例_.reject(list, predicate, [context]) 返回 list 列表中没能通过 predicate 检验的数值。 12345function reject() &#123; return num%2 === 0;&#125;let list = [1, 3, 5, 6];console.log(_.reject(list, reject)); // [1, 3, 5]; 作用与 filter 相反。 源码分析123_.reject = function(obj, predicate, context) &#123; return _.filter(obj, _.negate(cb(predicate)), context);&#125;; _.negate 函数 123456 _.negate = function(predicate) &#123; return function() &#123; // 通过使用 apply 方法将 arguments 方法传入 return !predicate.apply(this, arguments); &#125;;&#125;; #### _every 实例_every(list, [predicate], [context]) 如果 list 中的元素都通过 predicate 的真值检验就返回为 true 代码分析源码如下: 1234567891011121314function every(obj, predicate) &#123; if (obj == null) return true; // 通过使用 keys 获得到一个包含对象键的数组 let keys = obj.length == +obj.length &amp;&amp; Object.keys(obj); let currentKey; // length 为数组或者对象的长度 let length = (keys || obj).length; for (let index = 0; index &lt; length; index++) &#123; currentKey = keys ? keys[index] : index; // 如果对于predicate 函数返回为 false, every 函数返回为false if (!predicate(obj[currentKey])) return false; &#125; return true;&#125;]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js源码分析(一)]]></title>
    <url>%2F2017%2F11%2F18%2Funderscore-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[underscore.js 源码分析（一）_.each _.map _.refuce _.reduceRight _.find _.each实例_.each(list, iteratee, [context]) 这个方法用于循环遍历, 用于循环 list 对象或者数组， iteratee 是一个遍历函数，接收的参数为遍历之后的结果。 当 list 为数组的时候，传递给 iteratee 函数的参数是 (element, index, list), 当 list 为对象的时候, 传递给 iteratee 函数的参数是 [value, key, list]。 对于 context 上下文, 这个决定的是 iteratee 中的 this 的指向值。可选参数， 当 context 忽略的时候 this 指向的是全局变量。 _.each 返回值是进行遍历的 list 数组对象。 123456789101112131415function print(value, index, list) &#123; console.log(this.name);// 这里 this 指向了后面传递的 context console.log(value, index, list);&#125;let person = &#123; name: &apos;张宁宁&apos;&#125;console.log(_.each([1, 2, 3], print, person)); // [1, 2, 3]// 最终打印张宁宁1 0 (3) [1, 2, 3]张宁宁2 1 (3) [1, 2, 3]张宁宁3 2 (3) [1, 2, 3] 源码分析在 underscore.js 源码中， _.each() 源码为下: 1234567891011121314151617181920212223_.each = _.forEach = function(obj, iteratee, context) &#123; // 如果 obj == null 返回 null if (obj == null) return obj; // 调用 optimiseCb 函数 稍后分析 iteratee = optimizeCb(iteratee, context); var i, length = obj.length; // 这里提供了分别 数组和对象的一种方法 // 如果数组 if (length === +length) &#123; // 数组情况下， 将 [value, index, list] 传入遍历函数 for (i = 0; i &lt; length; i++) &#123; iteratee(obj[i], i, obj); &#125; &#125; else &#123; // 获取到对象所有的 key 值 var keys = _.keys(obj); for (i = 0, length = keys.length; i &lt; length; i++) &#123; iteratee(obj[keys[i]], keys[i], obj); &#125; &#125; // 返回数组或者对象 return obj; &#125;; 分析: 分别数组和对象的方法 我平常的时候使用 Object.prootype.toString.call().slice(8, -1) 这种方法来分别数组和纯对象，这里使用了一种方法。 12345if (length === +length) &#123;// 这是数组&#125; else &#123;// 这是对象&#125; +length 执行的是隐式类型转换，用于将其他的值转换为数字。经过实验，使用 + 进行类型转换的可能性如下: 123456789+null // 0+flase // 0+"" // 0+true // 1+对象 // NaN+非空字符串 // NaN+NaN // NaN+1 // 1+undefined // NaN 因为上面中 对象的 length 为 undefined 因此 length ===+length // false 这里 +length 会被转化为 NaN。 iteratee = optimizeCb(iteratee, context); optimizaCb 函数 使用 optimizaCb 函数用于绑定上下文: 使用 call 以及 apply 的方法实现的改变函数运行的 this 值的改变 接收三个参数: func 运行的函数 context 运行函数需要进行绑定的上下文 argCount 参数的个数 12345678910111213141516171819202122var optimizeCb = function(func, context, argCount) &#123; // 使用 void 0 类似于使用 undefined // 等同于使用 if(context === undefined) if (context === void 0) return func; switch (argCount == null ? 3 : argCount) &#123; case 1: return function(value) &#123; return func.call(context, value); &#125;; case 2: return function(value, other) &#123; return func.call(context, value, other); &#125;; case 3: return function(value, index, collection) &#123; return func.call(context, value, index, collection); &#125;; case 4: return function(accumulator, value, index, collection) &#123; return func.call(context, accumulator, value, index, collection); &#125;; &#125; return function() &#123; return func.apply(context, arguments); &#125;; &#125;; 上面的 _.each 源码中的使用这个函数的目的是将 iteratee 的上下文 this 绑定到 context 对象。 这里有一个 void 0 这里的 void 0 等同于使用 undefined 不同于使用 undefined 的原因在于： 在 javascript 中 undefined 不是一个保留字。 代码如下: 1234&gt;var undefined = 1;&gt;console.log(undefined); // 1 也是可以的&gt;使用 void 0 作用是这样的&gt; _.map实例_.map(list, iteratee, [context]) 通过 使用变换函数 iteratee 将list 中的值映射到一个新的数组。 1234function filter(value) &#123; return value * 2;&#125;_.map([1, 2, 3], filter); // [2, 4, 6] 源码如下: 12345678910111213141516_.map = _.collect = function(obj, iteratee, context) &#123; if (obj == null) return []; iteratee = cb(iteratee, context); // 使用 &amp;&amp; 操作符， 只有当第一个为true的时候才执行下一步操作 var keys = obj.length !== +obj.length &amp;&amp; _.keys(obj), // || 操作符 第一个为true的时候不再进行下一步动作 length = (keys || obj).length, // 使用 Array 创建一个 length 长度的数组 results = Array(length), currentKey; for (var index = 0; index &lt; length; index++) &#123; currentKey = keys ? keys[index] : index; results[index] = iteratee(obj[currentKey], currentKey, obj); &#125; return results;&#125;; 源码分析 使用 &amp;&amp; 以及 || 进行计算 这两个符号被称之为 选择器操作符，返回的是两边选择器结果的其中一个。在选择的过程中会被执行强制类型转换。 这里对于类型转换，使用的时候要注意出现假值的情况 使用 &amp;&amp; 以及 || 会首先对于 第一个 操作数进行计算，根据判断结果来决定返回哪一个操作数。 1234a || b// 如果 a 类型转换结果为 true 返回的是 a 否则 返回 ba &amp;&amp; b// 如果 a 类型转换结果为 true 返回的是 b 否则返回 a 上面我们可以看到，我们可以利用这两个操作符做一些事情: a || b 好像备用条件。 如果条件 a 不成立, 执行条件 b, 如果成立，执行条件 a a ? a : b a &amp;&amp; b 好像通过条件， 如果 a 成立，向下执行，如果不成立，打住，返回 a 执行的结果 a ? b : a 使用 Array(length) 创建的是一个 length 长度的数组。 _.reduce实例_.reduce(list, iteratee, [memo], context) 通过迭代将 list 中的元素归结为一个值。 memo 表示初始参数。 12345function reduceFn(memo, num) &#123; return memo * num;&#125;let list = [1, 2, 3];_.reduce(list, reduceFn, 1) // 6 源码分析源码如下: 123456789101112131415function reduce(obj, iteratee, memo, context) &#123; if (obj === null) obj = []; iteratee = optimizeCb(iteratee, context, 4); var keys = obj.length !== +obj.length &amp;&amp; Object.keys(), length = (keys || obj).length, index = 0, currentIndex; if (arguments.length &lt; 3) &#123; memo = obj[keys ? keys[index++] : index++]; &#125; for (; index &lt; length; index++) &#123; currentIndex = keys ? keys[index] : index; memo = iteratee(memo, obj[currentIndex], currentIndex, obj); &#125; return memo; &#125; 分析: 在 obj 可能是对象或者数组的情况下，当 obj 是对象的时候，需要产生了一个 使用 keys 来进行数组操作 在迭代的时候， 当没有 memo 初始值的时候， 将数组或者对象的第一个值作为 memo 这里，使用 index++ 来处理的 使用 index++ 的时候，相当于 index = index + 1; 但是直接使用的时候还是原来的 index 12345&gt;let currentIndex = 0;&gt;let addIndex = currentIndex++; // 相当于先返回 currentIndex 在进行加一操作&gt;addIndex // 0&gt;currentIndex // 1&gt; ​ 迭代的过程发生在使用循环赋值的过程中 123for (; index &lt; length; index++) &#123; memo = iteratee(memo, obj[currrentIndex], currentIndex, obj);&#125; _.reduceRight实例_.reduceRight(list, iteratee, [memo], context) 类似于使用_.reduce 不过不同于使用 _.reduce 的是，这个是从右边向左进行遍历操作; 12345function contact(a, b) &#123; return a.contact(b);&#125;let list = [[1, 2], [3, 4], [5, 6]];_.reduceRight(list, contact) // [5, 6, 3, 4, 1, 2] 源码分析1234567891011121314151617_.reduceRight = _.foldr = function(obj, iteratee, memo, context) &#123; if (obj == null) obj = []; iteratee = optimizeCb(iteratee, context, 4); var keys = obj.length !== + obj.length &amp;&amp; _.keys(obj), index = (keys || obj).length, currentKey; if (arguments.length &lt; 3) &#123; // 先对于 index 进行 减一操作 memo = obj[keys ? keys[--index] : --index]; &#125; // 在判断完成 index 之后进行减一操作 while (index-- &gt; 0) &#123; currentKey = keys ? keys[index] : index; memo = iteratee(memo, obj[currentKey], currentKey, obj); &#125; return memo; &#125;; 使用 while 循环进行判断 123while (index-- &gt; 0) &#123; // do something&#125; _.find实例_.find(list, predicate, [context]) 遍历 list 值 返回第一个通过 predicate 函数返回真值的数值。 12345let list = [1, 2, 3];function getodd(value) &#123; return value % 2 === 0;&#125;_find(list, getodd) // 2 源码分析123456789101112_.find = _.detect = function(obj, predicate, context) &#123; var key; // 如果是数组 if (obj.length === +obj.length) &#123; // 使用 findIndex 找到数组的值 key = _.findIndex(obj, predicate, context); &#125; else &#123; // 如果是是对象 key = _.findKey(obj, predicate, context); &#125; if (key !== void 0 &amp;&amp; key !== -1) return obj[key]; &#125;;]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[作用域 与 this 值]]></title>
    <url>%2F2017%2F11%2F12%2F%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[对于作用域而言，可以将作用域分为动态作用域和词法作用域。js 中的作用域属于词法作用域。 词法作用域对于使用词法作用域而言，词法作用域最重要的规则在于词法作用域的定义过程发生在代码的书写阶段。 代码如下: 123456789function foo() &#123; console.log(a) // 2&#125;function bar() &#123; var a = 3; foo();&#125;var a = 2;bar(); 因为这里面的 foo 函数书写在全局的作用域中，因此会被输出 2 动态作用域动态作用域关心的是函数是在哪里被调用的。 上面的函数中使用动态作用域的时候 最终输出应该是 3,因为从 foo 函数被调用的地方寻在变量 a 最后找到了 var a = 3. 词法作用域关心的是函数在那里被声明, 动态作用域关心的是函数在哪里被调用。 使用js 中的 this 的时候， this 的效果是类似于使用动态作用域的。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[translate3d']]></title>
    <url>%2F2017%2F11%2F05%2Ftranslate3d%2F</url>
    <content type="text"><![CDATA[transform 特性一个使用 transform 实现的垂直居中的代码如下: 1234567891011121314151617181920&lt;div class="fDiv"&gt; &lt;div class="cDiv"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style &gt; .fDiv &#123; width: 300px; height: 300px; position: relative background-color: blue; &#125; .cDiv &#123; position: absolute; background-color: red; top: 50%; left: 50%; width: 50%; height: 50%; transform: translate3d(-50%, -50%, 0); // translate(-50%, -50%) &#125;&lt;/style&gt; transform 这个的 css 元素实际上是可以允许我们对于元素进行旋转, 移动, 缩放, 或者平移 常见的 transform 特性如下 其中 translate 规定的是元素在 x, y ,z 轴上的位移 translate (x, y, z) length / percentage 其中 x, y z 的单位可以是长度或者是百分比, 当以百分比进行比较的时候, 百分比相对的是元素本身的高度或者宽度 在上面的完全居中代码中 1234567position: absolute;background-color: red;top: 50%;left: 50%;width: 50%;height: 50%;transform: translate3d(-50%, -50%, 0); // translate(-50%, -50%) 在添加 transform之前, 方块是这样被放置的: 因为这里是定位, top 以及 left 被放置的时候的宽度以及高度的百分比是按照父元素的宽度和高度进行计算的 添加了transform 之后 因为这里使用 translate 定义的距离 x , y , z 的距离是根据元素本身的宽度和高度被定义的, 而同时使用 left: 50% 的时候元素被紧靠在父元素的中间垂线上, 使用 translate 的时候向左移动了元素的一半距离, 使得这个元素在水平距离上是居中设置的。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>transform</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象复制]]></title>
    <url>%2F2017%2F11%2F04%2F%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[复制对象对于变量进行复制的代码如下: 123456789101112131415function clone(obj) &#123; if (obj &amp;&amp; typeof obj === 'object') &#123; let cloneObj = Object.prototype.toString.call(obj).slice(8, -1) === 'Array' ? [] : &#123;&#125;; for (let prop in obj) &#123; if (obj[prop] &amp;&amp; typeof obj[prop] === 'object') &#123; cloneObj[prop] = clone(obj[prop]); &#125; else &#123; cloneObj[prop] = obj[prop]; &#125; &#125; return cloneObj; &#125; else &#123; return obj; &#125;&#125; 要点 使用 Object.prototype.toString.call() 来判断数据是属于对象的哪一种子类型 1234let a = [];typeof a; // objectObject.prototype.toString.call(a) // &quot;[object, Array]&quot;Object.prototype.toString.call(a).slice(8, -1) // &quot;Array&quot; 在 js 中 null 代表假值, 并且 typeof null 为 object 检测类型为不为 null 123456if (typeof obj === 'object' &amp;&amp; obj) &#123;&#125;// 对于如果检查到的类型为 null 的时候if (obj === null) &#123;// do something &#125; null 表示类型尚未定义，表示未定义的类型， undefined 表示值没有被声明 获取class使用原生的方法获取到 class 值的方法如下: 123456789101112function getClass(parent, sClass) &#123; let elements = parent.getElementsByTagName('*'); let eleResult = []; // 使用 '\\b' 进行匹配一个单词的边界 let classReg = new RegExp('\\b' + sClass + '\\b', i); for (let i = 0; i &lt; elements.length; i++) &#123; if (classReg.test(elements[i].className)) &#123; eleResult.push(elements[i]); &#125; &#125; return eleResult;&#125;]]></content>
      <categories>
        <category>代码集</category>
      </categories>
      <tags>
        <tag>对象复制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-promise]]></title>
    <url>%2F2017%2F10%2F30%2Fes6-promise%2F</url>
    <content type="text"><![CDATA[resove and reject使用 es6 回调函数的例子 1234567let promise = new Promise(function (resolve, reject) &#123; if (/* 如果异步操作成功 */) &#123; resolve(value); &#125; else &#123; reject(error) &#125;&#125;) 在上面的函数中，调用promise 构造函数创建了一个 promise 对象, 这个构造函数接收一个函数作为参数, 在函数中存在两个参数 resolve 和 reject , 这两个参数是两个函数, 用来执行回调的作用 resolveresove 是作为异步回调成功之后需要执行的函数rejectreject 是作为异步回调失败之后需要进行执行的函数 在 promise 的对象中, 可以通过进行判断来选择执行 resolve 或者 reject 函数 使用 promise 进行 ajax 请求的函数如下: 123456789101112131415161718192021222324252627282930313233/*** @description promise 的 ajax 请求* @param url &#123;String&#125; ajax 请求的地址* @param method &#123;String&#125; ajax 请求的方法 &apos;get&apos; or &apos;method&apos;* @return promise 新的 promise 请求对象**/let ajax = function (url, method) &#123; let promise = new Promise((resolve, reject) =&gt; &#123; let xhr = new XMLHttpRequest(); xhr.open(method, url); xhr.onreadystatechange = handler; xhr.responseType = &apos;json&apos;; xhr.setRequestHeader(&apos;Accept&apos;, &apos;application/json&apos;); xhr.send(); function handler() &#123; if (this.readystate !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statuText)); &#125; &#125;; &#125;); return promise;&#125;;ajax(url, &apos;get&apos;).then((json) =&gt; &#123; console.log(&apos;请求成功之后返回的数据&apos;, json);&#125;, (error) =&gt; &#123; console.error(&apos;出现的错误&apos; + error);&#125;); promise.then()在创建完成 promise 实例之后, 可以调用 promise.then() 中指定具体的回调成功或者失败的具体函数 promise.then() 用于接收两个回调函数作为参数, 第一个回调函数是当 Promise 对象状态变为 resolve 的时候执行的函数,表示上面的 resolve 函数, 第二个回调函数是当 Promise 对象状态变为reject 的时候执行的函数, 也就是表示上面的 reject 函数,这两个函数都可以接收 promise 传入的值作为函数参数 12345promise.then(function(value) &#123; // when promise success do something&#125;, function(error) &#123; // when promise failed do something&#125;) promise.all()使用 promise.all() 方法用于将多个 promise 实例, 包装为一个 promise 实例 Promise.all([promise1, promise2, promise3]) 使用 Promise.all 接收的是一个数组作为参数， 其中 promise1 promise2 promise3 分别是 Promise 的实例 关于使用 Promise.all 的状态: 只有 promise1 promise2 promise3 的状态都变成了 fullfilled 的状态, Promise.all 的状态才会变成 fullfilled 并且三个 promise 的返回值组成一个数组, 传递给 Promise.all 的回调函数。 当三个 promise 中存在一个为 reject 的时候, Promise.all 的状态就会变成 reject , 这个时候 , 被 reject 实例 的返回值被传递给Promise.all 的回调函数. 123const firstNamePromise = namePromise.then(getFirstName);const lastNamePromise = namePromise.then(getLastName);Promise.all([firstNamePromise, lastNamePromise]).then(([firstName, lastName]) =&gt; nextAction(firstName, lastName)); 注意: 上面使用到了对于对象的解构赋值操作, 在上面的函数中 firstNamePromise 的返回值被赋给 firstName, lastNamePromise 的返回值被赋给 lastName ++++ 对于对象的解构赋值而言,我们可以这样赋值 1234let a = 2;let b = 3;// 这样let [a, b] = [2, 3]; ++++ promise .race()使用 promise.race() 类似于 promise.all 方法, 将多个 promise 实例包装为一个 promise 方法 let p = promise.race([p1, p2, p3]) 只要上面的 p1, p2, p3 中有一个的实例率先发生变化, 那么 p 的状态就会发生变化, 率先发生变化的返回值就会传递给 p 函数。 其他方法promise.finally使用 promise.finally 的方法的作用在于: 不管 promise 的最后的状态是什么, 使用 promise.finally 内的回调函数始终会被执行; 例如: 请求之前的指示器打开或者关闭： 123456789this.indicator.show();let promise = new Promise();promise.then(// callback success fn).catch(e =&gt; &#123; this.toast(e.message)&#125;).finally(() =&gt; &#123; this.indicator.hide()&#125;)]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2017%2F10%2F12%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[补充关于空间复制度和时间复杂度的概念。 冒泡排序使用 冒泡排序最重要的思想是: 将一个数和数组中右边的数依次进行比较，如果找到了有左边的数大于右边的数，进行互换，最终一次循环之后，放在左边的数是右边中的最小值，这样依次进行排列，最后得到的左边的数组是已经被排好序之后的数组。 12345678910111213141516function bubbleSort (arr) &#123; let len = arr.length; for (let i = 0; i &lt; len; i++) &#123; // 保证一轮循环之后 arr[i] 是 i 之后数组的最小值 for (let j = i + 1; j &lt; len; j++) &#123; // 比较相邻两个的大小, 将较大的那个排到后面去 // 始终保证 if (arr[j] &lt; arr[i]) &#123; // 使用 es6 结构赋值进行交换 let t = arr[j]; arr[j] = arr[i]; arr[i] = t; &#125; &#125; &#125;&#125; 快速排序使用快速排序的基本原理是: 算法参考某一个值，遍历一个数组，将数组中小于参考值的元素放在左边的数组中，将数组中大于参考值的元素放在右边的数组中，递归左右数组，返回合并之后的数组。合并之后的数组是已经被排好序的数组。 123456789101112131415161718192021222324/** @description quickSort 用于进行快速排序* @return &#123;Array&#125; 经过排序之后的数组*/function quicksort(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; let first = arr[0]; let leftArr = []; let rightArr = []; let len = arr.length; for (let i = 0; i &lt; len; i++) &#123; if (arr[i] &lt; first) &#123; leftArr.push(arr[i]); &#125; if (arr[i] &gt; first) &#123; rightArr.push(arr[i]); &#125; &#125; // 一层一层剥开我的心 // 一直一直进行递归~~ return [].concat(quicksort(leftArr), [first], [quicksort(rightArr)]);&#125; 插入排序使用 插入排序的基本原理是: 想象一个数组分为两部分，对于整个数组进行遍历的时候，被遍历到的数组元素的左边是已经排好序的，实现的过程是，遍历数组元素左边的元素，和遍历到的元素进行对比，最终将这个新的元素插入到左边元素的合适的位置。 1234567891011121314151617181920/** @description insertSort 用于进行插入排序* @param &#123;Array&#125; arr 进行排序的数组* @return &#123;Array&#125; arr 返回进过排序之后的数组*/function insertSort(arr) &#123; for (let i = 0; i &lt; arr.length; i++) &#123; let temp = arr[i]; for (let j = i - 1; j &gt;= 0; j--) &#123; if (arr[j] &gt; temp) &#123; // 将大于 temp 的元素向后推一位 // 这些元素是之前已经被排好序的 arr[j + 1] = arr[j]; // 将元素插入到 arr[j] 的位置 arr[j] = temp; &#125; &#125; &#125; return arr;&#125;]]></content>
      <categories>
        <category>代码集</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6: Map & Set]]></title>
    <url>%2F2017%2F09%2F23%2Fes6-Map-and-Set%2F</url>
    <content type="text"><![CDATA[Set 数据结构基本属性Set 数据结构类似于数组， 不同于数组的是， Set 数据结构中不允许存在重复的值。 123let arr = [1,2,2,3,4];let set = new Set(arr);console.log(arr) // &#123;1,2,3,4&#125; 去除重复数字 在上面的程序中， 使用 new Set构造函数生成的 set 的类型是一个对象，并且通过使用 set 结构进行处理之后的数据中没有重复数据。 使用 set 进行数组去重的方法 12arr = [...new Set([arr])]// [1,2,3,4]//如上所示，完成了数组的去重操作 Set 实例的属性和方法, 如下图所示 let set = new Set([1,2,3,4]) set.prototype.constructor : 默认 set 函数 set.size 表示 set 数据结构中成员的个数 1set.size // 4 对于 set 结构的方法，分为操作方法和遍历方法 操作方法: add() 用于向 set 数据机构中添加成员 delete() 用于删除数据中的某个值，返回布尔值， 表示是否删除成功 has() 表示判断数据结构中是否含有某个值，返回的是布尔值，表示是否含有 clear() 表示清除所有的成员，没有返回值 1234567set// &#123;1,2,3,4&#125;set.add(5)// &#123;1,2,3,4,5&#125;set.has(5) // trueset.delete(5) // true 删除成功set.has(5) // falseset.clear()set // &#123;&#125; 一个数组去重操作: 1234function removeDeu (Array) &#123; return [...new Set(Array)] // 换成 Array.from(new Set(Array)) 也是可以的&#125;使用 Array.from 也可以将Set 结构转换为数组结构 Set 实例的遍历方法keys() 返回键名的数组 values() 遍历键值 entires() 遍历键值对儿 因为 Set() 结构只有键值，没有键名，因此使用 values() 和 keys() 的遍历结果是一样的 123456let arr = [1,2,3,4];let set = new Set(arr);for (let key of set.keys()) &#123; console.log(key)&#125;// 1,2,3,4,5 对于set 结构可以转换为 数组结构,可以应用数组的 map 等方法 1let arr = [...set]; Map 数据结构基本属性对于对象而言，对象是有键值对的数据结构组成的，但是对于对象的键，他的格式会被转换为字符串， 即便我们传入了一个数组或者对象 1234567let obj = &#123;&#125;;let o = &#123;a: 1&#125;;obj[o] = &apos;content&apos;;for (let key in obj) &#123; console.log(typeOf key)&#125;// string 使用 map 结构可以实现对象的键不再必须是字符串的形式 创建 map 结构: 1let map = new Map(); map 属性的方法通过 console 控制台打印数据如下 类似于 Set 结构, 存在 set get delete has clear 等几种操作方法 set(键， 值) 写入数据 get(键) 从数据结构中获得对应键的值 虽然 typeof map // Object 以及 map instanceof Object === true 但是， Map 是一种不同于对象的数据结构，在对象上使用 [ ] 访问属性的方法在 map 数据结构中是不适用的，要获得 Map 数据结构中的值， 我们是通过使用 get 方法，后面我们会说如何将 map 数据结构转换为对象 delete(键) 删除对应键的值 clear() 将 map 数据中的所有数据清除 has() 返回布尔值, 表示是否含有某条数据 使用 map 的数据结构不同于对象的是，通过使用 map 添加的键名可以是变量 1234567let map = new Map();let obj = &#123;a: 1&#125;;map.set(obj, &apos;good&apos;);map.get(obj) // &apos;good&apos;for (let key of map) &#123; console.log(typeof key) // object&#125; 可以是数组: 123let arr = [1];map.set(arr, &apos;good&apos;);map.get(arr)// &apos;good&apos; 需要注意的一点，通过使用 get() 获取键值的时候，最终是查找到了键值的内存地址 代码如下: 12map.set(&#123;a:1&#125;, &apos;good&apos;);map.get(&#123;a:1&#125;)// undefined 在上面的代码中，虽然查找的键值是一样的，但是两个 {a:1} 实际上的内存地址是不一样的。使用下面的代码可以找到对应的键值，因为变量 obj 指向了同一个对象的内存地址。 123let obj = &#123;a: 1&#125;;map.set(obj, &apos;good&apos;);map.get(obj) // &apos;good&apos; 关于对象及内存地址: 每创建一个对象，总会创建一个内存地址，对于下面对象: let person = { name: &#39;张宁宁&#39; } 我们使用 person.name 来访问到值的，但是，对象的值并没有存放在person 容器内，person 中存放了对象的属性， 这个属性相当于指针，指向存放 张宁宁 的内存地址 例如: {} === {} // false 因为这两个空对象的内存地址是不一样的，所以是不相等的 使用 map 结构可以传入数组，数组中的成员是存在两个元素的数组结构。其中第一个元素会被当作键名，第二个元素会被当作键值 12let map = new Map([[&apos;name&apos;, &apos;张宁宁&apos;]]);map.get(&apos;name&apos;) // &apos;张宁宁&apos; map 对象的遍历方法对于 map 结构的遍历，存在下面几种方法 keys() 返回键名的遍历器 values() 返回键值的遍历器 entires() 返回所有成员的遍历器 forEach() 类似于数组中的 forEach() 方法， 实现对于 map 数据结构的遍历 使用 keys() values() 以及 entires() 返回的是类数组对象 123456let map = new Map();map.set(&apos;h&apos;, &apos;hello&apos;);map.set(&apos;g&apos;, &apos;good&apos;);map.keys() // &#123;&apos;h&apos;, &apos;g&apos;&#125;;map.values() // &#123;&apos;hello&apos;, &apos;good&apos;&#125;;map.entires(); // &#123;&apos;h&apos;: &apos;hello&apos;, &apos;g&apos;: &apos;good&apos;&#125;; 使用扩展运算符可以将类数组对象转化为数组对象，从而对于类数组对象上应用各种方法。 1[...map.keys()] // [&apos;h&apos;, &apos;g&apos;] Map 与各种数据结构的相互转化 对象转为 map 1234567function toMap (obj) &#123; let map = new Map(); for (let key in obj) &#123; map.set(key, obj[key]); &#125; return map;&#125; map 转化为对象 1234567function toObj (map) &#123; let obj = Object.create(null); for (let [k,v] of map) &#123; obj[k] = v; &#125; return obj;&#125; ​]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>Map Set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6: 对象的扩展]]></title>
    <url>%2F2017%2F09%2F17%2Fes6-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[es6 中对象扩展的用法1.简洁属性名函数的属性可以是一个变量： 12345let foo = &apos;good&apos;;let bar = &#123; foo: foo&#125;;console.log(bar.foo); // &apos;good&apos; es6 中我们可以直接传入一个变量到对象中 123456let foo = &apos;good&apos;;let bar = &#123; foo&#125;;console.log(bar.foo); // &apos;good&apos; //传入的变量名会被作为对象的属性名，变量的值会被作为对象属性的值 用在函数中返回一个对象 12345function Person(name) &#123; let age = 22; return &#123;name, age&#125;;&#125;person(&apos;张宁宁&apos;)// &#123;name: &apos;张宁宁&apos;, age: 22&#125; 2. Object.is( ) 判断相等对于比较两个值是否相等，使用 全等 === 运算符进行判断, 因为使用 == 会自动转换数据类型 使用 === 有缺点： NAN === NAN flase 以及 +0 === -0 false 使用 object.is 可以解决这个缺点 1234object.is(1,1) // trueobject.is(1,&apos;1&apos;) // falseobject.is(NaN, NaN) // trueObject.is(+0, -0) // true 使用== 或者 === 进行相等比较的时候，实际上，是无法进行比较对象的，因为对象是一个指针，指向存储对象数据的内存地址 1object.is(&#123;&#125; , &#123;&#125;); // false 3. Object.assign () 合并对象12345let t = &#123;&#125;;let s1 = &#123; a: 1 &#125;;let s2 = &#123; b: 2 &#125;;Object.assign(t, s1, s2);// &#123;a: 1, b: 2&#125; 上面中将对象 s1, s2, 合并入 t 中； 传入值的情况: 如果只有一个参数，使用这种方法会返回这个参数 如果传入的一个参数是 Null 或者 undefined 机会报错 要进行合并的参数是字符串的情况下，会返回该字符串的对象,传入非对象，非字符串的其他值，无效 12Object.assign(&#123;&#125;, &apos;string&apos;);// &#123;0: &quot;s&quot;, 1: &quot;t&quot;, 2: &quot;r&quot;, 3: &quot;i&quot;, 4: &quot;n&quot;, 5: &quot;g&quot;&#125; 使用 Object.assign () 返回的是对象的形式 使用 Object.assign() 实现浅拷贝 4. Object.keys() Object.values() Object.entires() Object.keys() 使用这种方法得到的是对象中所有可遍历的属性名组成的数组 Object.values() 使用这种方法得到的是对象自身所有可以遍历到的属性的值 Object.entires() 使用这种方法得到的数组，数组中包括对象自身所有可遍历得到的属性的键值对儿数组 应用 判断对象内是否是空对象的方法： 1const isEmpty = obj =&gt; return Object.keys(obj) === 0; 使用 Object.assign 实现自定义配置覆盖默认配置 123function toConfig(defaultConfig, config) &#123; return Object.assign(defaultConfig, config);&#125; ​]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>对象扩展</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS块状格式化上下文(BFC)]]></title>
    <url>%2F2017%2F09%2F17%2FBFC%2F</url>
    <content type="text"><![CDATA[BFC 的概念bfc 被称作: 块状格式化上下文，通过创建 bfc 可以创建出一块独立的渲染区域，在这个区域内，bfc 仅仅对于 blcok-level 块状水平的 box 起作用，bfc 上下文规定了内部的块状水平 box 如何起作用，并且创建了块状格式化上下文的容器，内部元素的布局方式不会影响到外部的区域，因此，我们可以使用 bfc 的概念实现对于浮动的清除。 BFC 的创建创建块状格式化上下文的方式有以下几种: float 的值不为 none position 的值不为 static 或者 relative display 的值为 table-cell table-caption inline-block flex inline-flex 中的其中一个 overflow 的值不为 visible (通过设置 overflow: hidden) 我的理解： 对于创建了块状格式化上下文的元素，在元素内部相当于定义了一个单独的区域，在这个区域内，内部子元素的布局不会影响到外部的元素 BFC 的布局规则 In a block formatting context: boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the ‘margin’ properties. Vertical margins between adjacent block boxes in a block formatting context collapse. each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats). 在BFC 中: 垂直方向上，内部的 box 元素从包含块的顶部开始一个接一个的布局，两个相邻块之间的垂直距离是有 margin 特性决定的，在相邻的块状元素的垂直 margin 上会出现外边距折叠的问题 每一个块状元素的左边缘会紧紧跟在包含块的左边缘，甚至当有浮动元素存在的情况下也是一样的道理，除非这个块状元素创建了一个新的 BFC BFC 的应用1. 使用 BFC 用来解决外边距折叠问题 外边距折叠是特定的相邻的外边距会形成一个单独的外边距，collpase margin 发生在下面的这些情况: 元素为空元素 padding 或者 border 为 0 no clearance to seperate them ? 什么意思 更多详细的的内容 : https://www.w3.org/TR/css3-box/#compact-boxes 对于外边距坍塌，最终形成的外边距遵循的是 M-N 原则: 如果两个元素的外边距是正值, 最后得到的坍塌之后的外边距是两个边距的最大值 M 如果两个元素的外边距是负值，最后得到的坍塌之后的外边距是两个边距中的最小值 N 如果外边距是 none , 得到的坍塌之后的外边距是 0 存在边距坍塌的几种情况 相邻的块状元素之间出现外边距坍塌 父元素和内部的子元素出现的外边距坍塌 使用块状格式化上下文解决外边距层叠: css 代码如下 : 1234567891011121314151617&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;b1&quot;&gt; &lt;/div&gt; &lt;div class=&quot;b2&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt;.container &#123; background: blue;&#125;.b1, .b2 &#123; width: 100px; height: 50px; margin: 10px; background: red;&#125;&lt;/style&gt; 如上图所示, 父元素container 内部的子元素和父元素的边界坍塌，导致子元素与父元素的边界贴合，并且在子元素之间。两个 div margin 都设为 10, 最后出现折叠之后的 margin 也变成了 10 ，出现了元素折叠的现象 如何解决： 使用 overflow: hidden 创建 bfc 当我们给父元素创建 bfc 之后, 123.container &#123; overflow: hidden&#125; 可以看到: 这时候因为父元素创建了 bfc ，因此子元素的 margin 不会出现坍塌现象，因为创建了 bf c 的元素不会和任何其它的元素出现边距折叠现象 但是, 我们看到，元素内部的两个字元素还是出现了边距坍塌现象，按照上边的思想，我们可以给单独的一个子元素创建bfc 1234567891011121314&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;b1&quot;&gt; &lt;/div&gt; &lt;div class=&quot;b3&quot;&gt; &lt;div class=&quot;b2&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt;.b3 &#123; overflow: hidden&#125;&lt;/style&gt; 上面的代码中, 我们给子元素 b2 上创建了一个父元素，给这个父元素创建bfc 最终结果如下: 最终我们可以看到，因为对于 b3 创建了 bfc ， 因此， 对于 bfc 内部的元素的布局是不会影响到外部的子元素的 2.使用 BFC 进行浮动的清除使用 BFC 进行浮动清除的原理还是一样的，利用位于块状上下文中的元素是不会影响到外部元素的特性，防止子元素设置浮动之后，父元素高度为 0 的情况 123456789101112131415161718192021&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;b1&quot;&gt; 我是浮动元素 &lt;/div&gt; &lt;div class=&quot;b2&quot;&gt; 我是浮动的元素 &lt;/div&gt;&lt;/div&gt;&lt;style&gt;.container &#123; background: blue; overflow: hidden;&#125;.b1, .b2 &#123; float: left; width: 100px; height: 50px; margin: 10px; background: red;&#125;&lt;/style&gt; 结果如下所示: 如上图所示，使用了 bfc 清除了由于使用 float:left 造成的浮动现象 浮动元素的父元素高度依然存在 3. 使用 BFC 实现两栏自适应布局在存在浮动的情况下,前面我们说过，包含块内部的子元素的左边缘会紧紧贴在其父元素的左边缘，即使存在浮动元素的情况下也是一样的，例如： 12345678910111213141516171819202122&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;aside&quot;&gt;&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;style type=&quot;text/css&quot;&gt; .container &#123; width: 300px; &#125; .aside &#123; width: 20%; float: left; height: 100px; background-color: red; &#125; .main &#123; width: 80%; height: 200px; background-color: blue; &#125;&lt;/style&gt; 图片如下: 即使 aside 浮动，main 还是会贴在左边缘，如果我们想要实现两栏的自适应布局，如何实现？ 根据上面的布局规则， 我们可以给 main 创建一个块状格式化上下文，这样，main 的布局就不会受到 aside 元素的影响 123456.main &#123; width: 80%; height: 200px; background-color: blue; overflow: hidden;&#125; 最终，我们得到了自适应布局: 从而得到了一个两栏布局]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>bfc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 组件之间的传值]]></title>
    <url>%2F2017%2F09%2F10%2FVue-%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[在 vue 中，进行组件通信有下面几种形式: 父子组件通信在 vue 中, 实现父子组件通信的方法主要是 : props down, emit up 使用 props 实现父组件向子组件传递信息, 在父组件上的子组件模板上绑定需要进行传递的数据 1234567891011121314151617父组件中：&lt;child :propsData = &apos;localData&apos;&gt;&lt;/child&gt;子组件中：&lt;template&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &apos;child&apos;, // 子组件中通过使用 props 声明需要进行接受的数据 props: [&apos;propsData&apos;], data () &#123; return &#123; localData: &apos;&apos; &#125; &#125; &#125;&lt;/script&gt; 对于实现子组件向父组件的传值操作，使用 emit() 操作实现: 兄弟组件通信Vuex使用 vuex 实现多个组件之间状态的共享 上图是使用 vuex 的工作流程，下面是我对于 vuex 的一些个人理解 vuex 主要是有三个部分组成: actions : 用来执行提交 mutations 操作 mutations : 用来对于 state 中存储的数据进行改变操作 state : 用来存储一些数据， 这些数据对于各个组件之间是可以共享的 总的来说： 要执行一次进行改变 state 中状态的数据，要进行以下操作 state 中保存了要进行改变的数据状态 mutations 中定义了要进行改变数据状态的操作，这是函数 我们通过 actions 中的函数对于在mutations 中定义的函数进行提交, 相当于执行函数，从而实现对于state 中保存数据的改变]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>组件通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6:变量的解构赋值]]></title>
    <url>%2F2017%2F09%2F09%2Fes6-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[es6的数值解构赋值1.es6 允许使用一定的方式从数组或者对象中提取数值，从而对于同样模式的变量进行赋值操作，代码如下:12345678let [a,b,c] = [1,2,3]a // 1b // 2c // 3类似:let a = 1let b = 2let c = 3 使用数组形式进行解构赋值的时候要注意到，两边其实并不是数组，而只是数组的形式 对于等号两边必须是数组的形式，如果是其他的形式，那么就会报错: 12345let [a] = &#123;&#125;;let [a] = null;let [a] = undefined;let [a] = NaN;let [a] = 1; 上面的几种形式都会被报错 2.使用结构变量可以初始数组12let [a,...b] = [1,2,3,4];b // [2,3,4] 使用扩展运算符可以将多个数合并为一个数组 3.可以在解构赋值的时候使用默认值操作123456789101112let [x = 1] = [];x // x 在没有被赋值的时候默认使用 1let [x = 1] = [2];x // 2当 x 存在明显只的时候默认值失效// 对于使用默认值, 还可以使用函数的返回值function fn() &#123; return 23&#125;let [a = fn()] = [45];// 这里 因为 a 能够取到值, 因此不会执行 fn 函数console.log(a); // 45 默认值可以引用其他结构值的对象 123let [x = 1, y = x] = [];x // 1y // 1 注意: 对于赋值操作两端的值, 在赋值操作两端执行的是 === 全等操作， 因此 1234let [a = 1] = [null]a // nulllet [a = 1] = [undefined]a // 1 es6 中对于对象的解构赋值操作代码如下: 1234567let person = &#123; name: &apos;张宁宁&apos;, home: &apos;山东&apos;&#125;;let &#123;name, home&#125; = person;name // &apos;张宁宁&apos;home // &apos;山东&apos; 这种写法无非是下面这种写法的简写:` 1let &#123;name: name, home: home&#125; = person; 实际上: 12let &#123;name: perName, home: perHome&#125; = person;perName // &apos;张宁宁&apos; 等号左边中 name 用于进行模式匹配，在 person 中找到 name 之后，将 name 的值赋给 perName 使用对象的形式解构也可以赋予默认值： 当在等号右边的对象中找不到对应的属性的时候, 会使用括号内被默认赋予的值 123let &#123;x = 1, y = 5&#125; = &#123;x: 2&#125;x // 2y // 5 es6 中对于字符串的解构赋值当对于字符串进行解构赋值操作的时候，字符串会被转换为类似数组的对象: 这意味着我们可以通过使用数组或者对象的方式进行解构： 1234let [a,b,c,d,e] = &apos;hello&apos;;a // &apos;h&apos;b // &apos;e&apos;.... 123let &#123;length&#125; = &apos;hello&apos;;length // 5因为使用解构的时候， 字符串对象含有一个 length 属性 函数参数的解构1.数组形式进行解构 12345function move([x,y]) &#123; return x + y&#125;move([1,2]);// 这里虽然传入的是一个数组，实际上传入函数之后会被解构 2.对象形式进行解构 12345678function person(&#123;name, home&#125;) &#123; console.log(home, name)&#125;let per = &#123; name: &apos;张宁宁&apos;, home: &apos;china&apos;&#125;person(per)// china 张宁宁 3.使用对象形式赋予默认值 12345function person (&#123;name = &apos;张宁宁&apos;, home = &apos;china&apos;&#125; = &#123;&#125;) &#123; console.log(name, home)&#125;person(); // 张宁宁 china和上面结果相同， 因为传入的是一个空对象，没有找到相应的属性，因此采用默认赋予的值进行操作 使用参数解构中的小技巧 提取函数的返回值: 123456function bar () &#123; return [1, 2]&#125;let [a, b] = bar ();a // 1b // 2 应用解构分离对象的键值对 12345678910111213let arrObj = [&#123;&#125;, &#123;&#125;, &#123;&#125;];// 取得数组对象中值对应的键function getKey( arrobj, objValue) &#123; for (const obj of arrobj) &#123; // 使用 &#123;&#125; 实现对象的解构赋值 let &#123;key, value&#125; = obj; if (value === objValue) &#123; return key; &#125; &#125;&#125;getKey(arrObj, &apos;someObjValue&apos;) ​]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>变量解构赋值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js学习（一）]]></title>
    <url>%2F2017%2F09%2F09%2FVue%E5%93%8D%E5%BA%94%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Vue的响应原理 上面这张图表示的就是 vue 的响应原理: 当我们将数据添加入 vue 实例中的 data 选项中的时候, vue 将遍历data 中数据的所有属性，并且调用 Object.defineProperty 方法将属性记录为依赖。当数据发生改变的时候,就会调用 object.defineProperty 中的 setter 方法, 在组件实例中存在一个 watcher 对象，这个对象的目的是：当被记录的依赖被调用的时候,也就是属性的 setter 被调用的时候，会通知watcher 对象进行重新渲染组件 Object.defineProperty12345678Object.defineProperty(Object, property, &#123; get () &#123; // 读取对象Object 的属性 property 的时候调用的函数 &#125;, set (newVal) &#123; // 设置对象 Object 的属性 property 的时候调用的函数 &#125;&#125;) 通过使用这种方法，调用 getter 和 setter 可以实现追踪对象属性的变化 vue.js 中的 生命周期在 vue.js 中]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue 响应原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSONP跨域 ajax请求]]></title>
    <url>%2F2017%2F09%2F03%2FJSONP%E8%B7%A8%E5%9F%9F-ajax%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[使用 JSONP 进行的跨域，链接的是聚合数据的手机号查询归属地 API，一开始的时候出现了问题，使用原生的 ajax 请求怎么样也是查询不到数据，后来了解到，使用 ajax 不能进行跨域请求。下面是通过使用 jsonp 实现的跨域请求 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;div id=&quot;div&quot;&gt;&lt;/div&gt;&lt;body&gt;&lt;div&gt; 号码归属地查询&lt;input id=&apos;phone&apos; type=&apos;text&apos; &gt;&lt;button id = &apos;btn&apos;&gt;查询手机号归属地&lt;/button&gt; &lt;p&gt;您的手机号码归属地是 &lt;span id=&apos;city&apos;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function doFunction (data) &#123; if (!data.result) &#123; return; &#125; document.getElementById(&apos;city&apos;).innerHTML = data.result.city; &#125; window.onload = function () &#123; var sendObj = &#123; url: &apos;http://apis.juhe.cn/mobile/get&apos;, phone: &apos;13429667914&apos;, key: &apos;4ebdd2325a4ce36fa7ca55e910c185e9&apos;, callback: &apos;doFunction&apos; &#125;; function sendLink (obj) &#123; var link = obj.url; for (var key in obj) &#123; if (key !== &apos;url&apos;) &#123; link = link + (~link.indexOf(&apos;?&apos;) ? &apos;&amp;&apos; : &apos;?&apos; ); link = link + key + &apos;=&apos; + obj[key]; &#125; &#125; return link; &#125; document.getElementById(&apos;btn&apos;).addEventListener(&apos;click&apos;, function () &#123; var body = document.getElementsByTagName(&apos;body&apos;)[0]; var script = document.createElement(&apos;script&apos;); sendObj.phone = document.getElementById(&apos;phone&apos;).value; script.setAttribute(&apos;src&apos;, sendLink(sendObj)); if (body.getElementsByTagName(&apos;script&apos;).length === 2) &#123; body.replaceChild( script ,body.lastChild); &#125; else &#123; document.getElementsByTagName(&apos;body&apos;)[0].appendChild(script); &#125; &#125;); &#125;&lt;/script&gt;&lt;!-- &lt;script src=&quot;http://apis.juhe.cn/mobile/get?phone=13429667914&amp;key=4ebdd2325a4ce36fa7ca55e910c185e9&amp;callback=doFunction&quot;&gt;&lt;/script&gt;--&gt;&lt;/body&gt;&lt;/html&gt; ajax 请求原生的 ajax 请求如下: 1234567891011121314var request;if (window.XMLHttpRequest) &#123; request = new XMLHttpRequest(); &#125; else &#123;// for IE request = new ActiveObject();&#125;request.onreadystatechange = function () &#123; if (request.readyState == 4 &amp;&amp; request.status == 200) &#123; console.log(request.responseText); &#125;&#125;;request.open(&apos;get&apos;, url, false / true);request.send(); 使用 ajax 的目的在于在没有重新加载页面的时候进行页面部分数据的更新； open 方法 使用 open 方法接收三个参数: 要发送的请求类型: ‘get ‘ 或者 ‘post’ 请求的url : 注意 只能向同一个域中使用相同端口和协议 URL 发出请求，如果请求的端口和本地页面不在同一个域的范围内，那么要使用跨域进行； 什么是跨域？ 只要是协议，端口，域名当中存在一个不同的值，那么请求就会被认为是跨域: 一个 URL 地址如下: https://www.baidu.com:8080 https 协议， 用来定义浏览器打开文件的形式 www.baidu.com 域名, 其中 baidu.com 主域 www.baidu.com 子域 :8080 端口 当两个 URL 的协议, 域名 ,端口中存在一个不同的时候，使用 ajax 是无法进行请求得出数据的 但是这种情况: https:// www.a.com/javascript/a.js https:// www.a.com/b.js 这种情况下, 域名，协议，端口都是相同的, 因此可以进行访问到 https://segmentfault.com/a/1190000000718840 http://blog.csdn.net/seebetpro/article/details/51326260 布尔值：表示是否进行异步 在上面的代码中，请求成功之后，响应的数据会自动填充 request 对象的属性，表示请求成功之后的状态: 12345request.onreadystatechange = function () &#123; if (request.readyState == 4 &amp;&amp; request.status == 200) &#123; // 表示请求成功之后，并且有返回数据之后要进行的动作 &#125;&#125; status : 表示响应的 http 状态,对于 http 的状态码， 要记住几个重要的：http状态码 2XX : 表示请求成功 200 请求成功， 201 已创建 202 接收 204 无内容 3XX: 表示重定向 300 多路选择 301 永久转移 302 暂时转移 304 未修改 4XX: 客户方错误 400 错误请求 401 未认证 408 请求超时 410 失败 5XX: 服务器错误 500 服务器内部错误 501 未实现 504 网关超时 关于这些请求的具体情况： 2XX: 表示已经接受到了请求 状态码 含义 200 表示请求已经成功 201 表示请求已经被创建 202 服务器已经接收到了请求， 但是尚未处理 204 服务器已经处理了请求， 但是没有返回任何 3XX:资源重定向 状态码 含义 301 表示永久性重定向， 请求的资源分配到新的 url 302 表示临时性重定向，表示请求的资源已经分配到新的url, 希望用户本次能够使用新的url 访问 304 表示请求的资源已经找到， 但是不符合条件要求 4XX:客户端请求错误 状态码 说明 400 表示客户端发给服务器的请求存在语法错误， 服务器无法理解这个请求。 401 表示发送的请求需要通过使用 HTTP 认证 403 表示客户端想要请求的资源被服务器拒绝访问 404 表示在服务器上没有找到请求的资源 5XX: 服务器错误 状态码 说明 500（服务器错误） 表示服务器在执行请求的时候发生了错误 503（服务器正忙） 表示现在服务器正在处于超负载状态，无法处理 readyState 表示 request 对象的 readyState 对象，属性可取的值如下： 0 : 未初始化，尚未调用 open() 方法 1 : 启动， 已经调用 open 方法，尚未调用 send() 方法 2 : 发送，已经调用 send() 方法，但是尚未接收到响应 3: 接收，表示已经接受到部分数据 4: 完成, 已经接收到全部的响应数据 使用 get 和 post 请求的区别 1. 两种方式传递参数的方式不同Get 请求用于向服务器发送请求查询信息，查询字符串参数添加到 url 的末尾 post 请求是将作为 HTTP 消息的实体内容发送给服务器 2. 两者缓存不同使用 get 方法的数据会被浏览器进行缓存起来，因此其他人可以通过使用浏览器的历史记录进行读取到这些数据 3.服务器端 针对这两种方式的获取参数是不同的在客户端通过使用 get 请求的时候，服务器端通过使用 Request.QueryString 来进行获取参数, 在客户端通过使用 post 进行请求的时候，服务器端通过使用 Request.Form 来进行获取到参数 为什么要使用两种方式: 当请求没有副作用的时候， 例如进行搜索数据， 可以使用 get 方法， 当请求存在副作用的时候，使用 post进行请求 使用 post 的情况: 请求的结果存在副作用，例如，向数据库内添加新的数据行 使用 GET 方法, 使用表单上添加的数据使得 URL太长 进行传送的数据不是7 位的 ASCII 编码 使用 get 的情况 请求是为了查找资源, HTML 上的表单数据仅仅用来进行搜索 请求结果无持续性的副作用 收集到的数据及HTML 表单内的输入字段名称的总长不超过 1024 字符 如何使用 ajax 实现跨域？对于使用原生的 ajax 而言,是无法实现进行跨域请求的,如何使用 ajax 实现跨域呢？ 1.使用跨源资源共享(CORS)跨源资源共享定义了当进行访问跨源资源的时候，浏览器和服务器之间应该如何进行通信, 基本的思想是: 浏览器向服务器发送请求的时候，添加一个额外的 origin 头部，这个头部包含了请求页面的源信息(协议， 域名， 端口) 如果服务器认为请求可以接受，可以在 Access-Control-Allow-Origin 中回发相同的源信息,如果在服务器端设置 为 * 表示公共资源 如上图所示，实现了公共资源的共享 2.使用 JSONP使用 jsonp 技术实现的，原理是将请求的参数放入到 js 中，通过使用动态 js 来实现资源的动态请求 缺点: 无法处理请求失败之后的动作,并且使用 jsonp 请求到的数据只能使用 get 请求进行]]></content>
      <categories>
        <category>代码集</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS居中效果]]></title>
    <url>%2F2017%2F09%2F02%2FCSS%E5%B1%85%E4%B8%AD%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[使用 CSS 并没有这么的简单，如果CSS 熟练了，开发网页就会快得多，自己实际上能够使用到的 CSS 样式不多，但是,太多的东西自己没有掌握， CSS 也有许多的技术点，只能不断的跳出自己的舒适区，不断的进行探索。 居中方法水平居中行内元素的水平居中使用 text-align 的方法实现行内元素的水平居中 text-align: center : 实现块状元素内部 行元素的水平居中 12345678&lt;div id = &apos;content&apos;&gt; &lt;span&gt;我是一段文字&lt;/span&gt;&lt;/div&gt;&lt;style&gt; #content &#123; text-align: center; &#125;&lt;/style&gt; 块状元素的水平居中方法1.使用 margin 进行定位 12345678910111213141516&lt;div id=&apos;content&apos;&gt; &lt;div id = &apos;block&apos;&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; #content &#123; width: 200px; height: 200px; background-color: blue; &#125; #block &#123; width: 50px; height: 50px; margin: auto; &#125;&lt;/style&gt; 注意， 对于块状元素使用 margin: auto 只能实现块状元素在父级块状元素内的水平居中 如果在正常流中一个块元素的 margin-top margin-bottom 设为 auto 的时候，这个元素的 margin 会自动计算为 0 ​ 效果如下: 在上面的图片中，尽管设置了 margin-top : 20px 但是由于 margin: auto 的存在，将块元素的 margin-top 重新计算为 0 2.借用定位元素 position: absolute 借用定位元素实现的居中，可以实现水平，垂直居中的效果 垂直居中： 1234567父元素：position: relative;子元素：position: absolute;top: 0;bottom: 0;margin: auto; 水平居中： 1234567父元素：position: relative;子元素：position: absolute;left: 0;right: 0;margin: auto; 垂直居中： 1234567父元素：position: relative;子元素：position: absolute;top: 0;bottom: 0;margin: auot; 完全居中: 123456789父元素：position: relative;子元素：position: absolute;top: 0;bottom: 0;left: 0;right: 0;margin: auto 3.借用 display: inline-block 来实现 display: inline-block 这个属性很有意思: 使用了 display: inline-block 的元素，这个元素会表现出行内块的特征，这个元素即可以像块状元素一样具有 width 和 height, 也可以是向行内元素一样，呈行内排列 因此，我们的思路是： 对于要进行水平居中的块状元素应用 display:inline-block , 使它表现出类似行状元素的特性，对于该元素的父元素，应用 text-align: center 垂直居中行内元素的垂直居中1.对于单行元素，使用 line-height: height 实现 2.对于多行元素的垂直居中方法，使用 display: table-cell 1234567891011&lt;div class = &apos;content&apos;&gt; &lt;p&gt;我是一段文字&lt;/p&gt; &lt;p&gt;我是另一段文字&lt;/p&gt;&lt;/div&gt;CSS:.content &#123; display: table-cell; vertical-align: middle&#125; 块状元素的垂直居中1.使用 position: absolute 来实现 2.子元素声明 display: table-cell display: inline-block vertical-align: middle 来实现 完全居中 position: absolute 来实现 使用 display: table-cell, 这时候 子元素必须要声明 display: inline-block 123456789101112131415161718&lt;div id=&apos;good&apos;&gt; &lt;div class=&apos;child&apos;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; #good&#123; display:table-cell; vertical-align: middle; text-align: center; width: 200px; height: 200px; background-color: blue; &#125; .child &#123; display: inline-block; width: 50px; height: 50px; background-color: red; &#125; 2.使用 display: flex 实现居中的效果 1234&lt;div class="parent"&gt; &lt;div class="children"&gt; &lt;/div&gt;&lt;/div&gt; 12345.parent &#123; display: flex; align-items: center; justify-content: center;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS 居中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日历]]></title>
    <url>%2F2017%2F08%2F31%2F%E6%97%A5%E5%8E%86%2F</url>
    <content type="text"><![CDATA[使用面向对象的 js 代码写法，写了一个日历，代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; 单个时间&lt;input type=&quot;text&quot; id=&quot;startTime&quot;&gt; 时间段&lt;input type=&quot;text&quot; id=&quot;longTime&quot;&gt;&lt;/div&gt;&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;&lt;script&gt; (function (window)&#123; function $(tag, parent) &#123; var children = []; if (tag.indexOf(&apos;#&apos;) !== -1) &#123; children = document.getElementById(tag.slice(1)); &#125; else if (tag.indexOf(&apos;.&apos;) !== -1) &#123; children = parent ? parent.getElementsByClassName(tag.slice(1)) : document.getElementsByClassName(tag.slice(1)); &#125; else &#123; children = parent ? parent.getElementsByTagName(tag) : document.getElementsByTagName(tag); &#125; return children; &#125; function listenEvent(dom,event,fn) &#123; if (dom.attachEvent) &#123; dom.attachEvent(&apos;on&apos; + event, fn); &#125; else &#123; dom.addEventListener(event, fn); &#125; &#125; function dateUI (isSingle ,inputIdName, callBack) &#123; this.isSingle = isSingle; this.inputIdName = inputIdName; this.callBack = callBack; var date = new Date(); this.data = &#123; weekDay: [&apos;日&apos;, &apos;一&apos;, &apos;二&apos;, &apos;三&apos;, &apos;四&apos;, &apos;五&apos;, &apos;六&apos;], minDate: &apos;&apos;, maxData: &apos;&apos;, year: 2017, month: 8, selectDays: [] &#125; this.data.year = 2017; this.data.month = 8; &#125; dateUI.prototype = &#123; $ : function (tag, parent) &#123; var children = []; if (tag.indexOf(&apos;#&apos;) !== -1) &#123; children = document.getElementById(tag.slice(1)); &#125; else if (tag.indexOf(&apos;.&apos;) !== -1) &#123; children = parent ? parent.getElementsByClassName(tag.slice(1)) : document.getElementsByClassName(tag.slice(1)); &#125; else &#123; children = parent ? parent.getElementsByTagName(tag) : document.getElementsByTagName(tag); &#125; return children; &#125;, listenEvent: function (dom, event, fn) &#123; if (dom.attachEvent) &#123; dom.attachEvent(&apos;on&apos; + event, fn); &#125; else &#123; dom.addEventListener(event, fn); &#125; &#125;, initTable: function () &#123; var that = this; var title = document.createElement(&apos;div&apos;); title.setAttribute(&apos;id&apos;, &apos;title&apos;); title.innerHTML = &apos;&lt;span id=&quot;pre&quot;&gt;back&lt;/span&gt;&lt;input type=&quot;number&quot; id=&quot;month&quot;&gt;&lt;input type=&quot;number&quot; id=&quot;year&quot;&gt;&lt;span id=&quot;back&quot;&gt;pre&lt;/span&gt;&apos; var main = document.createElement(&apos;div&apos;); main.setAttribute(&apos;id&apos;, &apos;main&apos;); var table = document.createElement(&apos;table&apos;); table.innerHTML = &apos;&lt;thead&gt;&lt;tr&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;/tbody&gt;&apos;; main.appendChild(table); that.$(&apos;#content&apos;).appendChild(title); that.$(&apos;#content&apos;).appendChild(main); for (let i = 0; i &lt; that.data.weekDay.length; i++) &#123; that.$(&apos;tr&apos;, that.$(&apos;thead&apos;)[0])[0].innerHTML += &apos;&lt;th&gt;&apos; + that.data.weekDay[i] + &apos;&lt;/th&gt;&apos;; &#125; var _ROW = 6; var _COL = 7; for (var i = 0; i &lt; _ROW; i++) &#123; that.$(&apos;tbody&apos;)[0].innerHTML += &apos;&lt;tr&gt;&lt;/tr&gt;&apos;; for (var j = 0; j &lt; _COL; j++) &#123; that.$(&apos;tr&apos;, that.$(&apos;tbody&apos;)[0])[i].innerHTML += &apos;&lt;td&gt;&lt;/td&gt;&apos;; &#125; &#125; that.tds = document.getElementsByTagName(&apos;td&apos;); that.tds = [].slice.call(that.tds); &#125;, reactData: function () &#123; var that = this; var props = [&apos;year&apos;, &apos;month&apos;]; props.map(function (item) &#123; var dom = null; item === &apos;year&apos; ? dom = that.$(&apos;#year&apos;) : dom = that.$(&apos;#month&apos;); Object.defineProperty(that.data, item, &#123; get: function () &#123; return dom.value; // 绑定dom, 自动获取到value值 &#125;, set: function (newVal) &#123; if (item === &apos;month&apos;) &#123; if (newVal &gt; 12) &#123; newVal = 1; that.data.year++; &#125; else if (newVal &lt;= 0) &#123; newVal = 12; that.data.year--; &#125; &#125; dom.value = newVal; &#125; &#125;) &#125;); &#125;, dateAct: function () &#123; var that = this; var inputAdd = [&apos;#month&apos;, &apos;#year&apos;]; that.listenEvent(that.$(&apos;#back&apos;) ,&apos;click&apos;, function () &#123; that.data.month++; that.initDate(); &#125;); that.listenEvent(that.$(&apos;#pre&apos;) ,&apos;click&apos;, function () &#123; that.data.month--; that.initDate(); &#125;); inputAdd.map(function (item) &#123; that.listenEvent($(item) ,&apos;change&apos;, function () &#123; if (item === &apos;#month&apos;) &#123; that.data.month = $(item).value; &#125; else &#123; that.data.year = $(item).value; &#125; that.initDate(); &#125;) &#125;); &#125;, initDate: function () &#123; var that = this; var date = new Date(that.data.year, that.$(&apos;#month&apos;).value - 1, 1); var startDate = date.getDay(); var allDates = new Date(that.data.year, that.$(&apos;#month&apos;).value, 0).getDate(); var tds = document.getElementsByTagName(&apos;td&apos;); that.initColor(); var j = 0; startDate = (startDate ? startDate : 7); // startDate 表示这一个月份的一号是星期几，当是星期天的时候，要从下一行开始 for (let i = 0 ; i &lt; 42; i++) &#123; if (i &gt;= startDate) &#123; j &gt;= allDates ? j = 1 : j++; tds[i].innerHTML = j; if(i &lt; allDates + startDate ) &#123; tds[i].onclick = function () &#123; // 这里有bug that.initColor(that.data.year, that.data.month, i); that.initColor(); that.$(&apos;#&apos; + that.inputIdName).value = &apos;&apos;; that.data.selectDays.map(function (item, index, array) &#123; that.$(&apos;#&apos; + that.inputIdName).value = item.year + &apos;-&apos; + item.month + &apos;-&apos; + that.tds[item.day].innerHTML; if (!that.isSingle) &#123; var min; that.data.selectDays.map(function (item, index, array) &#123; if (item.day &lt; that.data.selectDays[0].day) &#123; min = item; &#125; else &#123; min = that.data.selectDays[0]; &#125; &#125; ); &#125; &#125;); that.callBack(); &#125;; &#125; else &#123; tds[i].onclick = null; tds[i].className = &apos;notClick&apos;; &#125; &#125; else &#123; tds[i].className = &apos;notClick&apos;; document.getElementsByTagName(&apos;td&apos;)[i].onclick = null; // 回收 click 事件 tds[i].innerHTML = new Date(that.data.year, that.$(&apos;#month&apos;).value - 1, 0).getDate() + 1 -startDate + i ; &#125; &#125; &#125;, initColor: function (year, month, day) &#123; var that = this; var _minDate; var _maxDate; if (year) &#123; var obj = &#123;&#125;; obj.year = year; obj.month = month; obj.day = day; if (that.isSingle) &#123; that.data.selectDays[0] = obj; &#125; else &#123; that.data.selectDays.push(obj); if (that.data.selectDays.length &gt;= 2) &#123; that.data.selectDays[1] = obj; that.data.selectDays.length = 2; &#125; &#125; &#125; else &#123; that.tds.map(function (item) &#123; item.className = &apos;&apos;; &#125;); that.data.selectDays.map(function (key) &#123; ((key.year === that.data.year) &amp;&amp; (key.month === that.data.month)) ? that.tds[key.day].className = &apos;tdActive&apos; : &apos;&apos; ; &#125;); if (that.data.selectDays.length === 2) &#123; if (that.data.selectDays.length === 2) &#123; if (that.data.selectDays[0].day &lt; that.data.selectDays[1].day) &#123; _minDate = that.data.selectDays[0].day; _maxDate = that.data.selectDays[1].day; &#125; else &#123; _maxDate = that.data.selectDays[0].day; _minDate = that.data.selectDays[1].day; &#125; &#125; for (var j = _minDate + 1; j &lt; _maxDate; j++) &#123; if (that.data.selectDays[0].month === that.data.selectDays[1].month &amp;&amp; that.data.selectDays[0].month === that.data.month) &#123; that.tds[j].className = &apos;timeBar&apos;; &#125; else &#123; that.tds[j].className = &apos;&apos;; &#125; &#125; &#125; &#125; &#125; &#125;; // 使用 $() 类似于 jQuery 中的调用写法，用来调用 dom 元素 // data.year // data.month 表示真实的年和月 // data 对象， 用来集中管理数据信息 // initTable 用于初始化表格，构建日期选择框 // initData 将data 内的数据和 input 输入框内的数据进行同步， // 自动同步 if (window.dateCanlender !== &apos;undefined&apos;) &#123; listenEvent(document.getElementById(&apos;startTime&apos;), &apos;click&apos;, function () &#123; $(&apos;#content&apos;).style.display = &apos;block&apos; &#125;); var dateCanlender = new dateUI(true, &apos;startTime&apos;, function () &#123; &#125;) dateCanlender.initTable(); dateCanlender.tds = document.getElementsByTagName(&apos;td&apos;); dateCanlender.tds = [].slice.call(dateCanlender.tds); dateCanlender.reactData(); var date = new Date(); dateCanlender.data.year = date.getFullYear(); dateCanlender.data.month = date.getMonth() + 1; dateCanlender.initDate(); dateCanlender.dateAct(); &#125; &#125;(window))&lt;/script&gt;&lt;style&gt; #content &#123; display: none; border: 2px solid darkgray; padding: 10px; margin: 50px auto; width: 300px; &#125; #title &#123; margin: 10px 0; display: flex; justify-content: space-between; &#125; #title span, #title input &#123; display: inline-block; width: 25%; text-align: center; flex: 1; &#125; #title input &#123; margin: 0 10px; &#125; #main &#123; width: 300px; &#125; table, table thead &#123; width: 100%; &#125; table thead tr &#123; width: 100%; margin: 10px 0; /* display: flex; justify-content: space-between; */ &#125; table td &#123; text-align: center; &#125; .tdActive &#123; color: white; background-color: skyblue; &#125; .timeBar &#123; background-color: gray; &#125; .notClick&#123; color: lightgray; &#125;&lt;/style&gt;&lt;/body&gt;&lt;/html&gt; 思路这段代码是使用面向对象的语法写的，面向对象程序设计的主要使用了构造函数和原型的语法。 代码如下: 12345function person () &#123; &#125;person.prototype.eye = 2;var he = new person();he.eye // 2 上面的代码中，通过使用 new 操作符创建了 person 构造函数的一个实例，在构造函数中定义了一个属性 eye ，根据在原型链中的继承的特性，使用 new 操作符创建的实例，会继承构造函数上定义的属性和方法，因此，我们可以在构造函数上定义公共属性和方法。 在通过 new 操作符的过程中发生了什么？ 1.创建一个新对象 2.将构造函数的作用域赋给新对象，（这时候 this 指向这个新对象） 3.执行构造函数的代码 （这个新对象添加属性） 4.返回新对象 在上面的代码中 123var dateCanlender = new dateUI(true, &apos;startTime&apos;, function () &#123; &#125;) 这段代码创建了构造函数 dateUI 的一个新实例。 在构造函数的原型上，给原型添加方法 : initTable reactData initDate initColor dateAct initTable 用来初始化表格，生成表格 12345678910111213141516171819202122232425initTable: function () &#123; var that = this; var title = document.createElement(&apos;div&apos;); title.setAttribute(&apos;id&apos;, &apos;title&apos;); title.innerHTML = &apos;&lt;span id=&quot;pre&quot;&gt;back&lt;/span&gt;&lt;input type=&quot;number&quot; id=&quot;month&quot;&gt;&lt;input type=&quot;number&quot; id=&quot;year&quot;&gt;&lt;span id=&quot;back&quot;&gt;pre&lt;/span&gt;&apos; var main = document.createElement(&apos;div&apos;); main.setAttribute(&apos;id&apos;, &apos;main&apos;); var table = document.createElement(&apos;table&apos;); table.innerHTML = &apos;&lt;thead&gt;&lt;tr&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;/tbody&gt;&apos;; main.appendChild(table); that.$(&apos;#content&apos;).appendChild(title); that.$(&apos;#content&apos;).appendChild(main); for (let i = 0; i &lt; that.data.weekDay.length; i++) &#123; that.$(&apos;tr&apos;, that.$(&apos;thead&apos;)[0])[0].innerHTML += &apos;&lt;th&gt;&apos; + that.data.weekDay[i] + &apos;&lt;/th&gt;&apos;; &#125; var _ROW = 6; var _COL = 7; for (var i = 0; i &lt; _ROW; i++) &#123; that.$(&apos;tbody&apos;)[0].innerHTML += &apos;&lt;tr&gt;&lt;/tr&gt;&apos;; for (var j = 0; j &lt; _COL; j++) &#123; that.$(&apos;tr&apos;, that.$(&apos;tbody&apos;)[0])[i].innerHTML += &apos;&lt;td&gt;&lt;/td&gt;&apos;; &#125; &#125; that.tds = document.getElementsByTagName(&apos;td&apos;); that.tds = [].slice.call(that.tds); 上面中的代码 [].slice.call(that.tds) 将类数组对象 tds 转化为数组，从而可以使用数组的方法 数组中 slice 的方法 reactData: 将数据变为可以跟踪变化的形式，类似于在 vue 中的，将 data 数据变为可响应式的，使用的是 Object.defineProperty() 方法, getter setter 等方法构建响应式数据。通过这种方法创建的数据是可以响应式的。 代码如下: 12345678910111213141516171819202122232425reactData: function () &#123; var that = this; var props = [&apos;year&apos;, &apos;month&apos;]; props.map(function (item) &#123; var dom = null; item === &apos;year&apos; ? dom = that.$(&apos;#year&apos;) : dom = that.$(&apos;#month&apos;); Object.defineProperty(that.data, item, &#123; get: function () &#123; return dom.value; // 绑定dom, 自动获取到value值 &#125;, set: function (newVal) &#123; if (item === &apos;month&apos;) &#123; if (newVal &gt; 12) &#123; newVal = 1; that.data.year++; &#125; else if (newVal &lt;= 0) &#123; newVal = 12; that.data.year--; &#125; &#125; dom.value = newVal; &#125; &#125;) &#125;); &#125;, initDate 用来像表格中填入数据： 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556initDate: function () &#123; // 将 this 值存入 that,为了防止在 onclick 事件中 this 值改变的情况 var that = this; var date = new Date(that.data.year, that.$(&apos;#month&apos;).value - 1, 1); // startDate 得到的是当月 1 号的星期几 var startDate = date.getDay(); // allDates 得到的是当前月全部的日期 var allDates = new Date(that.data.year, that.$(&apos;#month&apos;).value, 0).getDate(); var tds = document.getElementsByTagName(&apos;td&apos;); that.initColor(); var j = 0; startDate = (startDate ? startDate : 7); // startDate 表示这一个月份的一号是星期几，当是星期天的时候，要从下一行开始 // 下面的程序用来向表格内填入天的号数 for (let i = 0 ; i &lt; 42; i++) &#123; // 判断开始时间，即判断表格中位于 1 号之前的表格 if (i &gt;= startDate) &#123; j &gt;= allDates ? j = 1 : j++; tds[i].innerHTML = j; // 定义位于中间的表格可以点击区域 if(i &lt; allDates + startDate ) &#123; tds[i].onclick = function () &#123; // 将当前的年 月 表格输存入数组 that.initColor(that.data.year, that.data.month, i); that.initColor(); // 清空input 框内的数据 that.$(&apos;#&apos; + that.inputIdName).value = &apos;&apos;; that.data.selectDays.map(function (item, index, array) &#123; that.$(&apos;#&apos; + that.inputIdName).value = item.year + &apos;-&apos; + item.month + &apos;-&apos; + that.tds[item.day].innerHTML; if (!that.isSingle) &#123; var min; that.data.selectDays.map(function (item, index, array) &#123; if (item.day &lt; that.data.selectDays[0].day) &#123; min = item; &#125; else &#123; min = that.data.selectDays[0]; &#125; &#125; ); &#125; &#125;); // 点击事件完成之后调用回调函数 that.callBack(); &#125;; &#125; else &#123; // 使用 onclick = null 回收点击事件 tds[i].onclick = null; tds[i].className = &apos;notClick&apos;; &#125; &#125; else &#123; tds[i].className = &apos;notClick&apos;; document.getElementsByTagName(&apos;td&apos;)[i].onclick = null; // 回收 click 事件 tds[i].innerHTML = new Date(that.data.year, that.$(&apos;#month&apos;).value - 1, 0).getDate() + 1 -startDate + i ; &#125; &#125; &#125;, 在上段代码中使用的日期对象的一些方法； initColor ：用来重置表格的颜色 dateAct 用来定义日历的一些行为 代码总结:1.使用面向对象的写法进行编写的，而非之前的面向过程编写 2.熟悉 js 中关于使用日期事件的一些方法 在代码中的一些问题:1.代码逻辑混乱，这一部分需要加强 2.代码中需要规范，包括注释，变量的定义 3.使用面向对象的写法的时候，需要知道使用 使用 property 构建函数的时候发生了什么，以及代码中 this 的指向值 little Tips addEventListener attachEvent 12345678910&lt;div id=&apos;btn&apos;&gt;&lt;/div&gt;&lt;script&gt; window.onload = function () &#123; var button = document.getElementById(&apos;btn&apos;); Good.addEventListener(&apos;click&apos;, function () &#123; console.log(this); // this 指向的是 id 为 good 的 dom 元素 &#125;) &#125;&lt;/script&gt; addEventistener 用于监听事件 target.addEventListenter(event, fn , [userCapture]) event : 表示要进行监听的事件 [string] fn :表示 监听到事件之后的回调函数 userCapture : 表示事件是应用到冒泡阶段还是应用到捕获阶段 [boolean] 在 addEventListener中定义的 this 值指向的是 tartget 对象 在 IE 下 使用 attachEvent 来实现类似 addEventListener 的行为: 实现兼容性： 12345678function listenEvent(dom,event,fn) &#123; if (dom.attachEvent) &#123; dom.attachEvent(&apos;on&apos; + event, fn); &#125; else &#123; dom.addEventListener(event, fn); &#125; &#125; 2.使用 Date对象对于得到月份的天数以及当前月第一天的星期几的求法是不同的]]></content>
      <categories>
        <category>代码集</category>
      </categories>
      <tags>
        <tag>日历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活]]></title>
    <url>%2F2017%2F08%2F26%2F%E7%94%9F%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[圣经 你们看那天上的飞鸟，也不种，也不收，也不积蓄在仓里，你们的天父尚且养活它。你们不比飞鸟贵重得多吗？” ​ (耶稣所讲的比喻，载于 马太福音 6:26) 前两天心里面有些焦虑，就想到了这句话。这句话在知乎里面看到过，当时记了下来，现在想一想，这句话挺适合现在的我的心态的。这句话在圣经书上看到过，当时还比较小，只是那圣经书当作故事书来读的，一来那时候家里没有什么书，父亲是农民，也没有给我买过什么书，那本圣经看的挺有趣。二来，其实那本书还挺不错的，家里的圣经书是带插画的，从上帝创造天地开始到耶稣基督升天结束，大约五十几章，每一章都是一个故事，配有插图。故事讲的生动有趣。自己看的津津有味的。现在回头想想，圣经的故事连小孩子都能吸引，基督教成为三大宗教之一也不是没有道理的。 人生哪里有这么多的挫折与逆境，不如意这十之八九，可与人言着不过二三，你自认为的困苦，只是一辈子的常态。 每天保持向上的力量，努力工作，认真学习，不要想遥远的未来，未来如何，你怎么也想不到，不要幻想将来，将来不是来自于幻想，来自于每天一点一滴的积累。 世上的工作无非苦与累，想要安逸，没有错，你是否为了安逸去努力。 脚踏实地，才能一步步的走的更远，不要想将来，不要想过去，把自己每天的事情做好。 你太懒了，也太怂了，你能否可以克服自己？ 饮冰十年，难凉热血。 不要想着战胜困难，先要战胜自己。]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[函数节流]]></title>
    <url>%2F2017%2F08%2F26%2F%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[函数节流代码如下: 123456789101112131415var processor = &#123; timeoutId: null, preformProcessing: function () &#123; //实际上要进行执行的代码 &#125;， process: function () &#123; clearTimeout(this.timeoutId); var that = this; // 在 setTimeout 函数内部是一个匿名函数，匿名函数的 this 指向值指向了全局作用域 this.timeoutId = setTimeout(function () &#123; that.preformProcessing(); &#125;, 100) &#125;&#125;processor.process() // 开始执行函数 使用函数节流的思想是： 假如有一个提交按钮，点击按钮执行提交操作，设置了一个延时器，在点击按钮一段时间之后执行函数，如果在这段时间内，按钮又被点击操作，process 函数会首先清除延时器，重新开始进行延时操作， 为了防止用户在点击按钮进行操作的时候，触发多次提交操作，下面是一个节流函数： 123456function throttle (method, context) &#123; clearTimeout(method.tId); method.tId = setTimeout(function () &#123; method.call(context) &#125;,100)&#125; 定时器使用 call 方法实现在适当的环境下执行函数，如果传入的 context 为空，那么就会在全局作用域中执行函数。 总结使用函数节流用来防止函数在一定时间内多次被触发操作。 setTimeout内的 this 指向值： 1234var timer = setTimeout(function () &#123; console.log(this) // window&#125;, 2000);timer; 因为使用 setTimeout this 值指向的是 window 全局对象，使用 es6 中的箭头函树，this 值是一样的效果。]]></content>
      <categories>
        <category>代码集</category>
      </categories>
      <tags>
        <tag>节流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS层叠上下文]]></title>
    <url>%2F2017%2F08%2F22%2FCSS%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87%2F</url>
    <content type="text"><![CDATA[​ 最近看到张鑫旭大神的关于css元素层叠显示的文章，感到收获了很多，对于css元素堆叠有了深入的理解，下面是我做的写笔记。 层叠上下文普通元素使用css的特殊属性可以创建层叠上下文，创建层叠上下文的元素的层级会高于普通的元素 ，这就好像，当我们眼睛看电脑的时候，创建了层叠上下文的元素离我们的眼睛更近了。当层叠上下文与普通元素叠加在一起的时候，层叠上下文元素会叠放在普通元素的上面。 在上面的这段话中，自己的理解是不正确的，创建了层叠上下文的元素只是有了层次，但是，并不能说，层叠上下文元素就一定到天然高于普通的元素。关于比较，还是要看 层叠顺序来的。 层叠水平层叠水平类似 ‘level’ , 层叠水平的大小决定了同一层叠上下文元素下元素在 z 轴上的显示顺序，所有的元素都有层叠水平都有层叠水平，但是对于普通元素，讨论其层叠水平是没有意义的。 普通元素的层叠水平优先由层叠上下文来决定，层叠水平的比较仅在层叠上下文中比较才有意义。 层叠顺序层叠顺序定义的是在相同的层叠上下文中 元素发生层叠的时候 ，特定的显示顺序, 层叠顺序图表引入顺序如下: 注意: 上面有句话 “当元素发生层叠的时候‘ ，如果元素没有创建层叠上下文，没有发生层叠的现象，下面的层叠顺序是不起作用的，但是，使用 dispplay: inline-block 是个例外，我想是因为在 CSS 中 内容主要，样式次之的原因吧， inline-block 会被认为是内容 ， block 会被认为属于布局的样式 如下代码所示: 1234567891011121314151617181920&lt;div class=&quot;con&quot;&gt; &lt;div class=&quot;block2&quot;&gt; &lt;/div&gt; &lt;div class=&quot;block1&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .block1 &#123; width: 200px; height: 200px; background-color: blue; &#125; .block2 &#123; display: inline-block; margin-bottom: -100px; width: 200px; height: 200px; background-color: red; &#125;&lt;/style&gt; 效果如下: 如果正常情况下，因为在 DOM 文档中，block1 元素位于 block2 元素下面，因此block 1 应该遮挡住 block2 才是，但是为什么会出现这种情况呢？ 因为我们给 block2元素添加了 display: inline-block 属性，根据上面的层叠规则图我们可以知道，应用到的 inline-block元素层叠水平上要高于 block 元素，因此 block2 元素会覆盖掉 block1 元素，这就是 使用层叠顺序的作用，用于比较同一层叠水平下的元素顺序。 下面是两条非常重要的层叠准则如下 : 1.谁大谁上，当两个元素位于同一层叠上下文中的时候，按照层叠顺序，层叠水平大的要覆盖掉层叠水平小的元素。（要注意这里面当元素位于同一个层叠上下文的时候，才会按照层叠顺序来创建） 2.后来居上，当两个元素的层叠水平一致的时候，并且层叠顺序一致的时候，在DOM流中 后面的元素会覆盖掉前面的元素 创建层叠上下文如何创建层叠上下文呢？这里有三种途径： 1.页面的根元素( html )本身带有层叠上下文 对于页面的根元素 html 本身具有层叠上下文的 2.对于包含有 position: absolute position: relative 的定位元素，当 z-index 不是auto 的时候，会创建层叠上下文。(注意这里，z-index 不能是 auto, 否则不能创建层叠上下文) 例如代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;con&quot;&gt; &lt;div class=&quot;block1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;block2&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .block1 &#123; width: 200px; height: 200px; background-color: blue; &#125; .block2 &#123; margin-top: -100px; width: 200px; height: 200px; background-color: red; &#125; // 第一种情况 .block1 &#123; z-index: 2; &#125; .blcok2 &#123; z-index: 1; &#125; // 第二种情况 .block1 &#123; position: relative; z-index: 0; &#125; .blcok2 &#123; z-index: 1000; &#125;&lt;/style&gt;&lt;/body&gt;&lt;/html&gt; 我们通过对于css样式的改变出现下面的这几种情况： 第一种情况: 这种情况下，实际上 z-index 没有起作用，因为这里面的两个元素都是普通元素，没有创建层叠上下文的元素因此 这里使用 z-index 进行比较没有起作用 使用 z-index只对于层叠上下文的元素起作用 第二种情况： 使用 position: relative 和 z-index 创建了层叠上下文， 在层次上，层叠上下文的要高于普通元素，因为使用 z-index: 0 的层叠水平会高于 display:block 元素，因此会出现下面的效果 3.使用其他特殊的 css3 属性创建的层叠上下文。 使用一些特殊的层叠CSS3属性也会创建层叠上下文：有这么几个: 1.当一个元素的 父元素 声明 display: flex | display: inline-flex 的时候，并且该元素的 z-index 不是 auto 而是数数值的时候，该元素变为层叠上下文元素； 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;con&quot;&gt; &lt;div class=&quot;block1&quot;&gt; &lt;/div&gt; &lt;div class=&quot;block2&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .con &#123; display: flex; &#125; .block1 &#123; width: 200px; height: 200px; background-color: blue; &#125; .block2 &#123; margin-left: -100px; width: 200px; height: 200px; background-color: red; &#125; .block2 &#123; &#125; .block1 &#123; z-index: 1; &#125;&lt;/style&gt;&lt;/body&gt;&lt;/html&gt; 正常情况下，block2 元素 应该在block元素上面，因为dom流中 block元素位于 后面 但是，当我们给 block1 添加了一个 z-index 不为 auto的值的时候，情况发生变化了, Magic ! 如下： 这是因为添加了 z-index 元素就变成了层叠上下文了，在层叠顺序表中， z-index 大于 0 的层叠上下文在 层次上要高于 display: block 的普通元素，如果 z-index 为 -1 的时候，其实情况又不一样了。因为 z-index 为负值的时候是会小于 display: block 元素的。 使用 CSS 中的 opacity 创建的层叠上下文元素: 我们有时候会出现想让 不透明元素内的元素显示正常， 123456789101112131415161718&lt;div class=&apos;con&apos;&gt; &lt;div class= &apos;text&apos;&gt;我是一段文字&lt;/div&gt;&lt;div&gt;&lt;sytle&gt;.con&#123; width: 100px; height: 100px; background-color: blue; opacity: 0.5;&#125;.text &#123; width: 100px; height: 100px; background-color: red; position: relative; z-index: -1;&#125;&lt;/style&gt; 在实际上，元素内的文字也会被透明度影响，这被认为是 使用 opacity 创建了层叠上下文元素 因为，在没有使用 opacity 的时候， 没有创建层叠上下文， 这时候 .text 元素是创建了层叠上下文的，因为 z-index 小于零，在层叠规则上小于 block 元素，所以会被遮盖掉。当我们对于 class=&#39;con&#39; 的元素没有设置 opacity的时候，效果如下： 这样效果的原因是因为：使用了 position: relative 和 z-index: -1 形成的层叠上下文，在层叠规则上要低于 其他的block 元素，因此图片中的红色方块就被遮挡住了； 然而，当我们对元素应用 opacity 当 opacity 是不为 1 的数字的时候，我们发现层叠顺序发生了改变： Magic! 如上, 因为我们对于 class = &#39;con&#39; 设置了 opacity: 0.7 创建了层叠上下文，其子元素 class =&#39;text&#39; 虽然也是创建了层叠上下文，但是根据层叠上下文的规则，如果父元素也是创建了层叠上下文，那么子元素创建的层叠上下文要受到父元素的层叠上下文的制约； 上面对于使用 opacity 创建的层叠上下文，来解释子元素会受到父元素 opacity 的影响，实际上，我们也可以认为属性 opacity 具有继承性，子元素会继承父元素的 opacity 属性 对于使用 opacity 会影响到子元素的效果，如果我们想让子元素不受到父元素 opacity 的影响， 解决办法有下面的几种方法： 借用 background: rgba() 了来实现 使用 这个属性可以避免 后代子元素使用 opacity 造成的干扰效果， 123456background: rgba(R,G,B,A)// R: 代表红色取值// G: 代表绿色取值// B: 代表蓝色取值// A: 代表透明度// R G B 代表 三原色, 数值为 0 - 255 使用这三种颜色的组合可以实现任何其他的颜色 因此，上面的问题，我们使用 rgba 来解决： background: rgba(0,0,255,0.5) 还有一种方法，是让被 opacity 不作用在父元素上 html: 123456&lt;div class=&apos;con&apos;&gt; &lt;div class=&apos;text&apos;&gt; &lt;p&gt;我是要进行显示的元素&lt;/p&gt; &lt;/div&gt; &lt;div class=&apos;back&apos;&gt;&lt;/div&gt;&lt;/div&gt; CSS: 1234567891011121314.blo &#123; position: relative; width: 100px; height: 100px; &#125;.back &#123; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: blue; opacity: 0.2; &#125; ​ 效果如下: 层叠上下文的特性：层叠上下文元素有如下特性： 层叠上下文的层叠水平要比普通元素高； 层叠上下文可以阻断元素的混合模式； 层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的层叠上下文。 每个层叠上下文和兄弟元素独立，也就是当进行层叠变化或渲染的时候，只需要考虑后代元素。 每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS层叠</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[作用域：函数作用域和块作用域]]></title>
    <url>%2F2017%2F08%2F20%2F%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9A%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[作用域单元作用域单元分为函数作用域和块作用域，使用作用域的目的是将变量单独定义在作用域内，防止变量污染，变量的声明应该距离是用地越近越好，并且最大限度的实现本地化。 为什么要创建块作用域例如代码如下： 12345678910if (true) &#123; var bar = 2&#125;console.log(bar) // 2for (var i =0 ;i &lt; 10; i++) &#123; console.log(i)&#125;console.log(i); 在上面的代码中，使用了 var 声明变量，当我们这个变量只在 if 或者 for 代码块中使用的时候，使用 var 声明变量容易造成变量污染，后续开发人员声明变量的时候还要避免声明同样的变量。 使用快作用域的作用是：在代码块中被声明的变量只在代码块中使用，不会污染到全局变量。这就需要我们创建块作用域。 创建块作用域的几种方式1.try catch 语句会在 catch 语句中创建一个块作用域 1234567try &#123; consolel.log(a);&#125;catch (err) &#123; console.log(err.name); // 抛出错误的名字&#125;console.log(err.name) // err is not defined 声明的catch 内变量只在 catch 语句内部被使用到 2.let 会为声明的变量隐式的创建块作用域 1234if (true) &#123; let bar = 2&#125;console.log(bar)// bar is not defined 通过使用 let 将声明的变量隐式的绑定到 if 语句上，在外部是不可访问到的。 也可以通过使用 { } 来显式的为 let 声明一个用于绑定的块: 1234567if () &#123; let bar = 2; &#123; let foo = 3; &#125; console.log(foo); // foo is not defined&#125; 使用 let 可以创建作用域，相对于使用 var 而言,var 会将变量定义到全局作用域中，使用 let 定义变量会被定义到隐式的块状作用域，因此，依赖变量的函数也要放到定义的块状作用域内。 3.使用 const也可以创建块状作用域，使用 const 创建的是常量，试图修改会导致错误: 1234if (true) &#123; const a = 2;&#125;console.log(a) // a is not defined 总结使用 var 定义的变量会被定义到全局变量中，使用let 可以创建块状作用域，使用let定义的变量依赖的函数要和声明的变量放在同一个作用域； 使用 {} 可以声明显式的作用域；]]></content>
      <categories>
        <category>js读书总结</category>
      </categories>
      <tags>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端touch事件]]></title>
    <url>%2F2017%2F08%2F19%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFtouch%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[touch事件当我们手指触摸屏幕的时候，touch事件有这几个事件: touchstart : 当手指触摸手机屏幕的时候触发 touchmove : 当手指当手机屏幕上移动的时候触发 touchend: 当手指移开手机屏幕的时候触发 ，事件方法应该在 touchend 中定义调用。 touchcancel: 这个事件在 uc 浏览器上，当我们在页面上进行左右滑动的时候会被触发 ,用于防止误操作 touch 事件对象touch事件对象返回了下面几个属性: touches: 当前屏幕上所有触摸点的集合 ,当只有一个触摸点的时候，使用 touches[0] 获得触摸对象 targetTouches: 当前对象上所有触摸点的集合 changedTouched: 自从变化之后的所有touch对象数组 touch 事件返回的对象中的属性集合返回的触摸点对象如下： 1234567891011121314151617TouchList &#123;length: 10: TouchclientX: 57.36600112915039clientY: 31.8700008392334force: 1identifier: 0pageX: 57.36600112915039pageY: 31.8700008392334radiusX: 36.65040588378906radiusY: 36.65040588378906rotationAngle: 0screenX: 547screenY: 167target: div#demo__proto__: Touch__proto__: TouchList 各个触摸点的属性解释如下: clientX，clientY: 触摸点在视口中的距离 pageX, pageY:触摸点在html文档中的距离，当html文档的宽度超过视口的宽度的时候， pageX = clientX + 超出的那一部分距离 screenX, screenY: 触摸点距离屏幕的距离 target: touch事件作用到的事件对象 在uc浏览器下遇到的问题使用uc浏览器的时候遇到了一个问题，我想要做导航栏随着手指移动而滑动的效果，在android 系统上chrome浏览器表现正常，但是在uc浏览器上出现bug, 手指滑动屏幕的时候导航栏不滑动，当手指离开的时候，导航栏出现滑动效果，貌似滑动效果只被触发了一次，touchend 事件消失，被touchcancel替代: 解决办法: 在touchmove的时候阻止默认行为，监听touchcancel 替代 touchend事件: 1234567891011121314touch(event) &#123; switch (event.type) &#123; case &apos;touchstart&apos;: .... break; case &apos;touchmove&apos;: .... event.preventDefault(); break; case &apos;touchend&apos;: .... break; &#125; &#125; 情况并不像我之前想的那样，touchcancel 的行为并不是类似于 touchend touchcancel 事件touchcancel 从字面意思上来讲，是取消touch 操作的意思，在 MDN 上是这样解释的: The touchcancel event is fired when a touch point has been disrupted in an implementation-specific manner (for example, too many touch points are created).\ touchcancel 事件是这样被触发的：当触摸点被一种特殊的执行方法被破坏，（例如，创建了太多的触摸点） 我是这样理解的： touchcancel 事件被触发是因为:当我们使用手机操作的时候，例如点击按钮操作，我们在 touchend 事件中定义了点击按钮后调用的方法，如果我们误操作，比如手指在按钮上左右滑动的时候，touchcancel 事件就会被紧跟着被调用（不同于点击事件，浏览器会认为在手机屏幕上的左右滑动是误操作），取消 touchend 事件，从touchend 事件中的方法不会被执行。 当手指在按钮上下滑动的时候，touchcancel 事件是不会被调用的。可以把touchcancel 事件视为防止误操作事件。]]></content>
      <tags>
        <tag>移动端touch事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my first blog]]></title>
    <url>%2F2017%2F08%2F18%2Fmy-first-blog%2F</url>
    <content type="text"><![CDATA[这是我的第一篇博客:折腾来折腾去终于搭建起来github博客，还好中间没有遇到太大的问题，搭建过程也还算顺利。 为什么要写博客？为了记录下自己前端学习中的一些知识点，在写代码的过程中，总结经验，提高自己的编程水平，写下自己在编程中遇到的问题，思考，以及是如何解决的，不断提高自己。 千里之行，始于足下 12]]></content>
      <tags>
        <tag>0</tag>
      </tags>
  </entry>
</search>
