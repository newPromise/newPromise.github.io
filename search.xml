<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>blob 对象</title>
    <url>/2019/01/12/Blob/</url>
    <content><![CDATA[<p>js 中的 blob 数据类型：</p>
<h3 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h3><h6 id="什么是-blob-？"><a href="#什么是-blob-？" class="headerlink" title="什么是 blob ？"></a>什么是 blob ？</h6><p>blob 代表了一个存放文d件数据的字节包， 使用 blob 可以代替 file， 我们可以在使用 file 的地方使用 blob 作为代替。同样， blob也有和 文件 file 类似的 size 和 MIME 属性。</p>
<p>在 blob 中可以存放二进制数据， 同时我们可以使用 arrayBuffer 进行读取数据。</p>
<h6 id="创建-blob："><a href="#创建-blob：" class="headerlink" title="创建 blob："></a>创建 blob：</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Blob(array, [,options]);</span><br><span class="line"><span class="comment">// array is an Array of ArrayBuffer, ArrayBufferView, Blob, DOMString objects, or a mix // of any of such objects, that will be put inside the Blob. DOMStrings are encoded as // UTF-8.</span></span><br><span class="line"><span class="comment">// options 是可选的额外参数， 比如， 可以传递一个 type， 表示放入 blob 中的数据的 MIME 类型</span></span><br></pre></td></tr></table></figure>
<p>如下， 将字符串保存到 blob 中， type 为 “text／plain”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const blob = new Blob([&quot;hello world&quot;], &#123; type: &apos;text/plain&apos; &#125;);</span><br></pre></td></tr></table></figure>
<h6 id="读取blob"><a href="#读取blob" class="headerlink" title="读取blob"></a>读取blob</h6><p>如果我们直接打印出 blob 是不能打印出来的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Blob(<span class="number">11</span>) &#123;<span class="attr">size</span>: <span class="number">11</span>, <span class="attr">type</span>: <span class="string">"text/plain"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以通过使用 FileReader 读取 blob 中的数据：</p>
<blockquote>
<p>FileReader 是 web 用来异步读取电脑上的文件或者blob数据的对象， 其对于从web端操作文件提供了一系列的方法， 具体内容查看 <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileReader" target="_blank" rel="noopener">FileReader</a></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">reader.readAsText(blob);</span><br><span class="line">rader.onloadend = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"result"</span>, reader.result);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// result "hello world"</span></span><br></pre></td></tr></table></figure>
<h6 id="我们可以使用-blob来做什么？"><a href="#我们可以使用-blob来做什么？" class="headerlink" title="我们可以使用 blob来做什么？"></a>我们可以使用 blob来做什么？</h6><p>blob 提供了用于操作二进制数据的一些接口， 一些可以用来操作二进制数据的api 比如 file 对象， 都是建立在blob的对象基础之上的， 继承了blob 的一些属性和方法。</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>blob</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS块状格式化上下文(BFC)</title>
    <url>/2017/09/17/BFC/</url>
    <content><![CDATA[<h3 id="BFC-的概念"><a href="#BFC-的概念" class="headerlink" title="BFC 的概念"></a>BFC 的概念</h3><p>bfc 被称作: 块状格式化上下文，通过创建 bfc 可以创建出一块独立的渲染区域，在这个区域内，bfc 仅仅对于 <code>blcok-level</code> 块状水平的 <code>box</code> 起作用，bfc 上下文规定了内部的块状水平 box 如何起作用，并且创建了块状格式化上下文的容器，内部元素的布局方式不会影响到外部的区域，因此，我们可以使用 bfc 的概念实现对于浮动的清除。</p>
<h3 id="BFC-的创建"><a href="#BFC-的创建" class="headerlink" title="BFC 的创建"></a>BFC 的创建</h3><p>创建块状格式化上下文的方式有以下几种:</p>
<ul>
<li><code>float</code> 的值不为 <code>none</code></li>
<li><code>position</code> 的值不为 <code>static</code> 或者 <code>relative</code></li>
<li><code>display</code> 的值为 <code>table-cell</code>  <code>table-caption</code> <code>inline-block</code> <code>flex</code> <code>inline-flex</code> 中的其中一个</li>
<li><code>overflow</code> 的值不为 <code>visible</code> (通过设置 <code>overflow: hidden</code>)</li>
</ul>
<p>我的理解： 对于创建了块状格式化上下文的元素，在元素内部相当于定义了一个单独的区域，在这个区域内，内部子元素的布局不会影响到外部的元素</p>
<h3 id="BFC-的布局规则"><a href="#BFC-的布局规则" class="headerlink" title="BFC 的布局规则"></a>BFC 的布局规则</h3><blockquote>
<p>In a block formatting context:</p>
<ul>
<li>boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the ‘margin’ properties. Vertical margins between adjacent block boxes in a block formatting context collapse.</li>
<li>each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats).</li>
</ul>
</blockquote>
<p>在BFC 中: </p>
<ul>
<li>垂直方向上，内部的 box 元素从包含块的顶部开始一个接一个的布局，两个相邻块之间的垂直距离是有 <code>margin</code> 特性决定的，在相邻的块状元素的垂直 <code>margin</code> 上会出现外边距折叠的问题</li>
<li>每一个块状元素的左边缘会紧紧跟在包含块的左边缘，甚至当有浮动元素存在的情况下也是一样的道理，除非这个块状元素创建了一个新的 BFC</li>
</ul>
<h3 id="BFC-的应用"><a href="#BFC-的应用" class="headerlink" title="BFC 的应用"></a>BFC 的应用</h3><h4 id="1-使用-BFC-用来解决外边距折叠问题"><a href="#1-使用-BFC-用来解决外边距折叠问题" class="headerlink" title="1. 使用 BFC 用来解决外边距折叠问题"></a>1. 使用 BFC 用来解决外边距折叠问题</h4><hr>
<p>外边距折叠是特定的相邻的外边距会形成一个单独的外边距，<code>collpase margin</code> 发生在下面的这些情况:</p>
<ul>
<li>元素为空元素</li>
<li><code>padding</code> 或者 <code>border</code> 为 0</li>
<li><code>no clearance to seperate them</code> ? 什么意思</li>
</ul>
<p>更多详细的的内容 :  <a href="https://www.w3.org/TR/css3-box/#compact-boxes" target="_blank" rel="noopener">https://www.w3.org/TR/css3-box/#compact-boxes</a></p>
<p>对于外边距坍塌，最终形成的外边距遵循的是 <code>M-N</code> 原则: </p>
<p>如果两个元素的外边距是正值, 最后得到的坍塌之后的外边距是两个边距的最大值 <code>M</code></p>
<p>如果两个元素的外边距是负值，最后得到的坍塌之后的外边距是两个边距中的最小值 <code>N</code></p>
<p>如果外边距是 <code>none</code> , 得到的坍塌之后的外边距是 0</p>
<p>存在边距坍塌的几种情况</p>
<ol>
<li>相邻的块状元素之间出现外边距坍塌</li>
<li>父元素和内部的子元素出现的外边距坍塌</li>
</ol>
<hr>
<p>使用块状格式化上下文解决外边距层叠:</p>
<p>css 代码如下 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">	&lt;div class=&quot;b1&quot;&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">	&lt;div class=&quot;b2&quot;&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.container &#123;</span><br><span class="line">  background: blue;</span><br><span class="line">&#125;</span><br><span class="line">.b1, .b2 &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 50px;</span><br><span class="line">  margin: 10px;</span><br><span class="line">  background: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/margin%20collapse.png" alt></p>
<p>如上图所示, 父元素<code>container</code> 内部的子元素和父元素的边界坍塌，导致子元素与父元素的边界贴合，并且在子元素之间。两个 <code>div</code> <code>margin</code>  都设为 10, 最后出现折叠之后的 <code>margin</code> 也变成了 10 ，出现了元素折叠的现象</p>
<p>如何解决： 使用 <code>overflow: hidden</code> 创建 bfc</p>
<p>当我们给父元素创建 bfc 之后, </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  overflow: hidden</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到:</p>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/%E7%88%B6%E5%85%83%E7%B4%A0%20bfc.png" alt></p>
<p>这时候因为父元素创建了 bfc ，因此子元素的 margin 不会出现坍塌现象，因为创建了 bf c 的元素不会和任何其它的元素出现边距折叠现象</p>
<p>但是, 我们看到，元素内部的两个字元素还是出现了边距坍塌现象，按照上边的思想，我们可以给单独的一个子元素创建bfc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">	&lt;div class=&quot;b1&quot;&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">	&lt;div class=&quot;b3&quot;&gt;</span><br><span class="line">		&lt;div class=&quot;b2&quot;&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.b3 &#123;</span><br><span class="line">  overflow: hidden</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>上面的代码中, 我们给子元素 <code>b2</code> 上创建了一个父元素，给这个父元素创建bfc </p>
<p>最终结果如下:</p>
<p> <img src="http://ov3b9jngp.bkt.clouddn.com/%E5%AD%90%E5%85%83%E7%B4%A0%20bfc.png" alt>  </p>
<p>最终我们可以看到，因为对于 <code>b3</code> 创建了 bfc ， 因此， 对于 bfc 内部的元素的布局是不会影响到外部的子元素的  </p>
<h4 id="2-使用-BFC-进行浮动的清除"><a href="#2-使用-BFC-进行浮动的清除" class="headerlink" title="2.使用 BFC 进行浮动的清除"></a>2.使用 BFC 进行浮动的清除</h4><p>使用 BFC 进行浮动清除的原理还是一样的，利用位于块状上下文中的元素是不会影响到外部元素的特性，防止子元素设置浮动之后，父元素高度为 0 的情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">	&lt;div class=&quot;b1&quot;&gt;</span><br><span class="line">	我是浮动元素</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">	&lt;div class=&quot;b2&quot;&gt;</span><br><span class="line">	我是浮动的元素</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.container &#123;</span><br><span class="line">  background: blue;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.b1, .b2 &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 50px;</span><br><span class="line">  margin: 10px;</span><br><span class="line">  background: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>结果如下所示:</p>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/bfc%20%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8.png" alt>  </p>
<p>如上图所示，使用了 bfc 清除了由于使用 <code>float:left</code> 造成的浮动现象  浮动元素的父元素高度依然存在</p>
<h4 id="3-使用-BFC-实现两栏自适应布局"><a href="#3-使用-BFC-实现两栏自适应布局" class="headerlink" title="3. 使用 BFC 实现两栏自适应布局"></a>3. 使用 BFC 实现两栏自适应布局</h4><p>在存在浮动的情况下,前面我们说过，包含块内部的子元素的左边缘会紧紧贴在其父元素的左边缘，即使存在浮动元素的情况下也是一样的，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">       &lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;</span><br><span class="line">       &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">   .container  &#123;</span><br><span class="line">        width: 300px;</span><br><span class="line">   &#125;</span><br><span class="line">   .aside &#123;</span><br><span class="line">    width: 20%;</span><br><span class="line">    float: left;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background-color: red;</span><br><span class="line">   &#125;</span><br><span class="line">   .main &#123;</span><br><span class="line">    width: 80%;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: blue;</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>图片如下:</p>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/noBFC%20%E8%87%AA%E9%80%82%E5%BA%94.png" alt></p>
<p>即使 <code>aside</code> 浮动，<code>main</code> 还是会贴在左边缘，如果我们想要实现两栏的自适应布局，如何实现？</p>
<p>根据上面的布局规则， 我们可以给 <code>main</code> 创建一个块状格式化上下文，这样，<code>main</code> 的布局就不会受到 <code>aside</code> 元素的影响</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.main &#123;</span><br><span class="line">  width: 80%;</span><br><span class="line">  height: 200px;</span><br><span class="line">  background-color: blue;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终，我们得到了自适应布局: 从而得到了一个两栏布局</p>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/BFC%20%E8%87%AA%E9%80%82%E5%BA%94.png" alt></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>bfc</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS: 未知高度内文本居中</title>
    <url>/2017/12/11/CSS-%E6%9C%AA%E7%9F%A5%E9%AB%98%E5%BA%A6%E5%86%85%E6%96%87%E6%9C%AC%E5%B1%85%E4%B8%AD/</url>
    <content><![CDATA[<p>在项目中遇到过单行文本出现垂直居中的问题， 对于已知高度使用 <code>line-height = height</code> 可以解决问题，对于未知高度，下面有几种方法。</p>
<p>例如下面的 <code>HTML</code> 以及 <code>CSS</code> 如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;wrapper&quot;&gt;</span><br><span class="line">  &lt;span class=&quot;first&quot;&gt;我是第一个需要居中的文字&lt;/span&gt;</span><br><span class="line">  &lt;span class=&quot;second&quot;&gt;我是第二个需要居中的文字&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.first</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.second</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">70%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们期望得到下面的效果:</p>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/span%20%E5%B1%85%E4%B8%AD.png" alt></p>
<p>但是, 因为我们无法使用 <code>line-height = height</code> (你总不能计算高度 * 30% 吧， 愚蠢的做法), 我们得到这样的效果:</p>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/span%20not%20middle.png" alt></p>
<p>为了实现居中效果，我们可以采用下面的方式:</p>
<ol>
<li>暴力 <code>flex</code></li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.jianshu.com/p/8aa3f1030908" target="_blank" rel="noopener">table</a></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>垂直居中</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS层叠上下文</title>
    <url>/2017/08/21/CSS%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<p>​    最近看到张鑫旭大神的关于css元素层叠显示的文章，感到收获了很多，对于css元素堆叠有了深入的理解，下面是我做的写笔记。</p>
<h3 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h3><p>普通元素使用css的特殊属性可以创建层叠上下文，<del>创建层叠上下文的元素的层级会高于普通的元素</del> ，这就好像，当我们眼睛看电脑的时候，创建了层叠上下文的元素离我们的眼睛更近了。当层叠上下文与普通元素叠加在一起的时候，层叠上下文元素会叠放在普通元素的上面。</p>
<p>在上面的这段话中，自己的理解是不正确的，创建了层叠上下文的元素只是有了层次，但是，并不能说，层叠上下文元素就一定到天然高于普通的元素。关于比较，还是要看 层叠顺序来的。</p>
<h3 id="层叠水平"><a href="#层叠水平" class="headerlink" title="层叠水平"></a>层叠水平</h3><p>层叠水平类似 ‘level’ , 层叠水平的大小决定了同一层叠上下文元素下元素在 z 轴上的显示顺序，所有的元素都有层叠水平都有层叠水平，但是对于普通元素，讨论其层叠水平是没有意义的。</p>
<p>普通元素的层叠水平优先由层叠上下文来决定，层叠水平的比较仅在层叠上下文中比较才有意义。</p>
<h3 id="层叠顺序"><a href="#层叠顺序" class="headerlink" title="层叠顺序"></a>层叠顺序</h3><p>层叠顺序定义的是在相同的层叠上下文中  <strong>元素发生层叠的时候</strong> ，特定的显示顺序, 层叠顺序图表引入顺序如下:</p>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/%E5%B1%82%E5%8F%A0%E8%A7%84%E5%88%99.png" alt=" "> </p>
<blockquote>
<p>注意: 上面有句话 “当元素发生层叠的时候‘ ，如果元素没有创建层叠上下文，没有发生层叠的现象，下面的层叠顺序是不起作用的，但是，使用 <code>dispplay: inline-block</code> 是个例外，我想是因为在 CSS 中 <code>内容主要，样式次之</code>的原因吧， <code>inline-block</code>  会被认为是内容 ， <code>block</code> 会被认为属于布局的样式</p>
</blockquote>
<p>如下代码所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;con&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;block2&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;block1&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">   .block1 &#123;</span><br><span class="line">       width: 200px;</span><br><span class="line">       height: 200px;</span><br><span class="line">       background-color: blue;</span><br><span class="line">   &#125;</span><br><span class="line">    .block2 &#123;</span><br><span class="line">        display: inline-block;</span><br><span class="line">        margin-bottom: -100px;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 200px;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>效果如下:</p>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/Snipaste_2017-08-22_23-40-52.png" alt="&#39;&#39;"></p>
<p>如果正常情况下，因为在 DOM 文档中，block1 元素位于 block2 元素下面，因此block 1 应该遮挡住 block2 才是，但是为什么会出现这种情况呢？</p>
<p>因为我们给 block2元素添加了 <code>display: inline-block</code> 属性，根据上面的层叠规则图我们可以知道，应用到的 inline-block元素层叠水平上要高于 block 元素，因此 block2 元素会覆盖掉 block1 元素，这就是 使用层叠顺序的作用，用于比较同一层叠水平下的元素顺序。</p>
<blockquote>
<p>下面是两条非常重要的层叠准则如下 :</p>
<p>1.谁大谁上，当两个元素位于同一层叠上下文中的时候，按照层叠顺序，层叠水平大的要覆盖掉层叠水平小的元素。（要注意这里面当元素位于同一个层叠上下文的时候，才会按照层叠顺序来创建）</p>
<p>2.后来居上，当两个元素的层叠水平一致的时候，并且层叠顺序一致的时候，在DOM流中 后面的元素会覆盖掉前面的元素</p>
</blockquote>
<h3 id="创建层叠上下文"><a href="#创建层叠上下文" class="headerlink" title="创建层叠上下文"></a>创建层叠上下文</h3><p>如何创建层叠上下文呢？这里有三种途径：</p>
<p>1.页面的根元素( html )本身带有层叠上下文</p>
<p>对于页面的根元素 <code>html</code> 本身具有层叠上下文的</p>
<p>2.对于包含有 <code>position: absolute</code>  <code>position: relative</code> 的定位元素，当 z-index 不是auto 的时候，会创建层叠上下文。(注意这里，z-index 不能是 auto, 否则不能创建层叠上下文)</p>
<p>例如代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;con&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;block1&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;block2&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">   .block1 &#123;</span><br><span class="line">       width: 200px;</span><br><span class="line">       height: 200px;</span><br><span class="line">       background-color: blue;</span><br><span class="line">   &#125;</span><br><span class="line">   .block2 &#123;</span><br><span class="line">        margin-top: -100px;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 200px;</span><br><span class="line">        background-color: red;</span><br><span class="line">   &#125;</span><br><span class="line">   // 第一种情况</span><br><span class="line">   .block1 &#123;</span><br><span class="line">      z-index: 2;</span><br><span class="line">   &#125; </span><br><span class="line">   .blcok2 &#123;</span><br><span class="line">      z-index: 1;</span><br><span class="line">   &#125;</span><br><span class="line">   // 第二种情况</span><br><span class="line">   .block1 &#123;</span><br><span class="line">      position: relative;</span><br><span class="line">      z-index: 0;</span><br><span class="line">   &#125; </span><br><span class="line">   .blcok2 &#123;</span><br><span class="line">      z-index: 1000;</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>我们通过对于css样式的改变出现下面的这几种情况：</p>
<p>第一种情况:</p>
<p>这种情况下，实际上 z-index 没有起作用，因为这里面的两个元素都是普通元素，没有创建层叠上下文的元素因此 这里使用 <code>z-index</code> 进行比较没有起作用   <strong>使用 <code>z-index</code>只对于层叠上下文的元素起作用</strong></p>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/%E5%B1%82%E5%8F%A0%EF%BC%881%EF%BC%89_2017-08-24_00-08-06.png" alt></p>
<p>第二种情况：</p>
<p>使用 <code>position: relative</code>  和 <code>z-index</code> 创建了层叠上下文， <del>在层次上，层叠上下文的要高于普通元素</del>，因为使用 <code>z-index: 0</code> 的层叠水平会高于 display:block  元素，因此会出现下面的效果</p>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/%E5%B1%82%E5%8F%A0%EF%BC%882%EF%BC%89_2017-08-24_00-10-54.png" alt></p>
<p>3.使用其他特殊的 css3  属性创建的层叠上下文。</p>
<p>使用一些特殊的层叠CSS3属性也会创建层叠上下文：有这么几个:</p>
<p>1.当一个元素的 <strong>父元素</strong> 声明 <code>display: flex | display: inline-flex</code> 的时候，并且该元素的 <code>z-index</code> 不是 <code>auto</code> 而是数数值的时候，该元素变为层叠上下文元素；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;con&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;block1&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;block2&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .con &#123;</span><br><span class="line">        display: flex;</span><br><span class="line">    &#125;</span><br><span class="line">    .block1 &#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 200px;</span><br><span class="line">        background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">    .block2 &#123;</span><br><span class="line">        margin-left: -100px;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 200px;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line">     .block2 &#123;</span><br><span class="line">       &#125;</span><br><span class="line">     .block1 &#123;</span><br><span class="line">         z-index: 1;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>正常情况下，block2 元素 应该在block元素上面，因为dom流中 block元素位于 后面</p>
<p>但是，当我们给 block1 添加了一个 <code>z-index</code>  不为 auto的值的时候，情况发生变化了, Magic !</p>
<p>如下：</p>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/flex-z-index%20%20magic%20%202017-08-24_22-33-25.png" alt></p>
<p>这是因为添加了 <code>z-index</code> 元素就变成了层叠上下文了，在层叠顺序表中， z-index 大于 0 的层叠上下文在 层次上要高于 <code>display: block</code> 的普通元素，如果 <code>z-index</code> 为 -1 的时候，其实情况又不一样了。因为 z-index 为负值的时候是会小于 <code>display: block</code> 元素的。</p>
<ol start="2">
<li><p>使用 CSS 中的 <code>opacity</code> 创建的层叠上下文元素:</p>
<p>我们有时候会出现想让 不透明元素内的元素显示正常，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&apos;con&apos;&gt;</span><br><span class="line">	&lt;div class= &apos;text&apos;&gt;我是一段文字&lt;/div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;sytle&gt;</span><br><span class="line">.con&#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background-color: blue;</span><br><span class="line">  opacity: 0.5;</span><br><span class="line">&#125;</span><br><span class="line">.text &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background-color: red;</span><br><span class="line">  position: relative;</span><br><span class="line">  z-index: -1;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>在实际上，元素内的文字也会被透明度影响，这被认为是 使用 <code>opacity</code> 创建了层叠上下文元素</p>
<p>因为，在没有使用 <code>opacity</code> 的时候， 没有创建层叠上下文， 这时候 .text 元素是创建了层叠上下文的，因为 <code>z-index</code> 小于零，在层叠规则上小于 <code>block</code> 元素，所以会被遮盖掉。当我们对于 <code>class=&#39;con&#39;</code> 的元素没有设置 <code>opacity</code>的时候，效果如下：</p>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/opacityCENGDIE%202017-08-25_23-16-27.png" alt></p>
<p>这样效果的原因是因为：使用了 <code>position: relative</code> 和 <code>z-index: -1</code> 形成的层叠上下文，在层叠规则上要低于 其他的<code>block</code> 元素，因此图片中的红色方块就被遮挡住了；</p>
<p>然而，当我们对元素应用 <code>opacity</code> 当 <code>opacity</code> 是不为 1 的数字的时候，我们发现层叠顺序发生了改变：  </p>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/opacity%20Mag%202017-08-25_23-27-13.png" alt></p>
<p>Magic!</p>
<p>如上,</p>
<p>因为我们对于 <code>class = &#39;con&#39;</code> 设置了 <code>opacity: 0.7</code> 创建了层叠上下文，其子元素 <code>class =&#39;text&#39;</code> 虽然也是创建了层叠上下文，但是根据层叠上下文的规则，如果父元素也是创建了层叠上下文，那么子元素创建的层叠上下文要受到父元素的层叠上下文的制约；</p>
<blockquote>
<p>上面对于使用 <code>opacity</code> 创建的层叠上下文，来解释子元素会受到父元素 <code>opacity</code> 的影响，实际上，我们也可以认为属性 <code>opacity</code> 具有继承性，子元素会继承父元素的 <code>opacity</code> 属性</p>
</blockquote>
<p>对于使用  <code>opacity</code> 会影响到子元素的效果，如果我们想让子元素不受到父元素  <code>opacity</code> 的影响， 解决办法有下面的几种方法：</p>
<blockquote>
<p>借用 <code>background: rgba()</code> 了来实现</p>
</blockquote>
<p>使用 这个属性可以避免 后代子元素使用 <code>opacity</code> 造成的干扰效果，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">background: rgba(R,G,B,A)</span><br><span class="line">// R: 代表红色取值</span><br><span class="line">// G: 代表绿色取值</span><br><span class="line">// B: 代表蓝色取值</span><br><span class="line">// A: 代表透明度</span><br><span class="line">// R G B 代表 三原色, 数值为 0 - 255 使用这三种颜色的组合可以实现任何其他的颜色</span><br></pre></td></tr></table></figure>
<p>因此，上面的问题，我们使用 <code>rgba</code> 来解决：</p>
<p><code>background: rgba(0,0,255,0.5)</code> </p>
<blockquote>
<p>还有一种方法，是让被 <code>opacity</code> 不作用在父元素上</p>
</blockquote>
<p>html: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&apos;con&apos;&gt;</span><br><span class="line">	&lt;div class=&apos;text&apos;&gt;</span><br><span class="line">		&lt;p&gt;我是要进行显示的元素&lt;/p&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">	&lt;div class=&apos;back&apos;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>CSS:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.blo &#123;</span><br><span class="line">        position: relative;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">    &#125;</span><br><span class="line">.back &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 100%;</span><br><span class="line">        background-color: blue;</span><br><span class="line">        opacity: 0.2;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
<p> 效果如下:</p>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/Snipaste_2017-08-26_00-24-17.png" alt></p>
<h4 id="层叠上下文的特性："><a href="#层叠上下文的特性：" class="headerlink" title="层叠上下文的特性："></a>层叠上下文的特性：</h4><p>层叠上下文元素有如下特性：</p>
<ul>
<li>层叠上下文的层叠水平要比普通元素高；</li>
<li>层叠上下文可以阻断元素的混合模式；</li>
<li>层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的层叠上下文。</li>
<li>每个层叠上下文和兄弟元素独立，也就是当进行层叠变化或渲染的时候，只需要考虑后代元素。</li>
<li>每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。 </li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS层叠</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS居中效果</title>
    <url>/2017/09/02/CSS%E5%B1%85%E4%B8%AD%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>使用 CSS 并没有这么的简单，如果CSS 熟练了，开发网页就会快得多，自己实际上能够使用到的 CSS 样式不多，但是,太多的东西自己没有掌握， CSS 也有许多的技术点，只能不断的跳出自己的舒适区，不断的进行探索。</p>
<h3 id="居中方法"><a href="#居中方法" class="headerlink" title="居中方法"></a>居中方法</h3><h4 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h4><h5 id="行内元素的水平居中"><a href="#行内元素的水平居中" class="headerlink" title="行内元素的水平居中"></a>行内元素的水平居中</h5><p>使用 <code>text-align</code> 的方法实现行内元素的水平居中</p>
<ol>
<li><code>text-align: center</code> : 实现块状元素内部 行元素的水平居中</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id = &apos;content&apos;&gt;</span><br><span class="line">	&lt;span&gt;我是一段文字&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">	#content &#123;</span><br><span class="line">      text-align: center;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<h5 id="块状元素的水平居中方法"><a href="#块状元素的水平居中方法" class="headerlink" title="块状元素的水平居中方法"></a>块状元素的水平居中方法</h5><p>1.使用 <code>margin</code> 进行定位</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&apos;content&apos;&gt;</span><br><span class="line">	&lt;div id = &apos;block&apos;&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">	#content &#123;</span><br><span class="line">    	width: 200px;</span><br><span class="line">		height: 200px;</span><br><span class="line">		background-color: blue;</span><br><span class="line">	&#125;</span><br><span class="line">	#block &#123;</span><br><span class="line">       width: 50px;</span><br><span class="line">       height: 50px;</span><br><span class="line">       margin: auto;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>注意， 对于块状元素使用 <code>margin: auto</code> 只能实现块状元素在父级块状元素内的水平居中</p>
<blockquote>
<p>如果在正常流中一个块元素的 <code>margin-top   margin-bottom</code> 设为 <code>auto</code> 的时候，这个元素的 margin  会自动计算为 0</p>
<p>​</p>
</blockquote>
</li>
</ul>
<p>效果如下:</p>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/marginAuto%20%20Snipaste_2017-09-02_12-18-20.png" alt></p>
<p>在上面的图片中，尽管设置了 <code>margin-top : 20px</code>  但是由于 <code>margin: auto</code> 的存在，将块元素的 <code>margin-top</code> 重新计算为 0</p>
<p>2.借用定位元素  <code>position: absolute</code></p>
<p>借用定位元素实现的居中，可以实现水平，垂直居中的效果</p>
<p>垂直居中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">父元素：</span><br><span class="line">position: relative;</span><br><span class="line">子元素：</span><br><span class="line">position: absolute;</span><br><span class="line">top: 0;</span><br><span class="line">bottom: 0;</span><br><span class="line">margin: auto;</span><br></pre></td></tr></table></figure>
<p>水平居中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">父元素：</span><br><span class="line">position: relative;</span><br><span class="line">子元素：</span><br><span class="line">position: absolute;</span><br><span class="line">left: 0;</span><br><span class="line">right: 0;</span><br><span class="line">margin: auto;</span><br></pre></td></tr></table></figure>
<p>垂直居中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">父元素：</span><br><span class="line">position: relative;</span><br><span class="line">子元素：</span><br><span class="line">position: absolute;</span><br><span class="line">top: 0;</span><br><span class="line">bottom: 0;</span><br><span class="line">margin: auot;</span><br></pre></td></tr></table></figure>
<p>完全居中:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">父元素：</span><br><span class="line">position: relative;</span><br><span class="line">子元素：</span><br><span class="line">position: absolute;</span><br><span class="line">top: 0;</span><br><span class="line">bottom: 0;</span><br><span class="line">left: 0;</span><br><span class="line">right: 0;</span><br><span class="line">margin: auto</span><br></pre></td></tr></table></figure>
<p>3.借用 <code>display: inline-block</code>  来实现</p>
<p><code>display: inline-block</code> 这个属性很有意思:</p>
<blockquote>
<p>使用了 <code>display: inline-block</code> 的元素，这个元素会表现出行内块的特征，这个元素即可以像块状元素一样具有 width  和 height, 也可以是向行内元素一样，呈行内排列</p>
</blockquote>
<p>因此，我们的思路是：</p>
<p>对于要进行水平居中的块状元素应用 <code>display:inline-block</code> , 使它表现出类似行状元素的特性，对于该元素的父元素，应用 <code>text-align: center</code></p>
<h4 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h4><h5 id="行内元素的垂直居中"><a href="#行内元素的垂直居中" class="headerlink" title="行内元素的垂直居中"></a>行内元素的垂直居中</h5><p>1.对于单行元素，使用 <code>line-height: height</code> 实现</p>
<p>2.对于多行元素的垂直居中方法，使用 <code>display: table-cell</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class = &apos;content&apos;&gt;</span><br><span class="line">	&lt;p&gt;我是一段文字&lt;/p&gt;</span><br><span class="line">	&lt;p&gt;我是另一段文字&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">CSS:</span><br><span class="line"></span><br><span class="line">.content &#123;</span><br><span class="line">  display: table-cell;</span><br><span class="line">  vertical-align: middle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/%E5%A4%9A%E8%A1%8C%E6%96%87%E5%AD%97%E5%B1%85%E4%B8%ADSnipaste_2017-09-02_17-38-37.png" alt></p>
<h5 id="块状元素的垂直居中"><a href="#块状元素的垂直居中" class="headerlink" title="块状元素的垂直居中"></a>块状元素的垂直居中</h5><p>1.使用 <code>position: absolute</code> 来实现</p>
<p>2.子元素声明  <code>display: table-cell</code>  <code>display: inline-block</code>  <code>vertical-align: middle</code> 来实现</p>
<h4 id="完全居中"><a href="#完全居中" class="headerlink" title="完全居中"></a>完全居中</h4><ol>
<li><p><code>position: absolute</code> 来实现</p>
</li>
<li><p>使用  <code>display: table-cell</code>, 这时候 子元素必须要声明  <code>display: inline-block</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&apos;good&apos;&gt;</span><br><span class="line">	&lt;div class=&apos;child&apos;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">	#good&#123;</span><br><span class="line">		display:table-cell;</span><br><span class="line">		vertical-align: middle;</span><br><span class="line">		text-align: center;</span><br><span class="line">		width: 200px;</span><br><span class="line">		height: 200px;</span><br><span class="line">		background-color: blue;</span><br><span class="line">	&#125;</span><br><span class="line">	.child &#123;</span><br><span class="line">		display: inline-block;</span><br><span class="line">		width: 50px;</span><br><span class="line">		height: 50px;</span><br><span class="line">		background-color: red;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>2.使用 <code>display: flex</code> 实现居中的效果</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"children"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS 居中</tag>
      </tags>
  </entry>
  <entry>
    <title>JSONP跨域 ajax请求</title>
    <url>/2017/09/03/JSONP%E8%B7%A8%E5%9F%9F-ajax%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<p>使用 JSONP 进行的跨域，链接的是聚合数据的手机号查询归属地 API，一开始的时候出现了问题，使用原生的 ajax 请求怎么样也是查询不到数据，后来了解到，使用 ajax 不能进行跨域请求。下面是通过使用 <code>jsonp</code> 实现的跨域请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;div id=&quot;div&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    号码归属地查询&lt;input id=&apos;phone&apos; type=&apos;text&apos; &gt;&lt;button id = &apos;btn&apos;&gt;查询手机号归属地&lt;/button&gt;</span><br><span class="line">    &lt;p&gt;您的手机号码归属地是  &lt;span id=&apos;city&apos;&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">   function doFunction (data) &#123;</span><br><span class="line">            if (!data.result) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125; </span><br><span class="line">            document.getElementById(&apos;city&apos;).innerHTML = data.result.city;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    window.onload = function () &#123;</span><br><span class="line">        var sendObj = &#123;</span><br><span class="line">            url: &apos;http://apis.juhe.cn/mobile/get&apos;,</span><br><span class="line">            phone: &apos;13429667914&apos;,</span><br><span class="line">            key: &apos;4ebdd2325a4ce36fa7ca55e910c185e9&apos;,</span><br><span class="line">            callback: &apos;doFunction&apos;</span><br><span class="line">        &#125;;</span><br><span class="line">        function sendLink (obj) &#123;</span><br><span class="line">            var link = obj.url;</span><br><span class="line">            for (var key in obj) &#123;</span><br><span class="line">                if (key !== &apos;url&apos;) &#123;</span><br><span class="line">                    link = link + (~link.indexOf(&apos;?&apos;) ? &apos;&amp;&apos; : &apos;?&apos; );</span><br><span class="line">                    link = link + key + &apos;=&apos; + obj[key];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return link;</span><br><span class="line">        &#125;</span><br><span class="line">        document.getElementById(&apos;btn&apos;).addEventListener(&apos;click&apos;, function () &#123;</span><br><span class="line">            var body = document.getElementsByTagName(&apos;body&apos;)[0];</span><br><span class="line">            var script = document.createElement(&apos;script&apos;);</span><br><span class="line">            sendObj.phone = document.getElementById(&apos;phone&apos;).value;</span><br><span class="line">            script.setAttribute(&apos;src&apos;, sendLink(sendObj));</span><br><span class="line">            if (body.getElementsByTagName(&apos;script&apos;).length === 2) &#123;</span><br><span class="line">                body.replaceChild( script ,body.lastChild);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                document.getElementsByTagName(&apos;body&apos;)[0].appendChild(script);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">   &lt;script src=&quot;http://apis.juhe.cn/mobile/get?phone=13429667914&amp;key=4ebdd2325a4ce36fa7ca55e910c185e9&amp;callback=doFunction&quot;&gt;&lt;/script&gt;</span><br><span class="line">--&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h4 id="ajax-请求"><a href="#ajax-请求" class="headerlink" title="ajax 请求"></a>ajax 请求</h4><p>原生的 ajax 请求如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var request;</span><br><span class="line">if (window.XMLHttpRequest) &#123;</span><br><span class="line">	request = new XMLHttpRequest();  </span><br><span class="line">&#125; else &#123;</span><br><span class="line">// for IE</span><br><span class="line">    request = new ActiveObject();</span><br><span class="line">&#125;</span><br><span class="line">request.onreadystatechange = function () &#123;</span><br><span class="line">  if (request.readyState == 4 &amp;&amp; request.status == 200) &#123;</span><br><span class="line">    console.log(request.responseText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">request.open(&apos;get&apos;, url, false / true);</span><br><span class="line">request.send();</span><br></pre></td></tr></table></figure>
<p>使用 ajax 的目的在于在没有重新加载页面的时候进行页面部分数据的更新；</p>
<p><code>open</code> 方法</p>
<p>使用 <code>open</code> 方法接收三个参数:</p>
<p>要发送的请求类型:  ‘get ‘    或者 ‘post’  </p>
<p>请求的url : 注意 <code>只能向同一个域中使用相同端口和协议 URL 发出请求</code>，如果请求的端口和本地页面不在同一个域的范围内，那么要使用跨域进行；</p>
<p>什么是跨域？</p>
<hr>
<p>只要是协议，端口，域名当中存在一个不同的值，那么请求就会被认为是跨域:</p>
<p>一个 URL 地址如下:</p>
<p><code>https://www.baidu.com:8080</code></p>
<p><code>https</code>  协议， 用来定义浏览器打开文件的形式</p>
<p><code>www.baidu.com</code> 域名,  其中     <code>baidu.com</code>  主域     <code>www.baidu.com</code>  子域</p>
<p><code>:8080</code> 端口</p>
<p>当两个 <code>URL</code> 的协议, 域名 ,端口中存在一个不同的时候，使用 ajax 是无法进行请求得出数据的  </p>
<p>但是这种情况:</p>
<p><code>https:// www.a.com/javascript/a.js</code></p>
<p><code>https:// www.a.com/b.js</code></p>
<p>这种情况下, 域名，协议，端口都是相同的, 因此可以进行访问到</p>
<p><a href="https://segmentfault.com/a/1190000000718840" target="_blank" rel="noopener">https://segmentfault.com/a/1190000000718840</a></p>
<p><a href="http://blog.csdn.net/seebetpro/article/details/51326260" target="_blank" rel="noopener">http://blog.csdn.net/seebetpro/article/details/51326260</a></p>
<hr>
<p>布尔值：表示是否进行异步</p>
<p>在上面的代码中，请求成功之后，响应的数据会自动填充 request 对象的属性，表示请求成功之后的状态:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">request.onreadystatechange = function () &#123;</span><br><span class="line">  if (request.readyState == 4 &amp;&amp; request.status == 200) &#123;</span><br><span class="line">    // 表示请求成功之后，并且有返回数据之后要进行的动作</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>status</code> : 表示响应的 <code>http</code> 状态,对于  http 的状态码， 要记住几个重要的：<a href="&#39;http://www.cnblogs.com/sprinng/p/6559431.html&#39;">http状态码</a></p>
<p>2XX :  表示请求成功  </p>
<p><code>200</code> 请求成功， <code>201</code> 已创建  <code>202</code> 接收   <code>204</code> 无内容  </p>
<p>3XX: 表示重定向  </p>
<p><code>300</code> 多路选择  <code>301</code> 永久转移  <code>302</code> 暂时转移  <code>304</code> 未修改</p>
<p>4XX: 客户方错误  </p>
<p><code>400</code> 错误请求  <code>401</code> 未认证   <code>408</code> 请求超时  <code>410</code> 失败</p>
<p>5XX: 服务器错误</p>
<p><code>500</code> 服务器内部错误  <code>501</code> 未实现   <code>504</code> 网关超时  </p>
<p>关于这些请求的具体情况：</p>
<p>2XX: 表示已经接受到了请求</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>表示请求已经成功</td>
</tr>
<tr>
<td>201</td>
<td>表示请求已经被创建</td>
</tr>
<tr>
<td>202</td>
<td>服务器已经接收到了请求， 但是尚未处理</td>
</tr>
<tr>
<td>204</td>
<td>服务器已经处理了请求， 但是没有返回任何</td>
</tr>
</tbody>
</table>
<p>3XX:资源重定向</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>301</td>
<td>表示永久性重定向， 请求的资源分配到新的 url</td>
</tr>
<tr>
<td>302</td>
<td>表示临时性重定向，表示请求的资源已经分配到新的url, 希望用户本次能够使用新的url 访问</td>
</tr>
<tr>
<td>304</td>
<td>表示请求的资源已经找到， 但是不符合条件要求</td>
</tr>
</tbody>
</table>
<p>4XX:客户端请求错误</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">400</td>
<td>表示客户端发给服务器的请求存在语法错误， 服务器无法理解这个请求。</td>
</tr>
<tr>
<td style="text-align:left">401</td>
<td>表示发送的请求需要通过使用 HTTP 认证</td>
</tr>
<tr>
<td style="text-align:left">403</td>
<td>表示客户端想要请求的资源被服务器拒绝访问</td>
</tr>
<tr>
<td style="text-align:left">404</td>
<td>表示在服务器上没有找到请求的资源</td>
</tr>
</tbody>
</table>
<p>5XX: 服务器错误</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>500（服务器错误）</td>
<td>表示服务器在执行请求的时候发生了错误</td>
</tr>
<tr>
<td>503（服务器正忙）</td>
<td>表示现在服务器正在处于超负载状态，无法处理</td>
</tr>
</tbody>
</table>
<p><code>readyState</code> 表示 <code>request</code> 对象的  <code>readyState</code> 对象，属性可取的值如下：</p>
<p><code>0</code> : 未初始化，尚未调用 open() 方法</p>
<p><code>1</code> : 启动， 已经调用 open  方法，尚未调用 send() 方法</p>
<p><code>2</code> : 发送，已经调用 send() 方法，但是尚未接收到响应</p>
<p><code>3</code>: 接收，表示已经接受到部分数据</p>
<p><code>4</code>: 完成, 已经接收到全部的响应数据</p>
<blockquote>
<p>使用 <code>get</code> 和 <code>post</code> 请求的区别</p>
</blockquote>
<h5 id="1-两种方式传递参数的方式不同"><a href="#1-两种方式传递参数的方式不同" class="headerlink" title="1. 两种方式传递参数的方式不同"></a>1. 两种方式传递参数的方式不同</h5><p><code>Get</code> 请求用于向服务器发送请求查询信息，查询字符串参数添加到 url 的末尾 </p>
<p><code>post</code> 请求是将作为 HTTP  消息的实体内容发送给服务器</p>
<h5 id="2-两者缓存不同"><a href="#2-两者缓存不同" class="headerlink" title="2. 两者缓存不同"></a>2. 两者缓存不同</h5><p>使用 <code>get</code> 方法的数据会被浏览器进行缓存起来，因此其他人可以通过使用浏览器的历史记录进行读取到这些数据</p>
<h5 id="3-服务器端-针对这两种方式的获取参数是不同的"><a href="#3-服务器端-针对这两种方式的获取参数是不同的" class="headerlink" title="3.服务器端 针对这两种方式的获取参数是不同的"></a>3.服务器端 针对这两种方式的获取参数是不同的</h5><p>在客户端通过使用 <code>get</code> 请求的时候，服务器端通过使用 <code>Request.QueryString</code>  来进行获取参数, 在客户端通过使用 post 进行请求的时候，服务器端通过使用 <code>Request.Form</code> 来进行获取到参数</p>
<p>为什么要使用两种方式:</p>
<p>当请求没有副作用的时候， 例如进行搜索数据， 可以使用 <code>get</code> 方法， 当请求存在副作用的时候，使用 <code>post</code>进行请求</p>
<p>使用 <code>post</code> 的情况:</p>
<ul>
<li>请求的结果存在副作用，例如，向数据库内添加新的数据行</li>
<li>使用 GET 方法, 使用表单上添加的数据使得 URL太长</li>
<li>进行传送的数据不是7 位的 ASCII 编码</li>
</ul>
<p>使用 <code>get</code> 的情况</p>
<ul>
<li>请求是为了查找资源, HTML 上的表单数据仅仅用来进行搜索</li>
<li>请求结果无持续性的副作用</li>
<li>收集到的数据及HTML 表单内的输入字段名称的总长不超过 1024 字符</li>
</ul>
<h3 id="如何使用-ajax-实现跨域？"><a href="#如何使用-ajax-实现跨域？" class="headerlink" title="如何使用 ajax 实现跨域？"></a>如何使用 ajax 实现跨域？</h3><p>对于使用原生的 ajax 而言,是无法实现进行跨域请求的,如何使用 ajax 实现跨域呢？</p>
<h4 id="1-使用跨源资源共享-CORS"><a href="#1-使用跨源资源共享-CORS" class="headerlink" title="1.使用跨源资源共享(CORS)"></a>1.使用跨源资源共享(CORS)</h4><p>跨源资源共享定义了当进行访问跨源资源的时候，浏览器和服务器之间应该如何进行通信, 基本的思想是:</p>
<p>浏览器向服务器发送请求的时候，添加一个额外的 <code>origin</code> 头部，这个头部包含了请求页面的源信息(协议， 域名， 端口)</p>
<p>如果服务器认为请求可以接受，可以在 <code>Access-Control-Allow-Origin</code> 中回发相同的源信息,如果在服务器端设置 为 * 表示公共资源</p>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/%E8%B7%A8%E6%BA%90%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%ABSnipaste_2017-09-09_10-35-03.png" alt></p>
<p>如上图所示，实现了公共资源的共享</p>
<h4 id="2-使用-JSONP"><a href="#2-使用-JSONP" class="headerlink" title="2.使用 JSONP"></a>2.使用 JSONP</h4><p>使用 jsonp 技术实现的，原理是将请求的参数放入到 js 中，通过使用动态 js 来实现资源的动态请求</p>
<p>缺点: 无法处理请求失败之后的动作,并且使用 jsonp 请求到的数据只能使用 <code>get</code> 请求进行</p>
]]></content>
      <categories>
        <category>代码集</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js学习（一）</title>
    <url>/2017/09/09/Vue%E5%93%8D%E5%BA%94%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="Vue的响应原理"><a href="#Vue的响应原理" class="headerlink" title="Vue的响应原理"></a>Vue的响应原理</h3><p><img src="https://cn.vuejs.org/images/data.png" alt></p>
<p>上面这张图表示的就是 vue 的响应原理:</p>
<p>当我们将数据添加入 vue 实例中的 <code>data</code> 选项中的时候, vue 将遍历data 中数据的所有属性，并且调用 <code>Object.defineProperty</code> 方法将属性记录为依赖。当数据发生改变的时候,就会调用 <code>object.defineProperty</code> 中的 <code>setter</code> 方法,</p>
<p>在组件实例中存在一个 <code>watcher</code> 对象，这个对象的目的是：当被记录的依赖被调用的时候,也就是属性的 <code>setter</code> 被调用的时候，会通知<code>watcher</code> 对象进行重新渲染组件</p>
<h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.defineProperty(Object, property, &#123;</span><br><span class="line">  get () &#123;</span><br><span class="line">  	// 读取对象Object 的属性 property 的时候调用的函数</span><br><span class="line">  &#125;,</span><br><span class="line">  set (newVal) &#123;</span><br><span class="line">   // 设置对象 Object 的属性 property 的时候调用的函数</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>通过使用这种方法，调用 <code>getter</code> 和 <code>setter</code> 可以实现追踪对象属性的变化  </p>
<h3 id="vue-js-中的-生命周期"><a href="#vue-js-中的-生命周期" class="headerlink" title="vue.js 中的 生命周期"></a><code>vue.js</code> 中的 生命周期</h3><p>在 <code>vue.js</code> 中</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue 响应原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 组件之间的传值</title>
    <url>/2017/09/10/Vue-%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E5%80%BC/</url>
    <content><![CDATA[<p>在 <code>vue</code> 中，进行组件通信有下面几种形式:</p>
<h3 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h3><p>在 <code>vue</code> 中, 实现父子组件通信的方法主要是 :  props down,  emit up</p>
<p>使用 props 实现父组件向子组件传递信息, 在父组件上的子组件模板上绑定需要进行传递的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">&lt;child  :propsData = &apos;localData&apos;&gt;&lt;/child&gt;</span><br><span class="line">子组件中：</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &apos;child&apos;,</span><br><span class="line">    // 子组件中通过使用 props 声明需要进行接受的数据</span><br><span class="line">    props: [&apos;propsData&apos;],</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        localData: &apos;&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>对于实现子组件向父组件的传值操作，使用 <code>emit()</code> 操作实现:</p>
<h3 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h3><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>使用 <code>vuex</code> 实现多个组件之间状态的共享</p>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/vuex.png" alt></p>
<p>上图是使用 vuex 的工作流程，下面是我对于 <code>vuex</code> 的一些个人理解</p>
<p><code>vuex</code> 主要是有三个部分组成: </p>
<p><code>actions</code> : 用来执行提交 mutations 操作  </p>
<p><code>mutations</code> : 用来对于 <code>state</code> 中存储的数据进行改变操作  </p>
<p><code>state</code> : 用来存储一些数据， 这些数据对于各个组件之间是可以共享的  </p>
<p>总的来说： 要执行一次进行改变 <code>state</code> 中状态的数据，要进行以下操作</p>
<p><code>state</code> 中保存了要进行改变的数据状态  </p>
<p><code>mutations</code> 中定义了要进行改变数据状态的操作，这是函数</p>
<p>我们通过 <code>actions</code>  中的函数对于在<code>mutations</code> 中定义的函数进行提交, 相当于执行函数，从而实现对于<code>state</code> 中保存数据的改变</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>组件通信</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 中的函数式编程（译）</title>
    <url>/2018/06/16/JavaScript-%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%88%E8%AF%91%EF%BC%89/</url>
    <content><![CDATA[<p>在这篇文章中，我们将会学习到声明式， 纯函数， 不变性以及副作用。</p>
<h2 id="什么是函数式编程？"><a href="#什么是函数式编程？" class="headerlink" title="什么是函数式编程？"></a>什么是函数式编程？</h2><ul>
<li>在计算机科学中，函数是编程是一种编程范例或者模式（一种构建计算机程序结构和元素的样式）</li>
<li>函数式编程将计算机运算视为数学概念中函数的计算。</li>
<li>函数式编程避免改变状态以及使用可变的数据。</li>
</ul>
<p>上面的这些定义来自于维基百科， 在这篇文章中，我们尝试理解FP(函数式编程)的价值和意义。</p>
<h2 id="其他主要的编程规范或模式："><a href="#其他主要的编程规范或模式：" class="headerlink" title="其他主要的编程规范或模式："></a>其他主要的编程规范或模式：</h2><ul>
<li>过程式编程</li>
<li>面向对象的编程</li>
<li>元编程</li>
<li>命令式编程</li>
<li>声明式编程</li>
</ul>
<p>过程式编程 基于程序调用的概念，简单包括计算机将要执行的一系列的计算过程， 在程序执行期间的任何时候，任何被设定的程序都有可能被调用，包括被其他的程序被调用或者自身调用，主要的过程式编程语言有COBOL, BASIC, C, ADA 和 GO</p>
<p>面向对象编程 基于对象的概念，对象中包含数据（属性）和程序（方法），这种模式更接近于函数式编程，一些重要的面向对象的语言包括：C++, Java, PHP, C#, Python, Ruby, Swift 等等。</p>
<p>元编程 具备将程序视为数据的能力，这意味着程序能够被设计成能够阅读，复制， 分析或者转换为其他程序，甚至在运行的时候修改自身。</p>
<p>命令模式 vs 声明模式</p>
<ul>
<li>命令模式关心描述程序如何运行, 由计算机执行的命令组成</li>
<li>声明模式关心程序能够做什么而无需确定程序应该如何完成。</li>
<li>函数式编程遵循声明模式。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> books = [</span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">'JavaScript'</span>, <span class="attr">pages</span>:<span class="number">450</span>&#125;, </span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">'Angular'</span>, <span class="attr">pages</span>:<span class="number">902</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">'Node'</span>, <span class="attr">pages</span>:<span class="number">732</span>&#125;</span><br><span class="line">];</span><br><span class="line"><span class="comment">/* Imperative Pattern */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; books.length; i++) &#123;</span><br><span class="line">  books[i].lastRead =  <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Declarative Pattern */</span></span><br><span class="line">books.map(<span class="function">(<span class="params">book</span>)=&gt;</span> &#123;</span><br><span class="line">  book.lastReadBy = <span class="string">'me'</span>;</span><br><span class="line">  <span class="keyword">return</span> book;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(books);</span><br></pre></td></tr></table></figure>
<ul>
<li>在上面的这一段代码中， 我们对于书籍数组中的每一本书添加了一个新的属性，这个过程通过两种不同的方法执行。</li>
<li>第一段中借用 <code>for 循环</code>，依据数组的长度进行迭代,接着将数组的指针计数器和数组的长度进行核对并且在每一次迭代中增加指针计数器，因此， 这更像程序/代码正在关心为了得到想要的输出结果如何进行运行操作。</li>
<li>第二段中的代码借助于原生Js数组中的 map  这个 map  方法将函数作为参数，这个函数获取到每一个元素，因此在这种情况下代码不是在描述程序如何运行，而是讨论需要达成什么 ，在这种情况后的 map 方法 关心实际的程序执行。</li>
</ul>
<h2 id="数学意义上的函数或者纯函数"><a href="#数学意义上的函数或者纯函数" class="headerlink" title="数学意义上的函数或者纯函数"></a>数学意义上的函数或者纯函数</h2><p>在数学中，函数是一系列输入值和合法的输出值之间的关系，这种特性反映了每一个输入组合都关联着一个确定的输出。</p>
<p>这函数式编程中，这种函数被称作纯函数，函数的输出结果仅仅取决于函数接收到的输入数据， 除了返回值之外， 函数不会改变输入的数据。</p>
<p>Math.random() 不是纯函数，因为每次调用的时候总会返回一个新的值。</p>
<p>Math.min(1, 2) 是纯函数的一个例子，对于相同的一组输入值总会返回新的值。</p>
<h2 id="为什么要使用函数式编程"><a href="#为什么要使用函数式编程" class="headerlink" title="为什么要使用函数式编程"></a>为什么要使用函数式编程</h2><ul>
<li>函数式编程中的纯函数确保了不会改变在其范围之外的数据。</li>
<li>其减少了复杂程度， 我们不需要关心程序如何怎样做， 而只需要关心程序做了什么。</li>
<li>易于测试，因为其不会取决于应用的状态，对于结果的验证也将会变得简单。</li>
<li>让代码更具有易读性。</li>
<li>函数式编程让代码更易于理解。</li>
</ul>
<h2 id="函数式编程的例子"><a href="#函数式编程的例子" class="headerlink" title="函数式编程的例子"></a>函数式编程的例子</h2><p>数组函数</p>
<p><img src="https://pic1.zhimg.com/v2-e66d6b1b5b60c7e36e852e8dc0779212_b.jpg" alt="img"></p>
<p>在上面的代码中， 我们试图过滤出只有活跃的 meet-ups, 我们可以看到这个功能可以使用两种不同的方法实现，在这里， 第二种方法是函数式编程，其中的 filter() 方法关心”程序如何运行”，程序只关心输入也就是 meetups数组以及输出activeMeetupsFP 但是在第一种方法中程序也关心 for 循环如何运行代码。</p>
<p>相似的，下面的这些数组方法有助于实现函数式编程，减少代码的复杂度。</p>
<ul>
<li>find</li>
<li>reduce</li>
<li>map</li>
<li>some</li>
<li>every</li>
</ul>
<h2 id="函数链"><a href="#函数链" class="headerlink" title="函数链"></a>函数链</h2><p>函数链是用于调用多种方法的机制， 每一个方法返回一个对象， 允许在一个声明中调用链接在一起而无需变量来储存中间结果。</p>
<p><img src="https://pic4.zhimg.com/v2-99715077ff8316e0a8e88a315c9bf560_b.jpg" alt="img"></p>
<p>在上面的代码片段中， 我们想要打印出所有的活跃的 meetup 用户的总人数， 考虑到可能有10%的用户重复。</p>
<h2 id="支持-FP-的库"><a href="#支持-FP-的库" class="headerlink" title="支持 FP 的库"></a>支持 FP 的库</h2><p>下面这些库中提供了一些让代码看起来更加声明式的有用函数。</p>
<ul>
<li>RamadaJS</li>
<li>UnderscoreJS</li>
<li>lodash</li>
</ul>
<h2 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h2><p>函数或者表达式除了返回一个值之外，在下面的几种情况下被认为产生了副作用： 如果其改变了其自身范围之外的程序状态， 或者与其调用的函数或者外部的程序有一个可以观察到的交互。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> meetup = &#123;<span class="attr">name</span>:<span class="string">'JS'</span>,<span class="attr">isActive</span>:<span class="literal">true</span>,<span class="attr">members</span>:<span class="number">49</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> scheduleMeetup = <span class="function">(<span class="params">date, place</span>) =&gt;</span> &#123;</span><br><span class="line">  meetup.date = date;</span><br><span class="line">  meetup.place = place;</span><br><span class="line">  <span class="keyword">if</span> (meetup.members &lt; <span class="number">50</span>)</span><br><span class="line">    meetup.isActive = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> publishMeetup = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (meetup.isActive) &#123;</span><br><span class="line">    meetup.publish = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">scheduleMeetup(<span class="string">'today'</span>,<span class="string">'Bnagalore'</span>);</span><br><span class="line">publishMeetup();</span><br><span class="line"><span class="built_in">console</span>.log(meetup);</span><br></pre></td></tr></table></figure>
<p>上面的这段代码产生了副作用，因为函数 scheduleMeetup 的本来的作用是给 meetup 添加 date 和 place, 但是这个函数改变了 isActive 的值， 而这个 isActive 正是函数 publishMeetup 所依赖的。具有副作用的 publishMeetup 函数将不会得到理想的输出， 因为其输入的值在这个过程中被改变了。 在大型的程序中（真实的程序情况下）， 很难去 debug 副作用。</p>
<p>副作用不总是产生坏的影响，但是如果其产生的时候我们应该小心对待。</p>
<h2 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h2><p>在函数运行之后，不变性是十分重要的对于确保一个函数确实没有改变原来的数据而不是返回数据的新的副本。</p>
<p>例如， 如果数组以及对象在经历过多个函数之后， 如果我们不能保持不变性， 那么函数可能不会得到数组或者对象的原始值。</p>
<p>在可变的对象和数组的情况下，如果发生了一些错误对于我们来说是非常困难排除bug的。</p>
<h2 id="支持不变性的库"><a href="#支持不变性的库" class="headerlink" title="支持不变性的库"></a>支持不变性的库</h2><p>JavaScript默认没有对于使得对象或者数组不变提供任何的工具， 下面是一些可能帮助我们实现不变性的库:</p>
<ul>
<li>Seamless-immutable</li>
<li>Immutable JS</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>函数式编程中主要的方面是纯函数和更小的功能， 函数不变性以及更少的副作用。</p>
<p>本文翻译至<a href="https://codeburst.io/functional-programming-in-javascript-e57e7e28c0e5" target="_blank" rel="noopener">Functional Programming in JavaScript</a>，实际上翻译之后才发现这里只是一些函数式编程基础知识，对于其他的函数式编程的更多特性并没有涉及，本文仅仅作为函数式编程的基本入门知识， 如果能帮到读者，那就再好不过了。</p>
]]></content>
      <categories>
        <category>翻译文集</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>promisify callback-style function</title>
    <url>/2019/10/03/PromisifyCallback/</url>
    <content><![CDATA[<p>将一个回调函数转换为 <code>promise</code> 类函数，在  <code>promisify</code> 化的函数的 <code>then</code> 方法里面执行回调函数， 避免回调地狱。</p>
<p>这样相当于我们日常代码开发中，对于某个函数返回一个 <code>promise</code>, 以期在函数的 <code>then</code> 方法里面处理数据的方法的一个封装。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// some data process code...</span></span><br><span class="line">    <span class="keyword">try</span> () &#123;</span><br><span class="line">      resolve(data);      </span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;...&#125;);</span><br></pre></td></tr></table></figure>
<p>在 node.js 中， 存在一个工具方法为 <code>utils.promisfy</code> 的工具方法， 这个方法将回调转换为 <code>promise</code> 类方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// error-first 类型回调</span></span><br><span class="line"><span class="comment">// 回调cb 的第一个参数为 error， 如果没有传 false</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cb(<span class="literal">false</span>, <span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> utils = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promiseFn = utils.promisify(fn);</span><br><span class="line"></span><br><span class="line">promiseFn().then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 使用这个方法， 可以将 node 中的一些异步的回调</span></span><br><span class="line"><span class="comment">// 比如： readFile 等</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promiseReadFile = utils.promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line">promiseReadFile(<span class="string">'./.gitignore'</span>, <span class="string">'utf-8'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">fs.readFile(<span class="string">'./.gitignore'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在 <code>promisify</code> 出现之前，使用 <a href="https://github.com/sindresorhus/pify" target="_blank" rel="noopener">pify</a> 实现相同的功能</p>
<p><code>pify</code> 模块的核心代码不多,  下面是全部的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 核心处理方法</span></span><br><span class="line"><span class="comment">// fn：将要被 promise 化的函数</span></span><br><span class="line"><span class="comment">// options: 相关配置选项</span></span><br><span class="line"><span class="comment">// args: 传入函数的相关参数</span></span><br><span class="line"><span class="comment">// 实际执行的时候， 执行这个方法返回的方法， 其中 args 为传入的参数</span></span><br><span class="line"><span class="comment">// 这里 args 是一个数组， 通过 push 回调的方法</span></span><br><span class="line"><span class="keyword">const</span> processFn = <span class="function">(<span class="params">fn, options</span>) =&gt;</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> P = options.promiseModule;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> P(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// multiArgs： 是否传入多个参数</span></span><br><span class="line">    <span class="keyword">if</span> (options.multiArgs) &#123;</span><br><span class="line">      <span class="comment">// push 一个方法函数， 这个函数就是我们在原函数中手动</span></span><br><span class="line">      <span class="comment">// 调用的回调函数 cb， 参数是我们手动写入回调函数中的参数</span></span><br><span class="line">      args.push(<span class="function">(<span class="params">...result</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// errorFirst: 是否包含错误， 适配 node 如 fs.exists() 类的方法</span></span><br><span class="line">        <span class="keyword">if</span> (options.errorFirst) &#123;</span><br><span class="line">          <span class="keyword">if</span> (result[<span class="number">0</span>]) &#123;</span><br><span class="line">            reject(result);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.shift();</span><br><span class="line">            resolve(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.errorFirst) &#123;</span><br><span class="line">      args.push(<span class="function">(<span class="params">error, result</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">          reject(error);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      args.push(resolve);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个时候， args 中传入了相关的回调方法</span></span><br><span class="line">    fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">input, options</span>) =&gt;</span> &#123;</span><br><span class="line">  options = <span class="built_in">Object</span>.assign(&#123;</span><br><span class="line">    exclude: [<span class="regexp">/.+(Sync|Stream)$/</span>],</span><br><span class="line">    <span class="comment">// errorFirst: 回调函数中是否第一个参数为 error</span></span><br><span class="line">    errorFirst: <span class="literal">true</span>,</span><br><span class="line">    promiseModule: <span class="built_in">Promise</span></span><br><span class="line">  &#125;, options);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> objType = <span class="keyword">typeof</span> input;</span><br><span class="line">  <span class="keyword">if</span> (!(input !== <span class="literal">null</span> &amp;&amp; (objType === <span class="string">'object'</span> || objType === <span class="string">'function'</span>))) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`Expected \`input\` to be a \`Function\` or \`Object\`, got \`<span class="subst">$&#123;input === <span class="literal">null</span> ? <span class="string">'null'</span> : objType&#125;</span>\``</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> filter = <span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> match = <span class="function"><span class="params">pattern</span> =&gt;</span> <span class="keyword">typeof</span> pattern === <span class="string">'string'</span> ? key === pattern : pattern.test(key);</span><br><span class="line">    <span class="comment">// options 中的 include 和 exclude 属性分别表示</span></span><br><span class="line">    <span class="comment">// 模块中可以被序列化的方法</span></span><br><span class="line">    <span class="keyword">return</span> options.include ? options.include.some(match) : !options.exclude.some(match);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> ret;</span><br><span class="line">  <span class="comment">// 当传入的 input 为函数的时候</span></span><br><span class="line">  <span class="keyword">if</span> (objType === <span class="string">'function'</span>) &#123;</span><br><span class="line">    ret = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// excludeMain：是否对于一些 module 内部方法 做 promise 化</span></span><br><span class="line">      <span class="keyword">return</span> options.excludeMain ? input(...args) : processFn(input, options).apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 否则 ret 为包含有 input 上面的属性的对象</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ret = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(input));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于 input 参数对象或者函数上面的每一个方法都做 promise 化</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> input) &#123; <span class="comment">// eslint-disable-line guard-for-in</span></span><br><span class="line">    <span class="keyword">const</span> property = input[key];</span><br><span class="line">    ret[key] = <span class="keyword">typeof</span> property === <span class="string">'function'</span> &amp;&amp; filter(key) ? processFn(property, options) : property;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>utils.promisify</code> 方法</p>
<p><code>promisify</code> 方法是 node 内置的 <code>promise</code> 化回调函数的工具方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promisify = <span class="function"><span class="keyword">function</span> <span class="title">promisify</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> kCustomPromisifiedSymbol = <span class="keyword">typeof</span> <span class="built_in">Symbol</span> !== <span class="string">'undefined'</span> ? <span class="built_in">Symbol</span>(<span class="string">'util.promisify.custom'</span>) : <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> original !== <span class="string">'function'</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'The "original" argument must be of type Function'</span>);</span><br><span class="line">   <span class="comment">// 在 original 方法上面存在有 `kCustomPromisifyedSymbol 这个属性</span></span><br><span class="line">  <span class="comment">// 这个属性上面存储的是被 promise 化的方法</span></span><br><span class="line">  <span class="keyword">if</span> (kCustomPromisifiedSymbol &amp;&amp; original[kCustomPromisifiedSymbol]) &#123;</span><br><span class="line">    <span class="keyword">var</span> fn = original[kCustomPromisifiedSymbol];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'The "util.promisify.custom" argument must be of type Function'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(fn, kCustomPromisifiedSymbol, &#123;</span><br><span class="line">      value: fn, <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="attr">writable</span>: <span class="literal">false</span>, <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> promiseResolve, promiseReject;</span><br><span class="line">    <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      promiseResolve = resolve;</span><br><span class="line">      promiseReject = reject;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">      args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    args.push(<span class="function"><span class="keyword">function</span> (<span class="params">err, value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        promiseReject(err);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        promiseResolve(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      original.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      promiseReject(err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将 fn 上的原型设置为 original 上的原型</span></span><br><span class="line">  <span class="built_in">Object</span>.setPrototypeOf(fn, <span class="built_in">Object</span>.getPrototypeOf(original));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (kCustomPromisifiedSymbol) <span class="built_in">Object</span>.defineProperty(fn, kCustomPromisifiedSymbol, &#123;</span><br><span class="line">    value: fn, <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="attr">writable</span>: <span class="literal">false</span>, <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="comment">// 设置 fn 上的属性为 original 方法上面的属性</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.defineProperties(</span><br><span class="line">    fn,</span><br><span class="line">    getOwnPropertyDescriptors(original)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>promsie</category>
      </categories>
      <tags>
        <tag>promisify</tag>
      </tags>
  </entry>
  <entry>
    <title>Base64 基础知识</title>
    <url>/2019/09/13/base64/</url>
    <content><![CDATA[<p>Base64 作为一种编码方式， 可以将对于一些数据使用Base64 编码， 那么， 为什么使用 Base64 编码， 使用 Base64 编码的原理是什么以及 Base64 编码在前端的应用，下面的文章将会涉及这些内容：</p>
<h2 id="what-is-Base64"><a href="#what-is-Base64" class="headerlink" title="what is Base64?"></a>what is Base64?</h2><p>在计算机中， 一个字节通常有8位字符， 这些字符使用二进制表示共有 256 种组合， 这些组合形成了 ascii（American Standard Code for Information Interchange，美国信息交换标准代码） 码：一种字节组合和字符的对应表,  基础的 ascii 码共有 128 种组合， 因为不同国家语言字符的需要， 现在很多是扩展的 ascii码，但不同的 扩展ascii 码的前 127 位是基本相同的， 这一部分称为基础 ascii 码： </p>
<img src="/2019/09/13/base64/ascii.png">
<p>假如我们不通过 Base64 编码， 而是直接向不同设备传输二进制数据，因为一些老旧设备或者软件对于某些二进制值字符的处理方式可能不同， 因就有可能被错误处理，为了解决这种问题， 我们使用Base64 编码将数据统一编码为可见字符，而可见字符在大多设备上的表现行为是一致的，这样就使得数据在不同设备之间的处理出错的可能被降低了。</p>
<p>Base64 码共用 64 种对应字符， 对应字符如下:</p>
<img src="/2019/09/13/base64/base64.jpg">
<p>Base64 码由下面这些字符组成：</p>
<ol>
<li>0 - 25 为大写英文字符 A - Z</li>
<li>26 - 51 为小写英文字符 a - z</li>
<li>52 - 61 为数字 0 -9</li>
<li>另外两个字符 + 和 /</li>
</ol>
<h2 id="Base64编码原理"><a href="#Base64编码原理" class="headerlink" title="Base64编码原理"></a>Base64编码原理</h2><p>Base64 本质上是将二进制数据转为文本的形式， 当遇到十进制数据的时候， 需要将十进制转为二进制， 对于二进制数据以连续 6 比特计算其十进制值， 在根据这个值查找上图 Base64表中的字符， 最终我们得到的这段文本即是我们编码后的数据：</p>
<p>比如我们对于 <code>myname</code> 进行Base64 编码：</p>
<table>
<thead>
<tr>
<th style="text-align:center">原始字符</th>
<th style="text-align:center">m</th>
<th style="text-align:center">y</th>
<th style="text-align:center">n</th>
<th style="text-align:center">a</th>
<th style="text-align:center">m</th>
<th style="text-align:center">e</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ASCII码十进制</td>
<td style="text-align:center">109</td>
<td style="text-align:center">121</td>
<td style="text-align:center">110</td>
<td style="text-align:center">97</td>
<td style="text-align:center">109</td>
<td style="text-align:center">101</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">二进制</td>
<td style="text-align:center">01101101</td>
<td style="text-align:center">01111001</td>
<td style="text-align:center">01101110</td>
<td style="text-align:center">01100001</td>
<td style="text-align:center">01101101</td>
<td style="text-align:center">01100101</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Base64码二进制</td>
<td style="text-align:center">011011</td>
<td style="text-align:center">010111</td>
<td style="text-align:center">100101</td>
<td style="text-align:center">101110</td>
<td style="text-align:center">011000</td>
<td style="text-align:center">010110</td>
<td style="text-align:center">110101</td>
<td style="text-align:center">100101</td>
</tr>
<tr>
<td style="text-align:center">Base64码十进制</td>
<td style="text-align:center">27</td>
<td style="text-align:center">23</td>
<td style="text-align:center">37</td>
<td style="text-align:center">46</td>
<td style="text-align:center">24</td>
<td style="text-align:center">22</td>
<td style="text-align:center">53</td>
<td style="text-align:center">37</td>
</tr>
<tr>
<td style="text-align:center">对应 Base64</td>
<td style="text-align:center">b</td>
<td style="text-align:center">X</td>
<td style="text-align:center">l</td>
<td style="text-align:center">u</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">W</td>
<td style="text-align:center">1</td>
<td style="text-align:center">l</td>
</tr>
</tbody>
</table>
<p>最终使用 Base64 编码之后的字符串为  <code>bXluYW1l</code></p>
<p>在上面的编码过程中， 我们将六个字符的字符串编码为八个字符的字符串， 编码长度前后对比为 4 ：3， 也即是说， 当原始字符长度为 3 的倍数时， 编码之后长度为 4 的相应倍数， 如果， 原始字符长度不能被 3 整除怎么办？ 这时候， 我们需要对原始字符的二进制进行补零操作：</p>
<p>例如， 我们对于 <code>my</code> 进行编码：</p>
<table>
<thead>
<tr>
<th>原始字符</th>
<th>m</th>
<th>y</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>ASCII码十进制</td>
<td>109</td>
<td>121</td>
<td></td>
<td></td>
</tr>
<tr>
<td>二进制</td>
<td>01101101</td>
<td>01111001</td>
<td>00000000</td>
<td></td>
</tr>
<tr>
<td>Base64码二进制</td>
<td>011011</td>
<td>010111</td>
<td>100100</td>
<td>000000</td>
</tr>
<tr>
<td>Base64码十进制</td>
<td>27</td>
<td>23</td>
<td>36</td>
<td>0</td>
</tr>
<tr>
<td>对应 Base64</td>
<td>b</td>
<td>X</td>
<td>k</td>
<td>A</td>
</tr>
</tbody>
</table>
<p>因为原始字符中补充的 0 没有任何意义， 因此编码后的 A 不带有任何的意义，标准的 ascii 码中将 A 替换为 <code>=</code></p>
<p><code>my</code> 的编码字符串为 <code>bXk=</code>;</p>
<p>对于解码过程， 首先观察编码字符串长度， 如果字符串长度不能被 4 整除，那么，需要给编码字符串补充 = 来使得字符串长度可以被 4 整除， 然后在进行解码操作。</p>
<p>解码过程是编码过程的逆向操作，将编码字符串的 <code>=</code> 转为 <code>A</code>, 然后转为十进制的 Base64 码， 后转为二进制的6位比特值，将字符串末尾的相应 <code>A</code> 的二进制比特0值丢弃，因为他们不携带任何的信息。</p>
<p>最后将8位二进制转为原始字符.</p>
<h2 id="前端应用-Base64"><a href="#前端应用-Base64" class="headerlink" title="前端应用 Base64"></a>前端应用 Base64</h2><p>Base64 在前端应用比较常见的是将图片的二进制数据转为 Base64， 嵌套入 html 中。</p>
<p>现代浏览器对于图片的 src 属性支持一种 <code>dataUrl</code> 的特性，格式为：</p>
<p><code>url(data:文件类型;编码方式,编码后的文件内容)</code></p>
<p>例如百度搜索的dataURL：</p>
<img src="/2019/09/13/base64/image-20190914095537734.png">
<p>使用这种方式的优点是可以减少外部资源请求， 加快页面加载时间， 缺点是对于色彩丰富的图片， 二进制数据编码之后的 Base64 字符串会比较大， 会影响页面的加载速度</p>
<h2 id="其他：Data-URLs"><a href="#其他：Data-URLs" class="headerlink" title="其他：Data URLs"></a>其他：Data URLs</h2><p>Data URLs 是以 <code>data:</code> 协议为前缀的一种 url，使用 data url 实现了可以将一些小的文件嵌入到文档中的一种方法</p>
<p>data url 的组成结构如下：</p>
<p> <code>data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</code></p>
<p> data url 由下面三种结构组成:</p>
<p> <code>mediatype</code> 表示当前文件的 <code>MIME type</code>, 例如： <code>image/jpeg</code>, <code>text/plain</code> 等</p>
<p>当数据 <code>data</code> 为非文本的格式的时候， 使用一个 <code>base64</code> 标志表示当前的数据为使用 <code>base64</code> 编码之后的数据，对于文字格式， 也是可以使用 <code>base64</code> 进行编码操作</p>
<p><code>data</code>: 数据本身</p>
<p>我们经常会遇到的是经过 <code>base64</code> 编码过后的图片，除了图片之外， 我们还可以对于文字进行转为 <code>data url</code> 的形式：</p>
<p><code>data:,Hello%2C%20World!</code></p>
<p><code>data:text/plain;base64,SGVsbG8sIFdvcmxkIQ%3D%3D</code><br>// 经过 base64 编码过的上面的文本： Hello World!</p>
<p><code>data:text/html,%3Ch1%3EHello%2C%20World!%3C%2Fh1%3E</code><br>// html 文本： <code>&lt;h1&gt;Hello World!&lt;h1&gt;</code></p>
<p>注意：在 data url 中数据本身是 <code>data</code>,当我们需要对于数据进行操作的时候， 我们需要获取到 <code>data urls</code> 中的数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 node 中下载 data urls 形式的图片</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">downloadImage</span>(<span class="params">dataUrl</span>) </span>&#123;</span><br><span class="line">  dataUrl = dataUrl.replace(<span class="regexp">/^data:image\/png;base64,/</span>, <span class="string">""</span>);</span><br><span class="line">  fs.writeSync(<span class="string">'image.jpg'</span>, dataUrl, &#123; <span class="attr">encoding</span>: <span class="string">'base64'</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考链接：<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs" target="_blank" rel="noopener">data urls</a></p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Base64</tag>
      </tags>
  </entry>
  <entry>
    <title>css modules: 前端模块化</title>
    <url>/2018/09/09/css-modules-%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<p>在 <code>css</code> 模块化的解决方案中， 存在两种解决方案， 一种是放弃使用 css, 使用 <code>js</code> 或者 <code>json</code> 的形式来重写 <code>css</code>, 这样写的好处在于方便利用 <code>js</code> 的模块化管理，缺点在于缺少 <code>css</code> 预处理器例如 less sass 等的支持，例如 <code>react-style</code> 属于这种解决方案。另外一种是依旧采用 <code>css</code> 的原生态写法， 但是通过 <code>js</code> 来进行管理依赖， 下面我们介绍的 <code>css-modules</code> 属于这种的写法。</p>
<h3 id="css-模块化中的一些问题"><a href="#css-模块化中的一些问题" class="headerlink" title="css 模块化中的一些问题"></a>css 模块化中的一些问题</h3><p>在 <code>css</code> 的模块化的过程中， 下面几种问题是需要解决的：</p>
<h4 id="全局污染"><a href="#全局污染" class="headerlink" title="全局污染"></a>全局污染</h4><p>在 css 中， 样式 <code>style</code> 是属于全局范围内的， 因此当我们在全局范围内w为某一元素标签添加样式的时候， 这一样式会被应用到全局的所有的该标签下的元素上面，为了减少掉全局变量的污染，我们会采用提高元素优先级的方法进行样式覆盖， 例如添加 <code>!important</code> ，获取通过复杂选择器增大元素的权重值以及行内样式，这种通过提高元素优先级的方法实现的元素样式覆盖导致了无法重写元素样式， 丧失了l灵活性。</p>
<h4 id="命名混乱"><a href="#命名混乱" class="headerlink" title="命名混乱"></a>命名混乱</h4><p>混乱的命名方式会导致开发过程中的样式冲突， 样式混乱， 为后续开发带来了困难， 在这个问题上面， 有一种解决方式， 就是采用  <code>BEM</code> 的命名方式；</p>
<h4 id="依赖管理不彻底"><a href="#依赖管理不彻底" class="headerlink" title="依赖管理不彻底"></a>依赖管理不彻底</h4><p>在引入组件的时候， 组件应该相互独立， css 文件应该随着组件的引入按需加载，而不是引入所有的样式， 这样造成了模块的浪费。</p>
<h4 id="实现变量共享"><a href="#实现变量共享" class="headerlink" title="实现变量共享"></a>实现变量共享</h4><p>在复杂的组件中, 可能需要通过 <code>js</code> 或者 <code>css</code> 同时进行操作样式，这种情况下可能会造成样式的冗余，现在的预处理器都不能实现变量在 <code>css</code> 与 <code>js</code> 之间的变量共享。</p>
<h3 id="CSS-modules"><a href="#CSS-modules" class="headerlink" title="CSS modules"></a>CSS modules</h3><p><code>css modules</code> 是一种模块化的解决方案，通过使用 js 文件引入管理， 同时， 在 <code>css modules</code> 中的 <code>css</code> 文件中的样式名被默认为局部样式，从而避免了局部样式的污染， 结合 <code>webpack</code>, 使用 <code>css modules</code> 应用的类名会被编译为一串字符， 从而避免 <code>class</code> 命名的重复。</p>
<p>下面是一些基本的语法:</p>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><h5 id="引入与导出"><a href="#引入与导出" class="headerlink" title="引入与导出"></a>引入与导出</h5><p>在需要使用 <code>css</code> 的组件中通过使用 <code>import</code> 的方法进行导入：</p>
<p>index.css:<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.btn</span> &#123; <span class="comment">/* btn 的相关样式 */</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>index.js:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">"./index.css"</span>;</span><br><span class="line">...</span><br><span class="line">render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&#123;</span> <span class="attr">style.btn</span> &#125;&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>最终生成：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button class=&quot;btn&quot;&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure></p>
<p>通过使用 js 引入的方式还可以实现常量的共享功能：<br>对于常量， 需要使用 <code>:export</code>关键字将 css 中的常量输出到 js 中:</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@color:</span> <span class="string">"red"</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">:export</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">@color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">"./index.css"</span>;</span><br><span class="line"></span><br><span class="line">style.color <span class="comment">// "red"</span></span><br></pre></td></tr></table></figure>
<h5 id="全局与局部样式"><a href="#全局与局部样式" class="headerlink" title="全局与局部样式"></a>全局与局部样式</h5><p>通过使用 <code>:global</code> 和 <code>:local</code> 样式可以将当前的样式声明为全局和局部样式：</p>
<p>index.css:<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于下面的 local</span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">:local(.btn)</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 声明为全局样式</span><br><span class="line">// 文件中所有类名为 `btn` 的元素都将应用这个样式</span><br><span class="line"><span class="selector-pseudo">:global</span> &#123;</span><br><span class="line">    .btn &#123;</span><br><span class="line">        <span class="selector-tag">color</span>: <span class="selector-tag">blue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="代码复用与样式组合"><a href="#代码复用与样式组合" class="headerlink" title="代码复用与样式组合"></a>代码复用与样式组合</h5><p>在 <code>css-modules</code> 中使用  <code>composes</code> 来实现多个类名的组合， 例如， 当我们定义组件 <code>Button</code> 的时候， 我们需要定义基础配置， 大小以及类型样式， 可以这么写</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">    <span class="comment">// 定义基础样式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn-small</span> &#123;</span><br><span class="line">    <span class="comment">// small 大小相关样式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn-text</span> &#123;</span><br><span class="line">    <span class="comment">// text btn 相关样式</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 组合样式  --&gt;</span><br><span class="line"><span class="selector-class">.btn-small-text</span> &#123;</span><br><span class="line">    <span class="attribute">compose</span>: btn btn-small btn-text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者当 btn 为全局样式 global-btn 的时候， 可以进行组合</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn-small-text</span> &#123;</span><br><span class="line">    <span class="attribute">composes</span>: global-btn btn-small btn-text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<strong>使用 <code>composes</code>进行样式组合的时候， 需保证组合的样式名在<code>composes</code>之前已经存在了， 并且是单独的样式名， 没有嵌套关系</strong></p>
<h4 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h4><ul>
<li>减少 class 嵌套, 使用单独 class 来定义样式，减少 class 层叠</li>
<li>使用 <code>composes</code> 类名组合来组合样式</li>
<li>不使用选择器， 仅仅使用 class 来定义样式</li>
</ul>
<h3 id="CSS-modules-使用"><a href="#CSS-modules-使用" class="headerlink" title="CSS modules 使用"></a>CSS modules 使用</h3><p>项目中使用 <code>less</code> 作为 css 预处理器，在 webpack 中 <code>css-loader</code> 支持 <code>css modules</code>, 相关配置如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">use: [</span><br><span class="line">    &#123;</span><br><span class="line">    loader: <span class="string">'style-loader'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">    loader: <span class="string">'css-loader'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">        <span class="comment">// 启用 css modules</span></span><br><span class="line">        modules: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 定义最终编译之后的样式名称</span></span><br><span class="line">        <span class="comment">// local: 应用的 class 名称</span></span><br><span class="line">        <span class="comment">// hash: 编译时随机生成的 hash 值， 避免 class 名称重复</span></span><br><span class="line">        localIdentName: <span class="string">'[local]--[hash:base64:5]'</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    &#123;</span><br><span class="line">        loader: <span class="string">'less-loader'</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css modules</tag>
      </tags>
  </entry>
  <entry>
    <title>decode &amp; encode</title>
    <url>/2019/09/15/encode%20&amp;%20decode/</url>
    <content><![CDATA[<p><a href="https://github.com/dankogai/js-base64" target="_blank" rel="noopener">js-base64</a> 是用来对于字符编码和解码操作的一个包， 可以用这个包实现原始字符与 base64 编码后字符之间的转换；</p>
<p>核心代码：</p>
<p>获取base64 对应字符在字符表中十进制值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b64chars = <span class="string">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'</span>;</span><br><span class="line"><span class="keyword">var</span> b64tab = <span class="function"><span class="keyword">function</span>(<span class="params">bin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> t = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = bin.length; i &lt; l; i++) t[bin.charAt(i)] = i;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;(b64chars);</span><br></pre></td></tr></table></figure>
<p>字符解码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cb_decode = <span class="function"><span class="keyword">function</span>(<span class="params">cccc</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = cccc.length,</span><br><span class="line">      padlen = len % <span class="number">4</span>,</span><br><span class="line">      <span class="comment">// 这里通过 &lt;&lt; 移位操作，可以直接操作二进制值</span></span><br><span class="line">      <span class="comment">// n : 将各个字符解码之后的二进制值对应的十进制</span></span><br><span class="line">      n = (len &gt; <span class="number">0</span> ? b64tab[cccc.charAt(<span class="number">0</span>)] &lt;&lt; <span class="number">18</span> : <span class="number">0</span>)</span><br><span class="line">  | (len &gt; <span class="number">1</span> ? b64tab[cccc.charAt(<span class="number">1</span>)] &lt;&lt; <span class="number">12</span> : <span class="number">0</span>)</span><br><span class="line">  | (len &gt; <span class="number">2</span> ? b64tab[cccc.charAt(<span class="number">2</span>)] &lt;&lt;  <span class="number">6</span> : <span class="number">0</span>)</span><br><span class="line">  | (len &gt; <span class="number">3</span> ? b64tab[cccc.charAt(<span class="number">3</span>)]       : <span class="number">0</span>),</span><br><span class="line">      <span class="comment">// 从二进制字符串中按照 8 位依次获取二进制的值</span></span><br><span class="line">      <span class="comment">// chars 即为解码之后的字符串原始值</span></span><br><span class="line">      chars = [</span><br><span class="line">        fromCharCode( n &gt;&gt;&gt; <span class="number">16</span>),</span><br><span class="line">        fromCharCode((n &gt;&gt;&gt;  <span class="number">8</span>) &amp; <span class="number">0xff</span>),</span><br><span class="line">        fromCharCode( n         &amp; <span class="number">0xff</span>)</span><br><span class="line">      ];</span><br><span class="line">  chars.length -= [<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>][padlen];</span><br><span class="line">  <span class="keyword">return</span> chars.join(<span class="string">''</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> _atob = global.atob ? <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> global.atob(a);</span><br><span class="line">&#125; : <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 将base64 字符串按照 4 个字符长度剪切</span></span><br><span class="line">  <span class="keyword">return</span> a.replace(<span class="regexp">/\S&#123;1,4&#125;/g</span>, cb_decode);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义在 atob 上的方法用于字符解码</span></span><br><span class="line"><span class="keyword">var</span> atob = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// replace 方法将不属于 base64 字符集内的字符清空</span></span><br><span class="line">  <span class="comment">// 比如 base64 编码字符串中最后一位可能为 =， 这个符号不代表任何含义</span></span><br><span class="line">  <span class="comment">// base64 字符集正则范围 A-Za-z0-9\+\/</span></span><br><span class="line">  <span class="keyword">return</span> _atob(<span class="built_in">String</span>(a).replace(<span class="regexp">/[^A-Za-z0-9\+\/]/g</span>, <span class="string">''</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><h3 id="String-replace-方法"><a href="#String-replace-方法" class="headerlink" title="String.replace  方法"></a><code>String.replace</code>  方法</h3><p>使用 <code>String.replace</code> 方法可以对于字符串中某些字符作替换操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.replace(searchStr | Regexp, replacedStr | replaceFn);</span><br><span class="line"><span class="comment">// searchStr: 匹配的字符</span></span><br><span class="line"><span class="comment">// Regexp: 正则表达式， 被正则表达式匹配到的都会被替换掉</span></span><br><span class="line"><span class="comment">// replacedStr: 用于替换的字符串</span></span><br><span class="line"><span class="comment">// replaceFn: 用于替换过程中的字符串</span></span><br><span class="line"><span class="comment">// return: 被替换掉的字符串</span></span><br></pre></td></tr></table></figure>
<p>例如上面的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将非base64 的字符串清除</span></span><br><span class="line"><span class="built_in">String</span>(a).replace(<span class="regexp">/[^A-Za-z0-9\+\/]/g</span>, <span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 替换正则表达式匹配的字符串， 在替换过程中应用 cb_decode 方法</span></span><br><span class="line">a.replace(<span class="regexp">/\S&#123;1,4&#125;/g</span>, cb_decode);</span><br></pre></td></tr></table></figure>
<h3 id="正则表达式相关"><a href="#正则表达式相关" class="headerlink" title="正则表达式相关"></a>正则表达式相关</h3><ul>
<li><p>在正则中使用限定符 <code>{}</code> 可以限定字符的长度范围</p>
<p><code>\S{1,4}</code>： 匹配字符长度为 1 - 4 的字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 截取字符串按长度为 4 分段截取</span><br><span class="line">let strArr = [];</span><br><span class="line">str.replace(/\S&#123;1,4&#125;/g, (mStr) =&gt;&#123;</span><br><span class="line">  strArr.push(mStr);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>replace</code> 方法接受函数参数如下图：</p>
<img src="/2019/09/15/encode%20&%20decode/replaceFn.png">
</li>
<li><p>正则中的描述符 <code>[]</code> 中使用 <code>^</code> 表示不匹配</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正则表示不匹配base64 字符的字符</span></span><br><span class="line"><span class="built_in">String</span>(a).replace(<span class="regexp">/[^A-Za-z0-9\+\/]/g</span>, <span class="string">''</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="按位操作符相关"><a href="#按位操作符相关" class="headerlink" title="按位操作符相关"></a>按位操作符相关</h3><p>在 js 中， 包含下面几种操作符号， 它们用来在js 中操作二进制数据的位数</p>
<p>各种操作符号的作用如下图：</p>
<img src="/2019/09/15/encode%20&%20decode/操作符.jpg">
<p>示例：</p>
<p>对于十进制数 10 和 20:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="number">20</span>;</span><br><span class="line">s1 &amp; s2; <span class="comment">//  十进制 0 二进制 0</span></span><br><span class="line">s1 | s2; <span class="comment">//  30  11110</span></span><br><span class="line">s1 ^ s2; <span class="comment">//  30  11110</span></span><br><span class="line">~s1; <span class="comment">// -11 -1011</span></span><br><span class="line">s1 &lt;&lt; <span class="number">2</span> <span class="comment">// 40 101000</span></span><br><span class="line">s1 &gt;&gt; <span class="number">2</span>; <span class="comment">// 2 10</span></span><br><span class="line">s1 &gt;&gt;&gt; <span class="number">2</span>; <span class="comment">// 2 10</span></span><br></pre></td></tr></table></figure>
<p>位操作符在上面 base64 转换中的使用：</p>
<ul>
<li><p>使用 <code>|</code>来增加二进制字符串</p>
<p>使用  <code>|</code> 可以用来存储信息，比如我们对于一组数据定义其存放位置， 将这组二进制数存入到一段二进制值中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">let</span> str = s1 | s2 &lt;&lt; <span class="number">8</span> | s3 &lt;&lt; <span class="number">16</span>;</span><br><span class="line"><span class="comment">// s1: 1010, s2: 10100, s3: 11110 str: 111100001010000001010</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>&amp;</code> 来保留相应位数</p>
<p>如：</p>
<p>我们想要保留8位二进制的高四位：</p>
<p><code>let str = s &amp; 0xf0</code> </p>
<p><code>0xf0</code>: 11110000</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s5 = <span class="number">0xf0</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> s4 = s2 &amp; s5;</span><br><span class="line"><span class="built_in">console</span>.log(s5.toString(<span class="number">2</span>), s2.toString(<span class="number">2</span>), s4.toString(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// 11110000 10100 10000</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="进制间的转换"><a href="#进制间的转换" class="headerlink" title="进制间的转换"></a>进制间的转换</h3><p>在 js 中进制之间的相互转化方法如下：</p>
<p>十进制转二进制：</p>
<p><code>numObj.toString(radix)</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">2</span>;</span><br><span class="line">num.toString(<span class="number">2</span>); <span class="comment">// '10'</span></span><br></pre></td></tr></table></figure>
<p>二进制十进制：</p>
<p><code>parseInt(string, radix)</code></p>
<blockquote>
<p>The <code>parseInt()</code> function parses a string argument and returns an integer of the specified <a href="https://en.wikipedia.org/wiki/Radix" target="_blank" rel="noopener">radix</a> (the base in mathematical numeral systems).</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parseInt(&apos;10&apos;, 2);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Base64</category>
      </categories>
      <tags>
        <tag>Base64</tag>
      </tags>
  </entry>
  <entry>
    <title>es6: Map &amp; Set</title>
    <url>/2017/09/23/es6-Map-and-Set/</url>
    <content><![CDATA[<h3 id="Set-数据结构"><a href="#Set-数据结构" class="headerlink" title="Set 数据结构"></a>Set 数据结构</h3><h4 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h4><p>Set 数据结构类似于数组， 不同于数组的是， Set 数据结构中不允许存在重复的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1,2,2,3,4];</span><br><span class="line">let set = new Set(arr);</span><br><span class="line">console.log(arr) // &#123;1,2,3,4&#125; 去除重复数字</span><br></pre></td></tr></table></figure>
<p>在上面的程序中， 使用 new Set构造函数生成的 <code>set</code> 的类型是一个对象，并且通过使用 <code>set</code> 结构进行处理之后的数据中没有重复数据。</p>
<p>使用 set 进行数组去重的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr = [...new Set([arr])]//  [1,2,3,4]</span><br><span class="line">//如上所示，完成了数组的去重操作</span><br></pre></td></tr></table></figure>
<h4 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法,"></a>Set 实例的属性和方法,</h4><p> 如下图所示</p>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/Set.png" alt></p>
<p><code>let set = new Set([1,2,3,4])</code></p>
<p><code>set.prototype.constructor</code>  : 默认 <code>set</code> 函数</p>
<p><code>set.size</code> 表示 <code>set</code> 数据结构中成员的个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set.size // 4</span><br></pre></td></tr></table></figure>
<p>对于 <code>set</code> 结构的方法，分为操作方法和遍历方法</p>
<p>操作方法:</p>
<p><code>add()</code> 用于向 <code>set</code> 数据机构中添加成员</p>
<p><code>delete()</code> 用于删除数据中的某个值，返回布尔值， 表示是否删除成功</p>
<p><code>has()</code> 表示判断数据结构中是否含有某个值，返回的是布尔值，表示是否含有</p>
<p><code>clear()</code> 表示清除所有的成员，没有返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set// &#123;1,2,3,4&#125;</span><br><span class="line">set.add(5)// &#123;1,2,3,4,5&#125;</span><br><span class="line">set.has(5) // true</span><br><span class="line">set.delete(5) // true 删除成功</span><br><span class="line">set.has(5) // false</span><br><span class="line">set.clear()</span><br><span class="line">set // &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>一个数组去重操作:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function removeDeu (Array) &#123;</span><br><span class="line">  return [...new Set(Array)] // 换成 Array.from(new Set(Array)) 也是可以的</span><br><span class="line">&#125;</span><br><span class="line">使用 Array.from 也可以将Set 结构转换为数组结构</span><br></pre></td></tr></table></figure>
<h4 id="Set-实例的遍历方法"><a href="#Set-实例的遍历方法" class="headerlink" title="Set 实例的遍历方法"></a>Set 实例的遍历方法</h4><p><code>keys()</code>  返回键名的数组</p>
<p><code>values()</code> 遍历键值</p>
<p><code>entires()</code> 遍历键值对儿</p>
<p>因为 <code>Set()</code> 结构只有键值，没有键名，因此使用 <code>values()</code> 和 <code>keys()</code> 的遍历结果是一样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1,2,3,4];</span><br><span class="line">let set = new Set(arr);</span><br><span class="line">for (let key of set.keys()) &#123;</span><br><span class="line">  console.log(key)</span><br><span class="line">&#125;</span><br><span class="line">// 1,2,3,4,5</span><br></pre></td></tr></table></figure>
<p>对于set 结构可以转换为 数组结构,可以应用数组的 <code>map</code> 等方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [...set];</span><br></pre></td></tr></table></figure>
<h3 id="Map-数据结构"><a href="#Map-数据结构" class="headerlink" title="Map 数据结构"></a>Map 数据结构</h3><h4 id="基本属性-1"><a href="#基本属性-1" class="headerlink" title="基本属性"></a>基本属性</h4><p>对于对象而言，对象是有键值对的数据结构组成的，但是对于对象的键，他的格式会被转换为字符串， 即便我们传入了一个数组或者对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj = &#123;&#125;;</span><br><span class="line">let o = &#123;a: 1&#125;;</span><br><span class="line">obj[o] = &apos;content&apos;;</span><br><span class="line">for (let key in obj) &#123;</span><br><span class="line">	console.log(typeOf key)</span><br><span class="line">&#125;</span><br><span class="line">// string</span><br></pre></td></tr></table></figure>
<p>使用 <code>map</code> 结构可以实现对象的键不再必须是字符串的形式</p>
<p>创建 <code>map</code> 结构:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let map = new Map();</span><br></pre></td></tr></table></figure>
<h4 id="map-属性的方法"><a href="#map-属性的方法" class="headerlink" title="map 属性的方法"></a><code>map</code> 属性的方法</h4><p>通过 console　控制台打印数据如下</p>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/map.png" alt></p>
<p>类似于　<code>Set</code> 结构, 存在 <code>set</code> <code>get</code> <code>delete</code> <code>has</code> <code>clear</code> 等几种操作方法</p>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/map%20%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE.png" alt></p>
<p><code>set(键， 值)</code> 写入数据</p>
<p><code>get(键)</code> 从数据结构中获得对应键的值</p>
<blockquote>
<p>虽然 <code>typeof map</code> // Object 以及  <code>map instanceof Object === true</code> 但是， Map 是一种不同于对象的数据结构，在对象上使用 [ ] 访问属性的方法在 map 数据结构中是不适用的，要获得 <code>Map</code> 数据结构中的值， 我们是通过使用 <code>get</code> 方法，后面我们会说如何将 map 数据结构转换为对象</p>
</blockquote>
<p><code>delete(键)</code> 删除对应键的值</p>
<p><code>clear()</code> 将 <code>map</code> 数据中的所有数据清除</p>
<p><code>has()</code> 返回布尔值, 表示是否含有某条数据</p>
<p>使用 <code>map</code> 的数据结构不同于对象的是，通过使用 <code>map</code> 添加的键名可以是变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let map = new Map();</span><br><span class="line">let obj = &#123;a: 1&#125;;</span><br><span class="line">map.set(obj, &apos;good&apos;);</span><br><span class="line">map.get(obj) // &apos;good&apos;</span><br><span class="line">for (let key of map) &#123;</span><br><span class="line">	console.log(typeof key) // object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以是数组:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1];</span><br><span class="line">map.set(arr, &apos;good&apos;);</span><br><span class="line">map.get(arr)// &apos;good&apos;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的一点，通过使用 <code>get()</code> 获取键值的时候，最终是查找到了键值的内存地址</p>
</blockquote>
<p>代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map.set(&#123;a:1&#125;, &apos;good&apos;);</span><br><span class="line">map.get(&#123;a:1&#125;)// undefined</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，虽然查找的键值是一样的，但是两个 <code>{a:1}</code> 实际上的内存地址是不一样的。使用下面的代码可以找到对应的键值，因为变量 obj 指向了同一个对象的内存地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj = &#123;a: 1&#125;;</span><br><span class="line">map.set(obj, &apos;good&apos;);</span><br><span class="line">map.get(obj) // &apos;good&apos;</span><br></pre></td></tr></table></figure>
<hr>
<p>关于对象及内存地址:</p>
<p>每创建一个对象，总会创建一个内存地址，对于下面对象:</p>
<p><code>let person = { name: &#39;张宁宁&#39; }</code> </p>
<p>我们使用 <code>person.name</code> 来访问到值的，但是，对象的值并没有存放在<code>person</code> 容器内，<code>person</code> 中存放了对象的属性，</p>
<p>这个属性相当于指针，指向存放 <code>张宁宁</code> 的内存地址</p>
<p>例如:</p>
<p><code>{} === {}</code> // false</p>
<p>因为这两个空对象的内存地址是不一样的，所以是不相等的</p>
<hr>
<p>使用 <code>map</code> 结构可以传入数组，数组中的成员是存在两个元素的数组结构。其中第一个元素会被当作键名，第二个元素会被当作键值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let map = new Map([[&apos;name&apos;, &apos;张宁宁&apos;]]);</span><br><span class="line">map.get(&apos;name&apos;) // &apos;张宁宁&apos;</span><br></pre></td></tr></table></figure>
<h4 id="map-对象的遍历方法"><a href="#map-对象的遍历方法" class="headerlink" title="map 对象的遍历方法"></a>map 对象的遍历方法</h4><p>对于 <code>map</code> 结构的遍历，存在下面几种方法</p>
<p><code>keys()</code> 返回键名的遍历器</p>
<p><code>values()</code> 返回键值的遍历器</p>
<p><code>entires()</code> 返回所有成员的遍历器</p>
<p><code>forEach()</code> 类似于数组中的 <code>forEach()</code> 方法， 实现对于 <code>map</code> 数据结构的遍历</p>
<p>使用 <code>keys()</code> <code>values()</code> 以及 <code>entires()</code> 返回的是类数组对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let map = new Map();</span><br><span class="line">map.set(&apos;h&apos;, &apos;hello&apos;);</span><br><span class="line">map.set(&apos;g&apos;, &apos;good&apos;);</span><br><span class="line">map.keys() // &#123;&apos;h&apos;, &apos;g&apos;&#125;;</span><br><span class="line">map.values() // &#123;&apos;hello&apos;, &apos;good&apos;&#125;;</span><br><span class="line">map.entires(); // &#123;&apos;h&apos;: &apos;hello&apos;, &apos;g&apos;: &apos;good&apos;&#125;;</span><br></pre></td></tr></table></figure>
<p>使用扩展运算符可以将类数组对象转化为数组对象，从而对于类数组对象上应用各种方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[...map.keys()] // [&apos;h&apos;, &apos;g&apos;]</span><br></pre></td></tr></table></figure>
<h4 id="Map-与各种数据结构的相互转化"><a href="#Map-与各种数据结构的相互转化" class="headerlink" title="Map 与各种数据结构的相互转化"></a><code>Map</code> 与各种数据结构的相互转化</h4><ol>
<li><p>对象转为 <code>map</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function toMap (obj) &#123;</span><br><span class="line">  let map = new Map();</span><br><span class="line">  for (let key in obj) &#123;</span><br><span class="line">    map.set(key, obj[key]);</span><br><span class="line">  &#125;</span><br><span class="line">  return map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>map</code> 转化为对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function toObj (map) &#123;</span><br><span class="line">  let obj = Object.create(null);</span><br><span class="line">  for (let [k,v] of map) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ol>
]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>Map Set</tag>
      </tags>
  </entry>
  <entry>
    <title>es6-promise</title>
    <url>/2017/10/30/es6-promise/</url>
    <content><![CDATA[<h4 id="resove-and-reject"><a href="#resove-and-reject" class="headerlink" title="resove and reject"></a>resove and reject</h4><p>使用 <code>es6</code> 回调函数的例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let promise = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  if (/* 如果异步操作成功 */) &#123;</span><br><span class="line">      resolve(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在上面的函数中，调用promise 构造函数创建了一个 promise 对象, 这个构造函数接收一个函数作为参数, 在函数中存在两个参数 <code>resolve</code> 和 <code>reject</code> , 这两个参数是两个函数, 用来执行回调的作用</p>
<blockquote>
<p>resolve<br>resove 是作为异步回调成功之后需要执行的函数<br>reject<br>reject 是作为异步回调失败之后需要进行执行的函数</p>
<p>在 promise 的对象中, 可以通过进行判断来选择执行 resolve 或者 reject 函数  </p>
</blockquote>
<p>使用 <code>promise</code> 进行 <code>ajax</code> 请求的函数如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* @description promise 的 ajax 请求</span><br><span class="line">* @param url &#123;String&#125; ajax 请求的地址</span><br><span class="line">* @param method &#123;String&#125; ajax 请求的方法 &apos;get&apos; or &apos;method&apos;</span><br><span class="line">* @return promise 新的 promise 请求对象</span><br><span class="line">**/</span><br><span class="line">let ajax = function (url, method) &#123;</span><br><span class="line">  let promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    let xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.open(method, url);</span><br><span class="line">    xhr.onreadystatechange = handler;</span><br><span class="line">    xhr.responseType = &apos;json&apos;;</span><br><span class="line">    xhr.setRequestHeader(&apos;Accept&apos;, &apos;application/json&apos;);</span><br><span class="line">    xhr.send();</span><br><span class="line">    function handler() &#123;</span><br><span class="line">      if (this.readystate !== 4) &#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      if (this.status === 200) &#123;</span><br><span class="line">        resolve(this.response);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(new Error(this.statuText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">  return promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ajax(url, &apos;get&apos;).then((json) =&gt; &#123;</span><br><span class="line">  console.log(&apos;请求成功之后返回的数据&apos;, json);</span><br><span class="line">&#125;, (error) =&gt; &#123;</span><br><span class="line">  console.error(&apos;出现的错误&apos; + error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="promise-then"><a href="#promise-then" class="headerlink" title="promise.then()"></a>promise.then()</h4><p>在创建完成 promise 实例之后, 可以调用 promise.then() 中指定具体的回调成功或者失败的具体函数</p>
<blockquote>
<p>promise.then() 用于接收两个回调函数作为参数, 第一个回调函数是当 Promise 对象状态变为 resolve 的时候执行的函数,表示上面的 resolve 函数, 第二个回调函数是当 Promise 对象状态变为reject 的时候执行的函数, 也就是表示上面的 reject 函数,这两个函数都可以接收 promise 传入的值作为函数参数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">promise.then(function(value) &#123;</span><br><span class="line">  // when promise success do something</span><br><span class="line">&#125;, function(error) &#123;</span><br><span class="line">  // when promise failed do something</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="promise-all"><a href="#promise-all" class="headerlink" title="promise.all()"></a>promise.all()</h4><p>使用 promise.all() 方法用于将多个 <code>promise</code> 实例, 包装为一个 <code>promise</code> 实例</p>
<p><code>Promise.all([promise1, promise2, promise3])</code></p>
<p>使用 <code>Promise.all</code> 接收的是一个数组作为参数， 其中 <code>promise1</code> <code>promise2</code> <code>promise3</code> 分别是 <code>Promise</code> 的实例</p>
<p>关于使用 <code>Promise.all</code> 的状态:</p>
<ol>
<li>只有 <code>promise1 promise2 promise3</code> 的状态都变成了 <code>fullfilled</code> 的状态,  <code>Promise.all</code> 的状态才会变成 <code>fullfilled</code> 并且三个 <code>promise</code> 的返回值组成一个数组, 传递给 <code>Promise.all</code> 的回调函数。 </li>
<li>当三个 <code>promise</code> 中存在一个为 <code>reject</code> 的时候, <code>Promise.all</code> 的状态就会变成 <code>reject</code> , 这个时候 ,  被  <code>reject</code>    实例 的返回值被传递给<code>Promise.all</code> 的回调函数.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const firstNamePromise = namePromise.then(getFirstName);</span><br><span class="line">const lastNamePromise = namePromise.then(getLastName);</span><br><span class="line">Promise.all([firstNamePromise, lastNamePromise]).then(([firstName, lastName]) =&gt; nextAction(firstName, lastName));</span><br></pre></td></tr></table></figure>
<p>注意: 上面使用到了对于对象的解构赋值操作, 在上面的函数中 </p>
<p>firstNamePromise 的返回值被赋给 firstName,  lastNamePromise 的返回值被赋给 lastName</p>
<p>++++</p>
<p>对于对象的解构赋值而言,我们可以这样赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a = 2;</span><br><span class="line">let b = 3;</span><br><span class="line">// 这样</span><br><span class="line">let [a, b] = [2, 3];</span><br></pre></td></tr></table></figure>
<p>++++</p>
<h4 id="promise-race"><a href="#promise-race" class="headerlink" title="promise .race()"></a>promise .race()</h4><p>使用 <code>promise.race()</code> 类似于 <code>promise.all</code> 方法, 将多个 <code>promise</code> 实例包装为一个 <code>promise</code> 方法</p>
<p><code>let p = promise.race([p1, p2, p3])</code>  </p>
<p>只要上面的 <code>p1, p2, p3</code> 中有一个的实例率先发生变化, 那么 <code>p</code> 的状态就会发生变化, 率先发生变化的返回值就会传递给 <code>p</code> 函数。</p>
<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><h5 id="promise-finally"><a href="#promise-finally" class="headerlink" title="promise.finally"></a><code>promise.finally</code></h5><p>使用 <code>promise.finally</code> 的方法的作用在于: 不管 <code>promise</code> 的最后的状态是什么, 使用 <code>promise.finally</code> 内的回调函数始终会被执行;</p>
<p>例如: 请求之前的指示器打开或者关闭：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.indicator.show();</span><br><span class="line">let promise = new Promise();</span><br><span class="line">promise.then(</span><br><span class="line">// callback success fn</span><br><span class="line">).catch(e =&gt; &#123;</span><br><span class="line">  this.toast(e.message)</span><br><span class="line">&#125;).finally(() =&gt; &#123;</span><br><span class="line">  this.indicator.hide()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>es6:变量的解构赋值</title>
    <url>/2017/09/09/es6-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
    <content><![CDATA[<h3 id="es6的数值解构赋值"><a href="#es6的数值解构赋值" class="headerlink" title="es6的数值解构赋值"></a>es6的数值解构赋值</h3><h4 id="1-es6-允许使用一定的方式从数组或者对象中提取数值，从而对于同样模式的变量进行赋值操作，代码如下"><a href="#1-es6-允许使用一定的方式从数组或者对象中提取数值，从而对于同样模式的变量进行赋值操作，代码如下" class="headerlink" title="1.es6 允许使用一定的方式从数组或者对象中提取数值，从而对于同样模式的变量进行赋值操作，代码如下:"></a>1.es6 允许使用一定的方式从数组或者对象中提取数值，从而对于同样模式的变量进行赋值操作，代码如下:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let [a,b,c] = [1,2,3]</span><br><span class="line">a // 1</span><br><span class="line">b // 2</span><br><span class="line">c // 3</span><br><span class="line">类似:</span><br><span class="line">let a = 1</span><br><span class="line">let b = 2</span><br><span class="line">let c = 3</span><br></pre></td></tr></table></figure>
<p>使用数组形式进行解构赋值的时候要注意到，两边其实并不是数组，而只是数组的形式</p>
<p>对于等号两边必须是数组的形式，如果是其他的形式，那么就会报错:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let [a] = &#123;&#125;;</span><br><span class="line">let [a] = null;</span><br><span class="line">let [a] = undefined;</span><br><span class="line">let [a] = NaN;</span><br><span class="line">let [a] = 1;</span><br></pre></td></tr></table></figure>
<p>上面的几种形式都会被报错</p>
<h4 id="2-使用结构变量可以初始数组"><a href="#2-使用结构变量可以初始数组" class="headerlink" title="2.使用结构变量可以初始数组"></a>2.使用结构变量可以初始数组</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let [a,...b] = [1,2,3,4];</span><br><span class="line">b // [2,3,4]</span><br></pre></td></tr></table></figure>
<p>使用扩展运算符可以将多个数合并为一个数组</p>
<h4 id="3-可以在解构赋值的时候使用默认值操作"><a href="#3-可以在解构赋值的时候使用默认值操作" class="headerlink" title="3.可以在解构赋值的时候使用默认值操作"></a>3.可以在解构赋值的时候使用默认值操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let [x = 1] = [];</span><br><span class="line">x //  x 在没有被赋值的时候默认使用 1</span><br><span class="line">let [x = 1] = [2];</span><br><span class="line">x // 2</span><br><span class="line">当 x 存在明显只的时候默认值失效</span><br><span class="line">// 对于使用默认值, 还可以使用函数的返回值</span><br><span class="line">function fn() &#123;</span><br><span class="line">  return 23</span><br><span class="line">&#125;</span><br><span class="line">let [a = fn()] = [45];</span><br><span class="line">// 这里 因为 a 能够取到值, 因此不会执行 fn 函数</span><br><span class="line">console.log(a); // 45</span><br></pre></td></tr></table></figure>
<p>默认值可以引用其他结构值的对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let [x = 1, y = x] = [];</span><br><span class="line">x // 1</span><br><span class="line">y // 1</span><br></pre></td></tr></table></figure>
<p>注意: 对于赋值操作两端的值, 在赋值操作两端执行的是 <code>===</code> 全等操作， 因此</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let [a = 1] = [null]</span><br><span class="line">a // null</span><br><span class="line">let [a = 1] = [undefined]</span><br><span class="line">a // 1</span><br></pre></td></tr></table></figure>
<h3 id="es6-中对于对象的解构赋值操作"><a href="#es6-中对于对象的解构赋值操作" class="headerlink" title="es6 中对于对象的解构赋值操作"></a>es6 中对于对象的解构赋值操作</h3><p>代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">	name: &apos;张宁宁&apos;,</span><br><span class="line">	home: &apos;山东&apos;</span><br><span class="line">&#125;;</span><br><span class="line">let &#123;name, home&#125; = person;</span><br><span class="line">name // &apos;张宁宁&apos;</span><br><span class="line">home // &apos;山东&apos;</span><br></pre></td></tr></table></figure>
<p>这种写法无非是下面这种写法的简写:`</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let &#123;name: name, home: home&#125; = person;</span><br></pre></td></tr></table></figure>
<p>实际上:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let &#123;name: perName, home: perHome&#125; = person;</span><br><span class="line">perName //  &apos;张宁宁&apos;</span><br></pre></td></tr></table></figure>
<p>等号左边中 <code>name</code> 用于进行模式匹配，在 <code>person</code> 中找到 <code>name</code> 之后，将 <code>name</code> 的值赋给 <code>perName</code></p>
<p>使用对象的形式解构也可以赋予默认值：</p>
<p>当在等号右边的对象中找不到对应的属性的时候, 会使用括号内被默认赋予的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let &#123;x = 1, y = 5&#125; = &#123;x: 2&#125;</span><br><span class="line">x // 2</span><br><span class="line">y // 5</span><br></pre></td></tr></table></figure>
<h3 id="es6-中对于字符串的解构赋值"><a href="#es6-中对于字符串的解构赋值" class="headerlink" title="es6 中对于字符串的解构赋值"></a>es6 中对于字符串的解构赋值</h3><p>当对于字符串进行解构赋值操作的时候，字符串会被转换为类似数组的对象:</p>
<p>这意味着我们可以通过使用数组或者对象的方式进行解构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let [a,b,c,d,e] = &apos;hello&apos;;</span><br><span class="line">a // &apos;h&apos;</span><br><span class="line">b // &apos;e&apos;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let &#123;length&#125; = &apos;hello&apos;;</span><br><span class="line">length // 5</span><br><span class="line">因为使用解构的时候， 字符串对象含有一个 length 属性</span><br></pre></td></tr></table></figure>
<h3 id="函数参数的解构"><a href="#函数参数的解构" class="headerlink" title="函数参数的解构"></a>函数参数的解构</h3><p>1.数组形式进行解构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function move([x,y]) &#123;</span><br><span class="line">  return x + y</span><br><span class="line">&#125;</span><br><span class="line">move([1,2]);</span><br><span class="line">// 这里虽然传入的是一个数组，实际上传入函数之后会被解构</span><br></pre></td></tr></table></figure>
<p>2.对象形式进行解构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function person(&#123;name, home&#125;) &#123;</span><br><span class="line">	console.log(home, name)</span><br><span class="line">&#125;</span><br><span class="line">let per = &#123;</span><br><span class="line">  name: &apos;张宁宁&apos;,</span><br><span class="line">  home: &apos;china&apos;</span><br><span class="line">&#125;</span><br><span class="line">person(per)//  china 张宁宁</span><br></pre></td></tr></table></figure>
<p>3.使用对象形式赋予默认值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function person (&#123;name = &apos;张宁宁&apos;, home = &apos;china&apos;&#125; = &#123;&#125;) &#123;</span><br><span class="line">	console.log(name, home)</span><br><span class="line">&#125;</span><br><span class="line">person(); // 张宁宁  china</span><br><span class="line">和上面结果相同， 因为传入的是一个空对象，没有找到相应的属性，因此采用默认赋予的值进行操作</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="使用参数解构中的小技巧"><a href="#使用参数解构中的小技巧" class="headerlink" title="使用参数解构中的小技巧"></a>使用参数解构中的小技巧</h3><ol>
<li><p>提取函数的返回值:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function bar () &#123;</span><br><span class="line">  return [1, 2]</span><br><span class="line">&#125;</span><br><span class="line">let [a, b] = bar ();</span><br><span class="line">a // 1</span><br><span class="line">b // 2</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用解构分离对象的键值对</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arrObj = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">// 取得数组对象中值对应的键</span><br><span class="line">function getKey( arrobj, objValue) &#123;</span><br><span class="line">  for (const obj of arrobj) &#123;</span><br><span class="line">  // 使用 &#123;&#125; 实现对象的解构赋值</span><br><span class="line">    let &#123;key, value&#125; = obj;</span><br><span class="line">    if (value === objValue) &#123;</span><br><span class="line">      return key;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getKey(arrObj, &apos;someObjValue&apos;)</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ol>
]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>变量解构赋值</tag>
      </tags>
  </entry>
  <entry>
    <title>es6: 对象的扩展</title>
    <url>/2017/09/17/es6-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h3 id="es6-中对象扩展的用法"><a href="#es6-中对象扩展的用法" class="headerlink" title="es6 中对象扩展的用法"></a>es6 中对象扩展的用法</h3><h4 id="1-简洁属性名"><a href="#1-简洁属性名" class="headerlink" title="1.简洁属性名"></a>1.简洁属性名</h4><p>函数的属性可以是一个变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let foo = &apos;good&apos;;</span><br><span class="line">let bar = &#123;</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line">console.log(bar.foo); // &apos;good&apos;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>es6 中我们可以直接传入一个变量到对象中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let foo = &apos;good&apos;;</span><br><span class="line">let bar = &#123;</span><br><span class="line">    foo</span><br><span class="line">&#125;;</span><br><span class="line">console.log(bar.foo); // &apos;good&apos; </span><br><span class="line">//传入的变量名会被作为对象的属性名，变量的值会被作为对象属性的值</span><br></pre></td></tr></table></figure>
</li>
<li><p>用在函数中返回一个对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">  let age = 22;</span><br><span class="line">  return &#123;name, age&#125;;</span><br><span class="line">&#125;</span><br><span class="line">person(&apos;张宁宁&apos;)// &#123;name: &apos;张宁宁&apos;, age: 22&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="2-Object-is-判断相等"><a href="#2-Object-is-判断相等" class="headerlink" title="2.  Object.is( ) 判断相等"></a>2.  Object.is( ) 判断相等</h4><p>对于比较两个值是否相等，使用 全等 <code>===</code> 运算符进行判断, 因为使用 <code>==</code> 会自动转换数据类型</p>
<p>使用 <code>===</code> 有缺点： NAN === NAN  flase  以及  +0 === -0 false</p>
<p>使用 <code>object.is</code> 可以解决这个缺点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">object.is(1,1) // true</span><br><span class="line">object.is(1,&apos;1&apos;) // false</span><br><span class="line">object.is(NaN, NaN) // true</span><br><span class="line">Object.is(+0, -0) //  true</span><br></pre></td></tr></table></figure>
<hr>
<p>使用<code>==</code> 或者 <code>===</code> 进行相等比较的时候，实际上，是无法进行比较对象的，因为对象是一个指针，指向存储对象数据的内存地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">object.is(&#123;&#125; , &#123;&#125;); // false</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="3-Object-assign-合并对象"><a href="#3-Object-assign-合并对象" class="headerlink" title="3. Object.assign () 合并对象"></a>3. Object.assign () 合并对象</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let t = &#123;&#125;;</span><br><span class="line">let s1 = &#123; a: 1 &#125;;</span><br><span class="line">let s2 = &#123; b: 2 &#125;;</span><br><span class="line">Object.assign(t, s1, s2);</span><br><span class="line">// &#123;a: 1, b: 2&#125;</span><br></pre></td></tr></table></figure>
<p>上面中将对象 s1, s2,  合并入 t 中；</p>
<p>传入值的情况:</p>
<ul>
<li>如果只有一个参数，使用这种方法会返回这个参数</li>
<li>如果传入的一个参数是 Null 或者 undefined 机会报错</li>
<li>要进行合并的参数是字符串的情况下，会返回该字符串的对象,传入非对象，非字符串的其他值，无效</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.assign(&#123;&#125;, &apos;string&apos;);</span><br><span class="line">// &#123;0: &quot;s&quot;, 1: &quot;t&quot;, 2: &quot;r&quot;, 3: &quot;i&quot;, 4: &quot;n&quot;, 5: &quot;g&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>使用 Object.assign () 返回的是对象的形式</p>
<p>使用 Object.assign() 实现浅拷贝</p>
<h4 id="4-Object-keys-Object-values-Object-entires"><a href="#4-Object-keys-Object-values-Object-entires" class="headerlink" title="4. Object.keys()   Object.values()   Object.entires()"></a>4. Object.keys()   Object.values()   Object.entires()</h4><ol>
<li><p><code>Object.keys()</code></p>
<p>使用这种方法得到的是对象中所有可遍历的属性名组成的数组</p>
</li>
<li><p><code>Object.values()</code></p>
<p>使用这种方法得到的是对象自身所有可以遍历到的属性的值</p>
</li>
<li><p><code>Object.entires()</code></p>
<p>使用这种方法得到的数组，数组中包括对象自身所有可遍历得到的属性的键值对儿数组</p>
</li>
</ol>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol>
<li><p>判断对象内是否是空对象的方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isEmpty = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="keyword">return</span> <span class="built_in">Object</span>.keys(obj) === <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>Object.assign</code> 实现自定义配置覆盖默认配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toConfig</span>(<span class="params">defaultConfig, config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(defaultConfig, config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ol>
]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>对象扩展</tag>
      </tags>
  </entry>
  <entry>
    <title>grid 布局（一）</title>
    <url>/2018/08/18/grid-%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p><code>grid</code> 布局是一种方便的用于创建网格布局的强大工具， 使用<code>grid</code> 布局可以很方便的构建网页结构， 本篇文章主要介绍<code>grid</code> 布局的基础知识。</p>
<h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><p>使用 <code>grid</code> 布局实现一个九宫格:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item9"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现的九宫格如下所示:</p>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/grid%282%29.png" alt></p>
<h4 id="display-grid"><a href="#display-grid" class="headerlink" title="display: grid"></a>display: grid</h4><p>使用 <code>display: grid</code> 的目的是用于声明当前元素使用 <code>grid</code> 布局构建;</p>
<p>常用值:</p>
<ul>
<li><code>grid</code>: 生成一个块状网格</li>
<li><code>inline-grid</code>: 生成一个内联网格</li>
<li><code>subgrid</code>: 表示当前的网格容器继承自父级元素的网格容器</li>
</ul>
<h4 id="grid-template-columns-grid-template-rows"><a href="#grid-template-columns-grid-template-rows" class="headerlink" title="grid-template-columns,  grid-template-rows"></a>grid-template-columns,  grid-template-rows</h4><p>这两个属性用于在声明 <code>grid</code> 的当前元素内部划分网格内容。后面的数值表明网格内容的长度大小， 数值之间的空格表示划分网格的网格线。</p>
<p><code>grid-template-columns</code> : 用于在网格元素划分列， 后面的值表示划分列的宽度， 比如上面的九宫格代码中， 表示将当前的元素划分为 3 列， 且三列的宽度均是 100px;</p>
<p><code>grid-template-row</code>: 使用效果类似于 <code>grid-template-columns</code>, 是对于 <code>grid</code> 元素行的划分。比如上面的代码中表示将 <code>grid</code> 元素划分为三行， 并且三行的高度均为 <code>100px</code>;</p>
<p>常用值:</p>
<ul>
<li><code>&lt;track-name&gt;&lt;track-size&gt;&lt;track-name&gt;&lt;track-size&gt;...</code></li>
</ul>
<p><code>track-size</code>: 表示网格内容的宽度，可取值:</p>
<ul>
<li><code>percentage</code> </li>
<li><code>数值</code></li>
<li><code>auto</code>: 网格宽度的剩余空间</li>
<li><code>fr</code>: 表示等份网格容器中的可用空间</li>
</ul>
<p><code>track-name</code>: 表示网格之间网格线的名称</p>
<p>式例:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: [line-start] <span class="number">50px</span> [line1-start] <span class="number">20%</span> [line2-start] <span class="number">1</span>fr [line-end];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下:</p>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/grid%283%29.png" alt></p>
<p><strong>当 auto 和 <code>fr</code> 同时存在的时候， 优先级： <code>auto</code> &gt; <code>fr</code>, 这个时候 , 声明 <code>auto</code> 的那一列宽度为 0</strong></p>
<h4 id="grid-template-areas"><a href="#grid-template-areas" class="headerlink" title="grid-template-areas"></a>grid-template-areas</h4><p>使用 <code>grid-template-areas</code> 用来定义网络模板；</p>
<p>常用值:</p>
<ul>
<li><code>grid-area-name</code> : 由网格项的 <code>grid-area</code> 指定的网格区域名称</li>
<li><code>.</code> 表示一个空的网格单元</li>
<li><code>none</code> 表示不定义网格区域</li>
</ul>
<p>例如下面实现的一个网页布局:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"menu"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"body"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">1</span>fr);</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="built_in">repeat</span>(<span class="number">1</span>fr);</span><br><span class="line">  // 这里的 h, m , b, f是和下面声明的 `grid-area` 是一一对应的</span><br><span class="line">  <span class="selector-tag">grid-template-areas</span>: </span><br><span class="line">    "<span class="selector-tag">h</span> <span class="selector-tag">h</span> <span class="selector-tag">h</span> <span class="selector-tag">h</span>"</span><br><span class="line">    "<span class="selector-tag">m</span> . <span class="selector-tag">b</span> <span class="selector-tag">b</span>"</span><br><span class="line">    "<span class="selector-tag">f</span> <span class="selector-tag">f</span> <span class="selector-tag">f</span> <span class="selector-tag">f</span>";</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: h;</span><br><span class="line">  <span class="attribute">background-color</span>: lightcoral;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.menu</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: m;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.body</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: b;</span><br><span class="line">  <span class="attribute">background-color</span>: lightslategray</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: f;</span><br><span class="line">  <span class="attribute">background-color</span>: lightseagreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下:</p>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/grid%284%29.png" alt></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>grid 布局</tag>
      </tags>
  </entry>
  <entry>
    <title>my first blog</title>
    <url>/2017/08/18/my-first-blog/</url>
    <content><![CDATA[<p>这是我的第一篇博客:<br>折腾来折腾去终于搭建起来github博客，还好中间没有遇到太大的问题，搭建过程也还算顺利。  </p>
<p>为什么要写博客？为了记录下自己前端学习中的一些知识点，在写代码的过程中，总结经验，提高自己的编程水平，写下自己在编程中遇到的问题，思考，以及是如何解决的，不断提高自己。</p>
<p>千里之行，始于足下</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>0</tag>
      </tags>
  </entry>
  <entry>
    <title>node 中的 events 模块学习</title>
    <url>/2019/09/08/event%20Emitter/</url>
    <content><![CDATA[<p><a href="https://link.zhihu.com/?target=https%3A//github.com/nodejs/node/blob/master/lib/events.js" target="_blank" rel="noopener">events 模块</a></p>
<p>模仿 events 模块的一些代码， 基本实现原 events 模块的一些功能：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneArray</span>(<span class="params">list, n, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> clonedArr = <span class="keyword">new</span> <span class="built_in">Array</span>(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; n; index++) &#123;</span><br><span class="line">    clonedArr[index] = fn ? fn(list[index]) : list[index];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clonedArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clonelisteners</span>(<span class="params">list, hasWrap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cloneArray(list, list.length, (listener) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> hasWrap ? listener : (listener.listener || listener);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getListeners</span>(<span class="params">target, type, hasWrap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> listenerList = target.events[type];</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> listenerList === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> hasWrap ? [listenerList] : [listenerList.listener || listenerList];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> clonelisteners(listenerList, hasWrap);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.maxListeners;</span><br><span class="line">    <span class="keyword">this</span>.defaultMaxlisteners = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">this</span>.events = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">this</span>.eventsCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">  &#125;</span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">this</span>.maxListeners = <span class="keyword">this</span>.maxListeners || <span class="keyword">this</span>.defaultMaxlisteners;</span><br><span class="line">    <span class="keyword">this</span>.events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  checkListener(listener) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'listener is not function type'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  listenerCount(emitter, type) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> emitter.listenerCount === <span class="string">'function'</span>) <span class="keyword">return</span> emitter.listenerCount(type);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">listenerCount</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> events = <span class="keyword">this</span>.events;</span><br><span class="line">      <span class="keyword">if</span> (events === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">const</span> eventList = <span class="keyword">this</span>.events[type];</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> eventList === <span class="string">'function'</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (eventList) &#123;</span><br><span class="line">        <span class="keyword">return</span> eventList.length;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;;</span><br><span class="line">    listenerCount.call(emitter, type);</span><br><span class="line">  &#125;</span><br><span class="line">  prependListener(type, listener) &#123;</span><br><span class="line">    <span class="keyword">this</span>.addListeners(type, listener, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  prependOnceListener(type, listener) &#123;</span><br><span class="line">    <span class="keyword">this</span>.once(type, listener, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  addListeners(type, listener, prepend) &#123;</span><br><span class="line">    <span class="keyword">this</span>.checkListener(listener);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.events) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.events.newListener) <span class="keyword">this</span>.emit(<span class="string">'newListener'</span>, listener.listener || listener);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> existlistener = <span class="keyword">this</span>.events[type];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> existlistener === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.events[type] = prepend ? [listener, existlistener] : [existlistener, listener];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> existlistener === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.events[type] = listener;</span><br><span class="line">      <span class="keyword">this</span>.eventsCount ++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prepend) &#123;</span><br><span class="line">      <span class="keyword">this</span>.events[type].unshift(listener);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.events[type].push(listener);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> maxlistenerLength = <span class="keyword">this</span>.getMaxlisteners();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.events[type].length &gt; maxlistenerLength) &#123;</span><br><span class="line">      <span class="keyword">let</span> w = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'memory leak'</span>);</span><br><span class="line">      process.emitWarning(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  on() &#123;</span><br><span class="line">    <span class="keyword">this</span>.addListeners(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">  off() &#123;</span><br><span class="line">    <span class="keyword">this</span>.removeListener(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">  once(type, listener, prepend) &#123;</span><br><span class="line">    <span class="keyword">this</span>.checkListener(listener);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">wrapFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.fired) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fired = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.emitter.removeListener(type, <span class="keyword">this</span>.wraplistenerFn);</span><br><span class="line">        <span class="keyword">this</span>.listener.apply(<span class="keyword">this</span>.emitter, <span class="built_in">arguments</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> listenerWrapStates = &#123; <span class="attr">fired</span>: <span class="literal">false</span>, listener, <span class="attr">wraplistenerFn</span>: <span class="literal">undefined</span>, <span class="attr">emitter</span>: <span class="keyword">this</span> &#125;;</span><br><span class="line">    <span class="keyword">const</span> wrapedlistener = wrapFn.bind(listenerWrapStates);</span><br><span class="line">    wrapedlistener.listener = listener;</span><br><span class="line">    listenerWrapStates.wraplistenerFn = wrapedlistener;</span><br><span class="line">    <span class="keyword">this</span>.on(type, wrapedlistener, prepend);</span><br><span class="line">  &#125;</span><br><span class="line">  emit(type, ...args) &#123;</span><br><span class="line">    <span class="keyword">const</span> existlistener = <span class="keyword">this</span>.events[type];</span><br><span class="line">    <span class="keyword">if</span> (existlistener === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> existlistener !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> existList = cloneArray(existlistener, existlistener.length);</span><br><span class="line">      existList.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> &#123;</span><br><span class="line">        listener.apply(<span class="keyword">this</span>, args);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      existlistener.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  removeAlllisteners(type) &#123;</span><br><span class="line">    <span class="keyword">const</span> listenerList = <span class="keyword">this</span>.events[type];</span><br><span class="line">    <span class="keyword">const</span> isRemoveAllEvens = <span class="built_in">arguments</span>.length === <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.events === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 移除全部的 listernr</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.events.removeListener === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isRemoveAllEvens) &#123;</span><br><span class="line">        <span class="keyword">this</span>.events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.eventsCount = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (listenerList) &#123;</span><br><span class="line">          <span class="keyword">delete</span> <span class="keyword">this</span>.events[type];</span><br><span class="line">          <span class="keyword">this</span>.eventsCount --;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.eventsCount === <span class="number">0</span>) <span class="keyword">this</span>.events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">        &#125; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isRemoveAllEvens) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="keyword">this</span>.events) &#123;</span><br><span class="line">          <span class="keyword">if</span> (key === <span class="string">'removeListener'</span>) <span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">this</span>.removeAlllisteners(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.removeAlllisteners(<span class="string">'removeListener'</span>);</span><br><span class="line">        <span class="keyword">this</span>.eventsCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> listenerList === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.removeListener(type, listenerList);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (listenerList) &#123;</span><br><span class="line">      listenerList.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.removeListener(type, listener);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  setMaxlisteners(num) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> num !== <span class="string">'number'</span> || num &lt; <span class="number">0</span> || <span class="built_in">Number</span>.isNaN(num)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'listernrs length is a number'</span>);</span><br><span class="line">    <span class="keyword">this</span>.maxListeners = num;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  getMaxlisteners() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.maxListeners;</span><br><span class="line">  &#125;</span><br><span class="line">  eventNames() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.events === <span class="literal">undefined</span> || <span class="keyword">this</span>.eventsCount === <span class="number">0</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.events);</span><br><span class="line">  &#125;</span><br><span class="line">  rawListeners(type) &#123;</span><br><span class="line">    <span class="keyword">const</span> eventList = <span class="keyword">this</span>.events[type];</span><br><span class="line">    <span class="keyword">if</span> (eventList === <span class="literal">undefined</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">return</span> getListeners(<span class="keyword">this</span>, type, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  listeners(type) &#123;</span><br><span class="line">    <span class="keyword">const</span> eventList = <span class="keyword">this</span>.events[type];</span><br><span class="line">    <span class="keyword">if</span> (eventList === <span class="literal">undefined</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">return</span> getListeners(<span class="keyword">this</span>, type, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  removeListener(type, listener) &#123;</span><br><span class="line">    <span class="keyword">this</span>.checkListener(listener);</span><br><span class="line">    <span class="keyword">const</span> eventListeners = <span class="keyword">this</span>.events[type];</span><br><span class="line">    <span class="keyword">if</span> (eventListeners === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> eventListeners === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (eventListeners === listener || eventListeners.listener === listener) &#123;</span><br><span class="line">        <span class="keyword">this</span>.eventsCount --;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.eventsCount === <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">delete</span> <span class="keyword">this</span>.events[type];</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.events.removeListener) &#123;</span><br><span class="line">            <span class="keyword">this</span>.emit(<span class="string">'removeListener'</span>, type, eventListeners || eventListeners.listener);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 当存放的事件是一个数组的时候</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> handlerIndex = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">let</span> originlistener;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; eventListeners.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventListeners[i] === listener || eventListeners[i].listener === listener) &#123;</span><br><span class="line">          handlerIndex = i;</span><br><span class="line">          originlistener = eventListeners[i].listener;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (handlerIndex &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">if</span> (handlerIndex === <span class="number">0</span>) &#123;</span><br><span class="line">        eventListeners.shift();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> spliceOne = <span class="function"><span class="keyword">function</span> (<span class="params">list, index</span>) </span>&#123;</span><br><span class="line">          list.splice(index, <span class="number">1</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        spliceOne(eventListeners, handlerIndex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (eventListeners.length === <span class="number">1</span>) <span class="keyword">this</span>.events[type] = eventListeners[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.events.removeListener) <span class="keyword">this</span>.emit(<span class="keyword">this</span>.removeListener, type, originlistener || listener); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = EventEmitter;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>node module</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>js 中数据结构的实现</title>
    <url>/2018/01/13/js-%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>对于线性表而言， 使用链式的存储结构可以提高相对于使用线性表添加和删除节点的操作效率。  对于链表中的每一个元素，除了需要存储其本身的信息之外，还需要存储一个显示后面元素位置的信息。</p>
<h4 id="单链表的实现"><a href="#单链表的实现" class="headerlink" title="单链表的实现"></a>单链表的实现</h4><p>实现单向链式列表的代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 对于链表中的元素包含有 element 以及 next</span></span><br><span class="line">  <span class="comment">// element 表示数据</span></span><br><span class="line">  <span class="comment">// next 表示指向下一个的指针</span></span><br><span class="line">  <span class="keyword">let</span> Node = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element;</span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> length = <span class="number">0</span>, head = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// append 添加元素</span></span><br><span class="line">  <span class="keyword">this</span>.append = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element), current;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">      head = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      current = node;</span><br><span class="line">      <span class="comment">// 使用 while 进行循环操作</span></span><br><span class="line">      <span class="comment">// 一直进行循环, current = current.next;</span></span><br><span class="line">      <span class="keyword">while</span> (current.next) &#123;</span><br><span class="line">        current = current.next;</span><br><span class="line">      &#125;</span><br><span class="line">      current.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    length++;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// this.insert 用于插入节点</span></span><br><span class="line">  <span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span> (<span class="params">position, element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position &gt; <span class="number">0</span> &amp;&amp; position &lt;= length) &#123;</span><br><span class="line">      <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element), currrent = head, previous, index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">        node.next = current;</span><br><span class="line">        head = node;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">          previous = current;</span><br><span class="line">          current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = current;</span><br><span class="line">        previous.next = node;</span><br><span class="line">      &#125;;</span><br><span class="line">      length++;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 删除某一个位置处的元素</span></span><br><span class="line">  <span class="keyword">this</span>.removeAt = <span class="function"><span class="keyword">function</span> (<span class="params">position</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position &gt; <span class="number">-1</span> &amp;&amp; position &lt; length) &#123;</span><br><span class="line">      <span class="keyword">let</span> current = head, previous, index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">        head = currrent.next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">          previous = current;</span><br><span class="line">          current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在删除了某一个元素之后</span></span><br><span class="line">        <span class="comment">// previous.next 指向 current.next</span></span><br><span class="line">        previous.next = current.next;</span><br><span class="line">      &#125;;</span><br><span class="line">      length--;</span><br><span class="line">      <span class="keyword">return</span> current.element;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 移除某一个节点</span></span><br><span class="line">  <span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> current = head, previous;</span><br><span class="line">    <span class="keyword">if</span> (element === current.element) &#123;</span><br><span class="line">      head = current.next;</span><br><span class="line">      length--;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    previous = current;</span><br><span class="line">    current = current.next;</span><br><span class="line">    <span class="keyword">while</span>(currrent) &#123;</span><br><span class="line">      <span class="keyword">if</span> (element === current.element) &#123;</span><br><span class="line">        previous.next = current.next;</span><br><span class="line">        length--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 继续轮询下一个元素</span></span><br><span class="line">        previous = current;</span><br><span class="line">        current = current.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// this.remove 用于删除最后一个节点</span></span><br><span class="line">  <span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> current = head, previous;</span><br><span class="line">    <span class="keyword">if</span> (length === <span class="number">1</span>) &#123;</span><br><span class="line">      head = <span class="literal">null</span>;</span><br><span class="line">      length--;</span><br><span class="line">      <span class="keyword">return</span> current.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(current.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">      previous = current;</span><br><span class="line">      current.current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    previous.next = <span class="literal">null</span>;</span><br><span class="line">    length--;</span><br><span class="line">    <span class="keyword">return</span> current.element;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// indexOf 获取到索引值</span></span><br><span class="line">  <span class="keyword">this</span>.indexOf = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> current = head, index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(current) &#123;</span><br><span class="line">      <span class="keyword">if</span> (element === current.element) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">      &#125;</span><br><span class="line">      index++;</span><br><span class="line">      current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length === <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> current = head, str = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">while</span>(current) &#123;</span><br><span class="line">      str+= current.element;</span><br><span class="line">      currrent = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.getHead = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于线性表的链式存储结构而言，链表中每一个节点包含数据域与指针域，相对于使用线性表的顺序存储结构而言， 在链表中数据的存储是没有特定的顺序的，在链表中， 节点之间的关系是通过其本身存储的指针来进行体现的。 指针表示的是线性表中的数据元素与数据元素之间的关系。  </p>
<p>对于链表而言，我们想要获取到第 i 个元素的值比较麻烦的， 因为对于第 i 个元素  a ~i~ 的存储地址放在了链表中上一个节点中的指针域中，同理， 这个节点的存储地址有被放在了上上一个节点中的指针域中…..，如果要查找到这个元素，要使用下面的算法:</p>
<ol>
<li>声明节点指向链表的第一个节点， 初始化 j 从 1 开始。</li>
<li>当 j &lt; i 的时候，遍历链表， 使 p 的指针向后移动， 不断指向下一个节点， j 累加 1;</li>
<li>如果链表末尾为空， 那么说明第 i 个元素不存在。</li>
<li>如果查找成功的话，返回查找到的数据。</li>
</ol>
<p>对于上面的单链表程序而言， 我们可以添加一个获得相关位置的元素的方法:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.getEle = <span class="function"><span class="keyword">function</span> (<span class="params">elementIndex</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> current = head, index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (elementIndex &gt; <span class="number">0</span> &amp;&amp; elementIndex &lt;= length) &#123;</span><br><span class="line">    <span class="comment">// while 内嵌 current = current.next 方法， 从头开始查询</span></span><br><span class="line">    <span class="keyword">while</span>(current) &#123;</span><br><span class="line">      <span class="keyword">if</span> (index === elementIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span> current.element;</span><br><span class="line">      &#125;</span><br><span class="line">      index++;</span><br><span class="line">      current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>链表的使用相对于使用线表而言, 对于链表之间的数据关系是通过使用指针进行体现的</p>
</blockquote>
<p>实现一个对象链表的实现；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">linkTable</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> linkArray = [];</span><br><span class="line">	<span class="keyword">const</span> getLinks = <span class="function">(<span class="params">now, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> len = arr.length;</span><br><span class="line">		<span class="keyword">let</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> next = <span class="number">0</span>;</span><br><span class="line">        pre = index - <span class="number">1</span>;</span><br><span class="line">        next = index + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">        	pre = len - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index === len - <span class="number">1</span>) &#123;</span><br><span class="line">        	next = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        linkArray.push(&#123;</span><br><span class="line">            pre: arr[pre],</span><br><span class="line">            current: now,</span><br><span class="line">            next: arr[next]</span><br><span class="line">        &#125;);</span><br><span class="line">	&#125;;</span><br><span class="line">		array.forEach(<span class="function">(<span class="params">now, index, arr</span>) =&gt;</span> getLinks(now, index, arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>js 链表</tag>
      </tags>
  </entry>
  <entry>
    <title>js-Worker</title>
    <url>/2019/10/27/js-Worker/</url>
    <content><![CDATA[<h2 id="What-is-the-worker"><a href="#What-is-the-worker" class="headerlink" title="What is the worker"></a>What is the worker</h2><p>浏览器是多线程的， 在浏览器中，存在下面几个线程：</p>
<ul>
<li>浏览器事件触发线程</li>
<li>UI 渲染线程</li>
<li>JS 引擎线程</li>
<li>定时触发器线程</li>
<li>http 请求线程</li>
</ul>
<p>js 语言的一个重要特征是单线程，因为在js 中会设计到一些页面交互的逻辑， 比如操作 dom 树， css 样式树等， 单线程的设计避免了复杂的同步问题。</p>
<p>因为在 js 中我们是可以进行 dom 操作的， 因此 UI 渲染线程和 js 引擎线程是互斥的，如果我们在页面上要进行一些耗时较大的 js 逻辑计算的时候， 页面可能会出现卡顿现象。</p>
<p>为了利用多核 CPU 的计算能力，在 HTML5 中引入的工作线程使得浏览器端的 JavaScript 引擎可以并发地执行 JavaScript 代码，但是引入的工作线程并没有改变 js 单线程的本质， 因为子线程完全受主线程控制， 并且不能操作dom。</p>
<p>工作线程的一些特点：</p>
<ul>
<li><p>工作线程内不能操作 dom，或者使用 window 对象下的一些属性和方法</p>
</li>
<li><p>工作线程和主线程之间通过消息传递系统实现，消息之间传递的数据是复制而不是共享一个存储空间（深复制和浅复制）</p>
<blockquote>
<p>both sides send their messages using the <code>postMessage()</code> method, and respond to messages via the <code>onmessage</code> event handler (the message is contained within the <code>Message</code> event’s <code>data</code> property). The data is copied rather than shared.</p>
</blockquote>
</li>
</ul>
<h2 id="How-to-create-worker"><a href="#How-to-create-worker" class="headerlink" title="How to create worker"></a>How to create worker</h2><p>一个 Worker 的创建是通过js 中的构造函数： <code>Worker()</code> 来实现的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myWorker = <span class="keyword">new</span> Worker(aURL, options);</span><br></pre></td></tr></table></figure>
<p>具体看 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker/Worker" target="_blank" rel="noopener">worker</a></p>
<p>当我们创建一个 worker 的时候， 我们需要手动创建一个 js 文件，这种方式过于死板， 我们希望我们能直接指定在 worker 中运行的代码，而不需要创建多余的文件， 那有没有可能我们直接传入一个方法呢？</p>
<p>比如如下代码，我们对于函数代码进行了四次转换，从而实现将一个普通函数转换为 webWroker:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWorker</span>(<span class="params">workerFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> url = URL.createObjectURL(<span class="keyword">new</span> Blob([<span class="string">`(<span class="subst">$&#123;workerFn.toString ()&#125;</span>)()`</span>]));</span><br><span class="line">  <span class="keyword">const</span> worker = <span class="keyword">new</span> Worker(url);</span><br><span class="line">  <span class="keyword">let</span> promiseResolve;</span><br><span class="line">  worker.onmessage = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    promiseResolve(msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      promiseResolve = resolve;</span><br><span class="line">      worker.postMessage(message);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  onmessage = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`resceive message`</span>, msg.data);</span><br><span class="line">    postMessage(<span class="string">'hello'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> worker = createWorker(fn);</span><br><span class="line"></span><br><span class="line">worker(<span class="string">'send message'</span>).then(<span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'msg'</span>, msg.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码实现了在不额外创建文件的情况下，实现创建 worker 代码的过程</p>
<p>如下是上面代码普通函数到 worker 的四种转换过程：</p>
<p><img src="js-Worker/v2-5887674cb213a45bef388a2f580da222_hd.jpg" alt="img"></p>
<img src="/2019/10/27/js-Worker/v2-5887674cb213a45bef388a2f580da222_hd.jpg">
<p>在上面的代码中，我们需要理解的是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">URL.createObjectURL(<span class="keyword">new</span> Blob([<span class="string">`(<span class="subst">$&#123;workerFn.toString ()&#125;</span>)()`</span>]));</span><br></pre></td></tr></table></figure>
<ol>
<li><p><code>Function.toString()</code> 方法可以将函数转换为代码字符串,例如上面的代码中， 执行完成</p>
<p><code>toString</code> 方法之后：</p>
</li>
</ol>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// workerFn.toString ()</span><br><span class="line">() =&gt; &#123;</span><br><span class="line">  onmessage = (msg) =&gt; &#123;</span><br><span class="line">    console.log(`resceive message`, msg.data);</span><br><span class="line">    postMessage(&apos;hello&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The <strong>toString()</strong> method returns a string representing the source code of the function.</p>
</blockquote>
<ol start="2">
<li><p><code>URL.createObjectURL()</code></p>
<p><code>createObjectURL</code> 可以创建指向 blob 对象的 URL，  需要注意的是， 使用这种方法创建的</p>
<p>是一个链接，这个链接指向数据对象， 这个数据对象可以是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/File" target="_blank" rel="noopener"><code>File</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" target="_blank" rel="noopener"><code>Blob</code></a> or <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaSource" target="_blank" rel="noopener"><code>MediaSource</code></a> 对象，真正的数据存放在 上面三种数据对象中。</p>
<p>在上面的代码中， <code>URL.createObjectURL</code> 创建的链接， 指向的是保存有 <code>(${workerFn.toString ()})()</code> 的 blob 对象中</p>
<p>关于 <a href="https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL" target="_blank" rel="noopener">createObjectURL</a></p>
</li>
</ol>
<h2 id="Worker-loader"><a href="#Worker-loader" class="headerlink" title="Worker-loader"></a>Worker-loader</h2><p><a href="https://github.com/webpack-contrib/worker-loader" target="_blank" rel="noopener">worker-loader</a> 是用来在 webpack 中实现 worker 的，核心代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> URL = <span class="built_in">window</span>.URL || <span class="built_in">window</span>.webkitURL;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content, url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> blob;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// BlobBuilder = Deprecated, but widely implemented</span></span><br><span class="line">        <span class="keyword">var</span> BlobBuilder = <span class="built_in">window</span>.BlobBuilder ||</span><br><span class="line">        <span class="built_in">window</span>.WebKitBlobBuilder ||</span><br><span class="line">        <span class="built_in">window</span>.MozBlobBuilder ||</span><br><span class="line">        <span class="built_in">window</span>.MSBlobBuilder;</span><br><span class="line"></span><br><span class="line">        blob = <span class="keyword">new</span> BlobBuilder();</span><br><span class="line"></span><br><span class="line">        blob.append(content);</span><br><span class="line"></span><br><span class="line">        blob = blob.getBlob();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">// The proposed API</span></span><br><span class="line">        blob = <span class="keyword">new</span> Blob([content]);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Worker(URL.createObjectURL(blob));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// 这里对于 js 数据进行编码</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Worker(<span class="string">'data:application/javascript,'</span> + <span class="built_in">encodeURIComponent</span>(content));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!url) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Inline worker is not supported'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Worker(url);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用多种不同的 api 主要是为了不同浏览器的兼容性问题，</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><strong>参考链接</strong></h2><ol>
<li><a href="https://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string" target="_blank" rel="noopener">how-to-create-a-web-worker-from-a-string</a></li>
</ol>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>Worker</tag>
      </tags>
  </entry>
  <entry>
    <title>js 文件上传与下载</title>
    <url>/2018/10/30/js-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<p>前端实现的文件上传与下载操作：</p>
<h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><p>在上传文件的操作中， 可以使用  <code>formData</code> 或者 <code>fileReader</code> 进行上传操作， 使用 <code>fileReader</code> 可以在本地将上传的文件转为二进制的数据格式； <code>formData</code> 是在 <code>XMLHttpRequest</code> 中的接口，可以用来实现模拟的表单提交， 当前端通过 <code>ajax</code> 向后端传递文件的时候， 使用 <code>ajax</code> 提交 <code>formData</code> 可以实现异步上传二进制文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;file&quot; onClick=&#123; this.uploadFile.bind(this) &#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>对于上传文件，可以通过两种方式进行上传，通过 <code>filereader</code> 或者通过 <code>formData</code> 都可以实现上传文件</p>
<h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader:"></a>FileReader:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uploadFile(fileInput) &#123;</span><br><span class="line">    const file = fileInput.target.files[0]; // 获取到文件对象</span><br><span class="line">    const reader = new FileReader(); // 创建 fileReader 的实例</span><br><span class="line">    reader.readAsArrayBuffer(file); // 将file 读取为 ArrayBuffer </span><br><span class="line">    reader.onload = function () &#123; // 当文件加载成功的时候调用</span><br><span class="line">        console.log(&quot;result&quot;, reader.result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 MDN 上面， 对于  FileReader 的描述如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。</span><br><span class="line"></span><br><span class="line">其中File对象可以是来自用户在一个&lt;input&gt;元素上选择文件后返回的FileList对象,也可以来自拖放操作生成的 DataTransfer对象,还可以是来自在一个HTMLCanvasElement上执行mozGetAsFile()方法后返回结果。</span><br></pre></td></tr></table></figure>
<p>使用 <code>fileReader</code> 接受的参数可以是一个 <code>File</code> 对象或者 <code>Blob</code> 对象， 使用上传文件的时候， 接收的是一个 <code>fileList</code> 对象。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader(); <span class="comment">// 创建一个新的 filereader 实例</span></span><br></pre></td></tr></table></figure>
<h4 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h4><p><code>reader.readAsArrayBuffer(file)</code> : 将文件读取为 <code>ArrayBuffer</code> 的数据对象</p>
<p><code>ArrayBuffer</code> 是一种二进制数组，通过 <code>ArrayBuffer</code> 中的一些语法可以实现使用数组的语法处理二进制数据</p>
<p><code>reader.readAsText(file, [encode])</code> : 读取文件内的内容作为字符串的形式输出，这个方法读取的是文件内的内容，其中的 <code>encode</code> 用于将 <code>file</code> 对象进行转换的编码格式;</p>
<p><code>reader.readAsDataURL(file)</code>: 将文件读取为 <code>DataUrl</code></p>
<h4 id="相关属性"><a href="#相关属性" class="headerlink" title="相关属性"></a>相关属性</h4><p><code>reader.error</code>: 表示在读取文件的时候发生的错误；</p>
<p><code>reader.readyState</code>: 表示当前上传文件的状态：</p>
<p><code>0</code>: 表示当前文件尚未加载</p>
<p><code>1</code>: 表示当前文件正在加载中</p>
<p><code>2</code>: 表示当前文件已经完成加载</p>
<p><code>reader.result</code> : 上传文件的内容，只有上传成功之后这个属性才有值</p>
<h4 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h4><table>
<thead>
<tr>
<th>事件名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Onabort</td>
<td>当读取操作中断的时候触发</td>
</tr>
<tr>
<td>Onerror</td>
<td>当操作发生错误的时候触发</td>
</tr>
<tr>
<td>Onload</td>
<td>当读取操作完成的时候触发</td>
</tr>
<tr>
<td>Onloadstart</td>
<td>当开始进行读取的时候触发</td>
</tr>
<tr>
<td>Onloadend</td>
<td>当读取操作结束的时候触发</td>
</tr>
<tr>
<td>Onprogress</td>
<td>当读取的时候触发</td>
</tr>
</tbody>
</table>
<h3 id="FormData"><a href="#FormData" class="headerlink" title="FormData:"></a>FormData:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uploadFile(fileInput) &#123;</span><br><span class="line">    const file = fileInput.target.file[0];</span><br><span class="line">    const formData = new FormData();</span><br><span class="line">    formData.append(&quot;file&quot;, formData);</span><br><span class="line">    axios(&#123;</span><br><span class="line">        method: &quot;post&quot;,</span><br><span class="line">        url: &apos;...&apos;,</span><br><span class="line">        data: formData</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>常用的下载操作是创建一个 <code>a</code> 标签， 通过 <code>a</code> 标签的 <code>href</code> 指向下载的文件链接，通过使用 <code>download</code> 属性来说明下载的文件名称:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span> <span class="attr">download</span>=<span class="string">"文件.txt"</span>&gt;</span>下载文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span> // download 表明下载的文件名, href 指向下载的文件的地址</span><br></pre></td></tr></table></figure>
<p>在后端传递的文件进行下载的时候， 因为后端传递的是一个二进制的数据格式文件， 前端这边需要将二进制数据转为 <code>a</code> 标签的链接进行下载操作， 通过使用 <code>window.URL.createObjectURL</code> 转为链接。</p>
<p><code>window.URL.createObjectURL</code>:</p>
<p>接受参数为一个 file 对象或者一个 blob 对象， 最后生成一个 url, 这个url指向参数中给定的对象。这个 URL 的生命周期和创建它的窗口中的 document 绑定，当不需要使用 URL 对象的时候， 可以通过  <code>URL.revokeObjectURL</code> 进行释放， 已获得最佳性能和内存使用情况。</p>
<p>在实际的开发中， 通常使用js 来创建下载标签， 代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// name: 下载的文件名</span></span><br><span class="line"><span class="comment">// blob 下载的文件的blob 二进制数据格式的文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">downloadFile</span> (<span class="params">name, blob</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> downloadElement = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">    <span class="keyword">var</span> href = <span class="built_in">window</span>.URL.createObjectURL(blob); <span class="comment">//创建下载的链接</span></span><br><span class="line">    downloadElement.href = href;</span><br><span class="line">    downloadElement.download = <span class="string">`<span class="subst">$&#123;name&#125;</span>.xlsx`</span>; <span class="comment">//下载后文件名</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(downloadElement);</span><br><span class="line">    downloadElement.click(); <span class="comment">//点击下载</span></span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(downloadElement); <span class="comment">//下载完成移除元素</span></span><br><span class="line">    <span class="built_in">window</span>.URL.revokeObjectURL(href); <span class="comment">//释放掉 URL 对象 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当接受到文件数据不为 blob 对象的时候, 可以通过使用 <code>new Blob([data])</code>  转换为 blob 对象。</p>
<h2 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h2><p><code>blob</code> 是 js 中的对象，可以存储大量的二进制编码格式的数据， 使用 blob, 当 <code>input</code> 标签 <code>type</code> 设为 <code>file</code> 的时候提交的 <code>fileList</code> 中的每一个 <code>file</code> 对象就是基于 <code>blob</code> 对象的；</p>
<h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><p><code>new Blob(array, [,options])</code>:</p>
<p><code>array</code> 中的值可能是 <code>ArrayBuffer</code>, <code>ArrayBufferView</code>, <code>Blob</code>, <code>DOMString</code> 对象， 或者这些对象的混合。</p>
<p><code>options</code> 字段是可选的字段， 包含下面两种值：</p>
<ul>
<li><code>type</code>: 表明将要放入 <code>blob</code> 中的数组内容的 <code>MIME</code> 类型</li>
<li>endings: 决定第一个参数的数据格式，可以取值为 “transparent” 或者 “native”（transparent的话不变，是默认值，native 的话按操作系统转换</li>
</ul>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p><code>Blob.slice([start[, end[, contentType]]])</code></p>
<p>用于对 <code>Blob</code> 进行”切割”， 返回一个新的 <code>Blob</code> 对象， 包含特定字节范围内的数据</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p><code>Blob.size</code>: 在 <code>Blob</code> 数据对象中的字节大小。</p>
<p><code>Blob.type</code>: <code>Blob</code> 数据对象中的 <code>MIME</code> 类型。</p>
<p>使用 <code>Blob</code> 存储的数据对象读取的唯一方式是通过使用 <code>FileReader</code> 进行读取， 通过使用 <code>FileReader</code> 中的 <code>readAsDataURL</code> 或者 <code>readAsArrayBuffer</code> 将 <code>Blob</code> 中的数据类型读取为 <code>ArrayBuffer</code> 或者 <code>dataurl</code> 的格式。</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>fileReader</tag>
      </tags>
  </entry>
  <entry>
    <title>node.js Timers</title>
    <url>/2017/12/19/node-js-Timers/</url>
    <content><![CDATA[<h3 id="Timers"><a href="#Timers" class="headerlink" title="Timers"></a><code>Timers</code></h3><h4 id="APIS"><a href="#APIS" class="headerlink" title="APIS"></a><code>APIS</code></h4><h5 id="setImmediate-callback-args"><a href="#setImmediate-callback-args" class="headerlink" title="setImmediate(callback, args)"></a><code>setImmediate(callback, args)</code></h5><p><code>callback</code> : 在 <code>node.js</code> 事件循环之后被调用的函数。  </p>
<p><code>args</code>: 当 <code>callback</code> 函数被调用的时候传递的参数。 </p>
<p>在 <code>I / O</code> 事件回调时间之后立即执行 <code>callback</code> 回调函数的执行。</p>
<p>如果 <code>callback</code> 不是一个 <code>function</code> , 会抛出一个 <code>TypeError</code> 错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'事件稍后被执行'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'事件立即被执行'</span>);</span><br><span class="line"><span class="comment">// 事件立即被执行</span></span><br><span class="line"><span class="comment">// 事件稍后被执行</span></span><br></pre></td></tr></table></figure>
<h5 id="setInterval-callback-delay-args"><a href="#setInterval-callback-delay-args" class="headerlink" title="setInterval(callback, delay, args)"></a><code>setInterval(callback, delay, args)</code></h5><p>使用 <code>setInterval</code> 类似于使用 <code>setInterval</code> 方法, 在一定的时间间隔 <code>delay</code> 之后执行 <code>callback</code> 函数。  </p>
<p>在官方给的例子中存在使用 <code>util.promisly()</code> 的一个变体。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> setTimeoutPromise = util.promisify(setTimeout);</span><br><span class="line">setTimeoutPromise(<span class="number">4000</span>, <span class="string">'foobar'</span>).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// after delay print 'foobar'</span></span><br></pre></td></tr></table></figure>
<h4 id="canceling-Timers"><a href="#canceling-Timers" class="headerlink" title="canceling Timers"></a><code>canceling Timers</code></h4><p>使用 <code>setImmediate</code> <code>setInterval</code>  以及 <code>setTimeout</code> 每一个方法都会返回一个代表排列事件的对象, 这些能够用来取消 <code>timer</code> 防止被触发的操作。  </p>
<p><code>clearImmediate</code>,  <code>clearInterval</code>,  <code>clearTimeout</code>  用来清除通过使用 <code>setImmedidate</code>  <code>setInterval</code> 以及 <code>setTimeout</code> 创建的定时器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> immidate = setImmediate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'事件之后被调用'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">clearImmediate(immidate);</span><br><span class="line"><span class="comment">// 清除事件， 事件之后不会调用</span></span><br><span class="line"></span><br><span class="line">clearInterval();</span><br><span class="line"><span class="comment">// 清除间隔时间后的调用</span></span><br><span class="line">clearTimeout();</span><br><span class="line"><span class="comment">// 清除一段时间之后的调用</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>Timers</tag>
      </tags>
  </entry>
  <entry>
    <title>nextTick in vue.js</title>
    <url>/2019/05/09/nextTick%20in%20vue/</url>
    <content><![CDATA[<h3 id="nextTick-方法"><a href="#nextTick-方法" class="headerlink" title="nextTick 方法"></a>nextTick 方法</h3><p><code>nextTick</code> 方法是挂载到 vue 实例上面， 我们可以通过使用 <code>this.$nextTick</code> 来使用这个方法。</p>
<p>这个方法的作用是：</p>
<blockquote>
<p>将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 <code>Vue.nextTick</code> 一样，不同的是回调的 <code>this</code> 自动绑定到调用它的实例上。 </p>
</blockquote>
<p>首先， 当我们在页面上面调用这个方法的时候， 在 <code>vue</code> 内部， 函数执行的路径是什么样的：</p>
<p>定义 <code>nextTick</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">  <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看调用栈：</p>
<img src="/2019/05/09/nextTick%20in%20vue/1.jpg">
<p>查看上面的调用栈得知， 当调用 <code>nextTick</code> 的时候，直到执行函数依次经历：</p>
<p><code>nextTick</code>  <code>timeFunc</code>  <code>flushCallbacks</code></p>
<p>那么 <code>nextTick</code> 方法在 <code>vue</code> 中是如何起作用的？</p>
<p><code>nextTick</code> 方法定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cb: 回调函数</span></span><br><span class="line"><span class="comment">// ctx 上下文对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nextTick</span> (<span class="params">cb, ctx</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _resolve;</span><br><span class="line">    <span class="comment">// callbacks 中用来存放所有 nextTick 中的 cb 函数</span></span><br><span class="line">    callbacks.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 当 cb 存在的时候， 执行回调函数</span></span><br><span class="line">          cb.call(ctx);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          handleError(e, ctx, <span class="string">'nextTick'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则， 返回一个 promise</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">        _resolve(ctx);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 这里保证不会执行 两次 timeFunc</span></span><br><span class="line">    <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">      pending = <span class="literal">true</span>;</span><br><span class="line">      timerFunc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// $flow-disable-line</span></span><br><span class="line">    <span class="comment">// 当没有回调函数的时候， 返回一个 promise</span></span><br><span class="line">    <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        _resolve = resolve;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>当我们调用 nextTick 的时候， 会将回调函数存入 <code>callbacks</code> 数组中， 这个数组用来存放当前组件中使用 <code>nextTick</code> 方法时的回调函数。</p>
<p><code>timeFunc</code> 函数：</p>
<p> 这个函数用来在合适的时机调用 <code>nextTick</code> 中推入 <code>callback</code> 列表中的所有函数， 所有代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Here we have async deferring wrappers using microtasks.</span></span><br><span class="line"><span class="comment">// In 2.5 we used (macro) tasks (in combination with microtasks).</span></span><br><span class="line"><span class="comment">// However, it has subtle problems when state is changed right before repaint</span></span><br><span class="line"><span class="comment">// (e.g. #6813, out-in transitions).</span></span><br><span class="line"><span class="comment">// Also, using (macro) tasks in event handler would cause some weird behaviors</span></span><br><span class="line"><span class="comment">// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).</span></span><br><span class="line"><span class="comment">// So we now use microtasks everywhere, again.</span></span><br><span class="line"><span class="comment">// A major drawback of this tradeoff is that there are some scenarios</span></span><br><span class="line"><span class="comment">// where microtasks have too high a priority and fire in between supposedly</span></span><br><span class="line"><span class="comment">// sequential events (e.g. #4521, #6690, which have workarounds)</span></span><br><span class="line"><span class="comment">// or even between bubbling of the same event (#6566).</span></span><br><span class="line"><span class="keyword">let</span> timerFunc</span><br><span class="line"></span><br><span class="line"><span class="comment">// The nextTick behavior leverages the microtask queue, which can be accessed</span></span><br><span class="line"><span class="comment">// via either native Promise.then or MutationObserver.</span></span><br><span class="line"><span class="comment">// MutationObserver has wider support, however it is seriously bugged in</span></span><br><span class="line"><span class="comment">// UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It</span></span><br><span class="line"><span class="comment">// completely stops working after triggering a few times... so, if native</span></span><br><span class="line"><span class="comment">// Promise is available, we will use it:</span></span><br><span class="line"><span class="comment">/* istanbul ignore next, $flow-disable-line */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    p.then(flushCallbacks)</span><br><span class="line">    <span class="comment">// In problematic UIWebViews, Promise.then doesn't completely break, but</span></span><br><span class="line">    <span class="comment">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class="line">    <span class="comment">// microtask queue but the queue isn't being flushed, until the browser</span></span><br><span class="line">    <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class="line">    <span class="comment">// "force" the microtask queue to be flushed by adding an empty timer.</span></span><br><span class="line">    <span class="keyword">if</span> (isIOS) setTimeout(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> MutationObserver !== <span class="string">'undefined'</span> &amp;&amp; (</span><br><span class="line">  isNative(MutationObserver) ||</span><br><span class="line">  <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">  MutationObserver.toString() === <span class="string">'[object MutationObserverConstructor]'</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="comment">// Use MutationObserver where native Promise is not available,</span></span><br><span class="line">  <span class="comment">// e.g. PhantomJS, iOS7, Android 4.4</span></span><br><span class="line">  <span class="comment">// (#6466 MutationObserver is unreliable in IE11)</span></span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line">  observer.observe(textNode, &#123;</span><br><span class="line">    characterData: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.data = <span class="built_in">String</span>(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">'undefined'</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  <span class="comment">// Fallback to setImmediate.</span></span><br><span class="line">  <span class="comment">// Techinically it leverages the (macro) task queue,</span></span><br><span class="line">  <span class="comment">// but it is still a better choice than setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Fallback to setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码表明， <code>nextTick</code> 中的回调函数的执行时机优先在<code>microTask</code> 执行的时候执行， 否则， 在 宏任务的时候执行代码。</p>
<p><code>flushCallbacks</code> 函数用来执行 <code>callbacks</code> 中存放的函数列表：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在执行前， 将 pending 置为 false</span></span><br><span class="line">  pending = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>)</span><br><span class="line">  callbacks.length = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">    copies[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>vue 源码阅读</category>
      </categories>
      <tags>
        <tag>vue 源码</tag>
      </tags>
  </entry>
  <entry>
    <title>node.js基础.基本服务器构建</title>
    <url>/2017/12/10/node-js%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<p><code>node.js</code> 是 <code>javascript</code> 对于后端的应用, 下面是使用<code>node.js</code> 构建的一个基础的图片上传应用:</p>
<p>应用地址<a href="https://github.com/newPromise/node.js/tree/master/hello%20world" target="_blank" rel="noopener">hello world</a>: </p>
<h3 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h3><p>这个基本的引用由下面几个部分组成:</p>
<p><code>index.js</code> : 作为各个模块的入口。  </p>
<p><code>server.js</code> 服务器模块。  </p>
<p><code>router.js</code> 用于路由的存放。</p>
<p><code>requireHandler.js</code> 用于路由相关的动作</p>
<h3 id="模块分析"><a href="#模块分析" class="headerlink" title="模块分析"></a>模块分析</h3><h4 id="server-js"><a href="#server-js" class="headerlink" title="server.js"></a><code>server.js</code></h4><p><code>server.js</code> 用于创建 <code>http</code> 服务器。</p>
<p>一个基础的 <code>http</code> 服务器的构成。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="comment">// request 是浏览器向服务器进行请求的相关信息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// response 用于向对于发送信息的浏览器响应请求</span></span><br><span class="line">  <span class="comment">// 规定返回响应的 头部信息</span></span><br><span class="line">  <span class="comment">// 返回一个 http 状态码为 200 Content-type 为 text/plain 的 http 信息</span></span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">  <span class="comment">// 使用 response.write 向响应的主体中发送内容</span></span><br><span class="line">  response.write();</span><br><span class="line">  <span class="comment">// 结束响应请求</span></span><br><span class="line">  response.end();</span><br><span class="line">&#125;</span><br><span class="line">http.createServer(onRequest).listen(<span class="number">8888</span>);</span><br></pre></td></tr></table></figure>
<p>上面的创建的基础的 <code>node.js</code> 服务器用于监听 8888 端口。</p>
<p><code>node.js</code> 是基于事件驱动的, 也就是我们说的 <code>回调</code>， 上面的服务器中， 只要在  <code>8888</code> 端口处监听到事件发生, 则进行回调 <code>onRequest</code> 函数。</p>
<p>在这个应用中，这样构建服务器模块:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 http 模块</span></span><br><span class="line"><span class="keyword">let</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="comment">// 引入 url 模块</span></span><br><span class="line"><span class="keyword">let</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="comment">// 创建一个 start 函数用于开启服务器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">route, handle</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pathname = url.parse(request.url).pathname;</span><br><span class="line">    route(handle, pathname, response, request);</span><br><span class="line">  &#125;</span><br><span class="line">  http.createServer(onRequest).listen(<span class="number">8888</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出 start 模块</span></span><br><span class="line"><span class="keyword">export</span>.start = start;</span><br></pre></td></tr></table></figure>
<h4 id="router-js"><a href="#router-js" class="headerlink" title="router.js"></a><code>router.js</code></h4><p>在 <code>router.js</code> 存放在对于根据不同的路由切换函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">handle, pathname, response, request</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> handle[pathname] === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行 handle[pathname] 函数</span></span><br><span class="line">    <span class="comment">// handle[pathname] 函数接收两个参数 response, request</span></span><br><span class="line">    <span class="comment">// 这个启动的函数位于 requireHandler.js 中</span></span><br><span class="line">    handle[pathname](response, request);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// http 状态 404 not found Content-type 设置 text/plain</span></span><br><span class="line">    response.writeHead(<span class="number">404</span>, &#123; <span class="string">'Content-type'</span>: <span class="string">'text/plain'</span> &#125;);</span><br><span class="line">    response.write(<span class="string">'404 not found'</span>);</span><br><span class="line">    response.end();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span>.route = route;</span><br></pre></td></tr></table></figure>
<h4 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a><code>index.js</code></h4><p>使用 <code>index.js</code> 用于对于各个模块进行集中处理:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入 server, router, requestHandlers 模块</span></span><br><span class="line"><span class="comment">// server: 服务器模块</span></span><br><span class="line"><span class="comment">// router: 路由模块</span></span><br><span class="line"><span class="comment">// requestHandlers： 相应路由的处理函数模块</span></span><br><span class="line"><span class="keyword">let</span> server = <span class="built_in">require</span>(<span class="string">"./server.js"</span>);</span><br><span class="line"><span class="keyword">let</span> router = <span class="built_in">require</span>(<span class="string">"./router"</span>);</span><br><span class="line"><span class="keyword">let</span> requestHandlers = <span class="built_in">require</span>(<span class="string">"./requireHandlers"</span>);</span><br><span class="line"><span class="keyword">let</span> handle = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于不同的路由进行不同的函数配置</span></span><br><span class="line">handle[<span class="string">'/'</span>] = requestHandlers.start;</span><br><span class="line">handle[<span class="string">'/start'</span>] = requestHandlers.start;</span><br><span class="line">handle[<span class="string">'/upload'</span>] = requestHandlers.upload;</span><br><span class="line">handle[<span class="string">'/show'</span>] = requestHandlers.show;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务器</span></span><br><span class="line">server.start(router.route, handle);</span><br></pre></td></tr></table></figure>
<h4 id="requireHandler-js"><a href="#requireHandler-js" class="headerlink" title="requireHandler.js"></a><code>requireHandler.js</code></h4><p>这个模块用来个根据不同的路由进行不同的函数处理:</p>
<p>对于上传数据的不同处理都是放在了这里面:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 formidable 用于处理文件上传的问题</span></span><br><span class="line"><span class="keyword">let</span> formidable = <span class="built_in">require</span>(<span class="string">'formidable'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">response, request</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> body = <span class="string">'&lt;html&gt;'</span>+</span><br><span class="line">	<span class="string">'&lt;head&gt;'</span>+</span><br><span class="line">	<span class="string">'&lt;meta http-equiv="Content-Type" '</span>+</span><br><span class="line">	<span class="string">'content="text/html; charset=UTF-8" /&gt;'</span>+</span><br><span class="line">	<span class="string">'&lt;/head&gt;'</span>+</span><br><span class="line">	<span class="string">'&lt;body&gt;'</span>+</span><br><span class="line">	<span class="string">'&lt;form action="/upload" enctype="multipart/form-data" '</span>+</span><br><span class="line">	<span class="string">'method="post"&gt;'</span>+</span><br><span class="line">	<span class="string">'&lt;input type="file" name="upload"&gt;'</span>+</span><br><span class="line">	<span class="string">'&lt;input type="submit" value="Upload file" /&gt;'</span>+</span><br><span class="line">	<span class="string">'&lt;/form&gt;'</span>+</span><br><span class="line">	<span class="string">'&lt;/body&gt;'</span>+</span><br><span class="line">	<span class="string">'&lt;/html&gt;'</span>;</span><br><span class="line">	response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/html"</span>&#125;);</span><br><span class="line">	response.write(body);</span><br><span class="line">	response.end();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params">response, request</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> form = <span class="keyword">new</span> formidable.IncomingForm();</span><br><span class="line">	form.parse(request, <span class="function"><span class="keyword">function</span> (<span class="params">error, fields, files</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> readStream=fs.createReadStream(files.upload.path);</span><br><span class="line">		<span class="keyword">var</span> writeStream=fs.createWriteStream(<span class="string">`./assets/<span class="subst">$&#123;files.upload.name&#125;</span>`</span>);</span><br><span class="line">		imgname = files.upload.name;</span><br><span class="line">        readStream.pipe(writeStream);</span><br><span class="line">        readStream.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	    fs.unlinkSync(files.upload.path);</span><br><span class="line">	  &#125;);</span><br><span class="line">		response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/html"</span>&#125;);</span><br><span class="line">		response.write(<span class="string">'received image: &lt;br/&gt;'</span>);</span><br><span class="line">		<span class="built_in">console</span>.log(files.upload.name);</span><br><span class="line">        <span class="comment">// src='/show' 调用 show 函数</span></span><br><span class="line">		response.write(<span class="string">"&lt;img src='/show'/&gt;"</span>);</span><br><span class="line">		response.end();</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// show 函数用于文件显示</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">response, postData</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 读取文件</span></span><br><span class="line">	fs.readFile(<span class="string">`./assets/<span class="subst">$&#123;imgname&#125;</span>`</span>, <span class="string">"binary"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, file</span>) </span>&#123;</span><br><span class="line">		<span class="comment">// 如果发生错误</span></span><br><span class="line">		<span class="keyword">if</span> (error) &#123;</span><br><span class="line">			response.writeHead(<span class="number">500</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">			response.write(error + <span class="string">"\n"</span>);</span><br><span class="line">			response.end();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"image/png"</span>&#125;);</span><br><span class="line">			response.write(file, <span class="string">"binary"</span>);</span><br><span class="line">			response.end();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br><span class="line">exports.upload = upload;</span><br><span class="line">exports.show = show;</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>关于使用 <code>response.write</code> 的问题:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">response.write(chunk, [encoding]);</span><br><span class="line"><span class="comment">// encoding 表示编码形式</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>node.js EventEmitter</title>
    <url>/2017/12/17/node-js-EventEmitter/</url>
    <content><![CDATA[<h2 id="EventEmitter"><a href="#EventEmitter" class="headerlink" title="EventEmitter"></a><code>EventEmitter</code></h2><h4 id="基本构建"><a href="#基本构建" class="headerlink" title="基本构建"></a>基本构建</h4><p>许多的 <code>node.js</code> 核心的 <code>API</code> 是围绕事件异步模型进行构建的，特定种类的事件对象会周期性的触发命名的函数对象，从而导致函数对象被触发。 这些函数对象被称作 <code>listeners</code>;</p>
<p>所有的触发事件的对象属于 <code>EventEmitter</code> 类， 这些对象暴露有 <code>emit</code> 以及 <code>on</code> 方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> eventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">let</span> myEmitter = <span class="keyword">new</span> eventEmitter();</span><br><span class="line"><span class="comment">// listeners</span></span><br><span class="line">myEmitter.on(<span class="string">'event'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'event'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// emitters</span></span><br><span class="line">myEmitter.emit(<span class="string">'event'</span>); <span class="comment">// event</span></span><br></pre></td></tr></table></figure>
<h5 id="向-lisitens-传递-arguments-以及-this-值"><a href="#向-lisitens-传递-arguments-以及-this-值" class="headerlink" title="向 lisitens 传递 arguments 以及 this 值"></a>向 <code>lisitens</code> 传递 <code>arguments</code> 以及 <code>this</code> 值</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myEmitter.on(<span class="string">'event'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'被传递的值'</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(<span class="string">'event'</span>, <span class="string">'张宁宁'</span>);</span><br><span class="line"><span class="comment">// my name is 张宁宁</span></span><br><span class="line"><span class="comment">// this 值指向的值是 eventEmitter 对象</span></span><br></pre></td></tr></table></figure>
<h4 id="handle-event-only-once"><a href="#handle-event-only-once" class="headerlink" title="handle event only once"></a>handle event only once</h4><p>使用 <code>once</code> 函数的时候, 当使用 <code>emit</code> 的时候只会被触发一次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myEmitter.once(&apos;event&apos;, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;事件被触发一次&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(&apos;event&apos;);</span><br><span class="line">// &apos;事件触发一次&apos;</span><br><span class="line">myEmitter.emit(&apos;event&apos;);</span><br></pre></td></tr></table></figure>
<h4 id="some-API"><a href="#some-API" class="headerlink" title="some API"></a>some API</h4><h5 id="Event-newListener"><a href="#Event-newListener" class="headerlink" title="Event: newListener"></a><code>Event: newListener</code></h5><p>在监听器被加入到监听器队列之前，<code>EventEmitter</code> 实例会触发自己的 <code>newListener</code> 事件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line">myEmitter.once(<span class="string">'newListener'</span>, (event, listener) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (event === <span class="string">'event'</span>) &#123;</span><br><span class="line">    myEmitter.on(<span class="string">'event'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'B'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.on(<span class="string">'event'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'A'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(<span class="string">'event'</span>);</span><br><span class="line"><span class="comment">// B</span></span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="comment">// 在触发 'event' 事件的时候先要触发事件 B 在触发事件 A</span></span><br></pre></td></tr></table></figure>
<h5 id="EventEmitter-listenerCount-emitter-eventName"><a href="#EventEmitter-listenerCount-emitter-eventName" class="headerlink" title="EventEmitter.listenerCount(emitter, eventName)"></a><code>EventEmitter.listenerCount(emitter, eventName)</code></h5><p>用来获得在 <code>emitter</code> 上面注册的 <code>eventName</code> 的次数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myEmitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line">myEmitter.on(<span class="string">'event'</span>, () =&gt; &#123;&#125;);</span><br><span class="line">myEmitter.on(<span class="string">'event'</span>, () =&gt; &#123;&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(EventEmitter.listenerCount(myEmitter, <span class="string">'event'</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h5 id="emitter-eventNames"><a href="#emitter-eventNames" class="headerlink" title="emitter.eventNames()"></a><code>emitter.eventNames()</code></h5><p>用来获得 <code>emitter</code> 上面注册的 <code>listeners</code> 的事件列表。  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myEmitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line">myEmitter.on(<span class="string">'a'</span>, () =&gt; &#123;&#125;);</span><br><span class="line">myEmitter.on(<span class="string">'b'</span>, () =&gt; &#123;&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(myEmitter.eventNames); <span class="comment">// ['a', 'b']</span></span><br></pre></td></tr></table></figure>
<h5 id="emitter-listenerCount-eventName"><a href="#emitter-listenerCount-eventName" class="headerlink" title="emitter.listenerCount(eventName)"></a><code>emitter.listenerCount(eventName)</code></h5><p><code>eventName</code> :  the name of the event being listened for</p>
<p>作用和 <code>EventEmitter.listenerCount(emitter, eventName)</code> 是相同的。  </p>
<h5 id="emitter-listeners-eventName"><a href="#emitter-listeners-eventName" class="headerlink" title="emitter.listeners(eventName)"></a><code>emitter.listeners(eventName)</code></h5><p>用于获得 <code>emitter</code> 上 <code>eventName</code> 事件的注册函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myEmitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line">myEmitter.on(<span class="string">'event'</span>, () =&gt; &#123;&#125;);</span><br><span class="line">myEmitter.on(<span class="string">'event'</span>, () =&gt; &#123;&#125;);</span><br><span class="line"><span class="comment">// 使用 emitter.listeners(eventName)</span></span><br><span class="line"><span class="comment">// 用于获得 emitter 上面的 eventName 上注册的函数</span></span><br><span class="line"><span class="built_in">console</span>.log(myEmitter.listeners(<span class="string">'event'</span>));</span><br><span class="line"><span class="comment">// [[Function], [Function]]</span></span><br></pre></td></tr></table></figure>
<h5 id="emitter-on-eventName-listener"><a href="#emitter-on-eventName-listener" class="headerlink" title="emitter.on(eventName, listener)"></a><code>emitter.on(eventName, listener)</code></h5><p>向一个被称作 <code>eventName</code> 的事件<code>listener</code> 的列表之中添加事件， 添加的事件被添加到 <code>listener</code> 列表的末尾。  注意，在添加事件的时候， 添加的事件只会按照顺序添加到时间列表数组的末尾，在这个过程中，不会进行判断事件是否已经添加了。</p>
<h5 id="emitter-prependListener-eventName-listener"><a href="#emitter-prependListener-eventName-listener" class="headerlink" title="emitter.prependListener(eventName, listener)"></a><code>emitter.prependListener(eventName, listener)</code></h5><p>将 <code>listener</code> function 添加到事件队列的开头</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">myEmitter.on(<span class="string">'otherEvent'</span>, () =&gt; &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'第一次'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.prependListener(<span class="string">'otherEvent'</span>, () =&gt; &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'第三次'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.on(<span class="string">'otherEvent'</span>, () =&gt; &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'第二次'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(<span class="string">'otherEvent'</span>);</span><br><span class="line"><span class="comment">// 第三次</span></span><br><span class="line"><span class="comment">// 第一次</span></span><br><span class="line"><span class="comment">// 第二次</span></span><br></pre></td></tr></table></figure>
<h4 id="emitter-prependOnceListener-eventName-listener"><a href="#emitter-prependOnceListener-eventName-listener" class="headerlink" title="emitter.prependOnceListener(eventName, listener)"></a><code>emitter.prependOnceListener(eventName, listener)</code></h4><p>仅仅添加一次运行的函数到事件队列开始，第二次调用的时候会被移除</p>
<h5 id="emitter-removeAllListeners-eventName"><a href="#emitter-removeAllListeners-eventName" class="headerlink" title="emitter.removeAllListeners([eventName])"></a><code>emitter.removeAllListeners([eventName])</code></h5><p>移除 <code>eventName</code> 事件上的所有函数。  </p>
<h5 id="emitter-removeListener-eventName-listener"><a href="#emitter-removeListener-eventName-listener" class="headerlink" title="emitter.removeListener(eventName, listener)"></a><code>emitter.removeListener(eventName, listener)</code></h5><blockquote>
<p>removes the specified listener from the listener array for the event named eventName</p>
</blockquote>
<p>使用 <code>removeListener</code> 的时候将会移除事件队列中至多一个<code>instance</code> (实例), 如果一个 单独的监听器被多次添加，那么使用 <code>removeListener</code> 需要多次调用才能被多次删除。  </p>
<p>从被称作 <code>eventName</code> 的事件队列中移除掉特定的事件函数。</p>
<p><em>注意</em>:</p>
<blockquote>
<p>一旦时间被触发的时候, 在触发的时刻所有与之相关联的 <code>listeners</code> 将会被调用， 这表明， 在 <code>listeners</code> 被 <code>emit</code> 之后，在 <code>listeners</code> 中的最后一个函数被执行之前， 使用 <code>removeListenr()</code> 或者 <code>removeAllListeners</code> 都不会起作用   </p>
</blockquote>
<p>也就是说， 使用使用移除事件的时候是不会在 <code>listeners</code> 函数执行的过程中被调用的。  </p>
<p>例子如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> callBackA = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'A'</span>);</span><br><span class="line">	myEmitter.removeListener(<span class="string">'callback'</span>, callBackB);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> callBackB = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'B'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myEmitter.on(<span class="string">'callback'</span>, callBackA);</span><br><span class="line">myEmitter.on(<span class="string">'callback'</span>, callBackB);</span><br><span class="line"></span><br><span class="line">myEmitter.emit(<span class="string">'callback'</span>); <span class="comment">// 这一次调用的时候是不会移除掉 B 的</span></span><br><span class="line">myEmitter.emit(<span class="string">'callback'</span>);<span class="comment">// 这一次调用的时候移除掉了 B</span></span><br><span class="line"><span class="comment">// A B A</span></span><br><span class="line">myEmitter.listeners() <span class="comment">// [[Function: callbackA]]</span></span><br></pre></td></tr></table></figure>
<p>因为对于 <code>listeners</code> 而言, 是通过使用内部的数组进行管理的,  当其中的 <code>listener</code> 被移除之后，会改变每一个注册的 <code>listern</code> 位置， 但是不会影响 <code>listener</code> 被调用的顺序，  但是通过使用 <code>emitter.listeners()</code> 返回的调用函数数组队列将会发生变化。</p>
]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>EventEmitter</tag>
      </tags>
  </entry>
  <entry>
    <title>promise 原理</title>
    <url>/2017/12/05/promise/</url>
    <content><![CDATA[<p>使用 <code>promise</code> 构建异步请求在 <code>es6-promise</code> 中已经说过了，下面这章想要探究一下使用 <code>promise</code> 的原理。</p>
<p>使用 <code>promise</code>  的实例如下:</p>
<p><code>new Promise(function (resolve, reject) {....})</code></p>
<p>对于 <code>promise</code> 的执行过程是这样的:</p>
<blockquote>
<p>executor 执行器:</p>
<p>executor 是一个带有  <code>resolve</code> 和 <code>reject</code> 两个参数的函数, <code>executor</code> 函数 <code>promise</code> 构造函数执行的时候同步执行， 被传递 <code>resolve</code> 以及 <code>reject</code> 函数，<code>executor</code> 函数在 <code>Promise</code> 构造函数返回新建对象前被调用, <code>resolve</code> 和 <code>reject</code> 函数被调用的时候，分别将 <code>promise</code> 的状态改为 <code>fullfilled(完成)</code> 和 </p>
<p><code>rejected(完成)</code> <code>executor</code> 函数内部会执行异步操作，操作完成成功之后将 <code>promise</code> 状态改为 <code>fullfiled</code> 或者将发生错误的时候, 将  状态变为 <code>rejected</code></p>
</blockquote>
<p>对于一个 <code>promise</code> 对象具有下面三种状态:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pending: 初始状态，不是成功就是失败 <span class="comment">// pending 英文: 等待，表示处于等待异步处理结果的状态</span></span><br><span class="line">fufilled 等待结果操作成功完成</span><br><span class="line">rejected 表示等待操作结果失败</span><br></pre></td></tr></table></figure>
<p>下面是通过使用 <code>promise</code> 进行调用的状态图:</p>
<p><img src="https://mdn.mozillademos.org/files/8633/promises.png" alt="&#39;promise 状态&#39;"></p>
<h3 id="promise-代码"><a href="#promise-代码" class="headerlink" title="promise 代码"></a><code>promise</code> 代码</h3><h4 id="构建-Promise-构造函数"><a href="#构建-Promise-构造函数" class="headerlink" title="构建 Promise 构造函数"></a>构建 <code>Promise</code> 构造函数</h4><p><code>es6</code>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resovle, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 异步操作</span></span><br><span class="line">  <span class="keyword">if</span> () &#123;</span><br><span class="line">  <span class="comment">// resolve(value)    </span></span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">// reject(value)      </span></span><br><span class="line">    reject(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>实际源码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> that = <span class="keyword">this</span>;</span><br><span class="line">  that.status = PENDDING;</span><br><span class="line">  that.value = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">  that.handlerQueue = [];</span><br><span class="line">  <span class="comment">// 执行函数， 传递进入 value</span></span><br><span class="line">  <span class="comment">// executor(成功函数， 失败函数);</span></span><br><span class="line">  executor(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 成功函数执行，传递进入 transition 状态: FULFILLED</span></span><br><span class="line">    that.transition(FULFILLED, value);</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 失败函数执行， 传递进入 transition 状态: REJECTED</span></span><br><span class="line">    that.transition(REJECTED, value);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="改变状态函数"><a href="#改变状态函数" class="headerlink" title="改变状态函数"></a>改变状态函数</h5><p><code>es6</code>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">resolve(value);</span><br><span class="line"></span><br><span class="line">reject(value);</span><br></pre></td></tr></table></figure>
<p>实际源码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototpe.transition = <span class="function"><span class="keyword">function</span> (<span class="params">status, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">    <span class="comment">// 当处于 PENDDING 状态的时候执行函数</span></span><br><span class="line">    <span class="keyword">this</span>.status = status;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="comment">// 当成功或者失败的时候都会执行 this.process() 函数</span></span><br><span class="line">    <span class="keyword">this</span>.process();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="then"><a href="#then" class="headerlink" title="then"></a><code>then</code></h4><p><code>es6</code>: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p.then(onFulFilled, onRejected);</span><br><span class="line"><span class="comment">// onFulFilled 成功之后执行的函数</span></span><br><span class="line"><span class="comment">// onRejected 失败之后执行的函数</span></span><br></pre></td></tr></table></figure>
<p>源码分析:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// thenPromise 是一个新的 Promise 对象</span></span><br><span class="line">  <span class="keyword">let</span> thenPromsie = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line">  <span class="comment">// 将执行的函数存入到 handlerQueue 数组之中</span></span><br><span class="line">  <span class="keyword">this</span>.handlerQueue.push(&#123;</span><br><span class="line">    <span class="comment">// 成功函数</span></span><br><span class="line">    onFulfilled,</span><br><span class="line">    <span class="comment">// 失败函数</span></span><br><span class="line">    onRejected,</span><br><span class="line">    thenPromise</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// this.process() 执行函数</span></span><br><span class="line">  <span class="keyword">this</span>.process();</span><br><span class="line">  <span class="comment">// 返回 thenPromise 一个新的 promise 对象</span></span><br><span class="line">  <span class="keyword">return</span> thenPromise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="process处理函数"><a href="#process处理函数" class="headerlink" title="process处理函数"></a><code>process</code>处理函数</h4><p>用来执行成功时的回调函数以及失败的回调函数。  </p>
<p><code>es6</code>:  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 成功函数执行</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 失败函数执行</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>源码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 process 的主要目的是执行保存在 this.handlerQueue 中的函数</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.process = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> that = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 如果状态处于 PENDING 状态 返回</span></span><br><span class="line">  <span class="keyword">if</span> (that.status === PENDING) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (that.handlerQueeu.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> handler = that.handlerQueue.shift();</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">handler</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> handlerFn = that.status === FULFILLED ? handler.onFulfilled : handler.onRejected;</span><br><span class="line">      <span class="comment">// 如果 handlerFn 是一个函数</span></span><br><span class="line">      <span class="keyword">if</span> (isFunction(handlerFn)) &#123;</span><br><span class="line">        <span class="comment">// 使用 callLater 回调函数执行</span></span><br><span class="line">        callLater(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行 handlerFn 函数</span></span><br><span class="line">            <span class="keyword">let</span> x = handlerFn(that.value);</span><br><span class="line">            <span class="comment">// 将 handler.thenPromise 以及 handlerFn 计算之后的 x 传入 resolve 函数</span></span><br><span class="line">            resolve(handler.thenPromise, x);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="comment">// 如果 catch error</span></span><br><span class="line">            handler.thenPromise.transition(REJECTED, e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handler.thenPromise.transition(that.status, that.value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)(handler);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a><code>resolve</code></h4><p><code>resovle</code> 函数用于函数执行完毕之后改变状态:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resovle</span>(<span class="params">promise, x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (promise === x) &#123;</span><br><span class="line">    promise.transition(REJECTED, <span class="keyword">new</span> <span class="built_in">TypeError</span>());</span><br><span class="line">    <span class="comment">// 如果 x 是一个 promise</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPromise(x)) &#123;</span><br><span class="line">    <span class="comment">// 调用 x 的 then 方法</span></span><br><span class="line">    x.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      promise.transition(FULFILLED, value);</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">      promise.transition(REJECTED, reason);</span><br><span class="line">    &#125; );</span><br><span class="line">    <span class="comment">// 如果函数执行之后的返回值是一个对象或者一个函数</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isObject(x) || isFunction(x)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> then = x.then;</span><br><span class="line">      <span class="comment">// 如果 then 是一个函数</span></span><br><span class="line">      <span class="comment">// 参数具有 then 方法的对象</span></span><br><span class="line">      <span class="keyword">if</span> (isFunction(then)) &#123;</span><br><span class="line">        <span class="keyword">let</span> called = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          then.call(x, <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!called) &#123;</span><br><span class="line">              resolve(promise, y);</span><br><span class="line">              called = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!called) &#123;</span><br><span class="line">              promise.transition(REJECTED, r);</span><br><span class="line">              called = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!called) &#123;</span><br><span class="line">            promise.transition(REJECTED, e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        promise.transition(FULFILLED, x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      promise.transition(REJECTED, x);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 如果 x 只是一个数值  </span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    promise.transition(FULFILLED, x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="promsie-resolve"><a href="#promsie-resolve" class="headerlink" title="promsie.resolve"></a><code>promsie.resolve</code></h4><blockquote>
<p>对于 <code>promise.resolve</code> 的状态，存在下面几种情况:</p>
<ol>
<li>如果参数是 Promise 实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</li>
<li>如果参数是一个具有 <code>then</code> 方法的对象, 使用 <code>promise.resolve</code> 会将这个对象转化为 <code>promise</code> 对象，并且立即执行 <code>thenable</code> 对象的 <code>then</code> 方法。</li>
<li>如果参数是一个原始值，或者是一个不具有<code>then</code>方法的对象，则<code>Promise.resolve</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</li>
<li>如果不带参数, 直接返回一个 <code>resolve</code> 状态的 Promise 对象。</li>
</ol>
</blockquote>
<p>实现代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个 new Promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isThenable(value)) &#123;</span><br><span class="line">      <span class="comment">// 如果 value 是一个 then 对象</span></span><br><span class="line">      <span class="comment">// 如果 value 具有 then 方法，执行下面的函数</span></span><br><span class="line">      value.then(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// else 执行 resolve 函数</span></span><br><span class="line">      resolve(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="promise-reject"><a href="#promise-reject" class="headerlink" title="promise.reject"></a><code>promise.reject</code></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    reject(reason);</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>Promise.reject</code> 接收的参数 <code>reason</code>会被作为 <code>error</code> 传递 </p>
<h4 id="other"><a href="#other" class="headerlink" title="other"></a>other</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 promise 的三种状态</span></span><br><span class="line"><span class="comment">// PENDING, FULFILLED  REJECTED</span></span><br><span class="line"><span class="keyword">let</span> PENDING = <span class="number">0</span>;</span><br><span class="line">    FULFILLED = <span class="number">1</span>;</span><br><span class="line">    REJECTED = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFunction</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fn <span class="keyword">instanceof</span> <span class="built_in">Function</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> p <span class="keyword">instanceof</span> <span class="built_in">Promise</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isThenable</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj &amp;&amp; isFunction(obj.then);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 借用 callLater 实现异步</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callLater</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  setTimeout(fn, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>代码集</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>promise中的错误捕获</title>
    <url>/2019/09/27/promise%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E6%8D%95%E8%8E%B7/</url>
    <content><![CDATA[<p>在代码中， 我们对于不能预知的代码通常会使用 <code>try catch</code> 来捕获代码错误，当代码内部发生错误时， 对于错误进行捕获， 可以防止代码的错误阻塞后续代码的执行，并且我们可以对于代码的错误进行后续处理；</p>
<p>在 <code>promise</code> 中， 对于错误的处理或许稍有不同， 需要注意下面几点：</p>
<ul>
<li>使用 <code>try catch</code> 只能捕获同步代码， 不能捕获异步代码， 在 <code>async</code> 函数内， 使用 <code>await</code> 可以捕获异步代码，这里实际上是异步代码变成了同步代码</li>
<li><code>promise</code> 内部代码的错误会沿着 <code>promise</code> 代码链传递， 直到被 <code>promise</code> 的 <code>catch</code> 方法或者上一层 <code>async</code>  函数内的  <code>try catch</code> 方法捕获到, 如果没有使用 <code>catch</code> 方法指定错误处理的回调函数， <code>Promise</code> 对象抛出的错误不会传递到外层的 <code>promise</code>；这个时候会报： <code>UnhandledPromiseRejectionWarning:</code></li>
</ul>
<h4 id="try-catch-处理async-函数内异步"><a href="#try-catch-处理async-函数内异步" class="headerlink" title="try catch 处理async 函数内异步"></a><code>try catch</code> 处理<code>async</code> 函数内异步</h4><p>使用 <code>try catch</code> 只能处理同步的代码， 对于异步代码中的代码错误， 使用 <code>try catch</code> 是无法捕获到的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryError</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    promise();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tryError();</span><br><span class="line"><span class="comment">// UnhandledPromiseRejectionWarning: Error: error</span></span><br></pre></td></tr></table></figure>
<p>在 <code>async</code> 函数内部使用 <code>try catch</code>可以捕获到异步错误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">tryError</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> promise();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">tryError();</span><br><span class="line"><span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<h4 id="promise-catch-错误捕获"><a href="#promise-catch-错误捕获" class="headerlink" title="promise.catch 错误捕获"></a><code>promise.catch 错误捕获</code></h4><p>使用 <code>promise.catch</code> 方法可以对于当前 <code>promise</code> 链上的代码进行错误捕获，当 <code>promise</code> 内部发生错误的时候， 错误会沿着 <code>promise</code> 链向后传递， 直到被 <code>promise</code> 后面的 <code>catch</code> 方法捕获到：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">apromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apromise().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'error'</span>, err);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// error: b is not defined</span></span><br></pre></td></tr></table></figure>
<p>当在 <code>promise</code> 链中没有 <code>catch</code> 方法的时候， <code>promise</code> 中发生的错误不会被上层的 <code>promise</code> 中的catch 捕获, 即使我们使用了 <code>throw new Error</code> 的方式对错误进行抛出也是如此；</p>
<p>因为 <code>async</code> 函数返回一个 <code>promise</code> 对象， 我们在 <code>async</code> 函数内部定义一个 <code>Error</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>);</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">promise();</span><br><span class="line"><span class="comment">// UnhandledPromiseRejectionWarning: Error: error</span></span><br><span class="line"><span class="comment">// 这里 async 函数内部抛出的错误不会被外部的 catch 方法捕获到， 因为错误不能传递到外层</span></span><br><span class="line"><span class="comment">// 的 `promise`</span></span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>防止出现 <code>unhandledRejection</code> 问题的解决方法是：</p>
<ol>
<li>在 <code>async</code> 函数内部使用 <code>try catch</code> 捕获异步错误</li>
<li><code>promise</code> 内部使用 <code>.catch</code> 方法来捕获 <code>promise</code> 内部代码错误</li>
</ol>
]]></content>
      <categories>
        <category>promise</category>
      </categories>
      <tags>
        <tag>promise catch</tag>
      </tags>
  </entry>
  <entry>
    <title>node中的 events 模块</title>
    <url>/2020/09/14/node%E4%B8%AD%E7%9A%84%20events%20%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>了解 Node 中的 Events 模块</p>
<p>node 中的 events 模块是 node 中使用较多的模块，比如在 node 中的流（stream），其内部使用 <code>events</code> 模块作为父类：</p>
<img src="/2020/09/14/node%E4%B8%AD%E7%9A%84%20events%20%E6%A8%A1%E5%9D%97/image-20200803102619367.png" class="">
<p>作为一个使用广泛的基础模块，其代码中是有些东西值得我们学习和借鉴的。</p>
<h4 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h4><p>发布/订阅模式定义了一种一对多的依赖关系，观察者同时监听某一个对象相应的状态变化， 当状态变化时通知到所有观察者， 这种设计模式解决了主体对象和观察者之间的耦合问题。</p>
<p>图示如下：</p>
 <img src="/2020/09/14/node%E4%B8%AD%E7%9A%84%20events%20%E6%A8%A1%E5%9D%97/eventsPic.jpg" class="">
<p><em>上图中左边为观察者模式， 右边为 发布/订阅 模式， 可以看出它们之间的区别是发布/订阅模式通过事件调度中心（Event Channel）来对于事件进行统一管理</em></p>
<p>观察上图可知，发布/订阅这种设计模式的组成特点：</p>
<ul>
<li>整体结构有三部分组成， 订阅者（Subscriber）, 发布者（Publisher）以及 事件调度器（Event Channel）</li>
<li>订阅者在事件调度器中订阅（Subscribe）事件， 发布者发布事件时，订阅该事件的订阅者将会收到消息通知（事件触发的形式）</li>
</ul>
<p>在 Node 中的 Events 模块中， 采用了这种设计模式，模块内部维护了一个事件列表（<code>_events</code>）,提供了基础的 api 来进行发布和订阅（<code>emit</code>, <code>on</code>）在 Events 中，订阅事件时需要传入两个参数： 事件名（eventName）以及 事件触发时的回调方法（listener），订阅之后按照下面的结构存储在 <code>_events</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_events = &#123;</span><br><span class="line">  eventName: listener, wrapFn &#123; <span class="attr">fired</span>: <span class="literal">false</span>/<span class="literal">true</span>, listener &#125;</span><br><span class="line">	eventName: [listener1, listener2 ....]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用 <code>this.emit(eventName)</code> 来发布特定事件时，将会依次调用<code>_events</code> 中的事件（<code>listener</code>）</p>
<h4 id="Events-模块代码实现"><a href="#Events-模块代码实现" class="headerlink" title="Events 模块代码实现"></a>Events 模块代码实现</h4><ol>
<li><p><code>on</code> / <code>addListener(eventName, listener)</code></p>
<p>这个方法的作用是订阅<code>eventName</code> 事件, 当事件被发布时， <code>listener</code> 方法被执行</p>
<p>具体代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 订阅事件</span></span><br><span class="line"><span class="comment">// target: EventEmitter 实例</span></span><br><span class="line"><span class="comment">// type: 事件类型</span></span><br><span class="line"><span class="comment">// listener: 事件触发后的回调方法</span></span><br><span class="line"><span class="comment">// prepend: 是否将回调方法前置（首先触发）,默认为 false, 将会被放到回调方法的最后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_addListener</span>(<span class="params">target, type, listener, prepend</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m;</span><br><span class="line">  <span class="keyword">var</span> events;</span><br><span class="line">  <span class="keyword">var</span> existing;</span><br><span class="line">  <span class="comment">// 判断是否为有效的函数    </span></span><br><span class="line">  checkListener(listener);</span><br><span class="line"></span><br><span class="line">  events = target._events;</span><br><span class="line">  <span class="keyword">if</span> (events === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    events = target._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    target._eventsCount = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// To avoid recursion in the case that type === &quot;newListener&quot;! Before</span></span><br><span class="line">    <span class="comment">// adding it to the listeners, first emit &quot;newListener&quot;.</span></span><br><span class="line">    <span class="keyword">if</span> (events.newListener !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      target.emit(<span class="string">&#x27;newListener&#x27;</span>, type,</span><br><span class="line">                  listener.listener ? listener.listener : listener);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Re-assign `events` because a newListener handler could have caused the</span></span><br><span class="line">      <span class="comment">// this._events to be assigned to a new object</span></span><br><span class="line">      events = target._events;</span><br><span class="line">    &#125;</span><br><span class="line">    existing = events[type];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (existing === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// Optimize the case of one listener. Don&#x27;t need the extra array object.</span></span><br><span class="line">    <span class="comment">// 只有一个 listener 的情况， 存储的直接是这个函数</span></span><br><span class="line">    existing = events[type] = listener;</span><br><span class="line">    ++target._eventsCount;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> existing === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// Adding the second element, need to change to array.</span></span><br><span class="line">      existing = events[type] =</span><br><span class="line">        prepend ? [listener, existing] : [existing, listener];</span><br><span class="line">      <span class="comment">// If we&#x27;ve already got an array, just append.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prepend) &#123;</span><br><span class="line">      existing.unshift(listener);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      existing.push(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for listener leak</span></span><br><span class="line">    <span class="comment">// 获取到一个事件最多的 listener 数量</span></span><br><span class="line">    m = _getMaxListeners(target);</span><br><span class="line">    <span class="keyword">if</span> (m &gt; <span class="number">0</span> &amp;&amp; existing.length &gt; m &amp;&amp; !existing.warned) &#123;</span><br><span class="line">      existing.warned = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// No error code for this since it is a Warning</span></span><br><span class="line">      <span class="comment">// eslint-disable-next-line no-restricted-syntax</span></span><br><span class="line">      <span class="keyword">var</span> w = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Possible EventEmitter memory leak detected. &#x27;</span> +</span><br><span class="line">                          existing.length + <span class="string">&#x27; &#x27;</span> + <span class="built_in">String</span>(type) + <span class="string">&#x27; listeners &#x27;</span> +</span><br><span class="line">                          <span class="string">&#x27;added. Use emitter.setMaxListeners() to &#x27;</span> +</span><br><span class="line">                          <span class="string">&#x27;increase limit&#x27;</span>);</span><br><span class="line">      w.name = <span class="string">&#x27;MaxListenersExceededWarning&#x27;</span>;</span><br><span class="line">      w.emitter = target;</span><br><span class="line">      w.type = type;</span><br><span class="line">      w.count = existing.length;</span><br><span class="line">      ProcessEmitWarning(w);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.addListener = <span class="function"><span class="keyword">function</span> <span class="title">addListener</span>(<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _addListener(<span class="built_in">this</span>, type, listener, <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.on = EventEmitter.prototype.addListener</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>emit(eventName[, ...args])</code></p>
<p>作用：发布 <code>eventName</code> 事件， 传入的 args 将会作为该事件下 <code>listener</code> 的参数</p>
<p>代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里包含了 type 为 &quot;error&quot; 或者其他需要 emit 的触发</span></span><br><span class="line">EventEmitter.prototype.emit = <span class="function"><span class="keyword">function</span> <span class="title">emit</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">  <span class="keyword">var</span> doError = (type === <span class="string">&#x27;error&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> events = <span class="built_in">this</span>._events;</span><br><span class="line">  <span class="comment">// 当 events 存在的时候</span></span><br><span class="line">  <span class="keyword">if</span> (events !== <span class="literal">undefined</span>)</span><br><span class="line">    <span class="comment">// 当 events 中不存在 error 事件时还 emit 了 error 事件</span></span><br><span class="line">    doError = (doError &amp;&amp; events.error === <span class="literal">undefined</span>);</span><br><span class="line">  <span class="comment">// 当 events 不存在， 并且 type 为非 error时， 直接返回 false</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!doError)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If there is no &#x27;error&#x27; event listener then throw.</span></span><br><span class="line">  <span class="comment">// events 中没有 error 的时候</span></span><br><span class="line">  <span class="keyword">if</span> (doError) &#123;</span><br><span class="line">    <span class="keyword">var</span> er;</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>)</span><br><span class="line">      er = args[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (er <span class="keyword">instanceof</span> <span class="built_in">Error</span>) &#123;</span><br><span class="line">      <span class="comment">// Note: The comments on the `throw` lines are intentional, they show</span></span><br><span class="line">      <span class="comment">// up in Node&#x27;s output if this results in an unhandled exception.</span></span><br><span class="line">      <span class="keyword">throw</span> er; <span class="comment">// Unhandled &#x27;error&#x27; event</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// At least give some kind of context to the user</span></span><br><span class="line">    <span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Unhandled error.&#x27;</span> + (er ? <span class="string">&#x27; (&#x27;</span> + er.message + <span class="string">&#x27;)&#x27;</span> : <span class="string">&#x27;&#x27;</span>));</span><br><span class="line">    err.context = er;</span><br><span class="line">    <span class="keyword">throw</span> err; <span class="comment">// Unhandled &#x27;error&#x27; event</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> handler = events[type];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (handler === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> handler === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    ReflectApply(handler, <span class="built_in">this</span>, args);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> len = handler.length;</span><br><span class="line">    <span class="keyword">var</span> listeners = arrayClone(handler, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">      ReflectApply(listeners[i], <span class="built_in">this</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li><p><code>off</code> / <code>removeListener(eventName, listener)</code><br>作用： 从事件名为 <code>eventName</code> 的事件下移除特定的回调方法（<code>listener</code>）<br>代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Emits a &#x27;removeListener&#x27; event if and only if the listener was removed.</span></span><br><span class="line"><span class="comment">// 移除特定事件的 listener &amp;&amp; </span></span><br><span class="line"><span class="comment">// EventEmitter.on(&#x27;removeListener&#x27;， handler) 触发</span></span><br><span class="line"><span class="comment">// type: 特定事件名称</span></span><br><span class="line"><span class="comment">// listener: 移除的函数</span></span><br><span class="line">EventEmitter.prototype.removeListener =</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">removeListener</span>(<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> list, events, position, i, originalListener;</span><br><span class="line"></span><br><span class="line">      checkListener(listener);</span><br><span class="line"></span><br><span class="line">      events = <span class="built_in">this</span>._events;</span><br><span class="line">      <span class="keyword">if</span> (events === <span class="literal">undefined</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">      list = events[type];</span><br><span class="line">      <span class="keyword">if</span> (list === <span class="literal">undefined</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="comment">// 这里判断是否 list 中只有一个 listener 或者 list 是 wrap fn 的情况</span></span><br><span class="line">      <span class="keyword">if</span> (list === listener || list.listener === listener) &#123;</span><br><span class="line">        <span class="keyword">if</span> (--<span class="built_in">this</span>._eventsCount === <span class="number">0</span>)</span><br><span class="line">          <span class="built_in">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">delete</span> events[type];</span><br><span class="line">          <span class="keyword">if</span> (events.removeListener)</span><br><span class="line">            <span class="built_in">this</span>.emit(<span class="string">&#x27;removeListener&#x27;</span>, type, list.listener || listener);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当 list 不是一个函数的时候，这个时候这个 list 是一个数组</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> list !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        position = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = list.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">          <span class="keyword">if</span> (list[i] === listener || list[i].listener === listener) &#123;</span><br><span class="line">            originalListener = list[i].listener;</span><br><span class="line">            position = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找不到listener</span></span><br><span class="line">        <span class="keyword">if</span> (position &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">          <span class="comment">// 第一个是要找到的 listener</span></span><br><span class="line">        <span class="keyword">if</span> (position === <span class="number">0</span>)</span><br><span class="line">          list.shift();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如果要进行删除的元素在 list 数组之中</span></span><br><span class="line">          <span class="comment">// splice</span></span><br><span class="line">          spliceOne(list, position);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当 list 删除完成之后只有一个 listener 时， 直接将这个 listener 作为 events[type] 的值</span></span><br><span class="line">        <span class="keyword">if</span> (list.length === <span class="number">1</span>)</span><br><span class="line">          events[type] = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (events.removeListener !== <span class="literal">undefined</span>)</span><br><span class="line">          <span class="built_in">this</span>.emit(<span class="string">&#x27;removeListener&#x27;</span>, type, originalListener || listener);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">EventEmitter.prototype.off = EventEmitter.prototype.removeListener;</span><br></pre></td></tr></table></figure>
<p>特别：<code>spliceOne</code> 方法, 而非使用<code>splice</code> 方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 这里是删除数组的方法</span><br><span class="line">&#x2F;&#x2F; 用的方法是找到一个数组的位置， 然后往前挪</span><br><span class="line">&#x2F;&#x2F; 这种方法性能提升比较大</span><br><span class="line">function spliceOne(list, index) &#123;</span><br><span class="line">  for (; index + 1 &lt; list.length; index++)</span><br><span class="line">    list[index] &#x3D; list[index + 1];</span><br><span class="line">  list.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>once(eventName, listener)</code><br>作用：添加只能调用一次的 <code>listener</code> 方法</p>
<p>代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onceWrapper</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里的 fired 或许是为了更方便的暴露给外部使用</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.fired) &#123;</span><br><span class="line">    <span class="comment">// 移除之后这里的闭包将会被回收了</span></span><br><span class="line">    <span class="built_in">this</span>.target.removeListener(<span class="built_in">this</span>.type, <span class="built_in">this</span>.wrapFn);</span><br><span class="line">    <span class="built_in">this</span>.fired = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.listener.call(<span class="built_in">this</span>.target);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.listener.apply(<span class="built_in">this</span>.target, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 onceWrap 维持了一个 state 状态 用来保存是否被触发过的状态</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_onceWrap</span>(<span class="params">target, type, listener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> state = &#123; <span class="attr">fired</span>: <span class="literal">false</span>, <span class="attr">wrapFn</span>: <span class="literal">undefined</span>, <span class="attr">target</span>: target, <span class="attr">type</span>: type, <span class="attr">listener</span>: listener &#125;;</span><br><span class="line">  <span class="comment">// 这里是注入里一些状态字段</span></span><br><span class="line">  <span class="comment">// 这里保存一些状态字段， 比如： fired 用来表示这个函数有没有被触发过</span></span><br><span class="line">  <span class="keyword">var</span> wrapped = onceWrapper.bind(state);</span><br><span class="line">  wrapped.listener = listener;</span><br><span class="line">  state.wrapFn = wrapped;</span><br><span class="line">  <span class="keyword">return</span> wrapped;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 _oncewrap 方法执行之后是一个方法， 方法上的 listener 属性才是传入 once 方法的</span></span><br><span class="line"><span class="comment">// listener 参数</span></span><br><span class="line"><span class="comment">// 这里的 _onceWrap 方法的包装解释了代码中存在的 listener.listener || listener 的判断</span></span><br><span class="line">EventEmitter.prototype.once = <span class="function"><span class="keyword">function</span> <span class="title">once</span>(<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">  checkListener(listener);</span><br><span class="line">  <span class="built_in">this</span>.on(type, _onceWrap(<span class="built_in">this</span>, type, listener));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="5">
<li><p><code>prependListener(eventName, listener)</code></p>
<p>作用：添加 <code>listener</code> 到事件 <code>eventName</code> 回调数组中的第一个， 当事件被发布时， 添加的 <code>listener</code> 第一个执行</p>
<p>代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">EventEmitter.prototype.prependListener =</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">prependListener</span>(<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _addListener(<span class="built_in">this</span>, type, listener, <span class="literal">true</span>);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="6">
<li><p><code>prependOnceListener(eventName, listener)</code></p>
<p>作用： 添加一次性的 listener 到事件回调函数队列头部</p>
<p>代码：就是 <code>prependListener</code> 和 <code>_onceWrap</code> 方法的结合</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">EventEmitter.prototype.prependOnceListener =</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">prependOnceListener</span>(<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">      checkListener(listener);</span><br><span class="line">      <span class="built_in">this</span>.prependListener(type, _onceWrap(<span class="built_in">this</span>, type, listener));</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="7">
<li><p><code>removeAllListeners([eventName])</code></p>
<p>作用： 移除 <code>eventName</code> 事件的全部 <code>listener</code></p>
<p>代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">EventEmitter.prototype.removeAllListeners =</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">removeAllListeners</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> listeners, events, i;</span><br><span class="line"></span><br><span class="line">      events = <span class="built_in">this</span>._events;</span><br><span class="line">      <span class="keyword">if</span> (events === <span class="literal">undefined</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// not listening for removeListener, no need to emit</span></span><br><span class="line">      <span class="comment">// 为了保证 removeListener 方法在删除完之后最后触发，</span></span><br><span class="line">      <span class="comment">// 需要判断是否存在这个 removeListener 方法是否存在</span></span><br><span class="line">      <span class="keyword">if</span> (events.removeListener === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">          <span class="built_in">this</span>._eventsCount = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[type] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (--<span class="built_in">this</span>._eventsCount === <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">delete</span> events[type];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// emit removeListener for all listeners on all events</span></span><br><span class="line">      <span class="comment">// _events 中存在 removeListener 方法</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(events);</span><br><span class="line">        <span class="keyword">var</span> key;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; keys.length; ++i) &#123;</span><br><span class="line">          key = keys[i];</span><br><span class="line">          <span class="keyword">if</span> (key === <span class="string">&#x27;removeListener&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">          <span class="built_in">this</span>.removeAllListeners(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保证之前移除listener 时能够触发 removeListener 回调</span></span><br><span class="line">        <span class="built_in">this</span>.removeAllListeners(<span class="string">&#x27;removeListener&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>._eventsCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 删除单个事件</span></span><br><span class="line"></span><br><span class="line">      listeners = events[type];</span><br><span class="line">      <span class="comment">// 兼容 listeners 中单个 listener 或者 多个 listener 的问题</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> listeners === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.removeListener(type, listeners);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (listeners !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="comment">// LIFO order</span></span><br><span class="line">        <span class="keyword">for</span> (i = listeners.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">          <span class="built_in">this</span>.removeListener(type, listeners[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="8">
<li><p><code>rawListeners(eventName)</code> </p>
<p>作用： 获取到 <code>eventName</code> 事件的全部 <code>listeners</code>, 包括是通过 <code>once</code> 方法创建的包裹 <code>listener</code></p>
<p>代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个方法用来获取到所有的 listener 无论是原生的还是放在 wrapper 上面的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unwrapListeners</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = <span class="keyword">new</span> <span class="built_in">Array</span>(arr.length);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ret.length; ++i) &#123;</span><br><span class="line">    ret[i] = arr[i].listener || arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取到全部的 _listeners </span></span><br><span class="line"><span class="comment">// type event 名称</span></span><br><span class="line"><span class="comment">// unwrap 是否是获取 非once 方法创建的 wrapper listener</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_listeners</span>(<span class="params">target, type, unwrap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> events = target._events;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (events === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> evlistener = events[type];</span><br><span class="line">  <span class="keyword">if</span> (evlistener === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> evlistener === <span class="string">&#x27;function&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> unwrap ? [evlistener.listener || evlistener] : [evlistener];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> unwrap ?</span><br><span class="line">    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);</span><br><span class="line">&#125;</span><br><span class="line">EventEmitter.prototype.rawListeners = <span class="function"><span class="keyword">function</span> <span class="title">rawListeners</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _listeners(<span class="built_in">this</span>, type, <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>translate3d&#39;</title>
    <url>/2017/11/05/translate3d/</url>
    <content><![CDATA[<h3 id="transform-特性"><a href="#transform-特性" class="headerlink" title="transform 特性"></a>transform 特性</h3><p>一个使用 <code>transform</code> 实现的垂直居中的代码如下:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fDiv"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cDiv"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> &gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.fDiv</span> &#123;</span></span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    position: relative</span><br><span class="line">    background-color: blue;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.cDiv</span> &#123;</span></span><br><span class="line">    position: absolute;</span><br><span class="line">    background-color: red;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    width: 50%;</span><br><span class="line">    height: 50%;</span><br><span class="line">    transform: translate3d(-50%, -50%, 0); // translate(-50%, -50%)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>transform</code> 这个的 css 元素实际上是可以允许我们对于元素进行旋转, 移动, 缩放, 或者平移</p>
<p>常见的 <code>transform 特性如下</code></p>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/tranform%20%E7%89%B9%E6%80%A7.png" alt></p>
<p>其中 translate 规定的是元素在 x, y ,z 轴上的位移</p>
<h4 id="translate"><a href="#translate" class="headerlink" title="translate"></a>translate</h4><blockquote>
<p>(x, y, z)</p>
<p>length / percentage  </p>
</blockquote>
<p>其中 x, y z 的单位可以是长度或者是百分比, 当以百分比进行比较的时候, 百分比相对的是元素本身的高度或者宽度</p>
<p>在上面的完全居中代码中</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line"><span class="selector-tag">background-color</span>: <span class="selector-tag">red</span>;</span><br><span class="line"><span class="selector-tag">top</span>: 50%;</span><br><span class="line"><span class="selector-tag">left</span>: 50%;</span><br><span class="line"><span class="selector-tag">width</span>: 50%;</span><br><span class="line"><span class="selector-tag">height</span>: 50%;</span><br><span class="line">transform: translate3d(-50%, -50%, 0); // translate(-50%, -50%)</span><br></pre></td></tr></table></figure>
<p>在添加 <code>transform</code>之前, 方块是这样被放置的:</p>
<p>因为这里是定位, <code>top</code> 以及 <code>left</code> 被放置的时候的宽度以及高度的百分比是按照父元素的宽度和高度进行计算的</p>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/notransform.png" alt></p>
<p>添加了<code>transform</code> 之后</p>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/tranform%20%E5%B1%85%E4%B8%AD.png" alt></p>
<p>因为这里使用 translate 定义的距离 x , y , z 的距离是根据元素本身的宽度和高度被定义的, 而同时使用 <code>left: 50%</code> 的时候元素被紧靠在父元素的中间垂线上, 使用 <code>translate</code> 的时候向左移动了元素的一半距离, 使得这个元素在水平距离上是居中设置的。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>transform</tag>
      </tags>
  </entry>
  <entry>
    <title>this.nextTick in vue.js</title>
    <url>/2018/01/21/this-nextTick-in-vue-js/</url>
    <content><![CDATA[<h3 id="this-nextTick-的作用"><a href="#this-nextTick-的作用" class="headerlink" title="this.nextTick 的作用"></a><code>this.nextTick</code> 的作用</h3><p>在 <code>Vue.js</code> 的官方文档中是这样描述 <code>this.nextTick</code> 的:</p>
<blockquote>
<p>为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 <code>Vue.nextTick(callback)</code> 。这样回调函数在 DOM 更新完成后就会调用.</p>
</blockquote>
<p>在 <code>vue.js</code> 中, 使用 <code>this.nextTick</code> 的作用是更新 <code>dom</code> , 在 涉及关于在 <code>vue.js</code> 中 <code>Dom</code> 的操作中, 当我们想要操作被更新后的 <code>DOM</code>的时候，可以使用 <code>this.nextTick</code> 进行操作。</p>
<h3 id="为什么采用-this-nextTick"><a href="#为什么采用-this-nextTick" class="headerlink" title="为什么采用   this.nextTick"></a>为什么采用   <code>this.nextTick</code></h3><blockquote>
<p>Vue <strong>异步</strong>执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 <code>Promise.then</code> 和 <code>MessageChannel</code>，如果执行环境不支持，会采用 <code>setTimeout(fn, 0)</code> 代替。</p>
</blockquote>
<p>使用 <code>this.nextTick</code> 的两种情况:</p>
<ol>
<li><p>在 <code>created</code> 阶段的时候， 这个时候 <code>DOM</code> 元素尚未挂载, 在这个钩子函数内操作 <code>DOM</code> 是无法找到 <code>DOM</code> 元素的， 这个时候使用 <code>this.nextTick</code> 类似于使用 <code>mounted</code> 的钩子函数， 这个时候所有的 <code>DOM</code> 元素挂载和渲染均已经完成，这个时候可以执行对于 <code>DOM</code> 元素的操作。</p>
</li>
<li><p>当我们想要对于数据发生变化之后的 <code>DOM</code> 元素之后执行一些操作的时候， 我们可以使用 <code>this.nextTick(callback)</code> 那么 <code>callback</code> 回调函数就会当 <code>DOM</code> 元素被更新之后被触发。</p>
<p>​</p>
<p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="https://cn.vuejs.org/images/lifecycle.png"> </p>
</li>
</ol>
<p>上图是 <code>vue</code> 实例的生命周期图。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>this.nextTick</tag>
      </tags>
  </entry>
  <entry>
    <title>prop in vue.js（prop 的初始化）</title>
    <url>/2019/05/25/prop%20in%20vue%EF%BC%88prop%20%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%89/</url>
    <content><![CDATA[<h3 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h3><p>在 vue.js 中, 使用 <code>prop</code> 可以实现父组件向子组件传递值，在子组件中的 <code>props</code> 中的数据将会和父组件中传递的相应的 <code>prop</code> 保持一致，在传递 <code>prop</code> 的时候，可以传递一个数组, 例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">'data1'</span>, <span class="string">'data2'</span>, <span class="string">'data3'</span> ...]</span><br></pre></td></tr></table></figure>
<p> 或者可以传递一个对象，对象的键是要传递的 prop 名称， 对象的值可以是一个对象， 这个对象中 可以定义传递值的<code>type</code> 以及 <code>default</code> 属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  data1: &#123;</span><br><span class="line">    type: <span class="built_in">Boolean</span>, <span class="comment">// 传递值的类型， 可以是一个数组 [Boolean, String]</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="literal">true</span> <span class="comment">// 当父组件没有传递的时候， 子组件中使用的默认值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当父组件中传递值的类型不符合子组件 props 中相应值的 type 的时候， vue 会在控制台进行报错。</p>
<p>在源码中， 在初始化 prop 的时候， 会对prop 进行校验。</p>
<h4 id="初始化-props"><a href="#初始化-props" class="headerlink" title="初始化 props"></a>初始化 <code>props</code></h4><p>在 <code>initState</code> 中：当当前组件中存在 <code>props</code> 的时候， 对于 <code>props</code> 执行 <code>initProps</code> 进行初始化：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm</span>) </span>&#123;</span><br><span class="line">    vm._watchers = [];</span><br><span class="line">    <span class="keyword">var</span> opts = vm.$options;</span><br><span class="line">    <span class="keyword">if</span> (opts.props) &#123; initProps(vm, opts.props); &#125;</span><br><span class="line">    <span class="keyword">if</span> (opts.methods) &#123; initMethods(vm, opts.methods); &#125;</span><br><span class="line">    <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">      initData(vm);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (opts.computed) &#123; initComputed(vm, opts.computed); &#125;</span><br><span class="line">    <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">      initWatch(vm, opts.watch);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>initProps</code> 中接受两个参数： <code>vm</code> 当前 vue 的实例， <code>propsOptions</code> 在当前组件中规范化后的 <code>props</code> 对象</p>
<blockquote>
<p>在执行 <code>initProps</code> 方法之前， 在 <code>vm.$options</code> 属性中的  <code>props</code> 属性中已经对于传递的 <code>props</code> 进行了规范化处理为下面的这种形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;test: &#123;</span><br><span class="line">&gt;  type: sometype,</span><br><span class="line">&gt;  <span class="keyword">default</span>: <span class="comment">//  默认值， 如果没有传， 那么就没有</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
</blockquote>
<p><code>initProps</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于初始化 props 对象  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initProps</span> (<span class="params">vm, propsOptions</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// vm.$options.propsData: 父组件中传递的 props 对象</span></span><br><span class="line">    <span class="keyword">var</span> propsData = vm.$options.propsData || &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> props = vm._props = &#123;&#125;;</span><br><span class="line">    <span class="comment">// cache prop keys so that future props updates can iterate using Array</span></span><br><span class="line">    <span class="comment">// instead of dynamic object key enumeration.</span></span><br><span class="line">    <span class="keyword">var</span> keys = vm.$options._propKeys = [];</span><br><span class="line">    <span class="keyword">var</span> isRoot = !vm.$parent;</span><br><span class="line">    <span class="comment">// root instance props should be converted</span></span><br><span class="line">    <span class="keyword">if</span> (!isRoot) &#123;</span><br><span class="line">      toggleObserving(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> loop = <span class="function"><span class="keyword">function</span> (<span class="params"> key </span>) </span>&#123;</span><br><span class="line">      keys.push(key);</span><br><span class="line">      <span class="keyword">var</span> value = validateProp(key, propsOptions, propsData, vm);</span><br><span class="line">      <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">var</span> hyphenatedKey = hyphenate(key);</span><br><span class="line">        <span class="keyword">if</span> (isReservedAttribute(hyphenatedKey) ||</span><br><span class="line">            config.isReservedAttr(hyphenatedKey)) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            (<span class="string">"\""</span> + hyphenatedKey + <span class="string">"\" is a reserved attribute and cannot be used as component prop."</span>),</span><br><span class="line">            vm</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">        defineReactive(props, key, value, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (!isRoot &amp;&amp; !isUpdatingChildComponent) &#123;</span><br><span class="line">            warn(</span><br><span class="line">              <span class="string">"Avoid mutating a prop directly since the value will be "</span> +</span><br><span class="line">              <span class="string">"overwritten whenever the parent component re-renders. "</span> +</span><br><span class="line">              <span class="string">"Instead, use a data or computed property based on the prop's "</span> +</span><br><span class="line">              <span class="string">"value. Prop being mutated: \""</span> + key + <span class="string">"\""</span>,</span><br><span class="line">              vm</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// static props are already proxied on the component's prototype</span></span><br><span class="line">      <span class="comment">// during Vue.extend(). We only need to proxy props defined at</span></span><br><span class="line">      <span class="comment">// instantiation here.</span></span><br><span class="line">      <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">        proxy(vm, <span class="string">"_props"</span>, key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> propsOptions) loop( key );</span><br><span class="line">    toggleObserving(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在上面的函数中。我们传入了 vue 实例和 当前组件中传入的 props 中的数据， 在这个函数中， 我们定义了四个变量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> propsData = vm.$options.propsData || &#123;&#125;; <span class="comment">// 获取到父组件传递到子组件中的值</span></span><br><span class="line"><span class="keyword">var</span> props = vm._props = &#123;&#125;; <span class="comment">// 在实例上的 _props 属性上定义空对象 &#123;&#125;</span></span><br><span class="line"><span class="comment">// cache prop keys so that future props updates can iterate using Array</span></span><br><span class="line"><span class="comment">// instead of dynamic object key enumeration.</span></span><br><span class="line"><span class="keyword">var</span> keys = vm.$options._propKeys = []; <span class="comment">// 在 实例的 $options 属性上定义 _propKeys 属性， 并初始化为数组</span></span><br><span class="line"><span class="keyword">var</span> isRoot = !vm.$parent; <span class="comment">// 判断是否为根元素， 因为对于根元素， 其实例上没有 `$parent` 属性， 这个时候 `isRoot` 为true</span></span><br></pre></td></tr></table></figure>
<p>上面的 <code>toggleObserving</code> 方法用来切换是否对与数据进行监听的开关函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * In some cases we may want to disable observation inside a component's</span></span><br><span class="line"><span class="comment"> * update computation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> shouldObserve = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 根据传递的 vue 属性来切换 `shouleObserve` 的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toggleObserving</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  shouldObserve = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过调用这个方法， 改变的是全局变量 <code>shouldObserve</code> 的值， 这个值的作用我们后面在说， 现在， 我们先看下在 <code>initProps</code> 中的 <code>for in</code> 中的 <code>loop</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> propsOptions) loop(key);</span><br></pre></td></tr></table></figure>
<p>在上面的代码中， 对于当前组件内 prop 中的每一个 prop 值， 都执行 <code>loop</code> 方法：</p>
<p><code>loop</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// key prop 值</span></span><br><span class="line"><span class="keyword">var</span> loop = <span class="function"><span class="keyword">function</span> (<span class="params"> key </span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将当前组件内所有的 prop 值存入到 keys 中</span></span><br><span class="line">  keys.push(key);</span><br><span class="line">  <span class="comment">// 根据定义的 prop 规则判断传入的 prop 值是否有效</span></span><br><span class="line">  <span class="keyword">var</span> value = validateProp(key, propsOptions, propsData, vm);</span><br><span class="line">  <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> hyphenatedKey = hyphenate(key);</span><br><span class="line">    <span class="keyword">if</span> (isReservedAttribute(hyphenatedKey) ||</span><br><span class="line">        config.isReservedAttr(hyphenatedKey)) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        (<span class="string">"\""</span> + hyphenatedKey + <span class="string">"\" is a reserved attribute and cannot be used as component prop."</span>),</span><br><span class="line">        vm</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    defineReactive(props, key, value, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!isRoot &amp;&amp; !isUpdatingChildComponent) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">"Avoid mutating a prop directly since the value will be "</span> +</span><br><span class="line">          <span class="string">"overwritten whenever the parent component re-renders. "</span> +</span><br><span class="line">          <span class="string">"Instead, use a data or computed property based on the prop's "</span> +</span><br><span class="line">          <span class="string">"value. Prop being mutated: \""</span> + key + <span class="string">"\""</span>,</span><br><span class="line">          vm</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// static props are already proxied on the component's prototype</span></span><br><span class="line">  <span class="comment">// during Vue.extend(). We only need to proxy props defined at</span></span><br><span class="line">  <span class="comment">// instantiation here.</span></span><br><span class="line">  <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">    proxy(vm, <span class="string">"_props"</span>, key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上面的 loop 方法中， 当传入 key 之后， 执行了 <code>validateProp</code> 方法， 这个方法定义如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;key&#125;</span> </span>在 props 中定义的 prop 值 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;propOptions&#125;</span> </span>propOptions : 所有的 prop 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;propsData&#125;</span> </span>propsData 从上层组件传入的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;vm&#125;</span> </span>vue 实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validateProp</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  key,</span></span></span><br><span class="line"><span class="function"><span class="params">  propOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">  propsData,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取当前 prop 值的规则</span></span><br><span class="line">  <span class="keyword">var</span> prop = propOptions[key];</span><br><span class="line">  <span class="comment">// 判断这个 prop 值有没有被传入到</span></span><br><span class="line">  <span class="keyword">var</span> absent = !hasOwn(propsData, key);</span><br><span class="line">  <span class="keyword">var</span> value = propsData[key];</span><br><span class="line">  <span class="comment">// boolean casting</span></span><br><span class="line">  <span class="keyword">var</span> booleanIndex = getTypeIndex(<span class="built_in">Boolean</span>, prop.type);</span><br><span class="line">  <span class="keyword">if</span> (booleanIndex &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (absent &amp;&amp; !hasOwn(prop, <span class="string">'default'</span>)) &#123;</span><br><span class="line">      value = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value === <span class="string">''</span> || value === hyphenate(key)) &#123;</span><br><span class="line">      <span class="comment">// only cast empty string / same name to boolean if</span></span><br><span class="line">      <span class="comment">// boolean has higher priority</span></span><br><span class="line">      <span class="keyword">var</span> stringIndex = getTypeIndex(<span class="built_in">String</span>, prop.type);</span><br><span class="line">      <span class="keyword">if</span> (stringIndex &lt; <span class="number">0</span> || booleanIndex &lt; stringIndex) &#123;</span><br><span class="line">        value = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// check default value</span></span><br><span class="line">  <span class="keyword">if</span> (value === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    value = getPropDefaultValue(vm, prop, key);</span><br><span class="line">    <span class="comment">// since the default value is a fresh copy,</span></span><br><span class="line">    <span class="comment">// make sure to observe it.</span></span><br><span class="line">    <span class="keyword">var</span> prevShouldObserve = shouldObserve;</span><br><span class="line">    toggleObserving(<span class="literal">true</span>);</span><br><span class="line">    observe(value);</span><br><span class="line">    toggleObserving(prevShouldObserve);</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    assertProp(prop, key, value, vm, absent);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法内部 定义了四个变量：</p>
<p><code>prop</code>: 当前传入 prop 值的对象</p>
<p><code>absent</code>:  布尔值， 当前 prop 有没有被父组件传入</p>
<p><code>value</code>:  父组件传入的 prop 的值， 如果没有传入，为 <code>undefined</code></p>
<p><code>booleanIndex</code>:  是通过 <code>getTypeIndex</code> 方法返回的， 这个方法的作用是：</p>
<p>当 prop 中声明的 type 中包含有布尔值的时候， 如果 type 为 String， 返回 0， 如果 type 为数组， 返回这个 Boolean 值在 type 数组中的顺序 index， 如果不包含布尔值， 那么返回 -1</p>
<p><code>getTypeIndex</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// expectedTypes： prop 中声明的 type</span></span><br><span class="line"><span class="comment">// type: 相应的 type 类型， 例如： Boolean, String</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTypeIndex</span> (<span class="params">type, expectedTypes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(expectedTypes)) &#123;</span><br><span class="line">    <span class="keyword">return</span> isSameType(expectedTypes, type) ? <span class="number">0</span> : <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = expectedTypes.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isSameType(expectedTypes[i], type)) &#123;</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里， 使用了 <code>isSameType</code> 方法来进行比较者两个 type 是否相等：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Use function string name to check built-in types,</span></span><br><span class="line"><span class="comment">  * because a simple equality check will fail when running</span></span><br><span class="line"><span class="comment">  * across different vms / iframes.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">getType</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> match = fn &amp;&amp; fn.toString().match(<span class="regexp">/^\s*function (\w+)/</span>);</span><br><span class="line">   <span class="keyword">return</span> match ? match[<span class="number">1</span>] : <span class="string">''</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">isSameType</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> getType(a) === getType(b)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在上面的 <code>getType</code> 中， 调用 <code>fn.toString()</code> 方法， 再通过正则表达式获取到 <code>(\w+)</code> 内的内容，例如：</p>
<blockquote>
<p>因为， 在 js 中例如 <code>Boolean</code>, <code>String</code> 之类的类型， 都是代表着一个个的函数方法， 对于这个函数， 可以调用 toString</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">Boolean</span><br><span class="line"><span class="comment">// ƒ Boolean() &#123; [native code] &#125;</span></span><br><span class="line">Boolean.toString()</span><br><span class="line"><span class="comment">//"function Boolean() &#123; [native code] &#125;"</span></span><br></pre></td></tr></table></figure>
<p>接来下， 对于数据进行初始化：针对需要校验的 type 中包含有 <code>Boolean</code> 字段的时候</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当 prop 的type中包含有 “Boolean” 的时候  </span></span><br><span class="line"><span class="keyword">if</span> (booleanIndex &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="comment">// 当没有传入的 prop 的时候， 并且没有 default 属性的时候</span></span><br><span class="line">      <span class="keyword">if</span> (absent &amp;&amp; !hasOwn(prop, <span class="string">'default'</span>)) &#123;</span><br><span class="line">        <span class="comment">// 将 prop 值置为 false</span></span><br><span class="line">        value = <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value === <span class="string">''</span> || value === hyphenate(key)) &#123;</span><br><span class="line">        <span class="comment">// 当 boolean 有更高优先级的时候， 将空字符串或者和 prop 中名字相同的值转化为 布尔值</span></span><br><span class="line">        <span class="comment">// only cast empty string / same name to boolean if</span></span><br><span class="line">        <span class="comment">// boolean has higher priority</span></span><br><span class="line">        <span class="keyword">var</span> stringIndex = getTypeIndex(<span class="built_in">String</span>, prop.type);</span><br><span class="line">        <span class="keyword">if</span> (stringIndex &lt; <span class="number">0</span> || booleanIndex &lt; stringIndex) &#123;</span><br><span class="line">          value = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<p>有以下子组件： child.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    propData: &#123;</span><br><span class="line">      type: [Boolean, String],</span><br><span class="line">			default: &apos;&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在父组件中如下定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;child prop-data=&quot;&quot;&gt;&lt;/child&gt;</span><br></pre></td></tr></table></figure>
<p>那么在子组件中， 获得到的 <code>propData</code> 值为 <code>true</code>;</p>
<p>或者， 当在父组件中如下定义的时候：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;child prop-data=&quot;propData&quot;&gt;&lt;/child&gt;</span><br></pre></td></tr></table></figure>
<p>和上面相同， 也是为 <code>true</code>,</p>
<p>总之：</p>
<p>当定义的 prop 接受值的类型，<code>Boolean</code> 值类型优先级要高于 <code>String</code> 的时候（在 type 中  <code>Boolean</code> 在 <code>String</code> 前面 <code>[Boolean, String]</code>）:</p>
<ul>
<li>当传递的值为空字符串的时候， 接受到的prop 值变为 <code>true</code></li>
<li>当传递的值为字符串并且和驼峰后的 prop 名相同的时候， 接受的值也将转为 <code>true</code></li>
</ul>
<p>另外， 当在父组件中没有传入 prop 值， 并且， 没有声明 <code>default</code> 属性， 当校验 <code>type</code> 中包含有<code>Boolean</code> 的时候， 这个时候， 获取这个  <code>prop</code> 的值将为 <code>false</code></p>
<p><code>child.vue</code> 组件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    propData: &#123;</span><br><span class="line">      type: [Boolean, String]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父组件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;child&gt;&lt;/child&gt;</span><br></pre></td></tr></table></figure>
<p>在 <code>child.vue</code> 组件中获取到 <code>propData</code> 的值为 <code>false</code>;</p>
]]></content>
      <categories>
        <category>vue 源码阅读</category>
      </categories>
      <tags>
        <tag>vue 源码</tag>
      </tags>
  </entry>
  <entry>
    <title>tooltip 的实现</title>
    <url>/2018/05/08/tooltip-%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>在业务上实现了一个类似于 <code>el-tooltip</code> 的方法，类似于下面这种情况：</p>
<p>业务需求是对于弹窗的文字标签字段， 如果文字标签说明太长的时候， 而这个时候文字标签说明又有宽度限制， 这个时候需要实现一个类似于 <code>el-tooltip</code> 的实现方法，但是对于每一个标签上都添加上 <code>el-tooltip</code> 是不现实的，因此想要通过使用指令的方法，对于表单中的标签字段进行动态添加，实现这个指令的 <code>toolTip.js</code> 的具体代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于出现dialog 的情况， 都是在 el-dialog__wrapper 上进行滚动的</span></span><br><span class="line"><span class="keyword">import</span> Util <span class="keyword">from</span> <span class="string">"./util"</span>;</span><br><span class="line"><span class="keyword">const</span> getScrollRoot = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.documentElement.querySelector(<span class="string">".el-dialog__wrapper"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> instancePool = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 tip instance 方法</span></span><br><span class="line"><span class="keyword">const</span> instanceAction = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> push = <span class="function">(<span class="params">instance</span>) =&gt;</span> &#123;</span><br><span class="line">        instancePool.push(instance);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        pushInstance: push</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 获取到绑定元素在当前页面上距离左边的距离</span></span><br><span class="line"><span class="keyword">const</span> getElementViewLeft = <span class="function">(<span class="params">element</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> actualLeft = element.offsetLeft;</span><br><span class="line">    <span class="keyword">let</span> current = element.offsetParent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">        actualLeft += current.offsetLeft;</span><br><span class="line">        current = current.offsetParent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> actualLeft;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取到绑定元素在当前页面上位置高度</span></span><br><span class="line"><span class="keyword">const</span> getElementViewTop = <span class="function">(<span class="params">element</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> actualTop = element.offsetTop;</span><br><span class="line">    <span class="keyword">let</span> current = element.offsetParent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">        actualTop += current.offsetTop;</span><br><span class="line">        current = current.offsetParent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> actualTop;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tooltip</span>(<span class="params">el, opt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> items = el.querySelectorAll(<span class="string">".el-form-item"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> items) &#123;</span><br><span class="line">        <span class="keyword">const</span> target = item.firstChild;</span><br><span class="line">        <span class="comment">// 如果定义了一个 label 为空的时候的 form-item， label 部分为 before 元素， 但是还是可以这个时候 			className 为 null</span></span><br><span class="line">        <span class="keyword">if</span> (target.className) &#123;</span><br><span class="line">            <span class="comment">// 将每一个需要显示标签的实例信息压入</span></span><br><span class="line">            instanceAction().pushInstance(&#123; <span class="attr">tip</span>: <span class="literal">null</span>, target, <span class="attr">message</span>: target.innerText, <span class="attr">offset</span>: <span class="number">0</span>, <span class="attr">class</span>: <span class="string">"vk-tooltip"</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.scrollListener = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.mouseenterListener = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.mouseleaveListener = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">    <span class="comment">// target：传入的DOM</span></span><br><span class="line">    <span class="comment">// this.target = el;</span></span><br><span class="line">    <span class="comment">// tip：用来放初始化创建的tip元素</span></span><br><span class="line">    <span class="comment">// this.tip = null;</span></span><br><span class="line">    <span class="comment">// this.message = (opt &amp;&amp; opt.msg) || this.target.innerText;</span></span><br><span class="line">    <span class="comment">// this.offset = (opt &amp;&amp; +opt.offset) || 0;</span></span><br><span class="line">    <span class="comment">// this.class = "vk-tooltip";</span></span><br><span class="line">    <span class="comment">// instanceAction.push();</span></span><br><span class="line">    <span class="comment">// this.init();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tooltip.prototype = &#123;</span><br><span class="line">    <span class="comment">// 初始化tip，添加事件监听</span></span><br><span class="line">    init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> me = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">const</span> root = getScrollRoot();</span><br><span class="line">        <span class="comment">// 鼠标进入才创建标签</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> instance <span class="keyword">of</span> instancePool) &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; target, tip, message, offset &#125; = instance;</span><br><span class="line">            <span class="comment">// 滚动监听事件</span></span><br><span class="line">            <span class="comment">// 鼠标移入监听事件</span></span><br><span class="line">            <span class="comment">// 鼠标移除监听事件</span></span><br><span class="line">            <span class="keyword">if</span> (message.length &lt; <span class="number">6</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">this</span>.mouseenterListener = Util.listener(target, <span class="string">"mouseenter"</span>, () =&gt; &#123;</span><br><span class="line">                instance = me.createTip(instance);</span><br><span class="line">                instance.tip.style.opacity = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">this</span>.scrollListener = Util.listener(root, <span class="string">"scroll"</span>, () =&gt; &#123;</span><br><span class="line">                    me.setTipPlace(instance.tip, instance.target, instance.offset);</span><br><span class="line">                    instance.tip.style.opacity = <span class="number">0</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">this</span>.scrollListener.listen();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">this</span>.mouseenterListener.listen();</span><br><span class="line">            <span class="keyword">this</span>.mouseleaveListener = Util.listener(target, <span class="string">"mouseleave"</span>, () =&gt; &#123;</span><br><span class="line">                instance.tip.style.opacity = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">this</span>.scrollListener.remove();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">this</span>.mouseleaveListener.listen();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    createTip(instance) &#123;</span><br><span class="line">        <span class="keyword">const</span> me = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">const</span> poppup = <span class="string">"&lt;div class='triangle-down'&gt;&lt;/div&gt;"</span>;</span><br><span class="line">        <span class="keyword">const</span> cache = <span class="built_in">document</span>.getElementsByClassName(instance.class);</span><br><span class="line">        <span class="comment">// 如果存在一个tip标签则使用该标签</span></span><br><span class="line">        instance.tip = cache.length ? cache[<span class="number">0</span>] : <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">        instance.tip.className = instance.class;</span><br><span class="line">        instance.tip.innerHTML = <span class="string">`<span class="subst">$&#123;instance.message&#125;</span><span class="subst">$&#123;poppup&#125;</span>`</span>;</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(instance.tip);</span><br><span class="line">        <span class="keyword">if</span> (!me.tip) &#123;</span><br><span class="line">            me.tip = instance.tip;</span><br><span class="line">        &#125;</span><br><span class="line">        me.setTipPlace(instance.tip, instance.target, instance.offset);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置tip显示的位置</span></span><br><span class="line">    setTipPlace: <span class="function"><span class="keyword">function</span> (<span class="params">tip, target, offset</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> root = getScrollRoot();</span><br><span class="line">        <span class="keyword">const</span> distance = (tip.clientWidth - target.clientWidth) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">const</span> pageX = <span class="string">`<span class="subst">$&#123;getElementViewLeft(target) - root.scrollLeft - distance + offset&#125;</span>px`</span>;</span><br><span class="line">        <span class="keyword">const</span> pageY = <span class="string">`<span class="subst">$&#123;getElementViewTop(target) - target.clientHeight - root.scrollTop&#125;</span>px`</span>;</span><br><span class="line">        tip.style.left = pageX;</span><br><span class="line">        tip.style.top = pageY;</span><br><span class="line">    &#125;,</span><br><span class="line">    clear: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        instancePool = [];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.tip) &#123;</span><br><span class="line">            <span class="keyword">this</span>.tip.parentNode.removeChild(<span class="keyword">this</span>.tip);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.mouseenterListener.remove();</span><br><span class="line">        <span class="keyword">this</span>.mouseleaveListener.remove();</span><br><span class="line">        <span class="keyword">this</span>.mouseenterListener = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.mouseleaveListener = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.scrollListener = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> tooltip;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// /**</span></span><br><span class="line"><span class="comment">//  * @description 因为el的tooltip展示需要用到组件，这里用指令进行tooltip展示</span></span><br><span class="line"><span class="comment">//  * @example &lt;div v-tips&gt;此处为被缩略的文本内容&lt;/div&gt;</span></span><br><span class="line"><span class="comment">//  * @param opt v-tips="opt" 可以传入配置对象, msg 展示信息, offset X轴偏移量</span></span><br><span class="line"><span class="comment">//  * 在元素插入DOM时，创建tooltip实例。</span></span><br><span class="line"><span class="comment">//  */</span></span><br><span class="line"><span class="comment">// Vue.directive("tips", &#123;</span></span><br><span class="line"><span class="comment">//     bind: (el) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//         console.log(el);</span></span><br><span class="line"><span class="comment">//     &#125;,</span></span><br><span class="line"><span class="comment">//     // 当绑定元素插入到 DOM 中。</span></span><br><span class="line"><span class="comment">//     inserted: (el, &#123; value &#125;) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//         // 暂时针对el-form的label标签，所以指定firsChild</span></span><br><span class="line"><span class="comment">//         this.instance = new VkTooltip(el.firstChild, value);</span></span><br><span class="line"><span class="comment">//     &#125;,</span></span><br><span class="line"><span class="comment">//     // 解除绑定的时候清除实例以及标签,清除事件监听</span></span><br><span class="line"><span class="comment">//     unbind: (el) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//         this.instance.clear();</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"><span class="comment">// Util listen 函数</span></span><br><span class="line">Util.listen = <span class="function">(<span class="params">target, eventType, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target.addEventListener) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">          listen: &#123;</span><br><span class="line">            target.addEventListener(eventType, callback, <span class="literal">false</span>);</span><br><span class="line">          &#125;,</span><br><span class="line">          remove: &#123;</span><br><span class="line">            target.removeEventListener(eventType, callback, <span class="literal">false</span>);</span><br><span class="line">      	  &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target.attachEvent) &#123;</span><br><span class="line">      listen: &#123;</span><br><span class="line">          target.attachEvent(<span class="string">'on'</span> + eventType, callback);</span><br><span class="line">      &#125;,</span><br><span class="line">      remove: &#123;</span><br><span class="line">          target.detachEvent(<span class="string">'on'</span> + eventType, callback);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用的时候， 这个函数被作为指令在 <code>main.js</code> 中引入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> VKTooltip <span class="keyword">from</span> <span class="string">"@/assets/js/tooltip"</span>;</span><br><span class="line">Vue.directive(<span class="string">"tips"</span>, &#123;</span><br><span class="line">  bind: <span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  inserted: <span class="function">(<span class="params">el, &#123; value &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.instance = <span class="keyword">new</span> VKTooltip(el, value);</span><br><span class="line">  &#125;,</span><br><span class="line">  unbind: <span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>. instance.clear();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>关于在 <code>vue.js</code> 中自定义指令的使用， 可以查看<code>vue.js</code> 官网， <a href="https://cn.vuejs.org/v2/guide/custom-directive.html#ad" target="_blank" rel="noopener">自定义指令</a></p>
<p>需要注意的知识点：</p>
<ol>
<li>对于页面元素各个位置的理解</li>
<li>js 基础一定要熟悉</li>
</ol>
]]></content>
      <categories>
        <category>代码集</category>
      </categories>
      <tags>
        <tag>toolTip</tag>
      </tags>
  </entry>
  <entry>
    <title>underscore.js 源码分析(九)</title>
    <url>/2017/12/04/underscore-js-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B9%9D/</url>
    <content><![CDATA[<h3 id="underscore-js-源码分析"><a href="#underscore-js-源码分析" class="headerlink" title="underscore.js 源码分析"></a>underscore.js 源码分析</h3><p><code>sortedIndex</code>  <code>findIndex</code>  <code>findLastIndex</code> <code>range</code></p>
<h5 id="sortedIndex"><a href="#sortedIndex" class="headerlink" title="sortedIndex"></a><code>sortedIndex</code></h5><p><code>sortedIndex(list, value, [iteratee], context)</code></p>
<p>其中 <code>list</code> 是已经被排好序的数组，通过使用 <code>soetedIndex</code> 可以查找到 <code>value</code> 在已经排好序的 <code>list</code> 数组中的顺序。使用 二分法进行查找的。</p>
<p>使用二分法进行查找的 <code>value</code> 位置如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortIndex</span>(<span class="params">array, obj, iteratee, context</span>) </span>&#123;</span><br><span class="line">  iteratee = cb(iteratee, context, <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 获取到传入的 obj 的值</span></span><br><span class="line">  <span class="keyword">let</span> value = iteratee(obj);</span><br><span class="line">  <span class="keyword">let</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 定义 high 是数组的长度 array.length</span></span><br><span class="line">  <span class="keyword">let</span> high = array.length;</span><br><span class="line">  <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((low + high) / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 如果 array[mid] &gt; value value 在 low 和 mid 之间</span></span><br><span class="line">    <span class="keyword">if</span> (itetatee(array[mid]) &gt; value) &gt; <span class="number">0</span>) mid = high; <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a><code>findIndex</code></h5><p><code>findIndex(array, predicate, [context])</code></p>
<p>返回在<code>array</code> 中满足 <code>predicate</code> 函数为真的第一个元素的索引, 如果没有找到，返回 <code>-1</code>;</p>
<h5 id="findLastIndex"><a href="#findLastIndex" class="headerlink" title="findLastIndex"></a><code>findLastIndex</code></h5><p>类似于使用 <code>findIndex</code> 不同的是从数组的从后向前开始检索，返回的是第一个判断为真的值</p>
<p>使用 <code>findIndex</code> 以及 <code>findLastIndex</code> 的代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getIndexFunc</span>(<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">array, predicate, context</span>) </span>&#123;</span><br><span class="line">    predicate = cb(predicate, context);</span><br><span class="line">    <span class="keyword">let</span> length = array.length;</span><br><span class="line">    <span class="keyword">let</span> index = dir &gt; <span class="number">0</span> ? <span class="number">0</span> : length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; index &gt;= <span class="number">0</span> &amp;&amp; index &lt; length; index += dir) &#123;</span><br><span class="line">      <span class="keyword">if</span> (predicate(array[index], index, array)) <span class="keyword">return</span> index; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> findIndex = getIndexFunc(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> findLastIndex = getIndexFunc(<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
<h5 id="range"><a href="#range" class="headerlink" title="range"></a><code>range</code></h5><p><code>range([start], stop, [step])</code></p>
<p>使用 <code>range</code> 创建一个整数灵活编号的列表函数，返回一个从 <code>start</code> 到 <code>stop</code> 的整数的一个列表, 通过使用 <code>step</code> 来减少独占。</p>
<p>如果省略 <code>start</code>, <code>start</code> 默认从 0 开始，步进为 1;</p>
<p>自己写的代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">range</span>(<span class="params">start, stop, step</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">	<span class="keyword">let</span> resultArray = [];</span><br><span class="line">	<span class="keyword">let</span> theStep = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">let</span> theStart = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (args.length === <span class="number">1</span>) &#123;</span><br><span class="line">		stop = args[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (args.length === <span class="number">2</span>) &#123;</span><br><span class="line">		theStart = args[<span class="number">0</span>];</span><br><span class="line">		stop = args[<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (args.length === <span class="number">3</span>) &#123;</span><br><span class="line">		theStart = args[<span class="number">0</span>];</span><br><span class="line">		stop = args[<span class="number">1</span>];</span><br><span class="line">		theStep = args[<span class="number">2</span>];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 太繁琐</span></span><br><span class="line">	<span class="keyword">if</span> (theStart &lt; stop) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> index = theStart; index &lt; stop; index = index + theStep) &#123;</span><br><span class="line">		  resultArray.push(index);</span><br><span class="line">	  &#125;</span><br><span class="line">	 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> index = theStart; index &gt; stop; index = index + theStep) &#123;</span><br><span class="line">		resultArray.push(index);</span><br><span class="line">	 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> resultArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @description range 返回特定范围的数组</span></span><br><span class="line"><span class="comment">* @param start &#123;Number&#125; 数组中开始的数字</span></span><br><span class="line"><span class="comment">* @param stop &#123;Number&#125; 数组中结束的数字</span></span><br><span class="line"><span class="comment">* @param step &#123;Nunber&#125; 步进</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">range</span>(<span class="params">start, stop, step</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    start = stop || <span class="number">0</span>;</span><br><span class="line">    stop = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  step = step || <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> length = <span class="built_in">Math</span>.max(<span class="built_in">Math</span>.ceil((start - stop) / step), <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>(length);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; length; index++, start += step) &#123;</span><br><span class="line">    result[index] = start;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title>underscore.js 源码分析(十三)</title>
    <url>/2017/12/11/underscore-js-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E4%B8%89/</url>
    <content><![CDATA[<h3 id="underscore-js-源码分析-十三"><a href="#underscore-js-源码分析-十三" class="headerlink" title="underscore.js 源码分析(十三)"></a>underscore.js 源码分析(十三)</h3><p><code>keys</code>  <code>values</code>  <code>pairs</code>  <code>invert</code> <code>functions</code>  <code>mapObject</code> <code>findKey</code></p>
<h4 id="keys-Object"><a href="#keys-Object" class="headerlink" title="keys(Object)"></a><code>keys(Object)</code></h4><p>使用 <code>keys(Object)</code> 用于获得 <code>Object</code> 的所有属性名称。 与 <code>es6</code> 中  <code>Object.keys()</code> 功能相同，不同的是做了兼容性处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">keys</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果 obj 不存在?</span></span><br><span class="line">  <span class="keyword">if</span> (!obj || <span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="comment">// 如果支持 Object.keys 方法, 返回 Object.keys(obj)</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.keys) <span class="keyword">return</span> <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">  <span class="comment">// else 使用 for in 进行属性获取</span></span><br><span class="line">  <span class="keyword">let</span> keys = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    keys.push(key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回属性数组</span></span><br><span class="line">  <span class="keyword">return</span> keys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="values-Object"><a href="#values-Object" class="headerlink" title="values(Object)"></a><code>values(Object)</code></h4><p>使用 <code>values(Object)</code> 用于获得对象的所有的属性名称。 类似于使用 <code>Object.values</code> 获取到对象的属性值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">values</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> keys = _.keys(obj);</span><br><span class="line">  <span class="keyword">let</span> length = keys.length;</span><br><span class="line">  <span class="keyword">let</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>(length);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    values[i] = obj[keys[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="pairs"><a href="#pairs" class="headerlink" title="pairs()"></a><code>pairs()</code></h4><p>使用 <code>pairs()</code> 用于将一个对象转化为键值对的形式。</p>
<p>自己写的函数:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pairs</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> keys = _.keys(obj);</span><br><span class="line">  <span class="keyword">let</span> values = _.values(obj);</span><br><span class="line">  <span class="keyword">let</span> len = keys.length;</span><br><span class="line">  <span class="keyword">let</span> pairs = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    pairs.push([keys[i], values[i]]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pairs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码分析:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.pairs = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> keys = _.keys(obj);</span><br><span class="line">    <span class="keyword">var</span> length = keys.length;</span><br><span class="line">    <span class="keyword">var</span> pairs = <span class="built_in">Array</span>(length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      pairs[i] = [keys[i], obj[keys[i]]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pairs;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="invert"><a href="#invert" class="headerlink" title="invert()"></a><code>invert()</code></h4><p><code>invert(object)</code></p>
<p>使用 <code>invert</code> 实现的是返回一个 <code>object</code> 的副本，在这个副本中, <code>object</code> 中的键和值互换。</p>
<p>源码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invert</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> keys = _.keys(object);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    result[object[keys[i]]] = keys[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="functions"><a href="#functions" class="headerlink" title="functions"></a><code>functions</code></h4><p><code>functions(object)</code></p>
<p>返回一个对象中所有的方法名，并且是已经经过排序的方法。</p>
<p>源码分析:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.functions = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> names = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_.isFunction(obj[key])) names.push(obj[key]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> name.sort();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mapObject"><a href="#mapObject" class="headerlink" title="mapObject"></a><code>mapObject</code></h4><p>类似于使用数组的 <code>map</code> 方法，不同的是这个方法针对的是对象的 <code>map</code> 方法, 使用 <code>mapObject</code> 用来对于对象的属性值进行操作， 实现的源码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.mapObject = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) </span>&#123;</span><br><span class="line">  iteratee = cb(iteratee, context);</span><br><span class="line">  <span class="keyword">let</span> keys = _.keys(obj);</span><br><span class="line">      length = keys.length;</span><br><span class="line">      result = &#123;&#125;;</span><br><span class="line">      currentKey;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">    currentKey = keys[index];</span><br><span class="line">    results[currentKey] = iteratee(obj[currentKey], currentKey, obj);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="findKey"><a href="#findKey" class="headerlink" title="findKey"></a><code>findKey</code></h4><p><code>_.findKey(obj, predicate, context)</code></p>
<p>使用 <code>findKey</code> 返回的是 <code>obj</code> 中第一个满足 <code>predicate</code> 函数的 <code>key</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = &#123;</span><br><span class="line">  first: <span class="number">5</span>,</span><br><span class="line">  second: <span class="number">8</span></span><br><span class="line">&#125;;</span><br><span class="line">_.findKey(numbers, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 返回 first</span></span><br></pre></td></tr></table></figure>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><p><code>findKey</code> 源码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.findKey = <span class="function"><span class="keyword">function</span> (<span class="params">obj, predicate, context</span>) </span>&#123;</span><br><span class="line">  predicate = cb(predicate, context);</span><br><span class="line">  <span class="keyword">let</span> keys = _.keys(obj), key;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; length = keys.length; i &lt; length; i++) &#123;</span><br><span class="line">    key = keys[i];</span><br><span class="line">    <span class="comment">// 如果条件满足, 返回 key</span></span><br><span class="line">    <span class="keyword">if</span> (predicate(obj[key], key, obj)) <span class="keyword">return</span> key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title>underscore.js 源码分析(五)</title>
    <url>/2017/11/25/underscore-js-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%94/</url>
    <content><![CDATA[<p>###　underscore.js 源码解析（五）</p>
<p><code>sample</code> <code>toArray</code>  <code>size</code>  <code>partition</code></p>
<h4 id="sample"><a href="#sample" class="headerlink" title="_.sample"></a><code>_.sample</code></h4><p><code>_.sample(list, [n])</code></p>
<p>用于产生一个随机样本, 传递的参数 n 表示从 <code>list</code> 中返回 <code>n</code> 个随机元素。</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.sample = <span class="function"><span class="keyword">function</span>(<span class="params">obj, n, guard</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="literal">null</span> || guard) &#123;</span><br><span class="line">      <span class="keyword">if</span> (obj.length !== +obj.length) obj = _.values(obj);</span><br><span class="line">      <span class="comment">// 返回使用 _.random 获得的随机数</span></span><br><span class="line">      <span class="keyword">return</span> obj[_.random(obj.length - <span class="number">1</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用 slice 用来分割数组</span></span><br><span class="line">    <span class="comment">// 使用 Math.max() 用来返回最大值</span></span><br><span class="line">    <span class="keyword">return</span> _.shuffle(obj).slice(<span class="number">0</span>, <span class="built_in">Math</span>.max(<span class="number">0</span>, n));</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>通过使用 <code>Math.max()</code> 用来获得一组数中的最大值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max(value1, value2, value3, value4...)</span><br><span class="line"><span class="comment">// 获取到 value1, value2, value3, value4... 等一组数中的最大值</span></span><br><span class="line"><span class="built_in">Math</span>.min(value1, value2, value3, value4...)</span><br><span class="line"><span class="comment">// 获取到 value1, value1.. 中的最小值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>Array.slice</code> 用来进行分割数组</p>
<p><code>Array.slice(start, end)</code> 分割的数组中包括 <code>start</code> 不包括 <code>end</code> </p>
</li>
</ol>
<h4 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a><code>toArray</code></h4><p>#####　实例</p>
<p><code>_.toArray(list)</code></p>
<p>如果 <code>list</code> 是一个可以迭代的对象, 可以将 <code>list</code> 转化为一个数组。</p>
<h5 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.toArray = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 obj 不存在, 返回一个空的数组</span></span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="comment">// 如果 obj 是一个真正的数组, 返回 slice.call(obj),</span></span><br><span class="line">    <span class="comment">// Object.prototype.slice</span></span><br><span class="line">    <span class="keyword">if</span> (_.isArray(obj)) <span class="keyword">return</span> slice.call(obj);</span><br><span class="line">    <span class="comment">// 如果 obj 是一个类数组对象</span></span><br><span class="line">    <span class="comment">// 类数组对象属于对象，但是有 length</span></span><br><span class="line">    <span class="keyword">if</span> (obj.length === +obj.length) <span class="keyword">return</span> _.map(obj, _.identity);</span><br><span class="line">    <span class="comment">// 返回 obj 是一个对象</span></span><br><span class="line">    <span class="keyword">return</span> _.values(obj);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>当我们判断一个对象是否是数组或者对象的时候我们要分为几种情况:</p>
<p>使用 <code>obj.length</code> 进行判断的时候:</p>
<ol>
<li><p>对象是数组:</p>
<p>使用 <code>Array.isArray</code> 进行判断，当 这个判断不支持的时候，使用 <code>Object.prototype.toString</code> 进行判断。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(obj) || <span class="built_in">Object</span>.prototype.toString.call(obj) ==== <span class="string">'[object Array]'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象是类数组对象</p>
<p>对于类数组对象也有 <code>length</code> 属性，因此当我们判断类数组对象不是数组的时候，接下来进行判断:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj.length === +obj.length) &#123;</span><br><span class="line">  <span class="comment">// 判断得到是类数组对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当得到的类型是对象的时候</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于对象而言: obj.length: undefined</span></span><br><span class="line"><span class="comment">// +obj.length: NaN</span></span><br><span class="line"><span class="keyword">if</span> (obj.length !== +obj.length) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="size"><a href="#size" class="headerlink" title="size"></a><code>size</code></h4><p><code>_.size(list)</code></p>
<p>用于返回 <code>list</code> 的长度</p>
<p>当 <code>list</code> 是数组的时候，返回的是数组的长度，当 <code>list</code> 是对象的时候，返回的是对象的长度。</p>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">'张宁宁'</span>,</span><br><span class="line">  age: <span class="number">23</span>,</span><br><span class="line">  sex: <span class="string">'female'</span></span><br><span class="line">&#125;;</span><br><span class="line">_.size(person) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h4 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h4><p>使用<code>_.size</code> 进行判断的数组数量的方法十分简单，判断传入的是对象或者是数组，对象的话返回的是键的值，对于数组返回的是数组的长度。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">size</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (list == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 判断 list 是否是对象或者数组</span></span><br><span class="line">  <span class="comment">// list 是数组，返回 list 的length</span></span><br><span class="line">  <span class="comment">// list 是对象, 返回的是 Object.keys(list) 的长度</span></span><br><span class="line">  <span class="keyword">return</span> list.length === +list.length ? list.length : <span class="built_in">Object</span>.keys(list).length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="partition"><a href="#partition" class="headerlink" title="partition"></a><code>partition</code></h4><p><code>_.partition(array, predicate)</code></p>
<h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><p>使用 <code>partition</code> 的目的在于拆分一个数组为两个数组，拆分之后的数组中第一个数组是满足 <code>predicate</code> 函数的数组，</p>
<p>拆分之后的第二个数组是不满足 <code>predicate</code> 函数的数组。</p>
<blockquote>
<p><code>predicate</code> : 断言，断定，宣布，宣讲，使基于</p>
</blockquote>
<h5 id="源码分析-3"><a href="#源码分析-3" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.partition = <span class="function"><span class="keyword">function</span>(<span class="params">obj, predicate, context</span>) </span>&#123;</span><br><span class="line">  predicate = cb(predicate, context);</span><br><span class="line">  <span class="comment">// 定义两个数组，分别用来存放成功的数组和失败的数组</span></span><br><span class="line">  <span class="keyword">var</span> pass = [], fail = [];</span><br><span class="line">  _.each(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value, key, object</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// predicate 返回 true : pass.push(obj)</span></span><br><span class="line">    <span class="comment">// predicate 返回 false : fail.push(obj)</span></span><br><span class="line">    (predicate(value, key, object) ? pass : fail).push(obj);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 返回一个二维数组</span></span><br><span class="line">  <span class="keyword">return</span> [[pass], [fail]];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title>underscore.js 源码分析(十六)</title>
    <url>/2017/12/16/underscore-js-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E5%85%AD/</url>
    <content><![CDATA[<h3 id="underscore-js-源码分析-十六"><a href="#underscore-js-源码分析-十六" class="headerlink" title="underscore.js 源码分析(十六)"></a>underscore.js 源码分析(十六)</h3><h4 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty"></a><code>isEmpty</code></h4><p><code>isEmpty(object)</code>   <code>isElement</code>  <code></code></p>
<p>如果 <code>object</code> 是一个空对象， 或者 <code>object</code> 是一个字符串或者数组, 并且字符串或者数组的 <code>length</code>  为 <code>0</code>; 返回 <code>true</code>,</p>
<p>否则, 返回 <code>false</code>.</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.isEmpty(&#123;&#125;); <span class="comment">// true</span></span><br><span class="line">_.isEmpty(&#123; <span class="attr">name</span>: <span class="string">'张宁宁'</span> &#125;); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @description isEmpty 用来判断 Obj 是否为空</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEmpty</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (isArray(obj) || isString(obj) || isArguments(obj)) <span class="keyword">return</span> obj.length === <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) <span class="keyword">if</span> (has(obj, key)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="isElement"><a href="#isElement" class="headerlink" title="isElement"></a><code>isElement</code></h4><p><code>isElement(obj)</code></p>
<p>如果 <code>obj</code> 是一个 <code>dom</code> 元素, 返回为 <code>true;</code></p>
<p>对于 dom 元素  <code>nodeType ===  1</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isElement</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果 obj 以及 obj.nodeType === 1</span></span><br><span class="line">  <span class="comment">// 表示 obj 是一个节点对象</span></span><br><span class="line">  <span class="keyword">return</span> !!(obj &amp;&amp; obj.nodeType === <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="判断函数"><a href="#判断函数" class="headerlink" title="判断函数"></a>判断函数</h4><p>使用判断函数用于判断函数的类型, 例如:   </p>
<p><code>isArray</code>  <code>isObject</code>  <code>isArguments</code>  <code>isFunction</code>  <code>isString</code>  <code>isNumber</code> ….</p>
<p>实现上面这几种方法的判断是使用 <code>Array.prototype.toString.call</code> 的方法进行判断的:</p>
<h5 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.each([<span class="string">'Arguments'</span>, <span class="string">'Function'</span>, <span class="string">'String'</span>, <span class="string">'Number'</span>, <span class="string">'Date'</span>, <span class="string">'RegExp'</span>, <span class="string">'Error'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  _.[<span class="string">'is'</span> + name] = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过使用 toString.call 来决定判断是属于哪一种类型</span></span><br><span class="line">    <span class="keyword">return</span> toString.call(obj) === <span class="string">`[object <span class="subst">$&#123;name&#125;</span>]`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>对于其他几个的判断:</p>
<h5 id="isObject"><a href="#isObject" class="headerlink" title="isObject"></a><code>isObject</code></h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.isObject = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> type = <span class="keyword">typeof</span> obj;</span><br><span class="line">  <span class="keyword">return</span> type === <span class="string">'function'</span> || type === <span class="string">'object'</span> &amp;&amp; !!obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="isFinite"><a href="#isFinite" class="headerlink" title="isFinite"></a><code>isFinite</code></h5><p>用来判断给定的对象是否属于一个无限的数。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.isFinite = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">isFinite</span>(obj) &amp;&amp; !<span class="built_in">isNaN</span>(<span class="built_in">parseFloat</span>(obj));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN"></a><code>isNaN</code></h5><p>用来判断给定的值是否是 <code>NaN</code> 值,</p>
<blockquote>
<p>NaN is the only number which does not equal itself (NaN 是唯一一个和他自身不等的值)  </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.isNaN = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// NaN !== NaN</span></span><br><span class="line">  <span class="comment">// NaN 是一个数字</span></span><br><span class="line">  <span class="keyword">return</span> _.isNumber(obj) &amp;&amp; obj !== +obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="isBoolean"><a href="#isBoolean" class="headerlink" title="isBoolean"></a><code>isBoolean</code></h5><p>用于判断是否是一个布尔值;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.isBoolean = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj === <span class="literal">true</span> || obj === <span class="literal">false</span> || toString.call(obj) === <span class="string">'[object, Boolean]'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="isNull"><a href="#isNull" class="headerlink" title="isNull"></a><code>isNull</code></h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.isNull = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj === <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="isUndefined"><a href="#isUndefined" class="headerlink" title="isUndefined"></a><code>isUndefined</code></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.isUndefine = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里通过使用 void 0 来代替 undefined 值</span></span><br><span class="line">  <span class="keyword">return</span> obj === <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title>underscore.js 源码分析(十五)</title>
    <url>/2017/12/14/underscore-js-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E4%BA%94/</url>
    <content><![CDATA[<h3 id="underscore-js-源码解析-十五"><a href="#underscore-js-源码解析-十五" class="headerlink" title="underscore.js 源码解析( 十五 )"></a>underscore.js 源码解析( 十五 )</h3><p><code>clone</code>  <code>tap</code>  <code>has</code>  <code>matcher</code>  <code>property</code>  <code>propertyOf</code>  <code>isEqual</code></p>
<h4 id="clone"><a href="#clone" class="headerlink" title="clone"></a><code>clone</code></h4><p><code>_.clone(object)</code>  </p>
<p>创建一个浅拷贝的 <code>object</code>  </p>
<p>使用  <code>_.clone</code> 的源码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.clone = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!.isObject(obj)) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="comment">// 对于 obj 是对象的, 分为数组和对象两种形式</span></span><br><span class="line">  <span class="keyword">return</span> isArray(obj) ? obj.slice() : _.extend(&#123;&#125;, obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="tap"><a href="#tap" class="headerlink" title="tap"></a><code>tap</code></h4><p><code>_.tap(object, interceptor)</code></p>
<blockquote>
<p><code>interceptor</code> 拦截器</p>
</blockquote>
<p>使用 <code>interceptor</code> 的作用是用于对于传入的对象 <code>object</code> 进行 <code>interceptor</code> 操作, 并且操作完成之后返回 <code>object</code> 本身。</p>
<p>用于链式调用: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.tap = <span class="function"><span class="keyword">function</span> (<span class="params">obj, interceptor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 对于对象应用 interceptor 函数作用</span></span><br><span class="line">  interceptor(obj);</span><br><span class="line">  <span class="comment">// 返回这个对象</span></span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="has"><a href="#has" class="headerlink" title="　has"></a>　<code>has</code></h4><p><code>_.has(object, key)</code></p>
<p>用于判断对象是否包含有特定的属性 <code>key</code>  , 在源码中有这样一句话, </p>
<blockquote>
<p>等同于<code>object.hasOwnProperty(key)</code>，但是使用<code>hasOwnProperty</code> 函数的一个安全引用，以防<a href="http://www.devthought.com/2012/01/18/an-object-is-not-a-hash/" target="_blank" rel="noopener">意外覆盖</a>。</p>
<p>什么是意外覆盖?</p>
</blockquote>
<p>源码分析如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.has = <span class="function"><span class="keyword">function</span>(<span class="params">obj, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj != <span class="literal">null</span> &amp;&amp; hasOwnProperty.call(obj, key);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="matcher"><a href="#matcher" class="headerlink" title="matcher"></a><code>matcher</code></h4><p><code>matcher(attrs)</code></p>
<p>使用 <code>matcher</code> 函数是一个断言函数, 返回一个 <code>true</code> or <code>false</code> 来判断给定的对象中是否含有 <code>attrs</code> 中指定的键值对儿</p>
<p>示例:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = &#123;</span><br><span class="line">  selected: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> hasSelected = _.matcher(&#123;<span class="attr">selected</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">hasSelected(list); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><p>源码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.matcher = _.matches = <span class="function"><span class="keyword">function</span>(<span class="params">attrs</span>) </span>&#123;</span><br><span class="line">  attrs = _.extendOwn(&#123;&#125;, attrs);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _.isMatch(obj, attrs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>_.isMatch</code> 源码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.isMatch = <span class="function"><span class="keyword">function</span> (<span class="params">object, attrs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> keys = _.keys(attrs), length = keys.length;</span><br><span class="line">  <span class="keyword">if</span> (object === <span class="literal">null</span>) <span class="keyword">return</span> !length;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>(object);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = keys[i];</span><br><span class="line">    <span class="comment">//如果 attrs 中的值和 obj 中的值不相等， 或者 key 不属于 obj 中</span></span><br><span class="line">    <span class="comment">// 返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (attrs[key] !== obj[key] || !(key <span class="keyword">in</span> obj)) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回 true</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="property"><a href="#property" class="headerlink" title="property"></a><code>property</code></h4><p><code>property(key)</code>  </p>
<p>该方法返回一个函数，返回传入该函数的任何对象的 <code>key</code> 属性。  </p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> property = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj === <span class="literal">null</span> ? <span class="keyword">void</span> <span class="number">0</span> : obj[key];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="propertyOf"><a href="#propertyOf" class="headerlink" title="propertyOf"></a><code>propertyOf</code></h4><p>使用 <code>propertyOf</code> 与使用  <code>property</code> 相反。  </p>
<p><code>propertyOf(object)</code>  传入一个对象， 返回一个函数，这个函数接收一个属性，返回对象对应属性的值。</p>
<p>使用 <code>propertyOf</code>   </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.propertyOf = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj == <span class="literal">null</span> ? <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; : <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="isEqual"><a href="#isEqual" class="headerlink" title="isEqual"></a><code>isEqual</code></h4><p><code>isEqual(object, other)</code> </p>
<p>使用  <code>isEqual</code> 用来判断两个对象是否相等。 </p>
<p>因为不同的对象被放在了不同的内存空间中, 因此， 即使是属性和值均相等的对象也是不相同的, 如果对象的属性和值都是相同的，使用 <code>isEqual</code> 返回的是 <code>true</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;&#125; == &#123;&#125; <span class="comment">// false</span></span><br><span class="line">_.isEqual(&#123;&#125;, &#123;&#125;); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>在源码中使用 <code>equal</code> 进行判断:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.equal = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> eq(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>eq</code> 进行判断的源码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> eq = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, aStack, bStack</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Identical objects are equal. `0 === -0`, but they aren't identical.</span></span><br><span class="line">    <span class="comment">// See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).</span></span><br><span class="line">    <span class="keyword">if</span> (a === b) <span class="keyword">return</span> a !== <span class="number">0</span> || <span class="number">1</span> / a === <span class="number">1</span> / b;</span><br><span class="line">    <span class="comment">// A strict comparison is necessary because `null == undefined`.</span></span><br><span class="line">    <span class="comment">// 如果 a 或者 b === undefined 返回 a === b</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span>) <span class="keyword">return</span> a === b;</span><br><span class="line">    <span class="comment">// Unwrap any wrapped objects.</span></span><br><span class="line">    <span class="keyword">if</span> (a <span class="keyword">instanceof</span> _) a = a._wrapped;</span><br><span class="line">    <span class="keyword">if</span> (b <span class="keyword">instanceof</span> _) b = b._wrapped;</span><br><span class="line">    <span class="comment">// Compare `[[Class]]` names.</span></span><br><span class="line">    <span class="keyword">var</span> className = toString.call(a);</span><br><span class="line">   <span class="comment">// 如果 a 的对象的类型不同于 b 的对象的类型， 返回的是 false</span></span><br><span class="line">    <span class="keyword">if</span> (className !== toString.call(b)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">switch</span> (className) &#123;</span><br><span class="line">      <span class="comment">// Strings, numbers, regular expressions, dates, and booleans are compared by value.</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'[object RegExp]'</span>:</span><br><span class="line">      <span class="comment">// RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'[object String]'</span>:</span><br><span class="line">        <span class="comment">// Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is</span></span><br><span class="line">        <span class="comment">// equivalent to `new String("5")`.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span> + a === <span class="string">''</span> + b;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'[object Number]'</span>:</span><br><span class="line">        <span class="comment">// `NaN`s are equivalent, but non-reflexive.</span></span><br><span class="line">        <span class="comment">// Object(NaN) is equivalent to NaN</span></span><br><span class="line">        <span class="comment">// 当 a 是 NaN 的时候, 如果 b 也是 NaN 那么 !b !== b // false</span></span><br><span class="line">        <span class="keyword">if</span> (+a !== +a) <span class="keyword">return</span> +b !== +b;</span><br><span class="line">        <span class="comment">// An `egal` comparison is performed for other numeric values.</span></span><br><span class="line">        <span class="comment">// 判断 +a === 0 ? </span></span><br><span class="line">        <span class="keyword">return</span> +a === <span class="number">0</span> ? <span class="number">1</span> / +a === <span class="number">1</span> / b : +a === +b;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'[object Date]'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'[object Boolean]'</span>:</span><br><span class="line">        <span class="comment">// Coerce dates and booleans to numeric primitive values. Dates are compared by their</span></span><br><span class="line">        <span class="comment">// millisecond representations. Note that invalid dates with millisecond representations</span></span><br><span class="line">        <span class="comment">// of `NaN` are not equivalent.</span></span><br><span class="line">        <span class="keyword">return</span> +a === +b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> areArrays = className === <span class="string">'[object Array]'</span>;</span><br><span class="line">    <span class="comment">// 如果不是一个数组</span></span><br><span class="line">    <span class="keyword">if</span> (!areArrays) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> a != <span class="string">'object'</span> || <span class="keyword">typeof</span> b != <span class="string">'object'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">// Objects with different constructors are not equivalent, but `Object`s or `Array`s</span></span><br><span class="line">      <span class="comment">// from different frames are.</span></span><br><span class="line">      <span class="keyword">var</span> aCtor = a.constructor, bCtor = b.constructor;</span><br><span class="line">      <span class="keyword">if</span> (aCtor !== bCtor &amp;&amp; !(_.isFunction(aCtor) &amp;&amp; aCtor <span class="keyword">instanceof</span> aCtor &amp;&amp;</span><br><span class="line">        _.isFunction(bCtor) &amp;&amp; bCtor <span class="keyword">instanceof</span> bCtor) &amp;&amp; (<span class="string">'constructor'</span> <span class="keyword">in</span> a &amp;&amp; <span class="string">'constructor'</span> <span class="keyword">in</span> b)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Assume equality for cyclic structures. The algorithm for detecting cyclic</span></span><br><span class="line">    <span class="comment">// structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initializing stack of traversed objects.</span></span><br><span class="line">    <span class="comment">// It's done here since we only need them for objects and arrays comparison.</span></span><br><span class="line">    aStack = aStack || [];</span><br><span class="line">    bStack = bStack || [];</span><br><span class="line">    <span class="keyword">var</span> length = aStack.length;</span><br><span class="line">    <span class="keyword">while</span> (length--) &#123;</span><br><span class="line">      <span class="comment">// Linear search. Performance is inversely proportional to the number of</span></span><br><span class="line">      <span class="comment">// unique nested structures.</span></span><br><span class="line">      <span class="keyword">if</span> (aStack[length] === a) <span class="keyword">return</span> bStack[length] === b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add the first object to the stack of traversed objects.</span></span><br><span class="line">    aStack.push(a);</span><br><span class="line">    bStack.push(b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursively compare objects and arrays.</span></span><br><span class="line">    <span class="keyword">if</span> (areArrays) &#123;</span><br><span class="line">      <span class="comment">// Compare array lengths to determine if a deep comparison is necessary.</span></span><br><span class="line">      length = a.length;</span><br><span class="line">      <span class="keyword">if</span> (length !== b.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">// Deep compare the contents, ignoring non-numeric properties.</span></span><br><span class="line">      <span class="keyword">while</span> (length--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!eq(a[length], b[length], aStack, bStack)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Deep compare objects.</span></span><br><span class="line">      <span class="keyword">var</span> keys = _.keys(a), key;</span><br><span class="line">      length = keys.length;</span><br><span class="line">      <span class="comment">// Ensure that both objects contain the same number of properties before comparing deep equality.</span></span><br><span class="line">      <span class="keyword">if</span> (_.keys(b).length !== length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">while</span> (length--) &#123;</span><br><span class="line">        <span class="comment">// Deep compare each member</span></span><br><span class="line">        key = keys[length];</span><br><span class="line">        <span class="keyword">if</span> (!(_.has(b, key) &amp;&amp; eq(a[key], b[key], aStack, bStack))) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Remove the first object from the stack of traversed objects.</span></span><br><span class="line">    aStack.pop();</span><br><span class="line">    bStack.pop();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<h5 id="eq-函数"><a href="#eq-函数" class="headerlink" title="eq 函数"></a><code>eq</code> 函数</h5><p>使用 <code>eq</code> 函数进行比较的时候，进行比较的值有下面几种情况:</p>
<ol>
<li><p>处理传递进比较的数值出现 <code>0 === -0</code> 的情况。这种情况用于单个数值的比较</p>
<p>因为 <code>a === -0</code> 但是他们是不相同的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当 a !== 0  || 1/a === 1 / b</span></span><br><span class="line"><span class="comment">// 因为 1 / a === 1 / b (Infinity === -Infinity) // false</span></span><br><span class="line"><span class="keyword">if</span> (a === b) <span class="keyword">return</span> a !== <span class="number">0</span> || <span class="number">1</span> / a === <span class="number">1</span> / b;</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理 <code>null == undefined</code> 的情况  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 当 a == null 或者 b == null 的时候， 返回 a === b</span><br><span class="line">if (a == null || b == null) return a === b;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>Object.toString</code> 进行判断属于 <code>Object</code> 的哪一种类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> className = toString.call(a);</span><br><span class="line"><span class="comment">// 类型不同, 返回 false</span></span><br><span class="line"><span class="keyword">if</span> (className !== toString.call(b)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">switch</span> (className) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'[object RegExp]'</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'[object String]'</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span> + a === <span class="string">''</span> +b;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'[object Number]'</span>:</span><br><span class="line">    <span class="comment">// 使用  NaN 进行比较</span></span><br><span class="line">    <span class="keyword">if</span> (+a !== +a) <span class="keyword">return</span> +b !== +b;</span><br><span class="line">    <span class="keyword">return</span> +a === <span class="number">0</span> ? <span class="number">1</span> / +a === <span class="number">1</span> / b : +a === +b;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'[object Date]'</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'[object Boolean]'</span>:</span><br><span class="line">    <span class="keyword">return</span> +a === +b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="4">
<li><p>对于数组和对象的之间进行比较，需要深度比较</p>
<p>当不是数组， 对象的情况:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> areArrays = className === <span class="string">'[object Array]'</span>;</span><br><span class="line"><span class="keyword">if</span> (!areArray) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a !== <span class="string">'object'</span> || <span class="keyword">typeof</span> b !== <span class="string">'object'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> aCtor = a.constructor, bCtor = b.constructor;</span><br><span class="line">  <span class="comment">// 如果 aCtor !== bCtor</span></span><br><span class="line">  <span class="keyword">if</span> (aCtor !== bCtor &amp;&amp; !(_.isFunction(aCtor) &amp;&amp; aCtor <span class="keyword">instanceof</span> aCtor &amp;&amp; _.isFunction(bCtor) &amp;&amp; bCtor isntanceof bCtor) &amp;&amp; (<span class="string">'constructor'</span> <span class="keyword">in</span> a &amp;&amp; <span class="string">'constructor'</span> <span class="keyword">in</span> b)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> length = aStack.length;</span><br><span class="line"><span class="keyword">while</span>(length--) &#123;</span><br><span class="line">  <span class="keyword">if</span> (aStack[length] === a) <span class="keyword">return</span> bStack[length] === b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 a 压入到 aStack 数组中</span></span><br><span class="line"><span class="comment">// 将 b 压入到 bStack 数组中</span></span><br><span class="line"><span class="comment">// aStack bStack 主要用于多重数组的情况</span></span><br><span class="line">aStack.push(a);</span><br><span class="line">bStack.push(b);</span><br></pre></td></tr></table></figure>
<p>进行比较对象或者数组:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比较数组</span></span><br><span class="line"><span class="keyword">if</span> (areArrays) &#123;</span><br><span class="line">  length = a.length;</span><br><span class="line">  <span class="keyword">if</span> (length !== b.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (length--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!eq(a[length], b[length], aStack, bStack)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 比较对象  </span></span><br><span class="line">  <span class="keyword">let</span> keys = _.keys(a), key;</span><br><span class="line">  length = keys.length;</span><br><span class="line">  <span class="comment">// 如果两个对象的属性数目不相同 返回 false 不用进行深度遍历</span></span><br><span class="line">  <span class="keyword">if</span> (_.keys(b).length !== length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (length--) &#123;</span><br><span class="line">    key = keys[length];</span><br><span class="line">    <span class="keyword">if</span> (!(_.has(b, key) &amp;&amp; eq(a[key], b[key], aStack, bStack))) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将存入的元素进行弹出</span></span><br><span class="line">aStack.pop();</span><br><span class="line">bStack.pop();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>​</p>
<p>​</p>
</li>
</ol>
]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title>underscore.js 源码解析(六)</title>
    <url>/2017/11/27/underscore-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%85%AD/</url>
    <content><![CDATA[<h3 id="underscore-js-源码解析-六"><a href="#underscore-js-源码解析-六" class="headerlink" title="underscore.js 源码解析(六)"></a>underscore.js 源码解析(六)</h3><p><code>first</code> <code>initial</code>  <code>last</code> <code>rest</code> <code>compact</code></p>
<h4 id="first"><a href="#first" class="headerlink" title="first"></a><code>first</code></h4><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p><code>_.first(array, [n])</code></p>
<p><code>n</code> 是可选的, 表示选择数组中的前 <code>n</code> 个元素， 当我们没有传递 <code>n</code> 的时候，我们获得的是数组的第一个元素 <code>array[0]</code>。</p>
<p>使用 <code>first</code> 用来获取到数组中的第一个元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">_.first(list) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><p>使用 <code>_.first</code> 实现的源码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_.first = _.head = _.take = function(array, n, guard) &#123;</span><br><span class="line">    // 如果 array 为null 返回 undefined</span><br><span class="line">    if (array == null) return void 0;</span><br><span class="line">    // 如果没有明确传入的 参数 n 返回数组的第一项 array[0]</span><br><span class="line">    if (n == null || guard) return array[0];</span><br><span class="line">    // 使用 _.initial 用于返回数组的前 n 个元素</span><br><span class="line">    return _.initial(array, array.length - n);</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>注意:</p>
<ol>
<li><p>如何判断 <code>null</code>? </p>
<p>如果使用 <code>typeof</code> 判断 <code>null</code> 会返回 <code>object</code> , 实现判断是否为 <code>null</code> 的简单方法是进行判断:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (obj == null) &#123;</span><br><span class="line">  // isnull</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这里使用了一个 <code>_.initial</code> 用于获取到数组的相关值:</p>
<h4 id="initial"><a href="#initial" class="headerlink" title="_.initial"></a><code>_.initial</code></h4><p>使用 <code>_.initial</code> 的目的在于返回数组中前 <code>n</code> 个元素，不包括第 <code>n</code> 个元素</p>
<h5 id="源码如下"><a href="#源码如下" class="headerlink" title="源码如下:"></a>源码如下:</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.initial = <span class="function"><span class="keyword">function</span>(<span class="params">array, n, guard</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> slice.call(array, <span class="number">0</span>, <span class="built_in">Math</span>.max(<span class="number">0</span>, array.length - (n == <span class="literal">null</span> || guard ? <span class="number">1</span> : n)));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="last"><a href="#last" class="headerlink" title="_.last"></a><code>_.last</code></h4><p>使用 <code>_.last</code> 用于返回数组中的最后一个元素。</p>
<h5 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.last = <span class="function"><span class="keyword">function</span>(<span class="params">array, n, guard</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="literal">null</span> || guard) <span class="keyword">return</span> array[array.length - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 调用 rest函数， 当 n !== null 的时候</span></span><br><span class="line">    <span class="keyword">return</span> _.rest(array, <span class="built_in">Math</span>.max(<span class="number">0</span>, array.length - n));</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="rest"><a href="#rest" class="headerlink" title="_.rest"></a><code>_.rest</code></h4><p>使用 <code>_.rest</code> 函数用于返回数组中剩下的元素。</p>
<h5 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.rest = _.tail = _.drop = <span class="function"><span class="keyword">function</span>(<span class="params">array, n, guard</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> slice.call(array, n == <span class="literal">null</span> || guard ? <span class="number">1</span> : n); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 <code>slice.call</code> 其实是 <code>Array.prototype.slice.call()</code> 的方法</p>
<p><code>Array.slice(start, end)</code> // 用于裁剪数组，裁剪的数组包括 <code>start</code> 不包括 <code>end</code>  </p>
</blockquote>
<h4 id="compact"><a href="#compact" class="headerlink" title="compact"></a><code>compact</code></h4><p>使用 <code>compact</code> 用于去除所有为 <code>假值</code> 的数组成员</p>
<blockquote>
<p>关于假值:  <code>false</code>, <code>undefined</code> <code>null</code>  <code>0</code> 以及 <code>&quot;&quot;</code> 被称为假值, 因为强制类型转换会被转换为 <code>false</code>。</p>
</blockquote>
<p>源码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.compact = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在 filter 的函数中</span></span><br><span class="line">   <span class="keyword">return</span> _.filter(array, _.identity);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为在上面的代码中，函数 <code>_.filter</code> 中存在一个判断:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (someFn) &#123;</span><br><span class="line">  <span class="comment">// doSomething</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会对位于 <code>if</code> 框内的元素<code>someFn</code>进行强制类型转换。</p>
]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title>underscore.js源码分析(一)</title>
    <url>/2017/11/18/underscore-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%80/</url>
    <content><![CDATA[<h4 id="underscore-js-源码分析（一）"><a href="#underscore-js-源码分析（一）" class="headerlink" title="underscore.js 源码分析（一）"></a>underscore.js 源码分析（一）</h4><p><code>_.each</code>  <code>_.map</code>  <code>_.refuce</code> <code>_.reduceRight</code>  <code>_.find</code></p>
<h4 id="each"><a href="#each" class="headerlink" title="_.each"></a><code>_.each</code></h4><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p><code>_.each(list, iteratee, [context])</code></p>
<p>这个方法用于循环遍历, 用于循环 <code>list</code> 对象或者数组， <code>iteratee</code> 是一个遍历函数，接收的参数为遍历之后的结果。  </p>
<p>当 <code>list</code> 为数组的时候，传递给 <code>iteratee</code> 函数的参数是  <code>(element, index, list)</code>, 当 <code>list</code> 为对象的时候, 传递给 <code>iteratee</code> 函数的参数是 <code>[value, key, list]</code>。</p>
<p>对于 <code>context</code> 上下文, 这个决定的是 <code>iteratee</code> 中的 <code>this</code> 的指向值。可选参数， 当 <code>context</code> 忽略的时候 <code>this</code> 指向的是全局变量。</p>
<p><code>_.each</code> 返回值是进行遍历的 <code>list</code> 数组对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function print(value, index, list) &#123;</span><br><span class="line">  console.log(this.name);// 这里 this 指向了后面传递的 context</span><br><span class="line">  console.log(value, index, list);</span><br><span class="line">&#125;</span><br><span class="line">let person = &#123;</span><br><span class="line">  name: &apos;张宁宁&apos;</span><br><span class="line">&#125;</span><br><span class="line">console.log(_.each([1, 2, 3], print, person)); // [1, 2, 3]</span><br><span class="line">// 最终打印</span><br><span class="line">张宁宁</span><br><span class="line">1 0 (3) [1, 2, 3]</span><br><span class="line">张宁宁</span><br><span class="line">2 1 (3) [1, 2, 3]</span><br><span class="line">张宁宁</span><br><span class="line">3 2 (3) [1, 2, 3]</span><br></pre></td></tr></table></figure>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><p>在 <code>underscore.js</code> 源码中， <code>_.each()</code> 源码为下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_.each = _.forEach = function(obj, iteratee, context) &#123;</span><br><span class="line">   // 如果 obj == null 返回 null</span><br><span class="line">   if (obj == null) return obj;</span><br><span class="line">   // 调用 optimiseCb 函数 稍后分析</span><br><span class="line">   iteratee = optimizeCb(iteratee, context);</span><br><span class="line">   var i, length = obj.length;</span><br><span class="line">   // 这里提供了分别 数组和对象的一种方法</span><br><span class="line">   // 如果数组</span><br><span class="line">   if (length === +length) &#123;</span><br><span class="line">   // 数组情况下， 将 [value, index, list] 传入遍历函数</span><br><span class="line">     for (i = 0; i &lt; length; i++) &#123;</span><br><span class="line">       iteratee(obj[i], i, obj);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">   // 获取到对象所有的 key 值</span><br><span class="line">     var keys = _.keys(obj);</span><br><span class="line">     for (i = 0, length = keys.length; i &lt; length; i++) &#123;</span><br><span class="line">       iteratee(obj[keys[i]], keys[i], obj);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   // 返回数组或者对象</span><br><span class="line">   return obj;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>分析:</p>
<ol>
<li><p>分别数组和对象的方法</p>
<p>我平常的时候使用 <code>Object.prootype.toString.call().slice(8, -1)</code> 这种方法来分别数组和纯对象，这里使用了一种方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (length === +length) &#123;</span><br><span class="line">// 这是数组</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// 这是对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>+length</code> 执行的是隐式类型转换，用于将其他的值转换为数字。经过实验，使用 <code>+</code> 进行类型转换的可能性如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">+<span class="literal">null</span> <span class="comment">// 0</span></span><br><span class="line">+flase <span class="comment">// 0</span></span><br><span class="line">+<span class="string">""</span> <span class="comment">// 0</span></span><br><span class="line">+<span class="literal">true</span> <span class="comment">// 1</span></span><br><span class="line">+对象 <span class="comment">// NaN</span></span><br><span class="line">+非空字符串 <span class="comment">// NaN</span></span><br><span class="line">+<span class="literal">NaN</span> <span class="comment">// NaN</span></span><br><span class="line">+<span class="number">1</span> <span class="comment">// 1</span></span><br><span class="line">+<span class="literal">undefined</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>因为上面中 对象的 length 为 undefined 因此  length ===+length  // false 这里 <code>+length</code> 会被转化为 <code>NaN</code>。</p>
</li>
<li><p><code>iteratee = optimizeCb(iteratee, context);</code></p>
<p><code>optimizaCb</code> 函数</p>
<p>使用 <code>optimizaCb</code> 函数用于绑定上下文: 使用 <code>call</code> 以及 <code>apply</code> 的方法实现的改变函数运行的 <code>this</code> 值的改变</p>
<p>接收三个参数: <code>func</code> 运行的函数  <code>context</code> 运行函数需要进行绑定的上下文  <code>argCount</code> 参数的个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var optimizeCb = function(func, context, argCount) &#123;</span><br><span class="line">    // 使用 void 0 类似于使用 undefined</span><br><span class="line">    // 等同于使用 if(context === undefined)</span><br><span class="line">    if (context === void 0) return func;</span><br><span class="line">    switch (argCount == null ? 3 : argCount) &#123;</span><br><span class="line">      case 1: return function(value) &#123;</span><br><span class="line">        return func.call(context, value);</span><br><span class="line">      &#125;;</span><br><span class="line">      case 2: return function(value, other) &#123;</span><br><span class="line">        return func.call(context, value, other);</span><br><span class="line">      &#125;;</span><br><span class="line">      case 3: return function(value, index, collection) &#123;</span><br><span class="line">        return func.call(context, value, index, collection);</span><br><span class="line">      &#125;;</span><br><span class="line">      case 4: return function(accumulator, value, index, collection) &#123;</span><br><span class="line">        return func.call(context, accumulator, value, index, collection);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return function() &#123;</span><br><span class="line">      return func.apply(context, arguments);</span><br><span class="line">    &#125;;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>上面的 <code>_.each</code> 源码中的使用这个函数的目的是将 <code>iteratee</code> 的上下文 <code>this</code> 绑定到 <code>context</code> 对象。</p>
<blockquote>
<p>这里有一个 void 0 这里的 void 0 等同于使用 undefined  不同于使用 <code>undefined</code> 的原因在于： 在 <code>javascript</code> 中 <code>undefined</code> 不是一个保留字。</p>
<p>代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;var undefined = 1;</span><br><span class="line">&gt;console.log(undefined); // 1  也是可以的</span><br><span class="line">&gt;使用 void 0 作用是这样的</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<h4 id="map"><a href="#map" class="headerlink" title="_.map"></a>_.map</h4><h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><p><code>_.map(list, iteratee, [context])</code></p>
<p>通过 使用变换函数 <code>iteratee</code> 将<code>list</code> 中的值映射到一个新的数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function filter(value) &#123;</span><br><span class="line">  return value * 2;</span><br><span class="line">&#125;</span><br><span class="line">_.map([1, 2, 3], filter); // [2, 4, 6]</span><br></pre></td></tr></table></figure>
<p>源码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.map = _.collect = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> [];</span><br><span class="line">  iteratee = cb(iteratee, context);</span><br><span class="line">  <span class="comment">// 使用 &amp;&amp; 操作符， 只有当第一个为true的时候才执行下一步操作</span></span><br><span class="line">  <span class="keyword">var</span> keys = obj.length !== +obj.length &amp;&amp; _.keys(obj),</span><br><span class="line">      <span class="comment">// || 操作符 第一个为true的时候不再进行下一步动作</span></span><br><span class="line">      length = (keys || obj).length,</span><br><span class="line">      <span class="comment">// 使用 Array 创建一个 length 长度的数组</span></span><br><span class="line">      results = <span class="built_in">Array</span>(length),</span><br><span class="line">      currentKey;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">    currentKey = keys ? keys[index] : index;</span><br><span class="line">    results[index] = iteratee(obj[currentKey], currentKey, obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h5><ol>
<li><p>使用 <code>&amp;&amp;</code> 以及 <code>||</code> 进行计算</p>
<p>这两个符号被称之为 选择器操作符，返回的是两边选择器结果的其中一个。在选择的过程中会被执行强制类型转换。</p>
<blockquote>
<p>这里对于类型转换，使用的时候要注意出现假值的情况</p>
</blockquote>
<p>使用 <code>&amp;&amp;</code> 以及 <code>||</code> 会首先对于 <em> 第一个</em>  操作数进行计算，根据判断结果来决定返回哪一个操作数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a || b</span><br><span class="line">// 如果 a 类型转换结果为 true 返回的是 a 否则 返回 b</span><br><span class="line">a &amp;&amp; b</span><br><span class="line">// 如果 a 类型转换结果为 true 返回的是 b 否则返回 a</span><br></pre></td></tr></table></figure>
<p>上面我们可以看到，我们可以利用这两个操作符做一些事情:</p>
<p><code>a || b</code> 好像备用条件。 如果条件 <code>a</code> 不成立, 执行条件 b, 如果成立，执行条件 <code>a</code>  <code>a ? a : b</code></p>
<p><code>a &amp;&amp; b</code> 好像通过条件， 如果 <code>a</code> 成立，向下执行，如果不成立，打住，返回 <code>a</code> 执行的结果 <code>a ? b : a</code>  </p>
</li>
<li><p>使用 <code>Array(length)</code> 创建的是一个 <code>length</code> 长度的数组。</p>
</li>
</ol>
<h4 id="reduce"><a href="#reduce" class="headerlink" title="_.reduce"></a>_.reduce</h4><h5 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h5><p><code>_.reduce(list, iteratee, [memo], context)</code></p>
<p>通过迭代将 <code>list</code> 中的元素归结为一个值。 <code>memo</code> 表示初始参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function reduceFn(memo, num) &#123;</span><br><span class="line">  return memo * num;</span><br><span class="line">&#125;</span><br><span class="line">let list = [1, 2, 3];</span><br><span class="line">_.reduce(list, reduceFn, 1) // 6</span><br></pre></td></tr></table></figure>
<h5 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h5><p>源码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reduce</span>(<span class="params">obj, iteratee, memo, context</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (obj === <span class="literal">null</span>) obj = [];</span><br><span class="line">	iteratee = optimizeCb(iteratee, context, <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">var</span> keys = obj.length !== +obj.length &amp;&amp; <span class="built_in">Object</span>.keys(),</span><br><span class="line">		length = (keys || obj).length,</span><br><span class="line">		index = <span class="number">0</span>, currentIndex;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">arguments</span>.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">		memo = obj[keys ? keys[index++] : index++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (; index &lt; length; index++) &#123;</span><br><span class="line">		currentIndex = keys ? keys[index] : index;</span><br><span class="line">		memo = iteratee(memo, obj[currentIndex], currentIndex, obj);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> memo;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>分析:</p>
<ol>
<li><p>在 <code>obj</code> 可能是对象或者数组的情况下，当 <code>obj</code> 是对象的时候，需要产生了一个 使用 <code>keys</code> 来进行数组操作</p>
</li>
<li><p>在迭代的时候， 当没有 <code>memo</code> 初始值的时候， 将数组或者对象的第一个值作为 <code>memo</code> 这里，使用 <code>index++</code> 来处理的</p>
<blockquote>
<p>使用 index++ 的时候，相当于 index = index + 1; 但是直接使用的时候还是原来的 index</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;let currentIndex = 0;</span><br><span class="line">&gt;let addIndex = currentIndex++; // 相当于先返回 currentIndex 在进行加一操作</span><br><span class="line">&gt;addIndex // 0</span><br><span class="line">&gt;currentIndex // 1</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>​</p>
</blockquote>
</li>
<li><p>迭代的过程发生在使用循环赋值的过程中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (; index &lt; length; index++) &#123;</span><br><span class="line">  memo = iteratee(memo, obj[currrentIndex], currentIndex, obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="reduceRight"><a href="#reduceRight" class="headerlink" title="_.reduceRight"></a>_.reduceRight</h4><h5 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h5><p><code>_.reduceRight(list, iteratee, [memo], context)</code></p>
<p>类似于使用<code>_.reduce</code> 不过不同于使用 <code>_.reduce</code> 的是，这个是从右边向左进行遍历操作;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">contact</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.contact(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> list = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]];</span><br><span class="line">_.reduceRight(list, contact) <span class="comment">// [5, 6, 3, 4, 1, 2]</span></span><br></pre></td></tr></table></figure>
<h5 id="源码分析-3"><a href="#源码分析-3" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.reduceRight = _.foldr = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, memo, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>) obj = [];</span><br><span class="line">    iteratee = optimizeCb(iteratee, context, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">var</span> keys = obj.length !== + obj.length &amp;&amp; _.keys(obj),</span><br><span class="line">        index = (keys || obj).length,</span><br><span class="line">        currentKey;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="comment">// 先对于 index 进行 减一操作</span></span><br><span class="line">      memo = obj[keys ? keys[--index] : --index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在判断完成 index 之后进行减一操作</span></span><br><span class="line">    <span class="keyword">while</span> (index-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      currentKey = keys ? keys[index] : index;</span><br><span class="line">      memo = iteratee(memo, obj[currentKey], currentKey, obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>使用 <code>while</code> 循环进行判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (index-- &gt; 0) &#123;</span><br><span class="line">  // do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="find"><a href="#find" class="headerlink" title="_.find"></a>_.find</h4><h5 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h5><p><code>_.find(list, predicate, [context])</code></p>
<p>遍历  <code>list</code> 值   返回第一个通过 <code>predicate</code> 函数返回真值的数值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let list = [1, 2, 3];</span><br><span class="line">function getodd(value) &#123;</span><br><span class="line">  return value % 2 === 0;</span><br><span class="line">&#125;</span><br><span class="line">_find(list, getodd) // 2</span><br></pre></td></tr></table></figure>
<h5 id="源码分析-4"><a href="#源码分析-4" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.find = _.detect = <span class="function"><span class="keyword">function</span>(<span class="params">obj, predicate, context</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> key;</span><br><span class="line">   <span class="comment">// 如果是数组</span></span><br><span class="line">   <span class="keyword">if</span> (obj.length === +obj.length) &#123;</span><br><span class="line">     <span class="comment">// 使用 findIndex 找到数组的值</span></span><br><span class="line">     key = _.findIndex(obj, predicate, context);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 如果是是对象</span></span><br><span class="line">     key = _.findKey(obj, predicate, context);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (key !== <span class="keyword">void</span> <span class="number">0</span> &amp;&amp; key !== <span class="number">-1</span>) <span class="keyword">return</span> obj[key];</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title>underscore.js源码分析(七)</title>
    <url>/2017/11/28/underscore-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%83/</url>
    <content><![CDATA[<h3 id="underscore-js-源码分析（七）"><a href="#underscore-js-源码分析（七）" class="headerlink" title="underscore.js 源码分析（七）"></a>underscore.js 源码分析（七）</h3><p><code>flatten</code> <code>without</code> <code>union</code>  <code>intersection</code>  <code>uniq</code></p>
<h4 id="flatten"><a href="#flatten" class="headerlink" title="flatten"></a><code>flatten</code></h4><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>使用 <code>flatten</code> 用来将多层嵌套的数组转化为一层，例如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">list = [<span class="number">1</span>, [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line">_.flatten(list) <span class="comment">// [1, 3, 4]</span></span><br></pre></td></tr></table></figure>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.flatten = <span class="function"><span class="keyword">function</span>(<span class="params">array, shallow</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> flatten(array, shallow, <span class="literal">false</span>);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>其中 <code>flatten</code> 函数如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*@description 用于将数组脱离嵌套</span></span><br><span class="line"><span class="comment">*@params input 传入的数组</span></span><br><span class="line"><span class="comment">*@params shallow &#123;Boolean&#125; 是否需要减少嵌套</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">var</span> flatten = <span class="function"><span class="keyword">function</span>(<span class="params">input, shallow, strict, startIndex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> output = [], idx = <span class="number">0</span>, value;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = startIndex || <span class="number">0</span>, length = input &amp;&amp; input.length; i &lt; length; i++) &#123;</span><br><span class="line">      value = input[i];</span><br><span class="line">      <span class="comment">// 这里使用了运算符嵌套表达式</span></span><br><span class="line">      <span class="comment">// value存在并且value的length 大于等于0 并且 value 输入数组或者类数组对象</span></span><br><span class="line">      <span class="keyword">if</span> (value &amp;&amp; value.length &gt;= <span class="number">0</span> &amp;&amp; (_.isArray(value) || _.isArguments(value))) &#123;</span><br><span class="line">        <span class="comment">//flatten current level of array or arguments object</span></span><br><span class="line">        <span class="comment">// use recursion to get the value</span></span><br><span class="line">        <span class="comment">// use if to decide isRecursion</span></span><br><span class="line">        <span class="comment">// 这里使用 if 来决定是否需要进行递归</span></span><br><span class="line">        <span class="keyword">if</span> (!shallow) value = flatten(value, shallow, strict);</span><br><span class="line">        <span class="keyword">var</span> j = <span class="number">0</span>, len = value.length;</span><br><span class="line">        output.length += len;</span><br><span class="line">        <span class="comment">// 看这种优雅的写法</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt; len) &#123;</span><br><span class="line">          <span class="comment">// 将取到的值依次填入</span></span><br><span class="line">          output[idx++] = value[j++];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strict) &#123;</span><br><span class="line">        output[idx++] = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="without"><a href="#without" class="headerlink" title="without"></a><code>without</code></h4><h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><p><code>_.without(array, values)</code></p>
<p>使用 <code>_.without</code> 用来所有 <code>values</code> 值后的 <code>array</code> 副本。</p>
<p>使用:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.without([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">1</span>)</span><br><span class="line">=&gt; [<span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<h5 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h5><p>自己写的函数:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">without</span>(<span class="params">array, values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> values === <span class="string">'undefined'</span>) <span class="keyword">return</span> array;</span><br><span class="line">  <span class="keyword">if</span> (array &amp;&amp; array.length) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    array.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ~values.indexOf(item);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数中存在错误: 结果或返回 <code>undefined</code></p>
<p>原因: 使用 <code>filter</code>方法中的 <code>return</code> 只会跳出 <code>filter</code> 循环，不会跳出最终的函数循环。 <code>低级错误</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">without</span>(<span class="params">array, values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> values === <span class="string">'undefined'</span>) <span class="keyword">return</span> array;</span><br><span class="line">  <span class="keyword">if</span> (array &amp;&amp; array.length) &#123;</span><br><span class="line">	<span class="keyword">let</span> value = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 使用 filter 进行的筛选效果选出的是符合效果的值</span></span><br><span class="line">    <span class="keyword">let</span> newArray = array.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> value.indexOf(item) === <span class="number">-1</span>;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="keyword">return</span> newArray;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用源码分析如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.without = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 向 difference 的函数中传入两个参数， array 以及 slice.call(arguments, 1);</span></span><br><span class="line">  <span class="comment">// array 是传入的需要进行删除的数组, slice.call() 获取到传入的第二个参数</span></span><br><span class="line">    <span class="keyword">return</span> _.difference(array, slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>这里调用了 <code>_.difference</code> 的方法实现。</p>
<p>使用 <code>_.difference</code> 实现的函数代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.difference = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获得到的 rest 函数</span></span><br><span class="line">    <span class="comment">// 将 arguments 传入到 flatten 函数, 传入的参数是 startIndex: 1</span></span><br><span class="line">    <span class="comment">// 表示获取到传入的 arguments 的第二个参数</span></span><br><span class="line">    <span class="keyword">var</span> rest = flatten(<span class="built_in">arguments</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 对于数组使用 filter 的方法</span></span><br><span class="line">   <span class="comment">// !_.contains 对于每一个数组进行遍历处理</span></span><br><span class="line">  <span class="comment">// 返回 rest 中没有包含 value 的值</span></span><br><span class="line">    <span class="keyword">return</span> _.filter(array, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> !_.contains(rest, value);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="union"><a href="#union" class="headerlink" title="union"></a><code>union</code></h4><h5 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h5><p><code>_.union(*arrays)</code></p>
<p>使用 <code>union</code> 用于返回传入的 <code>arrays</code> 的并集。按照顺序返回，可以传入一个或者多个的 <code>arrays</code> 数组。</p>
<h5 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.union = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _.uniq(flatten(<span class="built_in">arguments</span>, <span class="literal">true</span>, <span class="literal">true</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 其中 <code>_.uniq</code> 函数如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.uniq = _.unique = <span class="function"><span class="keyword">function</span>(<span class="params">array, isSorted, iteratee, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="literal">null</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="comment">// 如果 isSorted isBoolean</span></span><br><span class="line">    <span class="keyword">if</span> (!_.isBoolean(isSorted)) &#123;</span><br><span class="line">      context = iteratee;</span><br><span class="line">      iteratee = isSorted;</span><br><span class="line">      isSorted = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 iteratee 不是null</span></span><br><span class="line">    <span class="keyword">if</span> (iteratee != <span class="literal">null</span>) iteratee = cb(iteratee, context);</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">var</span> seen = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = array.length; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> value = array[i],</span><br><span class="line">      <span class="comment">// 获取到返回的结果</span></span><br><span class="line">          computed = iteratee ? iteratee(value, i, array) : value;</span><br><span class="line">      <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">        <span class="comment">// 如果 i !== 0 或者 seen 不等于 computed 将 value push 进入到 result 中</span></span><br><span class="line">        <span class="keyword">if</span> (!i || seen !== computed) result.push(value);</span><br><span class="line">        <span class="comment">// 将computed 结果赋给 seen</span></span><br><span class="line">        seen = computed;</span><br><span class="line">        <span class="comment">// 如果 iteratee 函数存在的话并且没有被排序</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iteratee) &#123;</span><br><span class="line">        <span class="comment">// 如果seen 中没有包含有 computed 结果</span></span><br><span class="line">        <span class="keyword">if</span> (!_.contains(seen, computed)) &#123;</span><br><span class="line">          <span class="comment">// 将computed 结果推入到 seen 中</span></span><br><span class="line">          seen.push(computed);</span><br><span class="line">          result.push(value);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!_.contains(result, value)) &#123;</span><br><span class="line">        result.push(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="intersection"><a href="#intersection" class="headerlink" title="intersection"></a><code>intersection</code></h4><p><code>_.intersection(arrays)</code></p>
<h5 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h5><p>使用 <code>_.intersection</code> 用来返回传入多个数组的并集。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.intersection([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>], [<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>]) <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>
<p>返回传入的多个数组的并集。</p>
<h5 id="源码分析-3"><a href="#源码分析-3" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.intersection = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">var</span> argsLength = <span class="built_in">arguments</span>.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = getLength(array); i &lt; length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> item = array[i];</span><br><span class="line">      <span class="comment">// 使用 continue 是结束本次循环</span></span><br><span class="line">      <span class="comment">// 用于判断传入的数组中是否有包含的相同的元素</span></span><br><span class="line">      <span class="keyword">if</span> (_.contains(result, item)) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">// 使用 break 是结束整个循环</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt; argsLength; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_.contains(<span class="built_in">arguments</span>[j], item)) <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 当上次循环结束之后 j === argsLength 成立</span></span><br><span class="line">      <span class="keyword">if</span> (j === argsLength) result.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>基本的思路是对于第一个传入的数组中的值进行遍历，根据第一个数组中的值, 遍历其他的数组，判断其他的数组中是否含有这个值。如果含有这个值的时候，将这个值存入一个<code>result</code>数组，最后将这个 <code>result</code> 数组返回。</p>
<p>要点:</p>
<ol>
<li><p>两次循环, 使用结束循环的方式是不一样的。</p>
<blockquote>
<p>使用 <code>break</code> 的时候， 结束的是整个循环</p>
<p>使用 <code>continue</code> 的时候, 结束的是当前的循环</p>
</blockquote>
</li>
<li><p>关于 <code>contain</code> 函数</p>
<p>使用 <code>contain</code> 用来判断在一个数组中是否包含有某一个元素:</p>
<p>在 <code>es6</code> 中使用 <code>Array.includes(item)</code> 来判断 <code>item</code> 是否包含在 <code>Array</code> 之中。</p>
</li>
</ol>
<h4 id="difference"><a href="#difference" class="headerlink" title="difference"></a><code>difference</code></h4><h5 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h5><p><code>_.difference(array, *others)</code> </p>
<p>使用 <code>difference</code> 获取到来自于 <code>array</code> 但是不存在于 <code>others</code> 中的数组元素。</p>
<h5 id="源码分析-4"><a href="#源码分析-4" class="headerlink" title="源码分析"></a>源码分析</h5><p>自己写的代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">difference</span>(<span class="params">array, other</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> rest = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">let</span> newArr = array.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> other.indexOf(item) === <span class="number">-1</span>;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.difference = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rest = flatten(<span class="built_in">arguments</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> _.filter(array, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> !_.contains(rest, value);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title>underscore.js源码分析(十)</title>
    <url>/2017/12/05/underscore-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81/</url>
    <content><![CDATA[<h3 id="underscore-js-源码分析（十）"><a href="#underscore-js-源码分析（十）" class="headerlink" title="underscore.js 源码分析（十）"></a>underscore.js 源码分析（十）</h3><p>使用underscore.js 的 function 部分</p>
<p><code>bind</code>  <code>bindall</code>  <code>partial</code>  <code>memorize</code>  <code>delay</code></p>
<h5 id="bind"><a href="#bind" class="headerlink" title="bind"></a><code>bind</code></h5><p><code>_.bind(func, obj, *arguments)</code></p>
<p>使用 <code>bind</code></p>
<p>使用 <code>bind</code> 的目的是将函数 <code>func</code> 绑定到 <code>obj</code> 上面去，也就是说，这时候 <code>func</code> 中的 <code>this</code> 就指向了 <code>obj</code>, 其中 <code>arguments</code> 被作为传递给 <code>func</code> 的参数被传入到 <code>func</code> 之中。</p>
<p>#####　实例如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">home</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`hi my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>, my home is <span class="subst">$&#123;home&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 _.bind 进行函数绑定</span></span><br><span class="line">_.bind(greet, &#123;<span class="attr">name</span>: <span class="string">'张宁宁'</span>&#125;, <span class="string">'山东'</span>);</span><br><span class="line"><span class="comment">// hi my name is 张宁宁, my home is 山东</span></span><br></pre></td></tr></table></figure>
<hr>
<p>关于使用 <code>bind</code> 的函数:</p>
<p>使用 <code>bind</code> 的函数</p>
<p>使用 <code>bind</code> 函数接收两个参数，第一个参数表示需要进行绑定的变量，第二个参数表示传递给函数的参数。</p>
<hr>
<p>源码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.bind = <span class="function"><span class="keyword">function</span>(<span class="params">func, context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 首先检查是否支持 es5 的bind 方法, 如果支持， 使用 nativeBind 进行绑定操</span></span><br><span class="line">  <span class="comment">// nativeBind.appy</span></span><br><span class="line">  <span class="comment">// 对于 es5 支持的 bind 方法接收两个参数</span></span><br><span class="line">  <span class="comment">// func 以及 参数</span></span><br><span class="line">    <span class="keyword">if</span> (nativeBind &amp;&amp; func.bind === nativeBind) <span class="keyword">return</span> nativeBind.apply(func, slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</span><br><span class="line">  <span class="comment">// 如果 func 不是一个函数的时候</span></span><br><span class="line">  <span class="comment">// throw new TypeError('bind must be called on a function');</span></span><br><span class="line">    <span class="keyword">if</span> (!_.isFunction(func)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Bind must be called on a function'</span>);</span><br><span class="line">  <span class="comment">// 使用 slice.call 用于截取 arguments</span></span><br><span class="line">  <span class="comment">// 通过使用 slice.call 方法截取传入函数的参数</span></span><br><span class="line">    <span class="keyword">var</span> args = slice.call(<span class="built_in">arguments</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">var</span> bound =  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 返回一个 executeBpund 函数</span></span><br><span class="line">      <span class="comment">// 使用 args 数组的 concat 方法用于连接数组</span></span><br><span class="line">      <span class="comment">// 分别传入的值是 func, bound, context, this, args</span></span><br><span class="line">      <span class="keyword">return</span> executeBound(func, bound, context, <span class="keyword">this</span>, args.concat(slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> bound;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>其中 <code>executeBound</code> 函数如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里面 boundFunc 是需要进行绑定的函数 </span></span><br><span class="line"><span class="keyword">var</span> executeBound = <span class="function"><span class="keyword">function</span>(<span class="params">sourceFunc, boundFunc, context, callingContext, args</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 如果 boundFunc 不在 callingContext 的原型链上</span></span><br><span class="line">  <span class="comment">// 使用 apply 方法进行绑定</span></span><br><span class="line">  <span class="comment">// 如果 callingContext 不在 boundFunc 的原型链上</span></span><br><span class="line">  <span class="comment">// 这里的 callingContext 是指的 this 值</span></span><br><span class="line">  <span class="comment">// 返回将 context 绑定到 sourceFunc 上面</span></span><br><span class="line">    <span class="keyword">if</span> (!(callingContext <span class="keyword">instanceof</span> boundFunc)) <span class="keyword">return</span> sourceFunc.apply(context, args);</span><br><span class="line">   <span class="comment">// 关于 baseCreate 函数</span></span><br><span class="line">    <span class="keyword">var</span> self = baseCreate(sourceFunc.prototype);</span><br><span class="line">    <span class="keyword">var</span> result = sourceFunc.apply(self, args);</span><br><span class="line">    <span class="keyword">if</span> (_.isObject(result)) <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>关于 <code>baseCreate</code> 函数如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Ctor = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> baseCreate = <span class="function"><span class="keyword">function</span>(<span class="params">prototype</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断 prototype 是否是一个对象</span></span><br><span class="line">  <span class="keyword">if</span> (!_.isObjject(prototype)) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  <span class="comment">// 如果nativeCreate 存在的话, 返回 nativeCreate(prototype) 这个函数</span></span><br><span class="line">  <span class="keyword">if</span> (nativeCreate) <span class="keyword">return</span> nativeCreate(protoytpe);</span><br><span class="line">  Ctor.prototype = prototype;</span><br><span class="line">  <span class="comment">// 创建一个函数的实例，这个函数的原型指向 prototype</span></span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">new</span> Ctor;</span><br><span class="line">  Ctor.prototype = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的 <code>nativeCreate</code> 返回的是这个 <code>Object.create()</code> </p>
<p>使用 <code>Object.create</code> 用来实现继承的关系</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 new 操作符的过程</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Constructor();</span><br><span class="line"><span class="comment">// 创建一个新的对象</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="comment">// 执行原型链接</span></span><br><span class="line">obj._proto_ = Constructor.prototype;</span><br><span class="line"><span class="comment">// 将这个构造函数的 this 值指向新创建的这个新对象</span></span><br><span class="line">Constructor.call(obj);</span><br><span class="line"><span class="comment">// 这样在 obj 中我们就能愉快的使用在 Constructor 中通过 this 值创建的新对象了</span></span><br></pre></td></tr></table></figure>
<h5 id="partial"><a href="#partial" class="headerlink" title="partial"></a><code>partial</code></h5><p><code>partial(function, *arguments)</code></p>
<p>局部应用一个函数填充在任意个数的 <code>arguments</code>。</p>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> particalAdd = _.partial(add, <span class="number">3</span>);</span><br><span class="line">particalAdd(<span class="number">5</span>); <span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 这里的 5 填充了函数的第二个参数 b</span></span><br></pre></td></tr></table></figure>
<p>自己写的函数:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取到传入到 partial 函数中的参数</span></span><br><span class="line">  <span class="keyword">let</span> partialArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// return 返回一个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fnArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 将参数传入，执行 fn</span></span><br><span class="line">    fn(...partialArgs, ...fnArgs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.partial = <span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> boundArgs = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">bound</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> position = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> args = boundArgs.slice();</span><br><span class="line">    <span class="keyword">let</span> length = args.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="comment">// 在数组中使用 position ++</span></span><br><span class="line">      <span class="keyword">if</span> (args[i] === _) args[i] = <span class="built_in">arguments</span>[position++]; </span><br><span class="line">    &#125;</span><br><span class="line">    whitle(position &lt; <span class="built_in">arguments</span>.length) args.push(<span class="built_in">arguments</span>[position++]);</span><br><span class="line">    <span class="comment">// 这时候的 args 中是包含了所有的参数</span></span><br><span class="line">    <span class="keyword">return</span> executeBound(func, bound, <span class="keyword">this</span>, <span class="keyword">this</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于 <code>executeBound</code> 函数上面有解释，这个函数的作用是:</p>
<blockquote>
<p>Determines whether to execute a function as a constructor,   or a normal function with the provided arguments</p>
<p>决定是否构建一个函数作为构造函数，或者运行一个给定参数的普通函数。</p>
</blockquote>
<p><code>memoize</code></p>
<p>使用 <code>memorize</code> 用来缓存函数计算的结果。</p>
<p><code>delay</code></p>
<p>使用 <code>delay</code> 用来实现对于函数延迟执行，代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过调用 Array.prototype.slice.call 的方法进行获得传递的参数</span></span><br><span class="line">  <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="comment">// 返回等待 wait 时间之后的函数</span></span><br><span class="line">  <span class="keyword">return</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 自己写的</span></span><br><span class="line">    func(args);</span><br><span class="line">    <span class="comment">// 源码写的</span></span><br><span class="line">    <span class="comment">// 使用 apply 的方法向函数 func 中传递 args 参数</span></span><br><span class="line">    <span class="keyword">return</span> func.apply(<span class="literal">null</span>, args);</span><br><span class="line">  &#125;, wait)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>defer</code></p>
<p><code>defer(function, *arguments)</code></p>
<p>使用 <code>defer</code> 的目的在于延迟调用 <code>function</code> 直到当前的调用栈被清空为止，其中 <code>arguments</code> 会被作为 <code>function</code> 的参数进行传入。</p>
<p>类似于使用 <code>setTimeout(function () {}, 0)</code> 的延迟调用效果。</p>
<p>实现的源码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.defer = _.partial(_.delay, _, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title>underscore.js源码分析(二)</title>
    <url>/2017/11/20/underscore-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%8C/</url>
    <content><![CDATA[<h3 id="underscore-js-源码分析-二"><a href="#underscore-js-源码分析-二" class="headerlink" title="underscore.js 源码分析(二)"></a>underscore.js 源码分析(二)</h3><p><code>_.filter</code>  <code>_.where</code> <code>_.findWhere</code>  <code>_.reject</code>  <code>_.every</code></p>
<h4 id="filter"><a href="#filter" class="headerlink" title="_.filter"></a><code>_.filter</code></h4><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p><code>_.filter(list, predicate, [context])</code></p>
<p>遍历 <code>list</code> 值, 返回通过 <code>predicate</code> 函数返回为真的值数组。</p>
<p>代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toFilter</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'通过过滤的数组'</span>, _.filter(list, toFilter)); <span class="comment">// [2, 6]</span></span><br></pre></td></tr></table></figure>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><p>使用 <code>_.filter()</code> 的源码如下所示:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.filter = _.select = <span class="function"><span class="keyword">function</span>(<span class="params">obj, predicate, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> results = [];</span><br><span class="line">  <span class="comment">// 判断 `obj` 是否为 null 是返回空数组</span></span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> results;</span><br><span class="line">  predicate = cb(predicate, context);</span><br><span class="line">  <span class="comment">// 使用 `each` 函数对于数组中的每一个列表进行遍历</span></span><br><span class="line">  _.each(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value, index, list</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (predicate(value, index, list)) results.push(value);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="where"><a href="#where" class="headerlink" title="_.where"></a>_.where</h4><h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><p><code>_.where(list, propertries)</code></p>
<p><code>list</code>: 数组</p>
<p><code>propertries</code> : 需要进行检索的键值对(一个对象)</p>
<p>遍历 <code>list</code> 中的每一个值， 返回一个数组，这个数组中包含含有 <code>propertries</code> 中属性的所有的键值对。</p>
<p>用法:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">list = [&#123;<span class="attr">name</span>: <span class="string">'张宁宁'</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">'张宁宁'</span>, <span class="attr">age</span>: <span class="number">70</span>&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(_.where(list, &#123;<span class="attr">name</span>: <span class="string">'张宁宁'</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;)); <span class="comment">//  [&#123;name: '张宁宁', age: 18&#125;]</span></span><br></pre></td></tr></table></figure>
<p>#####源码分析 </p>
<p>自己写的代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">where</span>(<span class="params">list, sObj</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> results = [];</span><br><span class="line">	<span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> results;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> obj <span class="keyword">of</span> list) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">Object</span>.keys(sObj).includes(key)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (sObj[key] === obj[key]) &#123;</span><br><span class="line">					flag = <span class="literal">true</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					flag = <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				flag = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">			results.push(obj);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_where()</code> 源代码如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_.where = function(obj, attrs) &#123;</span><br><span class="line">  return _.filter(obj, _.matches(attrs));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用 <code>_filter</code> 筛选出 <code>obj</code> 对象中适合函数 <code>_.matches</code> 的键值对儿。</p>
<p><code>_.match()</code> 方法的源码如下所示:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">_.matches = <span class="function"><span class="keyword">function</span>(<span class="params">attrs</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取到对象的键值对儿, 是 [key, value] 的形式</span></span><br><span class="line">    <span class="keyword">var</span> pairs = _.pairs(attrs), length = pairs.length;</span><br><span class="line">    <span class="comment">// 返回一个函数，接收 obj 参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">     <span class="comment">// 如果 obj == null 返回 !length</span></span><br><span class="line">     <span class="comment">// 为什么不直接返回false ?</span></span><br><span class="line">      <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> !length;</span><br><span class="line">      <span class="comment">// 创建一个新对象</span></span><br><span class="line">      obj = <span class="keyword">new</span> <span class="built_in">Object</span>(obj);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> pair = pairs[i], key = pair[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 两种情况， 不存在键或者键存在，值不相等， 两种情况发生一种情况</span></span><br><span class="line">        <span class="comment">// 返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (pair[<span class="number">1</span>] !== obj[key] || !(key <span class="keyword">in</span> obj)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 返回 true</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p>对于返回一个函数的这种形式:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// dosomething</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用的时候这样调用</span></span><br><span class="line">name()(); <span class="comment">// to dosomething</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="findWhere"><a href="#findWhere" class="headerlink" title="_.findWhere"></a><code>_.findWhere</code></h4><h5 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h5><p><code>_findWhere(list, properties)</code></p>
<p>遍历整个 <code>list</code> 返回匹配整个 <code>properties</code> 参数所列出的所有键值对儿的第一个值。</p>
<h5 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.findWhere = <span class="function"><span class="keyword">function</span>(<span class="params">obj, attrs</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过使用 _.matches(attrs) 返回了一个函数</span></span><br><span class="line">    <span class="comment">// 通过使用 _.find 方法调用了这个函数</span></span><br><span class="line">    <span class="keyword">return</span> _.find(obj, _.matches(attrs));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过调用 <code>_.find</code> 函数返回通过第一次获得匹配的对象。</p>
<h4 id="reject"><a href="#reject" class="headerlink" title="_.reject"></a><code>_.reject</code></h4><h5 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h5><p><code>_.reject(list, predicate, [context])</code></p>
<p>返回 <code>list</code> 列表中没能通过 <code>predicate</code> 检验的数值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num%<span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> list = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(_.reject(list, reject)); <span class="comment">// [1, 3, 5];</span></span><br></pre></td></tr></table></figure>
<p>作用与 <code>filter</code> 相反。</p>
<h5 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.reject = <span class="function"><span class="keyword">function</span>(<span class="params">obj, predicate, context</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> _.filter(obj, _.negate(cb(predicate)), context);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>_.negate</code> 函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> _.negate = <span class="function"><span class="keyword">function</span>(<span class="params">predicate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过使用 apply 方法将 arguments 方法传入</span></span><br><span class="line">    <span class="keyword">return</span> !predicate.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>####　<code>_every</code></p>
<h5 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h5><p><code>_every(list, [predicate], [context])</code></p>
<p>如果 <code>list</code> 中的元素都通过 <code>predicate</code> 的真值检验就返回为 <code>true</code></p>
<h5 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h5><p>源码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">every</span>(<span class="params">obj, predicate</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 通过使用 keys 获得到一个包含对象键的数组</span></span><br><span class="line">	<span class="keyword">let</span> keys = obj.length == +obj.length &amp;&amp; <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">	<span class="keyword">let</span> currentKey;</span><br><span class="line">    <span class="comment">// length 为数组或者对象的长度</span></span><br><span class="line">	<span class="keyword">let</span> length = (keys || obj).length;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">		currentKey = keys ? keys[index] : index;</span><br><span class="line">        <span class="comment">// 如果对于predicate 函数返回为 false, every 函数返回为false</span></span><br><span class="line">		<span class="keyword">if</span> (!predicate(obj[currentKey])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title>underscore.js源码分析(三)</title>
    <url>/2017/11/22/underscore-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%89/</url>
    <content><![CDATA[<p>###　 underscore.js 源码分析(三)</p>
<p><code>_.some</code> <code>_.contains</code>  <code>_.invoke</code>  <code>_.pluck</code>  <code>_.max</code></p>
<h4 id="some"><a href="#some" class="headerlink" title="_.some"></a><code>_.some</code></h4><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p><code>_.some(list, [predicate], [context])</code></p>
<p>遍历 <code>list</code> 中的元素, 只要其中有一个元素通过 <code>predicate</code> , 那么就返回为 <code>true</code></p>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.some = _.any = <span class="function"><span class="keyword">function</span>(<span class="params">obj, predicate, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    predicate = cb(predicate, context);</span><br><span class="line">    <span class="keyword">var</span> keys = obj.length !== +obj.length &amp;&amp; _.keys(obj),</span><br><span class="line">        length = (keys || obj).length,</span><br><span class="line">        index, currentKey;</span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">      currentKey = keys ? keys[index] : index;</span><br><span class="line">      <span class="comment">// 如果 obj 中其中的一个元素进行 predicate 检验的结果为 true 返回为true</span></span><br><span class="line">      <span class="keyword">if</span> (predicate(obj[currentKey], currentKey, obj)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="contains"><a href="#contains" class="headerlink" title="_.contains"></a><code>_.contains</code></h4><h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><p><code>_.contains(list, value, [fromIndex])</code></p>
<p>如果在 <code>list</code> 中包含有 <code>value</code> 值，那么返回为 <code>true</code> <code>fromIndex</code> 表示开始进行检索的位置。</p>
<p>如果 <code>list</code> 是数组, 检查数组中是否包含有对应的 <code>value</code> 值</p>
<p>如果 <code>list</code> 是对象, 检查对象中的值是否有存在的 <code>value</code> 值</p>
<p>自己写的代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">contain</span>(<span class="params">obj, value, fromIndex</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> list = obj;</span><br><span class="line">  <span class="keyword">if</span> (obj.length !== +obj.length) &#123;</span><br><span class="line">    list = obj.values();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 为了保证代码的健壮性，添加 typeof fromIndex === 'number' &amp;&amp; fromIndex 的判断</span></span><br><span class="line">  <span class="keyword">return</span> list.indexOf(value, <span class="keyword">typeof</span> fromIndex === <span class="string">'number'</span> &amp;&amp; fromIndex) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.contains = _.includes = _.include = <span class="function"><span class="keyword">function</span>(<span class="params">obj, target, fromIndex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 使用 _.values 获得到对象的值</span></span><br><span class="line">    <span class="keyword">if</span> (obj.length !== +obj.length) obj = _.values(obj);</span><br><span class="line">    <span class="comment">// 使用 `_.indexOf` 获取到索引</span></span><br><span class="line">    <span class="keyword">return</span> _.indexOf(obj, target, <span class="keyword">typeof</span> fromIndex == <span class="string">'number'</span> &amp;&amp; fromIndex) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="invoke"><a href="#invoke" class="headerlink" title="_.invoke"></a><code>_.invoke</code></h4><blockquote>
<p>计算机术语中: invoke : [ɪnˈvoʊk] 乞求，借助于   调用【计算机】</p>
</blockquote>
<h5 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h5><p><code>_.invoke(list, methodName, *arguments)</code> </p>
<p>在 <code>list</code> 的每一个元素上执行 <code>methodName</code> 方法。 <code>argument</code> 用于将使用 <code>_.invoke</code> 调用 <code>methodName</code> 方法的时候传递的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [[<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>]];</span><br><span class="line">_.invoke(list, <span class="string">'sort'</span>) <span class="comment">// [1, 3 ,4]</span></span><br><span class="line"><span class="comment">// 这个函数的作用是将 执行 list 元素中的数组 [1, 4, 3] 方法 sort</span></span><br><span class="line"><span class="comment">// 同样 我们可以使用别的函数,这个时候 argument 会被作为 methodName 函数的参数，</span></span><br><span class="line"><span class="comment">// 而 函数 print 中的 this 值指向的是 list 中的元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// [1, 4, 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h5><p>实现这个功能的源码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.invoke = <span class="function"><span class="keyword">function</span>(<span class="params">obj, method</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 Array.slice.call 返回一个子数组</span></span><br><span class="line">    <span class="comment">// 第二个参数 2 表示截取从传入参数的第二个处进行截取</span></span><br><span class="line">    <span class="keyword">var</span> args = slice.call(<span class="built_in">arguments</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">var</span> isFunc = _.isFunction(method);</span><br><span class="line">  <span class="comment">// 对于 obj 进行遍历</span></span><br><span class="line">    <span class="keyword">return</span> _.map(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过使用 apply 方法， 将 value 作为 func 的 this 值， 同时传入截取的参数</span></span><br><span class="line">    <span class="comment">// 进行判断是否是函数 method 或者 内置的 method 方法</span></span><br><span class="line">      <span class="keyword">return</span> (isFunc ? method : value[method]).apply(value, args);</span><br><span class="line">    &#125;);</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>这是一个用于进行调用绑定的函数。</p>
<h4 id="pluck"><a href="#pluck" class="headerlink" title="_.pluck"></a><code>_.pluck</code></h4><blockquote>
<p>pluck 拔掉，摘，拉</p>
</blockquote>
<p><code>_.pluck(list, propertyName)</code> </p>
<h5 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h5><p>使用 <code>_.pluck</code> 用于获取到数组对象中的对应属性的所有的值。</p>
<p>对于对象中不存在的属性返回 <code>undefined</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stooges = [&#123;<span class="attr">name</span>: <span class="string">'moe'</span>, <span class="attr">age</span>: <span class="number">40</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">'larry'</span>, <span class="attr">age</span>: <span class="number">50</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">'curly'</span>, <span class="attr">age</span>: <span class="number">60</span>&#125;];</span><br><span class="line">_.pluck(stooges, <span class="string">'name'</span>);</span><br><span class="line">=&gt; [<span class="string">"moe"</span>, <span class="string">"larry"</span>, <span class="string">"curly"</span>]</span><br></pre></td></tr></table></figure>
<p>自己写的一个 <code>pluck</code> 函数如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pluck</span>(<span class="params">list, name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> props = [];</span><br><span class="line">  list.map(<span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(obj).indexOf(name) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        props.push(obj[name]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这里使用 void 0 代替 undefined </span></span><br><span class="line">        props.push(<span class="keyword">void</span> <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">	<span class="keyword">return</span> props;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h5 id="源码分析-3"><a href="#源码分析-3" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.pluck = <span class="function"><span class="keyword">function</span>(<span class="params">obj, key</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用 _.map， 对于 obj 中的数组对象成员执行 _.property 方法</span></span><br><span class="line">  <span class="keyword">return</span> _.map(obj, _.property(key));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.property = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 返回一个函数， 参数 obj 接收到的是 _.property()(obj) 这个的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">     <span class="comment">// 传入的 obj 是否为 null 是 返回 undefined  否则 返回 obj[key]</span></span><br><span class="line">      <span class="keyword">return</span> obj == <span class="literal">null</span> ? <span class="keyword">void</span> <span class="number">0</span> : obj[key];</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="max"><a href="#max" class="headerlink" title="_.max"></a><code>_.max</code></h4><p><code>_.max(list, [iteratee], [context])</code> </p>
<p>返回 <code>list</code> 中的最大值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.max = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将 result 初始化为 -infinity lastComputed 初始化为 infinity</span></span><br><span class="line">    <span class="keyword">var</span> result = -<span class="literal">Infinity</span>, lastComputed = -<span class="literal">Infinity</span>,</span><br><span class="line">        value, computed;</span><br><span class="line">    <span class="comment">// 当 interaee 为null 不传参数,采用 obj 中内置的方法名称来做</span></span><br><span class="line">    <span class="comment">// 并且 obj 不等于 null 的时候</span></span><br><span class="line">    <span class="keyword">if</span> (iteratee == <span class="literal">null</span> &amp;&amp; obj != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// obj 为数组 ? 数组 : 对象的值</span></span><br><span class="line">      obj = obj.length === +obj.length ? obj : _.values(obj);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = obj.length; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="comment">// 进行遍历值</span></span><br><span class="line">        value = obj[i];</span><br><span class="line">        <span class="comment">// 比较大小，将最大的那个值赋给 result 参数</span></span><br><span class="line">        <span class="keyword">if</span> (value &gt; result) &#123;</span><br><span class="line">          result = value;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      iteratee = cb(iteratee, context);</span><br><span class="line">      <span class="comment">// 使用 foreach 对于 obj 进行计算</span></span><br><span class="line">      _.each(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value, index, list</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 进行计算之后返回计算结果</span></span><br><span class="line">        computed = iteratee(value, index, list);</span><br><span class="line">        <span class="comment">// 如果计算结果大于上一次计算结果， 将最大的值赋给 result</span></span><br><span class="line">        <span class="comment">// 将最大的结果赋予 lastComputed</span></span><br><span class="line">        <span class="keyword">if</span> (computed &gt; lastComputed || computed === -<span class="literal">Infinity</span> &amp;&amp; result === -<span class="literal">Infinity</span>) &#123;</span><br><span class="line">          result = value;</span><br><span class="line">          lastComputed = computed;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>在js 中关于运算符优先级的问题:</p>
<blockquote>
<p>逻辑 <code>&amp;&amp;</code> (与) 大于 逻辑 或<code>||</code></p>
</blockquote>
</li>
<li><p>上面有一段程序如下:</p>
<p><code>if (computed &gt; lastComputed || computed === -Infinity &amp;&amp; result === -Infinity)</code></p>
<p>这段话翻译为中文就是</p>
<p>如果满足 <code>computed === -Infinity &amp;&amp; result === -Infinity</code> 或者 <code>computed &gt; lastComputd</code> 的时候，进行动作。 </p>
</li>
</ol>
]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title>underscore.js源码分析(八)</title>
    <url>/2017/12/01/underscore-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%85%AB/</url>
    <content><![CDATA[<h3 id="underscore-js-源码分析-八"><a href="#underscore-js-源码分析-八" class="headerlink" title="underscore.js 源码分析(八)"></a>underscore.js 源码分析(八)</h3><p><code>zip</code> <code>unzip</code> <code>object</code> <code>indexOf</code> <code>lastIndexOf</code></p>
<h4 id="zip"><a href="#zip" class="headerlink" title="zip"></a><code>zip</code></h4><p><code>_.zip(*arrays)</code></p>
<p>使用 <code>zip</code> 的目的是将数组中相应位置的值结合在一起。将分离的数组归并为一个数组。</p>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.zip([<span class="string">'张宁宁'</span>, <span class="string">'张艺苇'</span>], [<span class="string">'男'</span>, <span class="string">'女'</span>], [<span class="string">'山东'</span>, <span class="string">'河北'</span>]);</span><br><span class="line">=&gt; [[<span class="string">'张宁宁'</span>, <span class="string">'男'</span>, <span class="string">'山东'</span>] , [<span class="string">'张艺苇'</span>, <span class="string">'女'</span>, <span class="string">'河北'</span>]]</span><br></pre></td></tr></table></figure>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><p>自己写的:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>用于合成数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>array 传入的多个数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Object&#125;</span> </span>返回的经过合成之后的数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">zip</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 需要添加是否为 null</span></span><br><span class="line">    <span class="keyword">if</span> (array === <span class="literal">null</span>) <span class="keyword">return</span> [];</span><br><span class="line">	<span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">let</span> result = [];</span><br><span class="line">	array.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">let</span> arr = [];</span><br><span class="line">		args.map(<span class="function">(<span class="params">argItem</span>) =&gt;</span> &#123;</span><br><span class="line">			arr.push(argItem[index]);</span><br><span class="line">		&#125;)</span><br><span class="line">		result.push(arr);</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的几点:</p>
<ol>
<li><p>对于传入的 <code>array</code> 需要进行判断，是否为 <code>null</code></p>
<blockquote>
<p>对于传入的参数一定要进行类型判断</p>
</blockquote>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.zip = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (array == <span class="literal">null</span>) <span class="keyword">return</span> [];</span><br><span class="line">   <span class="comment">// 使用 _.max 获取到 arguments 中所有的数组个数</span></span><br><span class="line">   <span class="keyword">var</span> length = _.max(<span class="built_in">arguments</span>, <span class="string">'length'</span>).length;</span><br><span class="line">   <span class="comment">// 使用 Array 生成 length 长度的数组</span></span><br><span class="line">   <span class="keyword">var</span> results = <span class="built_in">Array</span>(length);</span><br><span class="line">   <span class="keyword">while</span> (length-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// 使用 pluck 用于萃取获得 arguments 的某种属性值</span></span><br><span class="line">     results[length] = _.pluck(<span class="built_in">arguments</span>, length);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> results;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a><code>unzip</code></h4><p>使用 <code>unzip</code> 的目的是将归并后的数组分解为串联的一系列的新数组。</p>
<p>#####　实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.unzip([[<span class="string">'张宁宁'</span>, <span class="string">'张艺苇'</span>], [<span class="string">'山东'</span>, <span class="string">'行唐'</span>]]);</span><br><span class="line">=&gt; [<span class="string">'张宁宁'</span>, <span class="string">'山东'</span>] [<span class="string">'张艺苇'</span>, <span class="string">'行唐'</span>]</span><br><span class="line"><span class="comment">// 返回的第一个元素中包含所有输入数组的第一个元素</span></span><br></pre></td></tr></table></figure>
<p>实现代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.unzip = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回使用 apply 压入的一个数组</span></span><br><span class="line">  <span class="keyword">return</span> _.zip.apply(<span class="literal">null</span>, array);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="object"><a href="#object" class="headerlink" title="object"></a><code>object</code></h4><p>使用 <code>object</code> 用于将数组转化为对象的形式。</p>
<p><code>_.object(list, [values])</code></p>
<p>传递一个单独的<code>[key, value]</code> 的列表，或者一个键的列表和一个值的列表。当传入 <code>list</code> 和 <code>values</code> 的时候， <code>list</code> 中的值会被作为返回对象的键, <code>values</code> 中的值会被作为返回对象的值。</p>
<h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.object([<span class="string">'moe'</span>, <span class="string">'larry'</span>, <span class="string">'curly'</span>], [<span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>]);</span><br><span class="line">=&gt; &#123;<span class="attr">moe</span>: <span class="number">30</span>, <span class="attr">larry</span>: <span class="number">40</span>, <span class="attr">curly</span>: <span class="number">50</span>&#125;</span><br></pre></td></tr></table></figure>
<h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><p>代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>toObj 将键值数组组合为对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> </span>list 键数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> </span>values 值数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Object&#125;</span> </span>组成的对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toObj</span>(<span class="params">list, values</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (list === <span class="literal">null</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">	<span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> values === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">	  list.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">		obj[item[<span class="number">0</span>]] = item[<span class="number">1</span>];</span><br><span class="line">	  &#125;);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	  list.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">		obj[item] = values[index];</span><br><span class="line">	  &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h4><p><code>_.indexOf(array, value, [isSorted])</code></p>
<p>使用 <code>indexOf</code> 用于返回 <code>value</code> 在 <code>array</code> 中的索引值， 当传入第三个值为数字的时候，表示从第几个数字进行索引。</p>
<h5 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_.indexOf([1, 2, 3 ,4 ,1],1, 1);</span><br><span class="line">=&gt; 5</span><br></pre></td></tr></table></figure>
<h5 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.indexOf = <span class="function"><span class="keyword">function</span> (<span class="params">array, item, isSorted</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>; length = array &amp;&amp; array.length;</span><br><span class="line">  <span class="comment">// 使用判断数组的方法</span></span><br><span class="line">  <span class="comment">// length = array &amp;&amp; array.length;</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> isSorted === <span class="string">'number'</span>) &#123;</span><br><span class="line">    i = isSorted &lt; <span class="number">0</span> ? <span class="built_in">Math</span>.max(<span class="number">0</span>, length + isSorted) : isSorted;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isSorted &amp;&amp; length) &#123;</span><br><span class="line">    <span class="comment">// 如果传入的是一个 true, 使用更快的算法</span></span><br><span class="line">    i = _.sortedIndex(array, item);</span><br><span class="line">    <span class="keyword">return</span> array[i] === item ? i : <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; length; i++) <span class="keyword">if</span> (array[i] === item) <span class="keyword">return</span> i;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>判断一个数组是否存在:</p>
<p><code>length = array &amp;&amp; array.length</code> </p>
</li>
<li><p>使用 <code>Math.max</code> 的妙用</p>
<p>例如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max(<span class="number">0</span>, num);</span><br><span class="line"><span class="comment">// 返回 num &gt; 0</span></span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line">num &lt;= <span class="number">0</span> ? <span class="number">0</span> : num;</span><br><span class="line"><span class="comment">//因此</span></span><br><span class="line"><span class="comment">// 对于数字的判断比较，就不要使用三元运算符了，使用 `Math.max` 或者 `Math.min` 会更好些</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>例如下面的一个程序，用来获得一组数组中的最大的差值:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxProfit</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> minProfit = arr[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i ++) &#123;</span><br><span class="line">    minProfit = <span class="built_in">Math</span>.min(minProfit, arr[i]);</span><br><span class="line">    <span class="keyword">let</span> currentProfit = arr[i] - minProfit;</span><br><span class="line">    maxProfit = <span class="built_in">Math</span>.max(maxProfit, currentProfit);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a><code>lastIndexOf</code></h4><p><code>_.lastIndexOf(array, value, [fromIndex])</code></p>
<p>返回 <code>value</code> 在 <code>array</code> 中从最后开始的索引值，传入的 <code>fromIndex</code> 将从给定的索引值进行搜索。</p>
<h5 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.lastIndexOf = <span class="function"><span class="keyword">function</span>(<span class="params">array, item, fromIndex</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = array ? array.length : <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fromIndex === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用 Math.min 当 fromIndex + 1 &gt; index 的时候，要取 index</span></span><br><span class="line">    index = fromIndex &lt; <span class="number">0</span> ? index + fromIndex + <span class="number">1</span> : <span class="built_in">Math</span>.min(index, fromIndex + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 使用 --index 因为最后一个元素的索引是 array.length - 1</span></span><br><span class="line">  <span class="keyword">while</span> (--index &gt;= <span class="number">0</span>) <span class="keyword">if</span> (array[index] === item) <span class="keyword">return</span> index;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="sortIndex"><a href="#sortIndex" class="headerlink" title="sortIndex"></a><code>sortIndex</code></h4><p><code>_.sortIndex(list, value, [iteratee], [context])</code></p>
<p>使用 <code>sortIndex</code> 的目的在于使用二分法查找到 <code>value</code> 在 <code>list</code> 中的位置序号。</p>
<h5 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.sortedIndex([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>], <span class="number">35</span>)</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h5 id="源码分析-3"><a href="#源码分析-3" class="headerlink" title="源码分析"></a>源码分析</h5><p>使用二分法进行比较获得到元素在数组中的位置的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.sortedIndex = <span class="function"><span class="keyword">function</span> (<span class="params">array, obj, iteratee, context</span>) </span>&#123;</span><br><span class="line">  iteratee = cb(iteratee, context, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> value = iteratee(obj);</span><br><span class="line">  <span class="keyword">let</span> low = <span class="number">0</span>; <span class="keyword">let</span> high = array.length;</span><br><span class="line">  <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((low + high) / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 判断 value 在相对于 array 在左边还是在右边</span></span><br><span class="line">    <span class="keyword">if</span> (_.comparator(iteratee(array[mid], value)) &lt; <span class="number">0</span>) low = mid + <span class="number">1</span>; <span class="keyword">else</span> high = mid; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用二分法的原理是将数组中分为两个部分，判断 <code>value</code> 值在哪一个部分之内。</p>
]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title>underscore.js源码分析(十二)</title>
    <url>/2017/12/10/underscore-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E4%BA%8C/</url>
    <content><![CDATA[<h3 id="underscore-js-源码分析-十二"><a href="#underscore-js-源码分析-十二" class="headerlink" title="underscore.js 源码分析(十二)"></a>underscore.js 源码分析(十二)</h3><p><code>wrap</code> <code>negate</code> <code>compose</code></p>
<h4 id="wrap"><a href="#wrap" class="headerlink" title="wrap"></a><code>wrap</code></h4><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p><code>_.wrap(function, wrapper)</code></p>
<p>使用 <code>wrap</code> 的目的在于将函数 <code>function</code> 作为第一个参数传递进入 <code>wrapper</code> 之中, 从而在 <code>wrapper</code> 中在不同的事件，不同的代码，根据不同的条件执行 <code>function</code> 函数。</p>
<p>实例:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`hello my name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> sayHello = _.wrap(hello, <span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</span><br><span class="line">  func(<span class="string">'张宁宁'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">sayHello(); <span class="comment">// hello my name is 张宁宁</span></span><br></pre></td></tr></table></figure>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><p>使用 <code>_.partial</code> 函数实现的参数替换:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.wrap = <span class="function"><span class="keyword">function</span> (<span class="params">func, wrapper</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _.partial(wrapper, func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="negate"><a href="#negate" class="headerlink" title="negate"></a><code>negate</code></h4><p>返回 <code>negate</code> 的否定版本:</p>
<h5 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// predicate 迭代函数</span><br><span class="line">_.negate = function (predicate) &#123;</span><br><span class="line">  return funciton () &#123;</span><br><span class="line">    return !predicate.apply(this, arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="compose"><a href="#compose" class="headerlink" title="compose"></a><code>compose</code></h4><p><code>compose(*functions)</code></p>
<p><code>compose</code> 用于函数的组合, 将一个函数的返回值作为另外一个函数的参数。</p>
<h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sayHello(word) &#123;</span><br><span class="line">  console.log(`hello, my name UpperWorlds is $&#123;word&#125;`)</span><br><span class="line">&#125;</span><br><span class="line">function toUpper(word) &#123;</span><br><span class="line">  return word.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line">let composeFn = _.compose(sayHello, toUpper);</span><br><span class="line">composeFn(&apos;zhangningning&apos;); // hello my name UpperWorlds is ZHANGNINGNING;</span><br></pre></td></tr></table></figure>
<h5 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h5><p>自己写的部分代码:</p>
<p>哪个好？？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> fns = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  reurn <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">    fns.reduceRight(<span class="function">(<span class="params">preFn, nextFn</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> nextFn(preFn);</span><br><span class="line">    &#125;, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.compose = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> args = argumemts;</span><br><span class="line">  <span class="keyword">let</span> start = args.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = start;</span><br><span class="line">    <span class="comment">// 使用 call 以及 apply 进行参数传递</span></span><br><span class="line">    <span class="keyword">let</span> result = args[start].apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 使用 while 进行递减</span></span><br><span class="line">    <span class="keyword">while</span>(i--) result = args[i].call(<span class="keyword">this</span>, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title>underscore.js源码分析(十一)</title>
    <url>/2017/12/07/underscore-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E4%B8%80/</url>
    <content><![CDATA[<h3 id="underscore-js-源码分析-十一"><a href="#underscore-js-源码分析-十一" class="headerlink" title="underscore.js 源码分析(十一)"></a>underscore.js 源码分析(十一)</h3><p><code>throttle</code>  <code>debounce</code>  <code>once</code> <code>after</code> <code>before</code></p>
<h4 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a><code>throttle</code></h4><p>函数节流</p>
<p><code>_.throttle(function, wait, [options])</code></p>
<p>使用 <code>throttle</code> 函数用于节流操作, 目的是对于重复执行的函数，最多每隔 <code>wait</code> 毫秒调用一次这个函数。</p>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @description throttle 用于函数节流</span></span><br><span class="line"><span class="comment">* @param func 运行的函数</span></span><br><span class="line"><span class="comment">* @param wait 等待的毫秒数</span></span><br><span class="line"><span class="comment">* @param options</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// previous 这里的意思的记录下上次记录下上次的时间</span></span><br><span class="line">_.throttle = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context, args, result;</span><br><span class="line">    <span class="keyword">var</span> timeout = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 这里 previous 的作用</span></span><br><span class="line">      previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : _.now();</span><br><span class="line">      timeout = <span class="literal">null</span>;</span><br><span class="line">      result = func.apply(context, args);</span><br><span class="line">      <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> now = _.now();</span><br><span class="line">      <span class="comment">// 记录下被调用的时刻</span></span><br><span class="line">      <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">      <span class="comment">// 当 previous 等于 now 的时候 remaining = wait</span></span><br><span class="line">      <span class="comment">// 记录下等待的时间和 now - previous 的差值</span></span><br><span class="line">      <span class="comment">// 不会执行下面的 if else 函数</span></span><br><span class="line">      <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">      context = <span class="keyword">this</span>;</span><br><span class="line">      args = <span class="built_in">arguments</span>;</span><br><span class="line">      <span class="comment">// 如果 remaining &lt;= 0</span></span><br><span class="line">      <span class="comment">// 第一次函数执行的时候被调用，因为这个时候 now &gt;&gt; wait remaining &lt;= 0</span></span><br><span class="line">      <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">        <span class="comment">// 当超出等待时间之后调用的时候</span></span><br><span class="line">        <span class="comment">// 返回调用的结果，清除 timeout</span></span><br><span class="line">        <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">          clearTimeout(timeout);</span><br><span class="line">          timeout = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        previous = now;</span><br><span class="line">        <span class="comment">// 获取到 func 执行之后的结果</span></span><br><span class="line">        result = func.apply(context, args);</span><br><span class="line">        <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 如果 timeout 为 null</span></span><br><span class="line">        <span class="comment">// 开启一个新的队列等待</span></span><br><span class="line">        <span class="comment">// 如果 options.trailing === false, 表示禁用最后一次执行</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果没有超过等待时间</span></span><br><span class="line">        <span class="comment">// remaining 时间之后调用 later函数</span></span><br><span class="line">        <span class="comment">// 对于在一段时间内应用同一个函数的时候，只是改变的later 函数</span></span><br><span class="line">        timeout = setTimeout(later, remaining);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>首先，需要明白一点，函数式编程同样可以首先数据的共享。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getIndex() &#123;</span><br><span class="line">  let index = 0;</span><br><span class="line">  // return 返回的是一个函数</span><br><span class="line">  return function () &#123;</span><br><span class="line">    index++;</span><br><span class="line">    console.log(index);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let getIndexFn = getIndex();</span><br><span class="line">// 因为在个过程中，通过getIndex 返回的是一个函数</span><br><span class="line">// 在 getIndex 中的 index 并没有发生变化， 因为 getIdnex 只是调用了一次</span><br><span class="line">getIndexFn(); // 1</span><br><span class="line">getIndexFn(); // 2</span><br></pre></td></tr></table></figure>
<p>练习:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> context, args, result;</span><br><span class="line">  <span class="keyword">let</span> timeout = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> later = funciton () &#123;</span><br><span class="line">    previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : now();</span><br><span class="line">    timeout = <span class="literal">null</span>;</span><br><span class="line">    result = func.apply(context, args);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> funcion () &#123;</span><br><span class="line">    <span class="keyword">let</span> now = now();</span><br><span class="line">    <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">    <span class="keyword">let</span> remaining = wait - (now - previous);</span><br><span class="line">    context = <span class="keyword">this</span>;</span><br><span class="line">    args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="comment">// 如果第一次执行</span></span><br><span class="line">    <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">        cleatTimeout(timeout);</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      previous = now;</span><br><span class="line">      result = func.apply(context, args);</span><br><span class="line">      <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">      timeout = setTimeout(later, remaining);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a><code>debounce</code></h4><p><code>_.debounce(function, wait, [immediate])</code></p>
<p><code>debounce</code> 函数用于函数防抖: 函数防抖的意思是将延迟函数的执行(真正的执行)在函数最后一次调用的时刻的 <code>wait</code> 毫秒之后进行执行。</p>
<p>当函数重复调用的时候，函数执行只是发生在最后一次调用的 <code>wait</code> 毫秒之后进行执行。</p>
<p>自己写的:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义执行上下文, 参数， 结果</span></span><br><span class="line">  <span class="keyword">let</span> context, args, result;</span><br><span class="line">  <span class="keyword">let</span> timeout = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> previous <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> remainding = <span class="number">0</span>;</span><br><span class="line">  immediate = immediate || <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> later = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    result = func.apply(context, args);</span><br><span class="line">    timeout = <span class="literal">null</span>;</span><br><span class="line">    context = args = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = _.now();</span><br><span class="line">    remainding = now - previous;</span><br><span class="line">    context = <span class="keyword">this</span>;</span><br><span class="line">    args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="comment">// 保证使用 immediate 的时候立即执行函数</span></span><br><span class="line">    <span class="keyword">if</span> (immediate &amp;&amp; remainding &gt; wait) &#123;</span><br><span class="line">      previous = _.now();</span><br><span class="line">      result = func.apply(context, args);</span><br><span class="line">      timeout = <span class="literal">null</span>;</span><br><span class="line">      context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!immediate) &#123;</span><br><span class="line">      <span class="comment">// if timeout</span></span><br><span class="line">      <span class="comment">// clearTimeout 进行清除 timeout</span></span><br><span class="line">      <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      timeout = setTimeout(later, wait);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.debounce = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout, args, context, timestamp, result;</span><br><span class="line">  <span class="keyword">let</span> later = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> last = _.now() - timestamp;</span><br><span class="line">    <span class="keyword">if</span> (last &lt; wait &amp;&amp; last &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      timeout = setTimeout(later, wait - last);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timeout = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (!immediate) &#123;</span><br><span class="line">        result = func.apply(context, args);</span><br><span class="line">        <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    context = <span class="keyword">this</span>;</span><br><span class="line">    args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="comment">// 这里面继续调用的时候改变的只是这个</span></span><br><span class="line">    timestamp = _.now();</span><br><span class="line">    <span class="keyword">let</span> callNow = imemediate &amp;&amp; !timeout;</span><br><span class="line">    <span class="keyword">if</span> (!timeout) timeout = setTimeout(later, wait);</span><br><span class="line">    <span class="keyword">if</span> (callNow) &#123;</span><br><span class="line">      result = func.apply(context, args);</span><br><span class="line">      context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下流程图如下:</p>
<div id="flowchart-0" class="flow-chart"></div>

<p>关于 <code>later</code> 函数如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let later = function () &#123;</span><br><span class="line">  let last = now() - timestamp;</span><br><span class="line">  if (last &lt; wait &amp;&amp; last &gt;= 0) &#123;</span><br><span class="line">    timeout = setTimeout(later, last - wait);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    timeout = null;</span><br><span class="line">    if (!immediate) &#123;</span><br><span class="line">      result = func.apply(context, args);</span><br><span class="line">      if (!timeout) context = args = null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一部分实现的原理是:</p>
<p>假如使用 bounce 函数的程序被多次调用的时候，如果在函数被第一次调用之后的 <code>wait</code> 时间之内，函数被调用了第二次，程序会在函数调用第二次的时候记录下时间，这时候 <code>wait</code> 时间之后调用函数的时候，第一次调用的函数不会被触发，程序在 <code>later</code> 函数中继续延迟第二次调用函数距离上一次调用需要的时间，这样，最终，第二次函数也是和第一次函数调用的结果是相同点的，都是在延迟了<code>wait</code> 时间之后被调用。</p>
<h4 id="once"><a href="#once" class="headerlink" title="once"></a><code>once</code></h4><p>创建一个只能调用一次的函数。即使函数被调用一次，也只是返回第一次被调用的结果。</p>
<p>使用 <code>once</code> 是当 <code>before</code> 方法中 <code>count</code> 等于2的情况下进行执行的函数;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向 befor 函数中传递参数为 2</span></span><br><span class="line">_.once = _.partial(_.before, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h4 id="before"><a href="#before" class="headerlink" title="before"></a><code>before</code></h4><p><code>_.before(count, function)</code></p>
<p>创建一个函数，调用不超过 <code>count</code> 次, 当<code>count</code>已经被达到的时候，最后一次调用的结果被记住并被返回。</p>
<p>自己写的:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @description before 用于返回 调用不超过 count 次数的函数调用</span></span><br><span class="line"><span class="comment">* @param &#123;Numbet&#125; count 调用函数的次数</span></span><br><span class="line"><span class="comment">* @param &#123;function&#125; func 被调用的函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">before</span>(<span class="params">count, func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> memo;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; count) &#123;</span><br><span class="line">      memo = func.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码分析:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.before = <span class="function"><span class="keyword">function</span> (<span class="params">times, func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> memo;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// --times</span></span><br><span class="line">    <span class="keyword">if</span> (--times &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      memo = func.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 times &lt;= 1 将 func 重置为 null</span></span><br><span class="line">    <span class="keyword">if</span> (times &lt;= <span class="number">1</span>) func = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> memo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="after"><a href="#after" class="headerlink" title="after"></a><code>after</code></h4><p><code>_.after(count, function)</code></p>
<p>使用 <code>_.after</code> 的作用是创建一个函数，只有调用 <code>count</code> 次之后才能得到效果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @description after 用于表示 after 函数</span></span><br><span class="line"><span class="comment">* @param &#123;Number&#125; 需要的调用次数</span></span><br><span class="line"><span class="comment">* @param &#123;function&#125; func 规定调用次数之后的调用函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">after</span> (<span class="params">times, func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (--times &lt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> func.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: bounce;
init=>operation: 初始化context, args, timeout, timeStamp, result, 定义later函数
rt=>operation: 记录当前调用时间 timeStamp = _.now(), 
callNow = imemediate && !timeout
isTimeout=>condition: !timeout
iscallNow=>condition: callNow 为 true
setTimeout=>operation: setTimeout(later, wait);
cond=>condition: Yes or No?
replyFn=>operation: 执行函数,
result = func.apply(context, args);
context = args = null;
e=>end: return result
st->init->rt->isTimeout->e
isTimeout(yes, right)->setTimeout->iscallNow
isTimeout(no)->iscallNow
iscallNow(yes, right)->replyFn->e
iscallNow(no)->e
cond(no)->io
cond(yes)->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>
]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title>underscore.js源码分析(四)</title>
    <url>/2017/11/23/underscore-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%9B%9B/</url>
    <content><![CDATA[<h3 id="underscore-js-源码分析-四"><a href="#underscore-js-源码分析-四" class="headerlink" title="underscore.js 源码分析(四)"></a>underscore.js 源码分析(四)</h3><p><code>_.min</code> <code>_.sortBy</code> <code>_.groupBy</code> <code>_.indexBy</code> <code>_.countBy</code></p>
<h4 id="min"><a href="#min" class="headerlink" title="_.min"></a><code>_.min</code></h4><p><code>_.min(list, [iteratee], [context])</code></p>
<p>类似于使用 <code>_.max</code> 这个函数用于获取到 <code>list</code> 中的最小值, 其中 <code>iteratee</code> 是作为的筛选的依据。</p>
<p>源码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.min = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="literal">Infinity</span>, lastComputed = <span class="literal">Infinity</span>,</span><br><span class="line">        value, computed;</span><br><span class="line">    <span class="keyword">if</span> (iteratee == <span class="literal">null</span> &amp;&amp; obj != <span class="literal">null</span>) &#123;</span><br><span class="line">      obj = obj.length === +obj.length ? obj : _.values(obj);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = obj.length; i &lt; length; i++) &#123;</span><br><span class="line">        value = obj[i];</span><br><span class="line">        <span class="keyword">if</span> (value &lt; result) &#123;</span><br><span class="line">          <span class="comment">// 和使用 _.max 的没有什么不同，不同的是这里筛选的是最小值</span></span><br><span class="line">          result = value;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      iteratee = cb(iteratee, context);</span><br><span class="line">      _.each(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value, index, list</span>) </span>&#123;</span><br><span class="line">        computed = iteratee(value, index, list);</span><br><span class="line">        <span class="keyword">if</span> (computed &lt; lastComputed || computed === <span class="literal">Infinity</span> &amp;&amp; result === <span class="literal">Infinity</span>) &#123;</span><br><span class="line">          result = value;</span><br><span class="line">          lastComputed = computed;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="sortBy"><a href="#sortBy" class="headerlink" title="_.sortBy"></a><code>_.sortBy</code></h4><p><code>_.sortBy(list, iteratee, [context])</code></p>
<p>使用 <code>_.sortBy</code> 返回的是一个经过排序之后的数组。排序的依据是根据 <code>iteratee</code> 函数进行判断的。</p>
<p>返回的是进行排序之后的数组的副本，原来的数组并没有进行了改变。</p>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.sortBy = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) </span>&#123;</span><br><span class="line">    iteratee = cb(iteratee, context);</span><br><span class="line">    <span class="keyword">return</span> _.pluck(_.map(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value, index, list</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        value: value,</span><br><span class="line">        index: index,</span><br><span class="line">        criteria: iteratee(value, index, list)</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;).sort(<span class="function"><span class="keyword">function</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _.comparator(left.criteria, right.criteria) || left.index - right.index;</span><br><span class="line">    &#125;), <span class="string">'value'</span>);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>在 <code>_.sortBy</code> 函数中存在着多个的函数，下面一一进行分析。</p>
<p><code>_.pluck</code> 函数，这个函数用于获取到对象数组中包含有过相关属性的所有的对象。</p>
<p>看来是用 <code>_.map...</code> 这个方法返回的是一个对象数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _.pluck 函数用于</span></span><br><span class="line"><span class="keyword">return</span> _.pluck(_.map(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value, index, list</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// balabala</span></span><br><span class="line">&#125;), <span class="string">'value'</span>)</span><br></pre></td></tr></table></figure>
<p>在 <code>_.map...</code> 中执行了两步操作: 调用了使用的 <code>_.map</code> 方法以及接下来调用 <code>sort</code> 方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _.map 方法 obj 是一个对象数组</span></span><br><span class="line"><span class="comment">// 返回的是一个数组，数组中包含有对象</span></span><br><span class="line"><span class="comment">// value: 对象的值</span></span><br><span class="line"><span class="comment">// index: 对象的键</span></span><br><span class="line"><span class="comment">// criteria: 对象运行iteratee 之后返回的值</span></span><br><span class="line">_.map(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value, index, list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 对象中返回了三个值</span></span><br><span class="line">    <span class="comment">// &#123;value: '', index: '', criteria: ''&#125;</span></span><br><span class="line">    value: value,</span><br><span class="line">    index: index,</span><br><span class="line">    criteria: iteratee(value, index, list)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>对于使用 <code>_.map</code> 方法返回的一个新的数组对象之后， 对于这个新的对象数组执行  <code>sort</code> 方法。</p>
<p>关于数组的 <code>sort</code> 方法:</p>
<hr>
<p>关于使用数组的 <code>sort</code> 方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.sort(sortBy);</span><br><span class="line"><span class="comment">// sortBy 是一个用来进行排序依据的函数</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 sort() 方法的时候，如果不传递 <code>sortBy</code> 的时候，使用数组的 <code>sort</code> 方法默认的是按照字符编码的顺序进行排序</p>
</blockquote>
<p>例如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">23</span>];</span><br><span class="line"><span class="comment">// 在原来的数组上进行的改变，并没有生成一个新的数组</span></span><br><span class="line">a.sort() <span class="comment">// [1, 2, 23, 4]</span></span><br></pre></td></tr></table></figure>
<p><code>sortBy</code> 是用来进行排序的函数:</p>
<p><code>sortBy</code> 接收两个参数，用来对于这两个参数进行比较。</p>
<hr>
<p> 接下来执行的是 <code>sort</code> 函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.sort(<span class="function"><span class="keyword">function</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在使用 comparator 之后进行比较 left.index - right.index</span></span><br><span class="line">  <span class="comment">// 为什么呢？</span></span><br><span class="line">  <span class="keyword">return</span> _.comparator(left.criteria, right.criteria) || left.index - right.index;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这个函数的作用是对于上面返回的数组对象进行 <code>sort</code> 排序。 返回的是 <code>_.comparator(left.criteria, right.criteria)</code> 或者 <code>left.index - right.index</code>。</p>
<p>看来是用进行比较。</p>
<p>其中 <code>_.comparator</code> 的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入要进行比较的函数参数 a, b</span></span><br><span class="line">_.comparator = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果 a === b 返回 0</span></span><br><span class="line">    <span class="keyword">if</span> (a === b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 判断 a &gt;= a  b &gt;= b</span></span><br><span class="line">  <span class="comment">// 为什么呢？</span></span><br><span class="line">    <span class="keyword">var</span> isAComparable = a &gt;= a, isBComparable = b &gt;= b;</span><br><span class="line">  <span class="comment">// 如果其中一个为 true</span></span><br><span class="line">    <span class="keyword">if</span> (isAComparable || isBComparable) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isAComparable &amp;&amp; !isBComparable) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">if</span> (isBComparable &amp;&amp; !isAComparable) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? <span class="number">1</span> : (b &gt; a) ? <span class="number">-1</span> : <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="groupBy"><a href="#groupBy" class="headerlink" title="_.groupBy"></a><code>_.groupBy</code></h4><h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><p><code>_.groupBy(list, iteratee, [context])</code></p>
<p>将一个集合分为多个的集合，通过使用 <code>iteratee</code> 函数进行分组，如果 <code>iteratee</code> 是一个字符串而不是一个函数的时候，将这个 <code>iteratee</code> 作为元素的属性名来进行分组。</p>
<p>如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.groupBy([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>], <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;<span class="keyword">return</span> num % <span class="number">2</span>;&#125;) <span class="comment">// &#123; 0: [2, 4], 1: [1] &#125;</span></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"><span class="comment">// 对象的属性是函数中返回的值</span></span><br><span class="line"><span class="comment">// 相应属性的值是 list 数组中运行函数得到的相应属性的集合</span></span><br></pre></td></tr></table></figure>
<h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.groupBy = group(<span class="function"><span class="keyword">function</span>(<span class="params">result, value, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_.has(result, key)) result[key].push(value); <span class="keyword">else</span> result[key] = [value];</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>在上面的函数中，存在两个函数: <code>group</code> 以及 <code>_.has</code></p>
<p>关于使用 <span id="group"> <code>group</code> <span>函数:</span></span></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接收一个 behavior 作为参数</span></span><br><span class="line"><span class="keyword">var</span> group = <span class="function"><span class="keyword">function</span>(<span class="params">behavior</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个函数，这个函数就是返回的 _.groupBy</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 定义 result 是一个对象</span></span><br><span class="line">      <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line">      iteratee = cb(iteratee, context);</span><br><span class="line">      _.each(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value, index</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 对于使用 obj 进行遍历, 获取到 key</span></span><br><span class="line">        <span class="comment">// 将 list 中的 value, index 传入</span></span><br><span class="line">        <span class="keyword">var</span> key = iteratee(value, index, obj);</span><br><span class="line">        <span class="comment">// 执行 behavior 函数</span></span><br><span class="line">        behavior(result, value, key);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>在上面的函数中 <code>behavior</code> 函数是在 <code>_.groupBy</code> 中的函数是下面的这个:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_.has(result, key)) result[key].push(value); <span class="keyword">else</span> result[key] = [value];</span><br></pre></td></tr></table></figure>
<p>使用 <code>_.has</code> 方法用来判断对象 <code>result</code> 中是否含有属性 <code>key</code>:</p>
<p><code>_.has</code> 方法如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _.has = <span class="function"><span class="keyword">function</span> (<span class="params">obj, key</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当obj 不是null 并且 对象 Obj 中包含有属性 key 的时候 返回 true</span></span><br><span class="line">  <span class="keyword">return</span> obj !== <span class="literal">null</span> &amp;&amp; <span class="built_in">Object</span>.prototype.hasOwnProperty.call(obj, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>####　<code>_.indexBy</code></p>
<p><code>_.indexBy(list, iteratee, [context])</code></p>
<p>使用 <code>_.indexBy</code> 用来返回在列表中每一个元素键的 <code>iteratee</code> 函数。 返回一个每一项索引的对象。</p>
<blockquote>
<p>使用 <code>_.indexBy</code> 和使用 <code>_.groupBy</code> 的区别在于:</p>
<p>使用 <code>_.indexBy</code> 你需要知道键值对是唯一的，比如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> list = [&#123;<span class="attr">name</span>: <span class="string">'张宁宁'</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">'张宁宁'</span>, <span class="attr">age</span>: <span class="number">50</span>&#125;];</span><br><span class="line">&gt;_.indexBy(list, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="keyword">return</span> value.name &#125;);</span><br><span class="line">&gt;=&gt;</span><br><span class="line">&gt;&#123;张宁宁:&#123;<span class="attr">name</span>: <span class="string">"张宁宁"</span>, <span class="attr">age</span>: <span class="number">50</span>&#125;&#125;</span><br><span class="line">&gt;_.groupBy(list, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="keyword">return</span> value.name &#125;);</span><br><span class="line">&gt;=&gt;</span><br><span class="line">&gt;&#123;张宁宁:[&#123;<span class="attr">name</span>: <span class="string">'张宁宁'</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">'张宁宁'</span>, <span class="attr">age</span>: <span class="number">50</span>&#125;]&#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
</blockquote>
<h5 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [&#123;<span class="attr">name</span>: <span class="string">'张三'</span>, <span class="attr">age</span>: <span class="number">12</span>&#125;， &#123;<span class="attr">name</span>: <span class="string">'李四'</span>, <span class="attr">age</span>: <span class="number">13</span>&#125;];</span><br><span class="line">_.indexBy(list, <span class="string">'age'</span>);</span><br><span class="line">=&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">'12'</span>: &#123;<span class="attr">name</span>: <span class="string">'张三'</span>, <span class="attr">age</span>: <span class="number">12</span>&#125;,</span><br><span class="line">    <span class="string">'13'</span>: &#123;<span class="attr">name</span>: <span class="string">'李四'</span>, <span class="attr">age</span>: <span class="number">13</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="源码解析-1"><a href="#源码解析-1" class="headerlink" title="源码解析"></a>源码解析</h5><p>类似于使用 <code>_.groupBy</code> 的源码, 使用 <code>_.indexBy</code> 的源码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.indexBy = group(<span class="function"><span class="keyword">function</span>(<span class="params">result, value, key</span>) </span>&#123;</span><br><span class="line">    result[key] = value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="countBy"><a href="#countBy" class="headerlink" title="_.countBy"></a><code>_.countBy</code></h4><p><code>_.countBy(list, iteratee, [context])</code> </p>
<p>返回各组中对象的数量的计数。返回在该组中值的数目。</p>
<h5 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [&#123;<span class="attr">name</span>: <span class="string">'张宁宁'</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">'张宁宁'</span>, <span class="attr">age</span>: <span class="number">50</span>&#125;];</span><br><span class="line">_.countBy(list, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="keyword">return</span> value.age &#125;);</span><br><span class="line">=&gt;</span><br><span class="line">&#123; <span class="number">20</span>: <span class="number">1</span>, <span class="number">50</span>: <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>
<h5 id="源码如下"><a href="#源码如下" class="headerlink" title="源码如下"></a>源码如下</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _.countBy = group(<span class="function"><span class="keyword">function</span>(<span class="params">result, value, key</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果在 result 中存在 key result[key] ++ </span></span><br><span class="line">  <span class="comment">// 否则 将 result[key] = 1;</span></span><br><span class="line">  <span class="keyword">if</span> (_.has(result, key)) result[key] ++; <span class="keyword">else</span> result[key] = <span class="number">1</span>; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>其中 <a href="# group"><code>group</code></a> 函数；</p>
<h4 id="shuffle"><a href="#shuffle" class="headerlink" title="shuffle"></a><code>shuffle</code></h4><h5 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h5><p>用来返回一个随机乱序的副本。并没有改变 <code>list</code> 的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">_.shuffle(list)</span><br><span class="line">[<span class="number">2</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<h5 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h5><p>使用 <code>_.shuffle</code> 的源码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.shuffle = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取到数组的值或者对象的值</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">set</span> = obj &amp;&amp; obj.length === +obj.length ? obj : _.values(obj);</span><br><span class="line">  // var length = <span class="keyword">set</span>.length</span><br><span class="line">    var length = <span class="keyword">set</span>.length;</span><br><span class="line">  // shuffled 是一个数组</span><br><span class="line">    var shuffled = Array(length);</span><br><span class="line">    for (var index = 0, rand; index &lt; length; index++) &#123;</span><br><span class="line">      <span class="comment">// 通过使用 _.randow获得到rand 随机数</span></span><br><span class="line">      rand = _.random(<span class="number">0</span>, index);</span><br><span class="line">      <span class="keyword">if</span> (rand !== index) shuffled[index] = shuffled[rand];</span><br><span class="line">      <span class="comment">// 将 index 的值赋给这个随机数组</span></span><br><span class="line">      <span class="comment">// 将set[index] 传入到 shuffled 中</span></span><br><span class="line">      shuffled[rand] = <span class="keyword">set</span>[index];</span><br><span class="line">    &#125;</span><br><span class="line">  // 返回生成的随机数组</span><br><span class="line">    return shuffled;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于使用 <code>_.random</code> 的函数如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个函数的目的是用来生成</span></span><br><span class="line">_.random = <span class="function"><span class="keyword">function</span> (<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (max == <span class="literal">null</span>) &#123;</span><br><span class="line">    max = min;</span><br><span class="line">    min = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 加了一个 1 表示生成的数中可以包括 max</span></span><br><span class="line">  <span class="keyword">return</span> min + <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Math.floor</code> : 向下取整</p>
<p><code>Math.random</code>  用于生成 <code>0 - 1</code> 之间的随机数;</p>
<blockquote>
<p>注意:  使用的是生成 <code>min</code> 和 <code>max</code> 之间的值得时候: <code>min</code> : inclusive 包括 <code>max</code> : exclusive 不包括</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.random() * (max - min) + min</span><br><span class="line"><span class="comment">// 生成 位于 max 与 min 之间的数， 包括 min 但不包括 max</span></span><br></pre></td></tr></table></figure>
<p>在 <code>shuffle</code> 函数中，使用了一个分牌算法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>, rand; index &lt; length; index++) &#123;</span><br><span class="line">      <span class="comment">// 通过使用 _.randow获得到rand 随机数</span></span><br><span class="line">      rand = _.random(<span class="number">0</span>, index);</span><br><span class="line">      <span class="keyword">if</span> (rand !== index) shuffled[index] = shuffled[rand];</span><br><span class="line">      <span class="comment">// 将 index 的值赋给这个随机数组</span></span><br><span class="line">      <span class="comment">// 将set[index] 传入到 shuffled 中</span></span><br><span class="line">      shuffled[rand] = <span class="keyword">set</span>[index];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>使用 分牌算法的原理如下:</p>
<p>存在两个数组 a 和 b</p>
<p>现在想要将 a 中的元素随机生成到 b 中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a--&gt;b: index</span><br><span class="line">note left of a: a 中遍历</span><br><span class="line">b--&gt;b:根据 a 中的index b[index] = b[rand],\n取到自身的 b[rand] 值</span><br><span class="line">b--&gt;a: rand(随机生成的\n位于(0, index) 之间的数值)</span><br><span class="line">a--b: 将得到的 rand 随机数\n b[rand] = a[index],填补刚才 b取到的自身的 rand</span><br></pre></td></tr></table></figure>
<hr>
<p>如上图所示的算法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title>underscore.js源码分析(十四)</title>
    <url>/2017/12/12/underscore-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E5%9B%9B/</url>
    <content><![CDATA[<h3 id="underscore-js-源码分析-十四"><a href="#underscore-js-源码分析-十四" class="headerlink" title="underscore.js 源码分析(十四)"></a>underscore.js 源码分析(十四)</h3><p><code>extend</code> <code>extendOwn</code> <code>pick</code> <code>omit</code>  <code>default</code></p>
<h4 id="extend"><a href="#extend" class="headerlink" title="extend"></a><code>extend</code></h4><p><code>_.extend(destination, *sources)</code></p>
<p>将多个对象  <code>souces</code> 覆盖到 <code>destination</code> 上面，返回被覆盖掉的 <code>destination</code> 上面。</p>
<p>使用 <code>extend</code> 类似于使用 <code>Object.assign</code> 用来将多个对象进行合并。</p>
<p>自己写的代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">destination</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sources = <span class="built_in">Array</span>.prototyep.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> len = sources.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> currrentSource = sources[i];</span><br><span class="line">    <span class="keyword">let</span> key = _.keys(currentSource);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; keys.length; index++) &#123;</span><br><span class="line">      destination[keys[index]] = currentScource[keys[index]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码分析:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> createAssigner = <span class="function"><span class="keyword">function</span> (<span class="params">keysFunc, undefinedOnly</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length = <span class="built_in">arguments</span>.length;</span><br><span class="line">    <span class="comment">// 进行边界处理</span></span><br><span class="line">    <span class="comment">// 当传入一个参数的时候或者 obj === null 的时候, 返回 obj</span></span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">2</span> || obj === <span class="literal">null</span>) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">1</span>; index &lt; length; index++) &#123;</span><br><span class="line">      <span class="comment">// 需要对于额外传入的参数进行循环的时候使用 arguments[index] 进行获得</span></span><br><span class="line">      <span class="keyword">let</span> source = <span class="built_in">arguments</span>[index];</span><br><span class="line">           keys = keysFunc(source);</span><br><span class="line">           l = keys.length;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> key = keys[i];</span><br><span class="line">        <span class="comment">// 这里面使用了 undefinedOnly 如果 undefinedOnly 是 true 的时候</span></span><br><span class="line">        <span class="comment">// 接下来判断 obj[key] 是否为 undefined(void 0)</span></span><br><span class="line">        <span class="keyword">if</span> (!undefinedOnly || obj[key] === <span class="keyword">void</span> <span class="number">0</span>) obj[key] = source[key];</span><br><span class="line">      &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="extendOwn"><a href="#extendOwn" class="headerlink" title="extendOwn"></a><code>extendOwn</code></h4><p>使用  <code>extendOwn</code> 实现的效果类似于使用  <code>extends</code>, 实现的效果是只是复制自己的属性到目标对象。</p>
<p><code>_.extendOwn(destination, *source)</code></p>
<p>复制 <code>source</code> 属性的值到 <code>destination</code> 只是复制自身的属性。(不包括继承的属性)</p>
<p>这个函数与 <code>_.extend</code> 的不同之处在于不会将 <code>source</code> 对象中继承到的属性复制到 <code>destination</code> 之中。</p>
<p>使用 <code>extendOwn</code> 与 <code>extend</code> 的不同在于: 源码不同</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 _.allKeys 获得到包括自身和继承得到的属性</span></span><br><span class="line">_.extend = createAssigner(_.allKeys);</span><br><span class="line"><span class="comment">// 使用 extendOwn 获得到仅仅包括自身的属性</span></span><br><span class="line">_.extendOwn = _.assign = createAssigner(_.keys);</span><br></pre></td></tr></table></figure>
<h4 id="pick"><a href="#pick" class="headerlink" title="pick"></a><code>pick</code></h4><p><code>_.pick(object, *keys)</code>  </p>
<p>使用这个属性用于返回 <code>object</code> 副本, 过滤出  <code>keys(有效的键组成的数组)</code> 参数指定的属性值，或者接受一个判断函数，指定挑选哪一个 key</p>
<p>使用 <code>pick</code> 的源码如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.pick = <span class="function"><span class="keyword">function</span>(<span class="params">object, oiteratee, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = &#123;&#125;, obj = object, iteratee, keys;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">  <span class="comment">// 如果 oiteratee 是一个函数的话</span></span><br><span class="line">  <span class="keyword">if</span> (_.isFunction(oiteratee)) &#123;</span><br><span class="line">    <span class="comment">// 使用 _.allKeys 获得到 obj 中的所有键</span></span><br><span class="line">    keys = _.allKeys(obj);</span><br><span class="line">    iteratee = optiomizeCb(oiteratee, context);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 oiteratee 不是一个函数的时候</span></span><br><span class="line">    <span class="comment">// 表示这时候用于筛选出对象 object 中包含 keys 的内容</span></span><br><span class="line">    <span class="comment">// 效果是相同于 Array.prototype.slice.call(arguments, 1); 相识</span></span><br><span class="line">    keys = flatten(<span class="built_in">arguments</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 返回在 obj 中的 key</span></span><br><span class="line">    iteratee = <span class="function"><span class="keyword">function</span>(<span class="params">value, key, obj</span>) </span>&#123; <span class="keyword">return</span> key <span class="keyword">in</span> obj; &#125;;</span><br><span class="line">    obj = <span class="built_in">Object</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; length = keys.length; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = keys[i];</span><br><span class="line">    <span class="keyword">let</span> value = obj[key];</span><br><span class="line">    <span class="comment">// 这里通过使用不同的函数来实现对于不同情况下的处理条件</span></span><br><span class="line">    <span class="comment">// 通过改变 iteratee 函数的不同来实现不同的处理流程</span></span><br><span class="line">    <span class="comment">// if (iteratee(value, key, obj))</span></span><br><span class="line">    <span class="keyword">if</span> (iteratee(value, key, obj)) result[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面中有一个 <code>flatten</code> 函数, 使用 <code>flatten</code> 函数的目的是将多层嵌套的数组转化为一维数组。</p>
<p><code>flatten</code>源码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let flatten = function(input, shallow, strict, startIndex) &#123;</span><br><span class="line">  let output = [], idx = 0;</span><br><span class="line">  for (let i = startIndex || 0, length = getLength(input); i &lt; length; i++) &#123;</span><br><span class="line">    let value = input[i];</span><br><span class="line">    if (isArrayLike(value) &amp;&amp; (_.isArray(value) || _.isArguments(value))) &#123;</span><br><span class="line">      if (!shallow) value = flatten(value, shallow, strict);</span><br><span class="line">      let j = 0; len = value.length;</span><br><span class="line">      output.length += len;</span><br><span class="line">      while (j &lt; len) &#123;</span><br><span class="line">        output[idex++] = value[j++];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (!strict) &#123;</span><br><span class="line">      output[idx++] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自己写的函数: <code>pick</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">obj, oiteratee</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 边界处理 如果 obj === null 或者 typeof obj !== 'object'</span></span><br><span class="line">  <span class="comment">// 返回一个空对象</span></span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> output = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">  <span class="keyword">let</span> len = keys.length;</span><br><span class="line">  <span class="keyword">let</span> iteratee;</span><br><span class="line">  <span class="keyword">let</span> choiceKeys = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> oiteratee === <span class="string">'function'</span>) &#123;</span><br><span class="line">    iteratee = oiteratee;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    iteratee = <span class="function"><span class="keyword">function</span> (<span class="params">value, key</span>) </span>&#123; retutn choiceKeys.includes(key); &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = keys[i];</span><br><span class="line">    <span class="keyword">if</span> (iteratee(obj[key], key)) output[key] = obj[key];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="omit"><a href="#omit" class="headerlink" title="omit"></a><code>omit</code></h4><p><code>omit(object, *keys)</code></p>
<p>使用 <code>omit</code> 函数的目的是与使用 <code>pick</code> 函数相反，返回一个 <code>object</code> 副本，过滤出除去  <code>keys</code> 中的属性值，或者接收一个判断函数，指定忽略哪一个 <code>key</code> 值。</p>
<p><code>omit</code> 源码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.omit = <span class="function"><span class="keyword">function</span> (<span class="params">obj, iteratee, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (_.isFunction(iteratee))　&#123;</span><br><span class="line">    iteratee = _.negate(iteratee);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> keys = _.map(flatten(<span class="built_in">arguments</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">1</span>), <span class="built_in">String</span>);</span><br><span class="line">    iteratee = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> !_.contains(keys, key)</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _.pick(obj, iteratee, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="default"><a href="#default" class="headerlink" title="default"></a><code>default</code></h4><p><code>_.defaults(object, *defaults)</code></p>
<p>使用 <code>default</code> 的目的是使用 <code>default</code> 对象填充 <code>object</code> 中的 <code>undefined</code> 属性，并且返回这个 <code>object</code>。</p>
<p>当 <code>object</code> 中存在 <code>default</code> 中的属性被填充的时候，使用 <code>defaults</code> 方法不会起作用。</p>
<p>使用 <code>_.defaults</code> 方法的时候源码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 createAssigner(keysFunc, undefinedOnly);</span></span><br><span class="line"><span class="comment">// 传递两个参数： keysFunc 表示对于键的处理函数</span></span><br><span class="line"><span class="comment">// undefinedOnly 表示是否只是复制目标对象中值为 undefined 的属性</span></span><br><span class="line">_.default = createAssigner(_.allKeys, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>在 <code>createAssigner</code> 的函数中使用 <code>_.default</code> 方法主要是使用下面的这句函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 当 undefinedOnly 为 true 的时候, 接下来进行判断 obj[key] === void 0 对象的属性是否为 undefined</span><br><span class="line">if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title>vertical-align &amp;&amp; line-height</title>
    <url>/2018/03/26/vertical-align/</url>
    <content><![CDATA[<h3 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a>vertical-align</h3><p>关于 <code>vertical-align</code> 的字面意思是垂直居中的意思， 其中 <code>vertical-align</code> 有下面几种支持的属性：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>baseline</code>(初始值)</td>
<td>一个元素的基线和父元素的基线对齐</td>
</tr>
<tr>
<td><code>sub</code></td>
<td>将元素作为一个下标，该元素的基线会相当于父元素的基线降低</td>
</tr>
<tr>
<td><code>super</code></td>
<td>将元素作为一个上标， 该元素的基线会相当于父元素的基线升高</td>
</tr>
<tr>
<td><code>top</code></td>
<td>把对齐的子元素的顶端与父元素顶端对齐。</td>
</tr>
<tr>
<td><code>text-top</code></td>
<td>类似于使用 <code>text-bottom</code> ， 将元素行内文本的顶端与父元素的顶端对齐</td>
</tr>
<tr>
<td><code>middle</code></td>
<td>居中对齐，常用于图像的垂直居中</td>
</tr>
<tr>
<td><code>bottom</code></td>
<td>将元素行内框的低端与父元素的低端对齐</td>
</tr>
<tr>
<td><code>text-bottom</code></td>
<td>行内文本的底端与行框的低端对齐</td>
</tr>
<tr>
<td><code>百分数</code></td>
<td>将元素的基线相对于父元素的基线升高或者降低指定的量， 这里的百分数是指相对于该元素的 <code>line-height</code> 的百分数。</td>
</tr>
<tr>
<td><code>length</code></td>
<td>使用 <code>length</code> 用于将元素升高或者降低指定的距离</td>
</tr>
<tr>
<td><code>inherit</code></td>
<td>从父元素下继承属性</td>
</tr>
</tbody>
</table>
<p><em>注意：这里的 <code>vertical-align</code> 影响的是行内元素， 行内块元素，以及表单元格的对齐，对于 块状元素不受 <code>vertical-align</code> 的影响。</em></p>
<p><code>vertical-align</code> 作用效果在图像垂直居中的时候的作用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"img"</span> <span class="attr">alt</span>=<span class="string">"这是一张图片"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们知道对于行内元素的垂直居中我们可以使用 <code>line-height = height</code> 的方法实现垂直居中的效果， 但是对于图像而言使用这种方法是失效的，例如下面的代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.img</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/vertical-align.png" alt></p>
<p>如上图所示， 使用 <code>line-height = height</code> 并不能实现对于图片的垂直居中效果，为了实现图片的垂直居中， 在 <code>img</code> 元素上添加 <code>vertical-align:middle</code> 效果， 最终效果如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.img</span> &#123;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​                                                <img src="http://ov3b9jngp.bkt.clouddn.com/vertical-align2.png" alt>  </p>
<p>注意： 这里的 <code>vertical-align</code> 主要参照的是父元素的行高， 因此在设置 <code>vertical-align: middle</code> 的时候，需要将父元素的 <code>line-height</code> 设置为 父元素的 <code>height</code> 高度。</p>
<h4 id="vertical-align-middle"><a href="#vertical-align-middle" class="headerlink" title="vertical-align:middle"></a><code>vertical-align:middle</code></h4><p><code>vertical-align: middle</code> 经常用于图像的居中， 我们要注意的一点就是，当元素设置 <code>vertical-align: middle</code> 的时候，这个属性会将行内元素框的中点与父元素的基线上方 <em>0.5ex</em> 处的一个点进行对齐， 这里的 <em>1ex</em> 是相对于父元素的 <code>font-size</code> 进行定义的，例如下面这个例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"allDemo"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"demo1"</span>&gt;</span>我是一段文字<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"demo2"</span>&gt;</span>我是第二段文字<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><em>对于 demo1 进行 <code>vertical-align: middle</code></em>: </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.allDemo</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: inline-block;</span><br><span class="line">	<span class="attribute">background-color</span>: lightslategray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.demo2</span> &#123;</span><br><span class="line">	<span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">	<span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.demo1</span>&#123;</span><br><span class="line">	<span class="attribute">background-color</span>: lightcoral;</span><br><span class="line">	<span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/25844786/38161994-9af821b2-350b-11e8-898a-6074bbff3262.png" alt></p>
<p>如上图所示， <code>class = &quot;demo2&quot;</code> 这段文字， <code>vertical-align</code> 默认是 <code>baseline</code>,其元素框底端是与行框的基线对齐的，<code>demo1</code> 相比于 <code>demo2</code> 元素而言， 元素下移， 这是 <code>vertical-align: middle</code> 之后的结果， 图示如下:</p>
<p><img src="https://user-images.githubusercontent.com/25844786/38162080-78c48b88-350d-11e8-8d9c-378a8fc11606.png" alt></p>
<p>如果我们将父元素的 <code>font-size</code> 置为0， 我们将会看到下面的情况：</p>
<p>代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.allDemo</span> &#123; <span class="attribute">font-size</span>: <span class="number">0px</span> &#125;;</span><br><span class="line"><span class="selector-class">.demo1</span> &#123; <span class="attribute">font-size</span>: <span class="number">16px</span> &#125;;</span><br><span class="line"><span class="selector-class">.demo2</span> &#123; <span class="attribute">font-size</span>: <span class="number">16px</span> &#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/25844786/38162298-3cec1974-3511-11e8-8b4f-54709a46b049.png" alt></p>
<p><code>vertical-align</code> 各属性作用位置如下：</p>
<p><img src="https://user-images.githubusercontent.com/25844786/38162270-cd4fcf8e-3510-11e8-9926-5cc120923396.png" alt></p>
<h3 id="line-height"><a href="#line-height" class="headerlink" title="line-height"></a>line-height</h3><h3 id="line-height-与-line-box-之间的关系"><a href="#line-height-与-line-box-之间的关系" class="headerlink" title="line-height 与 line box 之间的关系"></a><code>line-height</code> 与 <code>line box</code> 之间的关系</h3><p><code>line-height</code> 从字面意义上来讲， 是 <code>行高</code> 的意思，在页面上表现出来的就是一行文字的高度， 在介绍 <code>line-height</code> 之前，我们先来认识一下 <code>line boxes</code> 和 <code>inline boxes</code> 这两个东西。</p>
<h4 id="line-boxes-与-inline-boxes"><a href="#line-boxes-与-inline-boxes" class="headerlink" title="line boxes  与 inline boxes"></a><code>line boxes</code>  与 <code>inline boxes</code></h4><p><code>inline boxes</code> : 可以认为是包裹在 <code>inline</code> 元素外面的的一层外层， 例如 <code>span</code> 元素， <code>img</code> 图片元素等 <code>inline</code> 形式的元素，对于 <code>inline</code> 水平的元素，都会形成一层的 <code>inline boxes</code> 进行包裹。<br><code>line boxex</code> : 对于 <code>line boxes</code> 你可以认为 <code>line boxes</code> 用于包裹一行元素， 也就是说，对于一行 <code>inline</code> 水平的元素而言， 在外面有一个 <code>line boxes</code> 进行包裹， 如果一行有多个 <code>inline</code> 水平的元素，那么，这一行的 <code>line boxes</code> 就会包含有多个的 <code>inline boxex</code>。<br><strong>对于 <code>line boxes</code> 的元素的高度， 他的高度是获取该 <code>box</code> 下面的所有的 <code>inline boxes</code> 元素的高度 ， 比较获取他们中最大的高度， 最后这个最大的高度被认为是 <code>line boxes</code> 的最大高度</strong>。</p>
<p><strong>这里 <code>inline boxes</code> 的高度是什么呢？ 就是今天我们要说的 <code>line-height</code></strong>.<br>行高具体来讲就是两行文字之间基线之间的距离：<br>如下图所示：<br><img src="https://user-images.githubusercontent.com/25844786/38088466-835a2b96-338e-11e8-82be-ac0a4a367222.png" alt="image"><br>上面的图中红线就是表示所谓的基线， 关于我们另外一个css 的属性 <code>vertical-align</code> 改变的就是基线的高低大小。 </p>
<h4 id="使用-line-height-实现的垂直居中实现"><a href="#使用-line-height-实现的垂直居中实现" class="headerlink" title="使用 line-height 实现的垂直居中实现"></a>使用 <code>line-height</code> 实现的垂直居中实现</h4><p>我们经常使用 <code>line-height = height</code> 实现行内元素的垂直居中效果， 这里的 <code>height</code> ， 更为确切的说是  我们将要居中 <code>line boxes</code> 的高度进行居中， 因为对于行高而言具有一个垂直居中的性质。</p>
<h4 id="使用-line-height-height-在图片中垂直居中效果的失效。"><a href="#使用-line-height-height-在图片中垂直居中效果的失效。" class="headerlink" title="使用 line-height = height 在图片中垂直居中效果的失效。"></a>使用 <code>line-height = height</code> 在图片中垂直居中效果的失效。</h4><p>html:<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./picture.png"</span> <span class="attr">alt</span>=<span class="string">"垂直居中的图片"</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>CSS:<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.demo</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.img</span> &#123;	</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终结果如下：</p>
<p><img src="https://user-images.githubusercontent.com/25844786/38089336-b99abea2-3391-11e8-81ee-5ffa5c6b736e.png" alt="image"></p>
<p>并没有居中！</p>
<p>对于图片元素而言， 使用 <code>line-height = height</code> 并不能实现元素的垂直居中，要想实现这种效果， 就需要 <code>vertcial-align: middle</code> 出马了。</p>
<p>但是使用 <code>vertical-align:middle</code> 就能保证万无一失了吗？</p>
<h3 id="font-size-0px-在图片居中时的应用"><a href="#font-size-0px-在图片居中时的应用" class="headerlink" title="font-size: 0px 在图片居中时的应用"></a><code>font-size: 0px</code> 在图片居中时的应用</h3><p>在讲解 <code>vertical-align:middle</code> 的时候， 我们使用 <code>vertical-align: middle</code> 实现了图片的垂直居中， 但是这个垂直居中只是近似的， 并不是真正的垂直居中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"imgWrap"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img.png"</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.imgWrap</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.img</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/25844786/38165453-22d6400c-3546-11e8-9eb6-460cac7be56b.png" alt></p>
<p>我们看到，这个时候使用 <code>vertical-align:middle</code> 并没有实现真正的垂直居中， 原因是什么呢？</p>
<p>因为就如同我们刚才说的那样：</p>
<blockquote>
<p>当元素设置 <code>vertical-align: middle</code> 的时候，这个属性会将行内元素框的中点与父元素的基线上方 <em>0.5ex</em> 处的一个点进行对齐</p>
</blockquote>
<p>我们想要的结果是将行内元素框的中点和父元素的中点进行对齐，而使用 <code>vertical-align</code> 的时候并不是这样， 为了解决这个问题， 我们使用了<code>font-size: 0</code>这个属性。</p>
<p>代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.imgWrap</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>居中成功！</p>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/vertical-alignFontSize.png" alt="mark"></p>
<p><code>font-size: 0px</code> 起的作用是：</p>
<ol>
<li>基线和中线之间的距离是根据字母  <code>x</code> 的高度进行计算的， 通过设置 <code>font-size</code> 为0， 使得 基线和中线在同一水平线上，从而使得图片元素框的中线和父元素的中线重合， 实现垂直对齐效果。</li>
<li>使用 <code>vertical-align:middle</code> 对齐的不是父元素的基线， 而是基线上面  <code>0.5ex</code> 这样一个高度的点， 但是这个高度是由父元素的 <code>font-size</code> 来决定的， 这样就将这个高度置为 0 ， 从而使得图片中线和父元素基线对齐。   </li>
</ol>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://www.zhangxinxu.com/wordpress/2009/11/css%E8%A1%8C%E9%AB%98line-height%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">张鑫旭：css行高line-height的一些深入理解及应用</a> </p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>vertical-align &amp;&amp; line-height</tag>
      </tags>
  </entry>
  <entry>
    <title>vue源码：utils 函数</title>
    <url>/2019/04/05/vue%20%E6%BA%90%E7%A0%81%EF%BC%9Autils%20%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h4 id="utils-函数"><a href="#utils-函数" class="headerlink" title="utils 函数"></a>utils 函数</h4><hr>
<p>在 vue 的 utils.js  文件中提供了一些使用的公共方法， 下面是在阅读这部分代码的时候的一些笔记：</p>
<h5 id="判断值的类型"><a href="#判断值的类型" class="headerlink" title="判断值的类型"></a>判断值的类型</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 Object.toString 得到的是 [object type]</span></span><br><span class="line"><span class="comment">// 可以获取到 type 值来获取到要进行判断的类型</span></span><br><span class="line"><span class="keyword">const</span> _toString = <span class="built_in">Object</span>.prototype.toString</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toRowType</span> = <span class="title">value</span> =&gt; <span class="title">_toString</span>.<span class="title">call</span>(<span class="params">value</span>).<span class="title">slice</span>(<span class="params"><span class="number">8</span>, <span class="number">-1</span></span>)</span></span><br></pre></td></tr></table></figure>
<p>如下： 判断值为纯对象：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">function isPlainObject = obj =&gt; toRowType(obj) === '[object Object]';</span><br></pre></td></tr></table></figure>
<p>判断为正则</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">function isRegExp = val =&gt; toRowType(val) === '[object RegExp]';</span><br></pre></td></tr></table></figure>
<h5 id="判断一个值为-promise"><a href="#判断一个值为-promise" class="headerlink" title="判断一个值为 promise"></a>判断一个值为 <code>promise</code></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPromise</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val !== undefind &amp;&amp; </span><br><span class="line">  			 val !== <span class="literal">null</span> &amp;&amp; </span><br><span class="line">  			 <span class="keyword">typeof</span> val.then === <span class="string">'function'</span> &amp;&amp; </span><br><span class="line">  			 <span class="keyword">typeof</span> val.catch === <span class="string">'function'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用 <code>instanceof</code> 方法进行判断：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPromise</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val <span class="keyword">instanceof</span> <span class="built_in">Promise</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的那种方法更多的是为了一些浏览器不能兼容 promise 的原因</p>
<h5 id="通过函数的方法判断字符串中是否含有字符串"><a href="#通过函数的方法判断字符串中是否含有字符串" class="headerlink" title="通过函数的方法判断字符串中是否含有字符串"></a>通过函数的方法判断字符串中是否含有字符串</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeMap</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用 Object.create 用来创建一个 “干净”的对象</span></span><br><span class="line">  <span class="keyword">const</span> map = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> list = str.split(<span class="string">','</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i ++) &#123;</span><br><span class="line">    map[list[i]] = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">val</span> =&gt;</span> map[val];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 vue 中，使用上面的方法用来判断一串使用逗号分割的字符串中是否包含有某个字符串：</p>
<p>目前， 使用 es6 的 <code>includes</code> 可以实现这种效果。</p>
<p>上面的 <code>Object.create</code> 方法， 可以创建自继承自传入值的对象， 例如上面的 <code>Object.create(null)</code> 代码就是创建了一个空对象， 与 <code>{}</code> 对象不同的是， 通过 <code>create</code> 创建的空对象， 没有继承 <code>Object.prototype</code> 上面的方法。</p>
<p>例如：</p>
<img src="/2019/04/05/vue%20源码：utils%20函数/code.png">
<p>在上面中 使用 <code>create</code> 创建的空对象， 原型上面没有任何的属性</p>
<p>使用 <code>Object.create</code> 创建空对象的好处如下：</p>
<ul>
<li>创建的对象比较“干净”,  我们可以实现自定义的比如 <code>toString</code> 方法</li>
<li>使用 <code>for in</code> 的时候无需使用 <code>hasOwnProperty</code> 方法判断属性是不是继承的来的属性， 并且必用遍历继承的属性而提高了性能。</li>
</ul>
<h5 id="校验相等，-对于对象，-判断是否-“看起来”-一样："><a href="#校验相等，-对于对象，-判断是否-“看起来”-一样：" class="headerlink" title="校验相等， 对于对象， 判断是否 “看起来” 一样："></a>校验相等， 对于对象， 判断是否 “看起来” 一样：</h5><p>在代码中使用 <code>looseEqual</code>  这个函数， 如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check if two values are loosely equal - that is,</span></span><br><span class="line"><span class="comment"> * if they are plain objects, do they have the same shape?</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">looseEqual</span> (<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a === b) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  <span class="keyword">const</span> isObjectA = isObject(a)</span><br><span class="line">  <span class="keyword">const</span> isObjectB = isObject(b)</span><br><span class="line">  <span class="comment">// 当都为对象的时候</span></span><br><span class="line">  <span class="keyword">if</span> (isObjectA &amp;&amp; isObjectB) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> isArrayA = <span class="built_in">Array</span>.isArray(a)</span><br><span class="line">      <span class="keyword">const</span> isArrayB = <span class="built_in">Array</span>.isArray(b)</span><br><span class="line">      <span class="comment">// 当都为数组的时候</span></span><br><span class="line">      <span class="comment">// 这里判断数组相等， 可以先判断数组长度是否相等</span></span><br><span class="line">      <span class="keyword">if</span> (isArrayA &amp;&amp; isArrayB) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.length === b.length &amp;&amp; a.every(<span class="function">(<span class="params">e, i</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> looseEqual(e, b[i])</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 对于时间判断的时候， 通过 getTime() 来判断</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a <span class="keyword">instanceof</span> <span class="built_in">Date</span> &amp;&amp; b <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.getTime() === b.getTime()</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isArrayA &amp;&amp; !isArrayB) &#123;</span><br><span class="line">        <span class="keyword">const</span> keysA = <span class="built_in">Object</span>.keys(a)</span><br><span class="line">        <span class="keyword">const</span> keysB = <span class="built_in">Object</span>.keys(b)</span><br><span class="line">        <span class="comment">// 判断都为对象的时候</span></span><br><span class="line">        <span class="keyword">return</span> keysA.length === keysB.length &amp;&amp; keysA.every(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> looseEqual(a[key], b[key])</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isObjectA &amp;&amp; !isObjectB) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(a) === <span class="built_in">String</span>(b)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="once-函数方法"><a href="#once-函数方法" class="headerlink" title="once 函数方法"></a>once 函数方法</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 确保 fn 只会调用一次</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">once</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> called = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!called) &#123;</span><br><span class="line">      called = <span class="literal">true</span>;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="正则相关"><a href="#正则相关" class="headerlink" title="正则相关"></a>正则相关</h5><p>代码中， 使用正则中的 <code>replace</code> 方法实现了对于变量命名由驼峰式转变为为连字符式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hyhenate</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="regexp">/\B([A-Z])/g</span>, <span class="string">'-$1'</span>).toLowerCase()</span><br><span class="line">&#125;</span><br><span class="line">hyhenate(<span class="string">'myComponent'</span>); <span class="comment">// my-component</span></span><br></pre></td></tr></table></figure>
<p>相关 <code>replace</code> 的一些特性， 在博客文章  <a href="https://newpromise.github.io/2019/01/20/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%96%B9%E6%B3%95/">正则表达式（二）：基础方法</a> 中已经说明， 需要注意的一些地方：</p>
<ul>
<li>正则表达式中需要添加标识符 <code>g</code> 用来进行全局匹配捕获</li>
<li>正则中使用括号包裹的表示一个捕获组进行捕获到的数据</li>
<li>使用 <code>\B</code> 表示匹配单词内部</li>
</ul>
<p>使用正则将连字符单词转换为驼峰式的单词：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">camelize</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="regexp">/-(\w)/g</span>, (_, c) =&gt; c ? c.toUpperCase() : <span class="string">''</span>)</span><br><span class="line">&#125;</span><br><span class="line">camelize(<span class="string">'my-component'</span>); <span class="comment">// myComponent</span></span><br></pre></td></tr></table></figure>
<p>注意： 关于 <code>replace</code> 的第二个参数,  可以阅读  <a href="https://newpromise.github.io/2019/01/20/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%96%B9%E6%B3%95/">正则表达式（二）：基础方法</a>   中关于<a href="/2019/01/20/正则表达式（二）：基础方法/#replaceFn">replace</a>的相关知识。</p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>vue 源码</tag>
      </tags>
  </entry>
  <entry>
    <title>事件监听代码</title>
    <url>/2018/05/06/%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>简单的事件监听函数，从 <code>N3-components</code> 组件代码中发现的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> EventListener = &#123;</span><br><span class="line">    listen (listen, eventType, callback) &#123;</span><br><span class="line">        <span class="comment">// 如果存在 addEventListener</span></span><br><span class="line">        <span class="keyword">if</span> (target.addEventListener) &#123;</span><br><span class="line">            target.addEventListener(eventType, callback, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                remove () &#123;</span><br><span class="line">                    target.removeEventListener(eventType, callback, <span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 如果存在 attachEvent 事件</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target.attachEvent) &#123;</span><br><span class="line">		    target.attachEvent(<span class="string">'on'</span> + eventType);</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                remove () &#123;</span><br><span class="line">                    target.detachEvent(<span class="string">'on'</span> + eventType, callback);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>代码集</category>
      </categories>
      <tags>
        <tag>事件监听</tag>
      </tags>
  </entry>
  <entry>
    <title>vue 知识总结</title>
    <url>/2018/04/29/vue%20%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>在项目开发中，发现对于 <code>vue</code> 的使用还有一些新的认识，在这段时间中使用到的知识点做一个总结：</p>
<h3 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h3><p>在  <code>vue.js</code> 中，通过使用 <code>watch</code> 以及 <code>computed</code> 这两个方法来进行侦听数据的变化，但是这两种方式对于数据侦听的处理是不同的，应用的场景也是不同的， 之前应用的时候总是习惯性的时候用 <code>watch</code>, 但是在一些情况下，使用 <code>comnputed</code> 要更好一些，这里先简单的介绍这两种方法的使用， 具体可见 <code>vue.js</code> 官方文档：<a href="https://cn.vuejs.org/v2/guide/computed.html#%E4%BE%A6%E5%90%AC%E5%99%A8" target="_blank" rel="noopener">计算属性和侦听器</a> </p>
<p><code>watch</code>:</p>
<p><code>watch</code>侦听器相对于 <code>computed</code> 而言更为通用，使用 <code>watch</code> 用来监听数据的变化， 定义在数据变化之后的行为，基本使用用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听某一个数据</span></span><br><span class="line">watch: &#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// some action</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监听对象中的某一个属性</span></span><br><span class="line">watch: &#123;</span><br><span class="line">    <span class="string">"object.value"</span>： <span class="function"><span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// some action</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意： 使用 <code>watch</code> 不能监听到对象的变化， 如果想要对于对象进行监听， 可以使用 <code>deep: true</code>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  object: &#123;</span><br><span class="line">      handler: <span class="function"><span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// somn action</span></span><br><span class="line">      &#125;,</span><br><span class="line">      deep: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要回调在监听之后立即被调用， 可以设置 <code>immediate:true</code> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  object: &#123;</span><br><span class="line">    // 回调函数立即被调用不管监听对象有没有被调用</span><br><span class="line">    handler: function (newVal, oldVal) &#123;</span><br><span class="line">      // some action</span><br><span class="line">    &#125;,</span><br><span class="line">    deep: true,</span><br><span class="line">    immediate: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>computed</code>:</p>
<p>在有些地方， 我们使用 <code>computed</code> 要比单纯的监听数据的变化要方便很多， 比如下面这种情况：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    person: &#123;</span><br><span class="line">        name: <span class="string">""</span>,</span><br><span class="line">        age: <span class="string">""</span>,</span><br><span class="line">        sex: <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">    personMsg: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 这里可以监听到对象的变化</span></span><br><span class="line">        <span class="keyword">const</span> &#123; name, age, sex &#125; = <span class="keyword">this</span>.person;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span> is a <span class="subst">$&#123;age&#125;</span> <span class="subst">$&#123;sex&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面代码中的 <code>this.person</code> 中的数据发生变化的时候， <code>personMsg</code> 就会实时的发生变化：</p>
<p>对于 <code>computed</code> 的使用， 注意下面两点：</p>
<ol>
<li><p>对于上面代码中的计算属性： <code>personMsg</code> 的取值决定于 <code>this.person</code> 的值， 这里计算函数实际上拦截了计算属性的 <code>getter</code> 函数， 计算属性可以在模版中像其他 <code>data</code> 中的数据一样被使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; personMsg &#125;&#125;<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用函数调用可以实现类似于计算属性相同的作用：不同的是计算属性可以进行缓存数据，之后只有当计算属性的依赖选项发生变化的时候， 计算属性才会求值， 如果依赖项没有发生变化，那么计算属性就不会发生再次求职。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  personMsg () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.msg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue 知识总结（一）</tag>
      </tags>
  </entry>
  <entry>
    <title>while and do</title>
    <url>/2017/12/09/while-and-do/</url>
    <content><![CDATA[<h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><p>关于运算符的优先级，存在下面的优先级级别:</p>
<p>(因此当我们在表达式中出现下面这些情况的时候, 我们注意符号的优先级)</p>
<table>
<thead>
<tr>
<th style="text-align:center">. [ ] ( )</th>
<th style="text-align:center">提取属性与调用函数 （优先级  () &gt; .）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>delete</code>   <code>new</code>   <code>typeof</code>  <code>+</code> <code>-</code>  <code>!</code></td>
<td style="text-align:center">一元运算符</td>
</tr>
<tr>
<td style="text-align:center"><code>*</code>  <code>/</code>  <code>%</code></td>
<td style="text-align:center">乘法， 除法, 求余</td>
</tr>
<tr>
<td style="text-align:center"><code>+</code>  <code>-</code></td>
<td style="text-align:center">加法/ 连接  减法</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;=</code>  <code>&lt;=</code>   <code>&gt;</code>  <code>&lt;</code></td>
<td style="text-align:center">不等式运算符</td>
</tr>
<tr>
<td style="text-align:center"><code>===</code>   <code>!==</code></td>
<td style="text-align:center">等式运算符</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;&amp;</code></td>
<td style="text-align:center">逻辑与</td>
</tr>
<tr>
<td style="text-align:center">`</td>
<td style="text-align:center"></td>
<td>`</td>
<td>逻辑或</td>
</tr>
<tr>
<td style="text-align:center"><code>?:</code></td>
<td style="text-align:center">三元</td>
</tr>
</tbody>
</table>
<p>使用运算符优先级中注意:  <code>&amp;&amp;</code> &gt; <code>||</code></p>
<p>下面是一些使用运算符的一些例子:</p>
<ol>
<li><p>对于点号运算符以及加号运算符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">+<span class="string">"2.34567"</span>.toFixed(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 我们的本意是先想要将字符串 "2.34567" 转化为数字在利用 toFixed(2) 进行保留两位小数</span></span><br><span class="line"><span class="comment">// 但是返回错误 uncaught TypeError "2.34567".toFixed(2) is not a function</span></span><br></pre></td></tr></table></figure>
<p>上面是因为使用上面的表达式的时候 . 号的操作符优先级要高于 +  所以先计算的是字符串的 <code>toFixed()</code> 函数， 当然会出现错误，</p>
<p>解决办法， 添加 <code>()</code> 因为这时候括号的优先级要高于点号:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(+<span class="string">"2.34567"</span>).toFixed(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>逻辑与的操作符  <code>&amp;&amp;</code> 的操作符优先级要高于 <code>||</code> 的操作符优先级。</p>
<p>例如对于下面的这个程序而言:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span> || <span class="literal">false</span> &amp;&amp; <span class="literal">false</span></span><br><span class="line"><span class="comment">// 因为这里 &amp;&amp; 操作符的优先级要高于 || 因此这里会返回 true</span></span><br></pre></td></tr></table></figure>
<p>注意: 这里对于 <code>||</code> 以及 <code>&amp;&amp;</code> 操作符的理解要正确:</p>
<p>这两个操作符返回的都是值，而不是 <code>true</code> 或者 `false</p>
</li>
<li><p><code>[] == ![]</code></p>
<p>上面这个等式是一个很有意思的等式， 理解这个等式有助于我们加深对于于运算符优先级的理解， 并且在上面的这个公式中还有涉及到了隐式转换的一些知识点。</p>
<p>在上面这个过程中， 因为 <code>!</code> 的优先级要高于 <code>==</code>, 因此先执行 <code>!</code> 进行类型转换， 因为这里 <code>[]</code> 是真值，(只要不属于假值的都是真值，你别看我这里是一个空数组)</p>
<blockquote>
<p>通过使用布尔强制类型转换结果为 <code>false</code> 的被称作假值， 假值有下面几种：</p>
<p><code>undefined</code>, <code>null</code>, <code>false</code>, <code>+0, -0 和 NaN</code>, “ “</p>
<p>ps: 其他的类型不要进来 （<code>[], {}</code> : 你们看我干嘛？）</p>
</blockquote>
<p>首先执行下面的操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">![] ===&gt; <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>这个时候等号右边的值变成了 <code>false</code>,这个时候使用 <code>==</code> 会进行强制类型转换，将布尔值转换为数字</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">false</span>) ===&gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这个时候 <code>==</code> 两边分别是 <code>object</code> 以及 <code>number</code> 类型的值， 这个时候需要将 <code>obejct</code> 转为数字：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>([].valueOf()) ===&gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>因此， 上面的等式经过转换之后，变成了下面的这种：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> === <span class="number">0</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>whileordo</tag>
      </tags>
  </entry>
  <entry>
    <title>作用域 与 this 值</title>
    <url>/2017/11/12/%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<p>对于作用域而言，可以将作用域分为动态作用域和词法作用域。js 中的作用域属于词法作用域。</p>
<h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>对于使用词法作用域而言，词法作用域最重要的规则在于词法作用域的定义过程发生在代码的书写阶段。</p>
<p>代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(a) // 2</span><br><span class="line">&#125;</span><br><span class="line">function bar() &#123;</span><br><span class="line">  var a = 3;</span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br><span class="line">var a = 2;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>
<p>因为这里面的 <code>foo</code> 函数书写在全局的作用域中，因此会被输出 <code>2</code></p>
<h3 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h3><p>动态作用域关心的是函数是在哪里被调用的。</p>
<p>上面的函数中使用动态作用域的时候 最终输出应该是 <code>3</code>,因为从 <code>foo</code> 函数被调用的地方寻在变量 <code>a</code> 最后找到了 <code>var a = 3</code>.</p>
<p>词法作用域关心的是函数在那里被声明, 动态作用域关心的是函数在哪里被调用。</p>
<p>使用js 中的 <code>this</code> 的时候， <code>this</code> 的效果是类似于使用动态作用域的。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title>watch in vue.js</title>
    <url>/2019/05/13/watch%20in%20vue/</url>
    <content><![CDATA[<h3 id="watch-方法"><a href="#watch-方法" class="headerlink" title="watch 方法"></a>watch 方法</h3><p>vue 的 watch 方法用来监听 vue 中 data 的变动, 可以接受一个函数， 对象， 字符串， 或者数组。</p>
<p><code>watch</code> 方法接受两个参数： <code>deep</code>  &amp; <code>immediate</code>,  <code>immediate</code>  表明是否立即进行函数调用， <code>deep</code> 表示是否监听更深一级的对象；</p>
<p>例如在vue 组件中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">    	data: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">  	data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// some code... </span></span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="keyword">this</span>.data = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>当 <code>this.data</code> 发生重新赋值的时候， 就会调用 <code>watch</code>  中 <code>data</code> 后面跟的匿名函数：</p>
<p>在 <code>vue.js</code> 中， 调用流程如下：</p>
<p>首先， 因为在 vue <code>watch</code> 中的名称是先写在 <code>data</code> 中的，在初始化 <code>watch</code> 方法之前， 首先对于 <code>data</code> 中的数据进行了初始化，调用了 <code>defineReactive</code>  方法， 将其数据设为响应式的数据</p>
<ol>
<li><h5 id="初始化-watch-方法："><a href="#初始化-watch-方法：" class="headerlink" title="初始化 watch 方法："></a>初始化 <code>watch</code> 方法：</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化状态</span></span><br><span class="line"><span class="comment">// vm： vue 实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm</span>) </span>&#123;</span><br><span class="line">  vm._watchers = [];</span><br><span class="line">  <span class="keyword">var</span> opts = vm.$options;</span><br><span class="line">  <span class="keyword">if</span> (opts.props) &#123; initProps(vm, opts.props); &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.methods) &#123; initMethods(vm, opts.methods); &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.computed) &#123; initComputed(vm, opts.computed); &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    <span class="comment">// 初始化 watch</span></span><br><span class="line">    initWatch(vm, opts.watch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>initWatch</code> 为如下方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于 vue watch 方法中的每一个键都创建一个 watcher  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initWatch</span> (<span class="params">vm, watch</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> watch) &#123;</span><br><span class="line">      <span class="keyword">var</span> handler = watch[key];</span><br><span class="line">      <span class="comment">// 当watch 键后面跟着一个数组的时候， 对于数组里面的每一个函数， 都调用 createWatcher 方法</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(handler)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; handler.length; i++) &#123;</span><br><span class="line">          createWatcher(vm, key, handler[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createWatcher(vm, key, handler);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>createWatcher</code> 方法： 用于在 <code>watch</code> 中某个键的相关字段进行解析：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vm: vue 实例</span></span><br><span class="line"><span class="comment">// expOrFn: 创建 watcher 的一些数据名称</span></span><br><span class="line"><span class="comment">// hander 回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWatcher</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    vm,</span></span></span><br><span class="line"><span class="function"><span class="params">    expOrFn,</span></span></span><br><span class="line"><span class="function"><span class="params">    handler,</span></span></span><br><span class="line"><span class="function"><span class="params">    options</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当执行函数是一个对象的时候， 这个时候是将 handler 的 handler调用给执行函数</span></span><br><span class="line">    <span class="comment">// 这里的 options 是 watch 函数的配置信息</span></span><br><span class="line">    <span class="keyword">if</span> (isPlainObject(handler)) &#123;</span><br><span class="line">      options = handler;</span><br><span class="line">      handler = handler.handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当 handler 是一个字符串的时候， 会调用 vm 中相应的方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> handler === <span class="string">'string'</span>) &#123;</span><br><span class="line">      handler = vm[handler];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用在 vue 实例 vm 上面的 $watch 方法</span></span><br><span class="line">    <span class="keyword">return</span> vm.$watch(expOrFn, handler, options)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="调用-vue-实例上面的-watch-方法，-这个方法会对于当前的方法创建一个观察者-watcher"><a href="#调用-vue-实例上面的-watch-方法，-这个方法会对于当前的方法创建一个观察者-watcher" class="headerlink" title="调用 vue 实例上面的 $watch 方法， 这个方法会对于当前的方法创建一个观察者 watcher"></a>调用 vue 实例上面的 <code>$watch</code> 方法， 这个方法会对于当前的方法创建一个观察者 <code>watcher</code></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  Vue.prototype.$watch = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    expOrFn,</span></span></span><br><span class="line"><span class="function"><span class="params">    cb,</span></span></span><br><span class="line"><span class="function"><span class="params">    options</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (isPlainObject(cb)) &#123;</span><br><span class="line">      <span class="keyword">return</span> createWatcher(vm, expOrFn, cb, options)</span><br><span class="line">    &#125;</span><br><span class="line">    options = options || &#123;&#125;;</span><br><span class="line">    options.user = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 创建一个新的观察者</span></span><br><span class="line">    <span class="keyword">var</span> watcher = <span class="keyword">new</span> Watcher(vm, expOrFn, cb, options);</span><br><span class="line">    <span class="comment">// 当可选项中包含有 immediate 属性的时候</span></span><br><span class="line">    <span class="keyword">if</span> (options.immediate) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 立即执行当前 watch 函数</span></span><br><span class="line">        cb.call(vm, watcher.value);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        handleError(error, vm, (<span class="string">"callback for immediate watcher \""</span> + (watcher.expression) + <span class="string">"\""</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一个取消 watch 的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unwatchFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      watcher.teardown();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="当-调用-watch-方法的时候，-将当前-watch-内-data-的回调函数作为依赖进行收集。"><a href="#当-调用-watch-方法的时候，-将当前-watch-内-data-的回调函数作为依赖进行收集。" class="headerlink" title="当 调用 watch 方法的时候， 将当前 watch 内 data 的回调函数作为依赖进行收集。"></a>当 调用 watch 方法的时候， 将当前 <code>watch</code> 内 <code>data</code> 的回调函数作为依赖进行收集。</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Watcher = <span class="function"><span class="keyword">function</span> <span class="title">Watcher</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    vm,</span></span></span><br><span class="line"><span class="function"><span class="params">    expOrFn,</span></span></span><br><span class="line"><span class="function"><span class="params">    cb,</span></span></span><br><span class="line"><span class="function"><span class="params">    options,</span></span></span><br><span class="line"><span class="function"><span class="params">    isRenderWatcher</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.vm = vm;</span><br><span class="line">    <span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">      vm._watcher = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vm._watchers.push(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// options</span></span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">      <span class="keyword">this</span>.deep = !!options.deep;</span><br><span class="line">      <span class="keyword">this</span>.user = !!options.user;</span><br><span class="line">      <span class="keyword">this</span>.lazy = !!options.lazy;</span><br><span class="line">      <span class="keyword">this</span>.sync = !!options.sync;</span><br><span class="line">      <span class="keyword">this</span>.before = options.before;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.deep = <span class="keyword">this</span>.user = <span class="keyword">this</span>.lazy = <span class="keyword">this</span>.sync = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回调函数被绑定到 Watcher 观察者上面的 cb 属性上面</span></span><br><span class="line">    <span class="keyword">this</span>.cb = cb;</span><br><span class="line">    <span class="keyword">this</span>.id = ++uid$<span class="number">1</span>; <span class="comment">// uid for batching</span></span><br><span class="line">    <span class="keyword">this</span>.active = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="keyword">this</span>.lazy; <span class="comment">// for lazy watchers</span></span><br><span class="line">    <span class="keyword">this</span>.deps = [];</span><br><span class="line">    <span class="keyword">this</span>.newDeps = [];</span><br><span class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">new</span> _Set();</span><br><span class="line">    <span class="keyword">this</span>.newDepIds = <span class="keyword">new</span> _Set();</span><br><span class="line">    <span class="keyword">this</span>.expression = expOrFn.toString();</span><br><span class="line">    <span class="comment">// parse expression for getter</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.getter = expOrFn;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 这里对于监听的变量值进行解析</span></span><br><span class="line">      <span class="keyword">this</span>.getter = parsePath(expOrFn);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'this.getter'</span>, <span class="keyword">this</span>.getter);</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.getter) &#123;</span><br><span class="line">        <span class="keyword">this</span>.getter = noop;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">"Failed watching path: \""</span> + expOrFn + <span class="string">"\" "</span> +</span><br><span class="line">          <span class="string">'Watcher only accepts simple dot-delimited paths. '</span> +</span><br><span class="line">          <span class="string">'For full control, use a function instead.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy</span><br><span class="line">      ? <span class="literal">undefined</span></span><br><span class="line">      : <span class="keyword">this</span>.get();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Evaluate the getter, and re-collect dependencies.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Watcher.prototype.get = <span class="function"><span class="keyword">function</span> <span class="title">get</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将当前的 Watcher 赋值给 Dep.target</span></span><br><span class="line">    pushTarget(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">var</span> value;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="keyword">this</span>.vm;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 调用 getter 方法， 触发响应式数据的 get 属性， 进行依赖搜集</span></span><br><span class="line">      value = <span class="keyword">this</span>.getter.call(vm, vm);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'this.value'</span>, value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">        handleError(e, vm, (<span class="string">"getter for watcher \""</span> + (<span class="keyword">this</span>.expression) + <span class="string">"\""</span>));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// "touch" every property so they are all tracked as</span></span><br><span class="line">      <span class="comment">// dependencies for deep watching</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">        traverse(value);</span><br><span class="line">      &#125;</span><br><span class="line">      popTarget();</span><br><span class="line">      <span class="keyword">this</span>.cleanupDeps();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p><code>parsePath</code> 方法用于监听的字段进行解析：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bailRE = <span class="keyword">new</span> <span class="built_in">RegExp</span>((<span class="string">"[^"</span> + (unicodeRegExp.source) + <span class="string">".$_\\d]"</span>));</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parsePath</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bailRE.test(path)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 按照 . 号进行分割为数组， 适用于我们想要监听一个对象下面的某一个属性的时候</span></span><br><span class="line">  <span class="keyword">var</span> segments = path.split(<span class="string">'.'</span>);</span><br><span class="line">  <span class="comment">// 返回的函数作为 上面代码中的 this.getter</span></span><br><span class="line">  <span class="comment">// 当调用 this.getter 函数的时候， 会触发在当前数据上面的响应式数据的 get 方法， 搜集依赖</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; segments.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!obj) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">      obj = obj[segments[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当触发响应式数据的 <code>getter</code> 属性的时候，在 <code>defineReactive</code> 中, 会进行依赖收集</p>
<img src="/2019/05/13/watch%20in%20vue/image-20190514150916088.png">
<p>当调用<code>dep.depend()</code> 的时候， 调用了 <code>Dep</code> 类的<code>depend</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Dep.prototype.depend = <span class="function"><span class="keyword">function</span> <span class="title">depend</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">    Dep.target.addDep(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里的<code>Dep.target</code> 是我们之前将<code>watcher</code> 赋值的那一个， 当调用 <code>Watcher</code> 上面的 <code>addDep</code> 方法的时候， 是将当前的<code>dep</code> 传入  <code>watcher</code> 实例中的 <code>newDeps</code> 属性， 并且， 当前<code>dep</code> 实例上面的 <code>addSub</code> 方法将会将 <code>Watcher</code> 存放到 这个实例的 <code>subs</code> 属性上面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Watcher.prototype.addDep = <span class="function"><span class="keyword">function</span> <span class="title">addDep</span> (<span class="params">dep</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> id = dep.id;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.newDepIds.add(id);</span><br><span class="line">    <span class="keyword">this</span>.newDeps.push(dep);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</span><br><span class="line">      dep.addSub(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="当依赖收集完毕之后，-当监听的值发生变化的时候，通知依赖发生变化："><a href="#当依赖收集完毕之后，-当监听的值发生变化的时候，通知依赖发生变化：" class="headerlink" title="当依赖收集完毕之后， 当监听的值发生变化的时候，通知依赖发生变化："></a>当依赖收集完毕之后， 当监听的值发生变化的时候，通知依赖发生变化：</h5><p>当监听的数据发生变化的时候， 会调用这个数据的 <code>set</code> 属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line">  <span class="comment">//  获取到原来的值</span></span><br><span class="line">  <span class="keyword">var</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">  <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">  <span class="comment">// 当要监听的数据没有发生变化的时候， 返回</span></span><br><span class="line">  <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">  <span class="keyword">if</span> (customSetter) &#123;</span><br><span class="line">    customSetter();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">  <span class="keyword">if</span> (getter &amp;&amp; !setter) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">    setter.call(obj, newVal);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    val = newVal;</span><br><span class="line">  &#125;</span><br><span class="line">  childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">  <span class="comment">//  通知依赖发生变化</span></span><br><span class="line">  dep.notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dep.notify()</code> 是用来通知依赖发生变化的,  调用了 <code>dep</code> 实例上面的 <code>notify</code>  方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Dep.prototype.notify = <span class="function"><span class="keyword">function</span> <span class="title">notify</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">  <span class="keyword">var</span> subs = <span class="keyword">this</span>.subs.slice();</span><br><span class="line">  <span class="keyword">if</span> (!config.async) &#123;</span><br><span class="line">    <span class="comment">// subs aren't sorted in scheduler if not running async</span></span><br><span class="line">    <span class="comment">// we need to sort them now to make sure they fire in correct</span></span><br><span class="line">    <span class="comment">// order</span></span><br><span class="line">    subs.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a.id - b.id; &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// subs 中存放的是 watcher ， 调用了 watcher 实例的  update 方法。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">    subs[i].update();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Watcher.prototype.update = <span class="function"><span class="keyword">function</span> <span class="title">update</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">    <span class="keyword">this</span>.run();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 调用  queueWatcher </span></span><br><span class="line">    queueWatcher(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 <code>queueWatcher</code> 方法中， 将当前变动的所有 <code>watcher</code> 存放数组 <code>queue</code>  中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Push a watcher into the watcher queue.</span></span><br><span class="line"><span class="comment">  * Jobs with duplicate IDs will be skipped unless it's</span></span><br><span class="line"><span class="comment">  * pushed when the queue is being flushed.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span> (<span class="params">watcher</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> id = watcher.id;</span><br><span class="line">   <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">     has[id] = <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">       <span class="comment">// 将 watcher 存入</span></span><br><span class="line">       queue.push(watcher);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// if already flushing, splice the watcher based on its id</span></span><br><span class="line">       <span class="comment">// if already past its id, it will be run next immediately.</span></span><br><span class="line">       <span class="keyword">var</span> i = queue.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">         i--;</span><br><span class="line">       &#125;</span><br><span class="line">       queue.splice(i + <span class="number">1</span>, <span class="number">0</span>, watcher);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// queue the flush</span></span><br><span class="line">     <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">       waiting = <span class="literal">true</span>;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">if</span> (!config.async) &#123;</span><br><span class="line">         flushSchedulerQueue();</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">       &#125;</span><br><span class="line">       nextTick(flushSchedulerQueue);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="执行-watch-中数据变动之后的函数回调：调用。flushSchedulerQueue"><a href="#执行-watch-中数据变动之后的函数回调：调用。flushSchedulerQueue" class="headerlink" title="执行 watch 中数据变动之后的函数回调：调用。flushSchedulerQueue"></a>执行 <code>watch</code> 中数据变动之后的函数回调：调用。<code>flushSchedulerQueue</code></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushSchedulerQueue</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  currentFlushTimestamp = getNow();</span><br><span class="line">  flushing = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">var</span> watcher, id;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// Sort queue before flush.</span></span><br><span class="line">  <span class="comment">// This ensures that:</span></span><br><span class="line">  <span class="comment">// 1. Components are updated from parent to child. (because parent is always</span></span><br><span class="line">  <span class="comment">//    created before the child)</span></span><br><span class="line">  <span class="comment">// 2. A component's user watchers are run before its render watcher (because</span></span><br><span class="line">  <span class="comment">//    user watchers are created before the render watcher)</span></span><br><span class="line">  <span class="comment">// 3. If a component is destroyed during a parent component's watcher run,</span></span><br><span class="line">  <span class="comment">//    its watchers can be skipped.</span></span><br><span class="line">  queue.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a.id - b.id; &#125;);</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// do not cache length because more watchers might be pushed</span></span><br><span class="line">  <span class="comment">// as we run existing watchers</span></span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; queue.length; index++) &#123;</span><br><span class="line">    watcher = queue[index];</span><br><span class="line">    <span class="keyword">if</span> (watcher.before) &#123;</span><br><span class="line">      watcher.before();</span><br><span class="line">    &#125;</span><br><span class="line">    id = watcher.id;</span><br><span class="line">    has[id] = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 调用 watcher 实例上面的  run 方法</span></span><br><span class="line">    watcher.run();</span><br><span class="line">    <span class="comment">// in dev build, check and stop circular updates.</span></span><br><span class="line">    <span class="keyword">if</span> (has[id] != <span class="literal">null</span>) &#123;</span><br><span class="line">      circular[id] = (circular[id] || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (circular[id] &gt; MAX_UPDATE_COUNT) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'You may have an infinite update loop '</span> + (</span><br><span class="line">            watcher.user</span><br><span class="line">              ? (<span class="string">"in watcher with expression \""</span> + (watcher.expression) + <span class="string">"\""</span>)</span><br><span class="line">              : <span class="string">"in a component render function."</span></span><br><span class="line">          ),</span><br><span class="line">          watcher.vm</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>调用 <code>watcher.run</code>  方法之后， 如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Watcher.prototype.run = <span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">      <span class="keyword">var</span> value = <span class="keyword">this</span>.get();</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        value !== <span class="keyword">this</span>.value ||</span><br><span class="line">        <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">        <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">        <span class="comment">// have mutated.</span></span><br><span class="line">        isObject(value) ||</span><br><span class="line">        <span class="keyword">this</span>.deep</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// set new value</span></span><br><span class="line">        <span class="keyword">var</span> oldValue = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            handleError(e, <span class="keyword">this</span>.vm, (<span class="string">"callback for watcher \""</span> + (<span class="keyword">this</span>.expression) + <span class="string">"\""</span>));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 调用 watch 之后的函数方法， 传入的两个值， 当前变动的值和之前的值</span></span><br><span class="line">          <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>最终， 调用</p>
<p><code>this.cb.call(this.vm, value, oldValue);</code></p>
<p>执行当监听的数据发生变化时候的回调函数， 调用的时候传入两个参数： value &amp;&amp; oldValue, 表示当前的值和变化之前的值。</p>
</li>
</ol>
<p>补充： deep 方法是如何起作用的：</p>
<p>当我们设定 <code>deep</code> 为 true 的时候， 这个时候， 当对象中的某个属性发生变化的时候， 也会被监听到变动， 关于  <code>deep</code> 为 true 的代码在下面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Watcher.prototype.get = <span class="function"><span class="keyword">function</span> <span class="title">get</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   pushTarget(<span class="keyword">this</span>);</span><br><span class="line">   <span class="keyword">var</span> value;</span><br><span class="line">   <span class="keyword">var</span> vm = <span class="keyword">this</span>.vm;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// 调用 getter, 搜集依赖</span></span><br><span class="line">     value = <span class="keyword">this</span>.getter.call(vm, vm);</span><br><span class="line">     <span class="comment">// console.log('this.value', value);</span></span><br><span class="line">   &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">       handleError(e, vm, (<span class="string">"getter for watcher \""</span> + (<span class="keyword">this</span>.expression) + <span class="string">"\""</span>));</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">throw</span> e</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="comment">// "touch" every property so they are all tracked as</span></span><br><span class="line">     <span class="comment">// dependencies for deep watching</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">       traverse(value);</span><br><span class="line">     &#125;</span><br><span class="line">     popTarget();</span><br><span class="line">     <span class="keyword">this</span>.cleanupDeps();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> value</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>正如上面注释写明的一样， 当  <code>deep</code> 为 true 的时候， 调用 <code>traverse</code>   方法， 这个方法的作用是出发对象中每一个属性的  <code>get</code> 方法， 从而让他们的依赖得以收集：</p>
<p>traverse. 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归调用对象中的属性， 通过 val[i]  或者  val[key[i]] 触发 get 方法  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverse</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    _traverse(val, seenObjects);</span><br><span class="line">    seenObjects.clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_traverse</span> (<span class="params">val, seen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i, keys;</span><br><span class="line">    <span class="keyword">var</span> isA = <span class="built_in">Array</span>.isArray(val);</span><br><span class="line">    <span class="keyword">if</span> ((!isA &amp;&amp; !isObject(val)) || <span class="built_in">Object</span>.isFrozen(val) || val <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (val.__ob__) &#123;</span><br><span class="line">      <span class="keyword">var</span> depId = val.__ob__.dep.id;</span><br><span class="line">      <span class="keyword">if</span> (seen.has(depId)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      seen.add(depId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isA) &#123;</span><br><span class="line">      i = val.length;</span><br><span class="line">      <span class="keyword">while</span> (i--) &#123; _traverse(val[i], seen); &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      keys = <span class="built_in">Object</span>.keys(val);</span><br><span class="line">      i = keys.length;</span><br><span class="line">      <span class="comment">// val[key[i]] 这里是关键</span></span><br><span class="line">      <span class="keyword">while</span> (i--) &#123; _traverse(val[keys[i]], seen); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>vue 源码阅读</category>
      </categories>
      <tags>
        <tag>vue 源码</tag>
      </tags>
  </entry>
  <entry>
    <title>作用域：函数作用域和块作用域</title>
    <url>/2017/08/20/%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9A%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h3 id="作用域单元"><a href="#作用域单元" class="headerlink" title="作用域单元"></a>作用域单元</h3><p>作用域单元分为函数作用域和块作用域，使用作用域的目的是将变量单独定义在作用域内，防止变量污染，变量的声明应该距离是用地越近越好，并且最大限度的实现本地化。</p>
<h4 id="为什么要创建块作用域"><a href="#为什么要创建块作用域" class="headerlink" title="为什么要创建块作用域"></a>为什么要创建块作用域</h4><p>例如代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">  var bar = 2</span><br><span class="line">&#125;</span><br><span class="line">console.log(bar) // 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for (var i =0 ;i &lt; 10; i++) &#123;</span><br><span class="line">  console.log(i)</span><br><span class="line">&#125;</span><br><span class="line">console.log(i);</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，使用了 <code>var</code> 声明变量，当我们这个变量只在 if 或者 for 代码块中使用的时候，使用 var 声明变量容易造成变量污染，后续开发人员声明变量的时候还要避免声明同样的变量。</p>
<p>使用快作用域的作用是：在代码块中被声明的变量只在代码块中使用，不会污染到全局变量。这就需要我们创建块作用域。</p>
<h4 id="创建块作用域的几种方式"><a href="#创建块作用域的几种方式" class="headerlink" title="创建块作用域的几种方式"></a>创建块作用域的几种方式</h4><p>1.try catch 语句会在 catch 语句中创建一个块作用域</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    consolel.log(a);</span><br><span class="line">&#125;</span><br><span class="line">catch (err) &#123;</span><br><span class="line">    console.log(err.name); // 抛出错误的名字</span><br><span class="line">&#125;</span><br><span class="line">console.log(err.name) // err is not defined</span><br></pre></td></tr></table></figure>
<p>声明的catch 内变量只在 catch 语句内部被使用到</p>
<p>2.let 会为声明的变量隐式的创建块作用域</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">  let bar = 2</span><br><span class="line">&#125;</span><br><span class="line">console.log(bar)// bar is not defined</span><br></pre></td></tr></table></figure>
<p>通过使用 <code>let</code>  将声明的变量隐式的绑定到 if 语句上，在外部是不可访问到的。</p>
<p>也可以通过使用 <code>{ }</code> 来显式的为 <code>let</code> 声明一个用于绑定的块:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if () &#123;</span><br><span class="line">  let bar = 2;</span><br><span class="line">  &#123;</span><br><span class="line">    let foo = 3;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(foo); // foo is not defined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用  <code>let</code> 可以创建作用域，相对于使用 <code>var</code> 而言,<code>var</code> 会将变量定义到全局作用域中，使用 <code>let</code> 定义变量会被定义到隐式的块状作用域，因此，依赖变量的函数也要放到定义的块状作用域内。</p>
<p>3.使用 <code>const</code>也可以创建块状作用域，使用 <code>const</code> 创建的是常量，试图修改会导致错误:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">  const a = 2;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a) // a is not defined</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>使用 <code>var</code> 定义的变量会被定义到全局变量中，使用<code>let</code> 可以创建块状作用域，使用<code>let</code>定义的变量依赖的函数要和声明的变量放在同一个作用域；</p>
<p>使用 <code>{}</code> 可以声明显式的作用域；</p>
]]></content>
      <categories>
        <category>js读书总结</category>
      </categories>
      <tags>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程（一）</title>
    <url>/2019/09/14/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<p>函数式编程是一种编程范式， 与之相对应的是面向对象编程和指令式编程等。</p>
<p>函数式编程（FP）要更加偏向于声明式而不是命令式；</p>
<blockquote>
<p>声明式关注于程序做什么， 命令式关注于程序怎样做</p>
</blockquote>
<p>在FP 中， 有下面几个关键词：</p>
<ul>
<li>纯函数</li>
<li>函数组合</li>
<li>避免状态共享</li>
<li>避免状态的变化</li>
<li>避免副作用</li>
</ul>
<ol>
<li><p>纯函数</p>
<p>纯函数给定特定的输入值，将总会返回同样的输出值，且没有副作用， 纯函数具有引用透明性的特点，这使得我们更易追踪数据的变化， 减少问题的发生</p>
</li>
<li><p>函数组合</p>
<p>函数组合可以根据我们传入的多个函数返回多个函数组合的新函数，或者根据传入的多个函数进行计算</p>
</li>
<li><p>避免状态共享</p>
<p>状态共享的问题在于你需要了解某一个函数的功能时， 你需要知道函数中使用到的共享变量的调用历史记录， 另外， 使用共享的状态时， 调用函数的顺序不同会导致最终共享状态数据的不同</p>
</li>
<li><p>状态不变性</p>
<p>当函数中的数据被创建之后将不会被更改，如果创建的数据在被创建之后可以被调用的函数更改，那么将会导致程序中的数据流混乱</p>
</li>
<li><p>避免副作用</p>
<p>副作用指的是调用函数之后， 改变了函数之外的状态， 或者导致其他的可以被观测到的行为</p>
<p>比如以下副作用：</p>
<ul>
<li>改变外部对象或者变量属性</li>
<li>写文件</li>
<li>错发任何外部的程序</li>
<li>调用其他含有副作用的函数</li>
</ul>
<p>避免上面的副作用可以使得我们易于扩展， 重构， debug 代码</p>
</li>
</ol>
<p>函数式编程中的一些其他应用：</p>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数可以接受函数作为参数， 返回一种新的函数，高阶函数经常被用作：</p>
<ul>
<li>抽象或者隔离动作， 行为， 例如回调函数或者 promises</li>
<li>创造作用于范围广范的数据类型的工具方法</li>
<li>实现函数组合或者函数重用，通过将函数作为参数传递或者创建柯里化的函数</li>
<li>接口函数列表， 返回这些输入方法的组合</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>FP</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 browserify 处理virtual-dom模块的一个例子</title>
    <url>/2020/09/13/%E4%BD%BF%E7%94%A8%20browserify%20%E5%A4%84%E7%90%86virtual-dom%E6%A8%A1%E5%9D%97%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90/</url>
    <content><![CDATA[<p>使用 browserify 来实现程序在node环境和浏览器环境的适配： 适配不同的模块加载方式</p>
<p>有的时候js文件需要在 node 和 浏览器环境下都能执行，除了兼容性问题之外，还有一点是 node 和 浏览器平台引入文件时的模块机制是不同的 ：</p>
<p>Node 中使用 <code>Commonjs</code> 的模块加载机制，Commonjs 模块加载机制如下：</p>
<p>使用：使用 <code>require</code> 加载模块， 使用 <code>module.exports</code> 向外部暴露模块</p>
<p>特定： 模块同时加载，这种特点在 node 环境下是不存在问题的， 因为 node 环境下模块都是在本地磁盘，加载比较快， 但是在浏览器环境下时会出现阻塞渲染的问题</p>
<p>为了解决异步加载模块的问题，<code>AMD(https://github.com/amdjs/amdjs-api/wiki)</code>  和 <code>CMD</code> 通过不同的方式实现异步加载模块：</p>
<p>AMD   :  相关库： <code>requireJs</code></p>
<p>写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define(<span class="string">"module"</span>, [<span class="string">"dep1"</span>, <span class="string">"dep2"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">d1, d2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someExportedValue;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">require</span>([<span class="string">"module"</span>, <span class="string">"../file"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">module, file</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>CMD:  相关库： <code>seaJs</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> add = <span class="built_in">require</span>(<span class="string">'math'</span>).add;</span><br><span class="line">  exports.increment = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(val, <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>除了 <code>AMD</code> 和 <code>CMD</code> 两个规范之外，使用<code>es6</code>  的模块加载是浏览器的另一种模块加载机制，也是未来的主流</p>
<p>使用 <code>es6</code> 模块加载实现动态加载的方法： <code>import(module)</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 导入 dayJs 模块</span><br><span class="line">// import(...) 返回 promise</span><br><span class="line">const dayJs = await import(&apos;dayjs&apos;);</span><br></pre></td></tr></table></figure>
<p>使用 <code>browserify</code> 是如何实现的适配各种模块加载的呢 ？</p>
<p>具体代码如下：</p>
<p>按照 <a href="https://github.com/Matt-Esch/virtual-dom" target="_blank" rel="noopener"><code>virtual-dom</code></a> 这个包为例：这个包的作用是生成虚拟dom对象</p>
<p>执行 <code>package.json</code> 中的命令：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"dist"</span>: <span class="string">"browserify  virtual-dom index.js &gt; dist/virtual-dom.js"</span>,</span><br></pre></td></tr></table></figure>
<p>打包时，使用 <code>browserify</code> 来处理， 最终打包完成后的文件输出到 <code>dist/virtual-dom.js</code> 中， 在打包后的代码中，我们可以看到如下的代码结构：</p>
<p>处理之后的代码中：将原来文件中 <code>require(...)</code> 这样的文件引用替换为具体的执行函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自执行方法 f 为下面的 函数1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里根据不同的模块加载方式来导出 virtual-dom 这个包的代码</span></span><br><span class="line">    <span class="comment">// 如果是 CommonJs 规范，比如在 node 中使用</span></span><br><span class="line">    <span class="comment">// 这里当执行 f() 之后，执行路径是：</span></span><br><span class="line">    <span class="comment">// 函数1 作为参数 f 传入， 执行 f 函数1 执行 ==&gt;</span></span><br><span class="line">    <span class="comment">// 函数1 执行 ==&gt; 返回函数 e （为自执行函数）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> exports === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">        <span class="built_in">module</span>.exports = f()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">"function"</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">        define([], f)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> g;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">            g = <span class="built_in">window</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> global !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">            g = global</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">            g = self</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            g = <span class="keyword">this</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在不同环境下，给不同全局变量挂载 virtualDom 变量值为 f 函数执行后的结果</span></span><br><span class="line">        g.virtualDom = f()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)(</span><br><span class="line">  <span class="comment">// 函数1 作为参数 f 传入上面的参数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> define, <span class="built_in">module</span>, exports;</span><br><span class="line">    <span class="comment">// 函数 e 也是一个自执行函数，接受三个参数：</span></span><br><span class="line">    <span class="comment">// 这里参数的各个部分</span></span><br><span class="line">    <span class="comment">// t: 表示下面的对象1</span></span><br><span class="line">    <span class="comment">// n: 表示下面的对象2</span></span><br><span class="line">    <span class="comment">// r: 表示下面的对象3</span></span><br><span class="line">    <span class="comment">// 这里返回的结构为 (function e(t, n, r) &#123;&#125;)(对象1,对象2,对象3)(4)</span></span><br><span class="line">    <span class="comment">// 函数e为自执行函数，执行后返回函数 s， s 接受 4 作为参数，最终这里 return</span></span><br><span class="line">    <span class="comment">// 的结果为 s(4) 之后的返回值</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params">t, n, r</span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params">o, u</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!n[o]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!t[o]) &#123;</span><br><span class="line">                    <span class="keyword">var</span> a = <span class="keyword">typeof</span> <span class="built_in">require</span> == <span class="string">"function"</span> &amp;&amp; <span class="built_in">require</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!u &amp;&amp; a) <span class="keyword">return</span> a(o, !<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (i) <span class="keyword">return</span> i(o, !<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Cannot find module '"</span> + o + <span class="string">"'"</span>);</span><br><span class="line">                    <span class="keyword">throw</span> f.code = <span class="string">"MODULE_NOT_FOUND"</span>, f</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">var</span> l = n[o] = &#123;</span><br><span class="line">                    exports: &#123;&#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">// 这里的 t[o]0 表示每个模块的方法</span></span><br><span class="line">                <span class="comment">// 这里的 t[o]1 表示文件对象，文件对象的键名为引用的文件地址，建值为该文件在对象1中的key</span></span><br><span class="line">                <span class="comment">// 这里使用 call 会立即执行 t[o]0 这个方法</span></span><br><span class="line">                t[o][<span class="number">0</span>].call(l.exports, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">                    <span class="comment">// 这里的 function (e) &#123;&#125;, l, l.exports </span></span><br><span class="line">                    <span class="comment">// 分别表示 function (require, module, exports) 中的 require, module,         </span></span><br><span class="line">                    <span class="comment">// exports 这三个参数</span></span><br><span class="line">                    <span class="comment">// 所以当调用 module.exports 的时候， 实际上 module.exports === l.exports</span></span><br><span class="line">                    <span class="keyword">var</span> n = t[o][<span class="number">1</span>][e];</span><br><span class="line">                    <span class="comment">// 获取到文件地址对象对应的值</span></span><br><span class="line">                    <span class="keyword">return</span> s(n ? n : e)</span><br><span class="line">                &#125;, l, l.exports, e, t, n, r)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里是 s 方法的返回值</span></span><br><span class="line">            <span class="keyword">return</span> n[o].exports</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="keyword">typeof</span> <span class="built_in">require</span> == <span class="string">"function"</span> &amp;&amp; <span class="built_in">require</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> o = <span class="number">0</span>; o &lt; r.length; o++) s(r[o]);</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    &#125;)(</span><br><span class="line">      <span class="comment">// 对象1</span></span><br><span class="line">      &#123;</span><br><span class="line">      ===== 从之前的代码中抽取出来的一些代码 =====</span><br><span class="line">      这个对象中的元素的结构都是一样的：</span><br><span class="line">      对象的键key为数字，表示当前文件的标识</span><br><span class="line">      对象的值是一个数组， 这个数组中有两个元素，一个元素是 <span class="string">`function(require, module, exports) &#123;&#125;`</span> 			方法包裹的文件内的方法，另外一个元素是上面文件中使用 <span class="built_in">require</span> 引用的文件路径和文件标识对象</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 为什么这里要先进行处理呢 ？ 因为可以认为这里是程序的主入口</span></span><br><span class="line">      <span class="comment">// 分析程序先从这里进入开始分析</span></span><br><span class="line">      <span class="number">4</span>: [<span class="function"><span class="keyword">function</span> (<span class="params">require, module, exports</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> diff = <span class="built_in">require</span>(<span class="string">"./diff.js"</span>)</span><br><span class="line">        <span class="keyword">var</span> patch = <span class="built_in">require</span>(<span class="string">"./patch.js"</span>)</span><br><span class="line">        <span class="keyword">var</span> h = <span class="built_in">require</span>(<span class="string">"./h.js"</span>)</span><br><span class="line">        <span class="keyword">var</span> create = <span class="built_in">require</span>(<span class="string">"./create-element.js"</span>)</span><br><span class="line">        <span class="keyword">var</span> VNode = <span class="built_in">require</span>(<span class="string">'./vnode/vnode.js'</span>)</span><br><span class="line">        <span class="keyword">var</span> VText = <span class="built_in">require</span>(<span class="string">'./vnode/vtext.js'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">          diff: diff,</span><br><span class="line">          patch: patch,</span><br><span class="line">          h: h,</span><br><span class="line">          create: create,</span><br><span class="line">          VNode: VNode,</span><br><span class="line">          VText: VText</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        <span class="string">"./create-element.js"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">"./diff.js"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">"./h.js"</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="string">"./patch.js"</span>: <span class="number">13</span>,</span><br><span class="line">        <span class="string">"./vnode/vnode.js"</span>: <span class="number">31</span>,</span><br><span class="line">        <span class="string">"./vnode/vtext.js"</span>: <span class="number">33</span></span><br><span class="line">      &#125;],</span><br><span class="line">      ...</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="comment">// 对象2</span></span><br><span class="line">    &#123;&#125;, </span><br><span class="line">    <span class="comment">// 对象3</span></span><br><span class="line">    [<span class="number">4</span>]</span><br><span class="line">    <span class="comment">// 这里的参数 （4） 实际上是 上面函数 s 接受的参数</span></span><br><span class="line">   )(<span class="number">4</span>)</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>js-module</tag>
      </tags>
  </entry>
  <entry>
    <title>函数节流</title>
    <url>/2017/08/26/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h4 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h4><p>代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var processor = &#123;</span><br><span class="line">  timeoutId: null,</span><br><span class="line">  preformProcessing: function () &#123;</span><br><span class="line">    //实际上要进行执行的代码</span><br><span class="line">  &#125;，</span><br><span class="line">  process: function () &#123;</span><br><span class="line">    clearTimeout(this.timeoutId);</span><br><span class="line">    var that = this;</span><br><span class="line">    // 在 setTimeout 函数内部是一个匿名函数，匿名函数的 this 指向值指向了全局作用域 </span><br><span class="line">    this.timeoutId = setTimeout(function () &#123;</span><br><span class="line">      that.preformProcessing();</span><br><span class="line">    &#125;, 100)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">processor.process() // 开始执行函数</span><br></pre></td></tr></table></figure>
<p>使用函数节流的思想是：</p>
<p>假如有一个提交按钮，点击按钮执行提交操作，设置了一个延时器，在点击按钮一段时间之后执行函数，如果在这段时间内，按钮又被点击操作，<code>process</code> 函数会首先清除延时器，重新开始进行延时操作，</p>
<p>为了防止用户在点击按钮进行操作的时候，触发多次提交操作，下面是一个节流函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function throttle (method, context) &#123;</span><br><span class="line">  clearTimeout(method.tId);</span><br><span class="line">  method.tId = setTimeout(function () &#123;</span><br><span class="line">  		method.call(context)</span><br><span class="line">  &#125;,100)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定时器使用 <code>call</code> 方法实现在适当的环境下执行函数，如果传入的 <code>context</code> 为空，那么就会在全局作用域中执行函数。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>使用函数节流用来防止函数在一定时间内多次被触发操作。</p>
<p>setTimeout内的 <code>this</code> 指向值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var timer = setTimeout(function () &#123;</span><br><span class="line">	console.log(this) // window</span><br><span class="line">&#125;, 2000);</span><br><span class="line">timer;</span><br></pre></td></tr></table></figure>
<p>因为使用 setTimeout  <code>this</code> 值指向的是 window 全局对象，使用 es6 中的箭头函树，this 值是一样的效果。</p>
]]></content>
      <categories>
        <category>代码集</category>
      </categories>
      <tags>
        <tag>节流</tag>
      </tags>
  </entry>
  <entry>
    <title>前端路由的实现</title>
    <url>/2019/01/12/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前端路由的两种实现方式"><a href="#前端路由的两种实现方式" class="headerlink" title="前端路由的两种实现方式"></a>前端路由的两种实现方式</h2><h3 id="路由是什么？"><a href="#路由是什么？" class="headerlink" title="路由是什么？"></a>路由是什么？</h3><p>路由一种根据请求的内容来匹配相应执行代码的一种机制， 在前端应用上面来说， 就是通过不同的路径来请求不同的资源。</p>
<p>对于前端应用， 路由可以分为前端路由以及后端路由两种类型。</p>
<h4 id="后端路由："><a href="#后端路由：" class="headerlink" title="后端路由："></a>后端路由：</h4><p>在spa单页面应用出来之前， 最常用的一种渲染方式是服务端渲染（SSR）， 主要的方式是通过服务器返回页面上需要呈现的内容， 因此， 需要页面呈现什么的内容， 如何根据请求的不同路径返回不同的资源是由服务器端进行配置的，使用服务器端进行渲染有如下几个优缺点：</p>
<p>优点：</p>
<ul>
<li>有利于 SEO 优化。</li>
<li>首屏加载速度快。</li>
</ul>
<p>缺点：</p>
<ul>
<li>每次请求都是渲染一个新的页面，页面重新进行刷新， 旧的页面会被丢失， 从而造成性能上的影响。</li>
</ul>
<h4 id="前端路由："><a href="#前端路由：" class="headerlink" title="前端路由："></a>前端路由：</h4><p>前端路由是单页面应用中页面切换时的资源请求方式， 前端路由会通过url的改变匹配获取到请求参数，根据请求参数的不同 在一个页面中加载不同的资源， 通过这种方式，可以跳转到不同的页面并且不会刷新页面。</p>
<p>优点： </p>
<ul>
<li>除了首屏之外的页面能够快速响应， 因为每次切换页面都只需要加载少量数据。</li>
<li>组件的复用度高， 提高页面加载性能。</li>
<li>前后端分离开发。</li>
<li>当页面进行切换的时候的 transiton 或者 animation 动画更容易被应用。</li>
</ul>
<p>缺点： </p>
<ul>
<li>首屏资源加载速度慢， 因为对于单页面应用， 页面渲染相关的逻辑位于js文件中，js 文件会在浏览器解析 html 之后加载， 因此会造成首屏加载时的白屏问题。</li>
<li>SEO 性能差。</li>
<li>首次加载比较慢， 因为整个网站的资源需要在首次加载页面的时候全部加载。</li>
</ul>
<h3 id="前端路由的实现方式："><a href="#前端路由的实现方式：" class="headerlink" title="前端路由的实现方式："></a>前端路由的实现方式：</h3><p>更新视图但不重新请求页面时前端路由的核心之一。</p>
<p>实现前端路由主要有两种模式， hash 以及 history 模式。</p>
<h4 id="hash："><a href="#hash：" class="headerlink" title="hash："></a>hash：</h4><p>hash 又被称作锚点， 本来用于放在 url 中指定网页中的位置， hash 指的是url 中  <code>#</code> 符号之后的字符， 这个值可以通过  window.localtion.hash 获取到值。</p>
<p>hash 值时用于浏览器端的， 对于服务器端没有作用， 不会包含在 http 请求中， 改变 hash 值不会重新加载页面。</p>
<p>可以通过使用监听 <code>hashchange</code> 监听 hash 值的改变：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'hashchange'</span>, func, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>这样我们就可以在 hash 值发生变化的时候触发 func 函数， 从而更新视图。</p>
<h5 id="history："><a href="#history：" class="headerlink" title="history："></a>history：</h5><p>history 模式主要是通过使用 window.history 只读属性从而对于浏览器历史记录栈进行读取信息和操作。</p>
<blockquote>
<p>window.history 是指向浏览器历史记录栈的只读对象， 提供了操作浏览器历史记录栈的接口</p>
</blockquote>
<p>window.history 提供了一些方法用于操作浏览器的页面行为：</p>
<p><code>window.history.back();</code> : url 回退， 类似于点击浏览器上方的回退按钮。</p>
<p><code>window.history.forward()</code>; url 前进， 类似于点击浏览器上方的前进按钮。</p>
<p><code>window.history.go(1)</code>: 前进到下一个页面。与 forward 相同。</p>
<p><code>window.history.go(-1):</code> 回退到上一个页面， 和 back 相同。</p>
<p> 在 HTML5 中， 新增了两个新的 API： <code>pushState</code> 和 <code>replaceState</code>.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.history.pushState(state, title, url);</span><br><span class="line"><span class="built_in">window</span>.history.replaceState(state, title, url);</span><br></pre></td></tr></table></figure>
<p>使用这两种方法修改浏览器历史记录栈之后， 虽然改变了当前的 url， 但是浏览器不会立即发送这个 url， 这就实现了更新视图但是不会请求页面的作用。</p>
<p>这两个 api 都有三个参数：</p>
<ul>
<li>状态对象（state object）：一个JavaScript对象，与用pushState()方法创建的新历史记录条目关联。无论何时用户导航到新创建的状态，popstate事件都会被触发，并且事件对象的state属性都包含历史记录条目的状态对象的拷贝。</li>
<li>标题（title）：FireFox浏览器目前会忽略该参数，虽然以后可能会用上。考虑到未来可能会对该方法进行修改，传一个空字符串会比较安全。或者，你也可以传入一个简短的标题，标明将要进入的状态。</li>
<li>地址（URL）： 新的历史记录条目的地址。浏览器不会在调用pushState()方法后加载该地址，但之后，可能会试图加载，例如用户重启浏览器。新的URL不一定是绝对路径；如果是相对路径，它将以当前URL为基准；传入的URL与当前URL应该是同源的，否则，pushState()会抛出异常。该参数是可选的；不指定的话则为文档当前URL。</li>
</ul>
<p>使用 <code>pushState</code> 用于增加一条新的历史记录， 使用 <code>replaceState</code> 将会替换掉当前的历史记录。</p>
<p>当活动历史记录中的条目更改的时候， 将会触发 <code>popstate</code>  事件， 例如点击浏览器的回退按钮， 当事件被触发的时候, 事件的 state 属性为使用 <code>pushState</code> 或者 <code>replaceState</code> 中传入的参数 <code>state</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> state = &#123; <span class="attr">bar</span>: <span class="string">'foo'</span> &#125;;</span><br><span class="line"><span class="built_in">window</span>.history.pushState(state, <span class="string">''</span>, <span class="string">'route'</span>);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'popstate'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'state'</span>, e.state); <span class="comment">// &#123; bar: 'foo' &#125;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="两种路由实现方式的区别："><a href="#两种路由实现方式的区别：" class="headerlink" title="两种路由实现方式的区别："></a>两种路由实现方式的区别：</h5><ul>
<li>使用 history 模式可以设置任意和当前 url 同源的 url ，但是使用 hash 只能设置 <code>#</code> 号之后的数值。</li>
<li>使用 history 的 pushState 可以设置相同的 url ，这个新的 url 也会被存放在记录中， 而 hash 值只有和之前的 url 不同才会被记录到 url 中。</li>
<li>在 pushState 中通过传入的 state 值可以添加任何类型的数据， 而 hash 值只可以添加短字符。</li>
</ul>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>route</tag>
      </tags>
  </entry>
  <entry>
    <title>实现machine函数</title>
    <url>/2019/04/01/%E5%AE%9E%E7%8E%B0machine%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>机器可以按照一定的顺序对于零件进行加工， 在程序中， 我们也可以实现一个机器函数， 这个函数可以按照我们调用函数的顺序进行执行。</p>
<img src="/2019/04/01/实现machine函数/mechine.png">
<p>实现一个类似于 <code>machine</code> 的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>machineName 机器名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>机器函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">machine</span>(<span class="params">machineName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> fnList = [];</span><br><span class="line">  fnList.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`start <span class="subst">$&#123;machineName&#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> doFnMap = &#123;</span><br><span class="line">    <span class="keyword">do</span>(doName) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`do <span class="subst">$&#123;doName&#125;</span>`</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 执行机器函数</span></span><br><span class="line">    execute() &#123;</span><br><span class="line">      <span class="keyword">const</span> handleFn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fnList.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> fnNow = fnList.shift();</span><br><span class="line">          <span class="keyword">const</span> fnVal = fnNow();</span><br><span class="line">          <span class="keyword">if</span> (fnVal <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">            fnVal.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              handleFn();</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handleFn();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">`end <span class="subst">$&#123;machineName&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      handleFn();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 执行机器前等待时间</span></span><br><span class="line">    waitFirst(time) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">`wait first <span class="subst">$&#123;time&#125;</span>s`</span>);</span><br><span class="line">          resolve();</span><br><span class="line">        &#125;, time * <span class="number">1000</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    waitEnd(time) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">`wait end <span class="subst">$&#123;time&#125;</span>s`</span>);</span><br><span class="line">          resolve();</span><br><span class="line">        &#125;, time * <span class="number">1000</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 执行过程中等待时间</span></span><br><span class="line">    wait: <span class="function">(<span class="params">time</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">`wait <span class="subst">$&#123;time&#125;</span>s`</span>);</span><br><span class="line">          resolve();</span><br><span class="line">        &#125;, time * <span class="number">1000</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> proxy;</span><br><span class="line">  <span class="comment">// proxy 代理拦截</span></span><br><span class="line">  <span class="comment">// 获取到需要执行的函数名之后，将其放入执行函数队列数组</span></span><br><span class="line">  proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(doFnMap, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function (target, property) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (property !== <span class="string">'execute'</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (property === <span class="string">'waitFirst'</span>) &#123;</span><br><span class="line">            fnList.unshift(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> target.waitFirst(args);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fnList.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> target[property](args);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> proxy;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> doFnMap.execute();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行效果如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">machine(<span class="string">'machine'</span>).waitFirst(<span class="number">3</span>).do(<span class="string">'eat'</span>).do(<span class="string">'run'</span>).wait(<span class="number">5</span>).do(<span class="string">'sleep'</span>).execute()</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<img src="/2019/04/01/实现machine函数/imageconsole.png">
<p><img src="实现machine函数/imageconsole.png" alt></p>
<p>上面代码的主要思路是， 通过使用 <code>proxy</code> 获取到每一次的动作， 将每一次的函数存放到一个函数list 数组中， 当执行 <code>execute</code> 的时候， 依次执行数组中的函数， 在执行过程中进行判断， 当判断为 <code>wait</code>或者 <code>waitFirst</code> 函数的时候， 等待 <code>wait</code> 或者 <code>waitFirst</code> 函数执行完毕之后执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于 wait 或者 waitFirst 函数执行完毕之后返回了一个 promise</span></span><br><span class="line"><span class="keyword">if</span> (fnVal <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">  fnVal.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  	handleFn();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  handleFn();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在执行过程中， 当调用执行方法的时候， 在代码中通过使用 <code>proxy</code> 进行拦截处理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(doFnMap, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function (target, property) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (property !== <span class="string">'execute'</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (property === <span class="string">'waitFirst'</span>) &#123;</span><br><span class="line">            fnList.unshift(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> target.waitFirst(args);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fnList.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> target[property](args);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> proxy;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> doFnMap.execute();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>使用 <code>Proxy</code> 方法用于对一个对象的属性访问和获取进行拦截， 在上面的代码中， 使用 <code>proxy</code> 中的 <code>get</code> 方法，设置了当调用 <code>doFnMap</code> 中的方法的时候， 调用<code>get</code> 方法，在 <code>get</code> 方法中， 可以用来将将要执行的函数方法推入到函数数组列表中以及调整函数的执行顺序。</p>
]]></content>
      <categories>
        <category>代码集</category>
      </categories>
      <tags>
        <tag>machine 函数</tag>
      </tags>
  </entry>
  <entry>
    <title>对象复制</title>
    <url>/2017/11/04/%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h4 id="复制对象"><a href="#复制对象" class="headerlink" title="复制对象"></a>复制对象</h4><p>对于变量进行复制的代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> cloneObj = <span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Array'</span> ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (obj[prop] &amp;&amp; <span class="keyword">typeof</span> obj[prop] === <span class="string">'object'</span>) &#123;</span><br><span class="line">        cloneObj[prop] = clone(obj[prop]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cloneObj[prop] = obj[prop];    </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneObj;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ol>
<li><p>使用 <code>Object.prototype.toString.call()</code> 来判断数据是属于对象的哪一种子类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a = [];</span><br><span class="line">typeof a; // object</span><br><span class="line">Object.prototype.toString.call(a) // &quot;[object, Array]&quot;</span><br><span class="line">Object.prototype.toString.call(a).slice(8, -1) // &quot;Array&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 js 中 <code>null</code> 代表假值, 并且 <code>typeof null</code> 为 <code>object</code></p>
<p>检测类型为不为 <code>null</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> obj === <span class="string">'object'</span> &amp;&amp; obj) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于如果检查到的类型为 null 的时候</span></span><br><span class="line"><span class="keyword">if</span> (obj === <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// do something      </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>null</code> 表示类型尚未定义，表示未定义的类型， <code>undefined</code> 表示值没有被声明</p>
</li>
</ol>
<h4 id="获取class"><a href="#获取class" class="headerlink" title="获取class"></a>获取class</h4><p>使用原生的方法获取到 <code>class</code> 值的方法如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getClass</span>(<span class="params">parent, sClass</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> elements = parent.getElementsByTagName(<span class="string">'*'</span>);</span><br><span class="line">  <span class="keyword">let</span> eleResult = [];</span><br><span class="line">  <span class="comment">// 使用 '\\b' 进行匹配一个单词的边界</span></span><br><span class="line">  <span class="keyword">let</span> classReg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\b'</span> + sClass + <span class="string">'\\b'</span>, i);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; elements.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (classReg.test(elements[i].className)) &#123;</span><br><span class="line">      eleResult.push(elements[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> eleResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>代码集</category>
      </categories>
      <tags>
        <tag>对象复制</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2017/10/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<hr>
<p>补充关于空间复制度和时间复杂度的概念。</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>使用 冒泡排序最重要的思想是: 将一个数和数组中右边的数依次进行比较，如果找到了有左边的数大于右边的数，进行互换，最终一次循环之后，放在左边的数是右边中的最小值，这样依次进行排列，最后得到的左边的数组是已经被排好序之后的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// 保证一轮循环之后 arr[i] 是 i 之后数组的最小值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">    <span class="comment">// 比较相邻两个的大小, 将较大的那个排到后面去</span></span><br><span class="line">    <span class="comment">// 始终保证</span></span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; arr[i]) &#123;</span><br><span class="line">        <span class="comment">// 使用 es6 结构赋值进行交换</span></span><br><span class="line">		<span class="keyword">let</span> t = arr[j];</span><br><span class="line">		arr[j] = arr[i];</span><br><span class="line">		arr[i] = t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>使用快速排序的基本原理是:</p>
<p>算法参考某一个值，遍历一个数组，将数组中小于参考值的元素放在左边的数组中，将数组中大于参考值的元素放在右边的数组中，递归左右数组，返回合并之后的数组。合并之后的数组是已经被排好序的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @description quickSort 用于进行快速排序</span></span><br><span class="line"><span class="comment">* @return &#123;Array&#125; 经过排序之后的数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quicksort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> first = arr[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> leftArr = [];</span><br><span class="line">  <span class="keyword">let</span> rightArr = [];</span><br><span class="line">  <span class="keyword">let</span> len = arr.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; first) &#123;</span><br><span class="line">      leftArr.push(arr[i]);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &gt; first) &#123;</span><br><span class="line">      rightArr.push(arr[i]);    </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 一层一层剥开我的心</span></span><br><span class="line">  <span class="comment">// 一直一直进行递归~~</span></span><br><span class="line">  <span class="keyword">return</span> [].concat(quicksort(leftArr), [first], [quicksort(rightArr)]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>使用 插入排序的基本原理是: 想象一个数组分为两部分，对于整个数组进行遍历的时候，被遍历到的数组元素的左边是已经排好序的，实现的过程是，遍历数组元素左边的元素，和遍历到的元素进行对比，最终将这个新的元素插入到左边元素的合适的位置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @description insertSort 用于进行插入排序</span></span><br><span class="line"><span class="comment">* @param &#123;Array&#125; arr 进行排序的数组</span></span><br><span class="line"><span class="comment">* @return &#123;Array&#125; arr 返回进过排序之后的数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = arr[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; temp) &#123;</span><br><span class="line">        <span class="comment">// 将大于 temp 的元素向后推一位</span></span><br><span class="line">        <span class="comment">// 这些元素是之前已经被排好序的</span></span><br><span class="line">        arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">        <span class="comment">// 将元素插入到 arr[j] 的位置</span></span><br><span class="line">        arr[j] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>代码集</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构：栈和队列</title>
    <url>/2019/09/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种特殊的线性表，这种线性表仅允许在表尾（栈顶）进行插入和删除工作：</p>
<p>将可以被插入和删除元素的位置称为<code>栈顶</code>， 将另一端称为 <code>栈底</code>， 如果栈没有任何的元素， 这个栈被称为 <code>空栈</code>；</p>
<p>栈的数据元素的进出遵循后进先出的原则，简称为  <em>LIFO (Last In First Out)</em> 结构；</p>
<p>栈的插入被称为入栈， 栈的删除被称为出栈， 在程序中我们可以将其称为 <code>push</code> 和 <code>pop</code>;</p>
<p>在 js 中， 我们使用数组的 <code>push</code> 和 <code>pop</code> 方法模拟栈的入栈和出栈操作；</p>
<h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>我们将调用函数自身或者间接调用自身的函数称为 <em>递归</em></p>
<p> 在每一层递归的过程中， 我们需要存储当前调用函数的局部变量， 参数值等数据信息存储到栈中，当递归返回之后， 再将这些数据从栈中弹出数据</p>
<h4 id="使用栈实现四则运算表达式"><a href="#使用栈实现四则运算表达式" class="headerlink" title="使用栈实现四则运算表达式"></a>使用栈实现四则运算表达式</h4><p>如下面程序， 实现将一串运算表达式进行计算的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于逆波兰法表示的后缀表达式计算求值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RPNcompute</span>(<span class="params">mathStrStack</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> stack = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> mathStrStack) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Number</span>.isNaN(+num)) &#123;</span><br><span class="line">      <span class="keyword">const</span> num1 = stack.pop();</span><br><span class="line">      <span class="keyword">const</span> num2 = stack.pop();</span><br><span class="line">      <span class="keyword">const</span> total = num2 + num + num1;</span><br><span class="line">      stack.push(<span class="built_in">eval</span>(total));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      stack.push(num);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stack.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将中缀表达式转为后缀表达式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toPostFixExpression</span>(<span class="params">expression</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> expressionArr = expression.split(<span class="string">' '</span>);</span><br><span class="line">  <span class="keyword">let</span> stack = [];</span><br><span class="line">  <span class="keyword">let</span> outputStr = <span class="string">''</span>;</span><br><span class="line">  <span class="comment">// 处理符号入栈与出栈</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">pushStack</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">if</span> (!stack.length) &#123;</span><br><span class="line">      stack.push(s);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">      <span class="keyword">let</span> stackTopData = stack.pop();</span><br><span class="line">      <span class="keyword">if</span> (s === <span class="string">')'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stackTopData === <span class="string">'('</span>) <span class="keyword">break</span>;</span><br><span class="line">        result += stackTopData + <span class="string">' '</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="string">'+'</span>, <span class="string">'-'</span>, <span class="string">'*'</span>, <span class="string">'/'</span>].includes(s))&#123;</span><br><span class="line">        <span class="keyword">const</span> isLower = [<span class="string">'+'</span>, <span class="string">'-'</span>].includes(s);</span><br><span class="line">        <span class="comment">// 当栈顶元素优先级大于等于当前入栈元素时， 栈顶元素依次出栈</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="string">'/'</span>, <span class="string">'*'</span>].concat(isLower ? [<span class="string">'+'</span>, <span class="string">'-'</span>] : []).includes(stackTopData)) &#123;</span><br><span class="line">          result += stackTopData + <span class="string">' '</span>;</span><br><span class="line">          <span class="keyword">if</span> (!stack.length) &#123;</span><br><span class="line">            stack.push(s);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          stack.push(stackTopData);</span><br><span class="line">          stack.push(s);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stack.push(stackTopData);</span><br><span class="line">        stack.push(s);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> expressionArr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Number</span>.isNaN(+num)) &#123;</span><br><span class="line">      outputStr += pushStack(num);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      outputStr += <span class="string">`<span class="subst">$&#123;num&#125;</span> `</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> outputStr + stack.reverse().join(<span class="string">' '</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compute</span>(<span class="params">mathStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> stackArr = toPostFixExpression(mathStr).split(<span class="string">' '</span>);</span><br><span class="line">  <span class="keyword">return</span> RPNcompute(stackArr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line">compute(<span class="string">'9 + ( 3 - 1 ) * 3 + 10 / 2'</span>);</span><br><span class="line"><span class="comment">// 20</span></span><br><span class="line">compute(<span class="string">'9 + 3 * ( 2 + 2 / 2 ) - 10 / 5'</span>);</span><br><span class="line"><span class="comment">// 16</span></span><br></pre></td></tr></table></figure>
<p>关于 中缀表达式转后缀表达式（逆波兰）法规则如下:</p>
<p>从左到右遍历中缀表达式的每个数字和符号，如果是数字那么就输出，成为后缀表达式的一部分，如果是符号， 那么判断该符号与栈顶符号的优先级，是右括号或者优先级低于等于栈顶符号， 那么栈顶符号依次出栈并输出，并将当前符号进栈， 一直到最终输出后缀表达式为止。</p>
<p>运算符号优先级： 乘除 &gt; 加减</p>
<p>对于后缀表达式的计算规则如下：</p>
<p>从左到右遍历后缀表达式的每个数字和符号，如果遇到数字那么就入栈，遇到是符号， 那么就将处于栈顶的两个数字出栈， 进行运算，并将运算结果入栈， 一直到最终获得到结果。</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><blockquote>
<p>队列是只允许在一端进行插入操作， 而在另一端进行删除操作的线性表</p>
</blockquote>
<p>队列遵循的是先进先出的线性表， 在程序设计中的应用， 比如我们在显示器上记事本上文字的输出。</p>
<p>在日常生活中， 比如我们购买火车票时的排队。</p>
<h3 id="队列的线式存储结构"><a href="#队列的线式存储结构" class="headerlink" title="队列的线式存储结构"></a>队列的线式存储结构</h3><p>在 js 中， 我们使用数组的 <code>push</code> 和 <code>shift(表头弹出)</code> 这两个 api 实现队列的模拟。</p>
<h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><p>使用顺序存储时，我们将队列数据元素按照顺序存储到数组中， 当我们想要对于队列进行出列操作时， 因为出列操作是在表头出列， 因此，出列数据元素后面的每一个数据都会向前移动一个元素位置， 这样会造成程序性能的损耗。</p>
<img src="/2019/09/28/数据结构：栈和队列/image-20191002114710061-9988030.png">
<p><img src="数据结构：栈和队列/image-20191002114710061-9988030.png" alt="image-20191002114710061"></p>
<p>这个时候的时间复杂度为  <code>O(n)</code></p>
<p>为了解决这个移动队列数据元素的问题， 我们可以引入两个指针： <code>front</code>: 指向队头元素， <code>rear</code>: 指向队尾元素的下一个位置</p>
<p>当我们对于队列进行添加和删除元素的时候， 只要改变 <code>front</code> 和 <code>rear</code> 指针的位置就可以了， 不需要移动每个队列元素:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queue</span>(<span class="params">queueLen</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> queueArr = <span class="keyword">new</span> <span class="built_in">Array</span>(queueLen);</span><br><span class="line">  <span class="keyword">let</span> front = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> rear = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.out = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    queueArr[front] = <span class="literal">undefined</span>;</span><br><span class="line">    front ++;</span><br><span class="line">    <span class="keyword">return</span> queueArr;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    queueArr[rear] = data;</span><br><span class="line">    rear ++;</span><br><span class="line">    <span class="keyword">return</span> queueArr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面的代码， 存在一个问题是， 如果我们当删除数据时， 队列不往前移动， 那么当我们新增队列数据元素的时候， 可以会增加到规定的队列长度之外的元素：</p>
<p>比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> queueList = queue(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">queueList.add(<span class="number">1</span>);</span><br><span class="line">queueList.add(<span class="number">2</span>);</span><br><span class="line">queueList.out();</span><br><span class="line"><span class="built_in">console</span>.log(queueList.add(<span class="number">3</span>));</span><br><span class="line"><span class="comment">// [ undefined, 2, 3 ]</span></span><br><span class="line"><span class="comment">// 队列长度超出了我们规定的 2 的长度的队列长度</span></span><br></pre></td></tr></table></figure>
<p>这个时候， 队列数据填充情况如下图所示：</p>
<img src="/2019/09/28/数据结构：栈和队列/image-20191002141645991-9997006.png">
<p><img src="数据结构：栈和队列/image-20191002141645991-9997006.png" alt="image-20191002141645991"></p>
<p>这个时候虽然添加的数据位置超出了队列的长度， 但是删除的队列的第 0 位 和 第 1 位元素却是空的， 我们的溢出是“假溢出”。</p>
<p>我们思考， 如何能够利用删除之后的空间， 防止假溢出？</p>
<h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a><strong>循环队列</strong></h4><p>循环队列相比上面的存储方法而言， 有一些不同， 主要是体现在  <code>rear</code> 指针的指向，<code>rear</code> 指针在队列初始化的时候指向下标 为 0 的位置,  当到达队列列尾的时候， <code>rear</code> 指针移动到队列列头</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queue</span>(<span class="params">queueSize</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> queueArr = <span class="keyword">new</span> <span class="built_in">Array</span>(queueSize);</span><br><span class="line">  <span class="keyword">let</span> front = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> rear = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.out = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (front === rear) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'empty'</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    queueArr[front] = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 使用 %（取模）操作来进行归 0 操作</span></span><br><span class="line">    front = (front + <span class="number">1</span>) % queueSize;</span><br><span class="line">    <span class="keyword">return</span> queueArr;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'full'</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    queueArr[rear] = data;</span><br><span class="line">    rear = (rear + <span class="number">1</span>) % queueSize;</span><br><span class="line">    <span class="keyword">return</span> queueArr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.queueLength = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (rear - front + queueSize) % queueSize;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isFull</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (rear + <span class="number">1</span>) % queueSize === front;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><p>队列的链式存储结构其实就是单链表。与普通的单链表不同的是， 只能操作链表的头部和尾部节点，</p>
<p>队列的链式存储结构被称为 <code>链队列</code>；</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当已知队列空间大小的情况下， 可以使用 <code>循环队列</code>， 否则， 如果不知道队列的长度， 使用 <code>链对列</code></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈 和 队列</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构：树</title>
    <url>/2019/10/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91/</url>
    <content><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树是这样的一种结构：<br><img src="/2019/10/03/数据结构：树/image-20191003112501951.png"><br><img src="数据结构：树/image-20191003112501951.png" alt="image-20191003112501951"></p>
<p>对于树的定义如下：</p>
<blockquote>
<p>树是 n (n &gt;= 0) 个结点的有限集，n = 0 时称为空树，在任意一棵非空树中，</p>
<ol>
<li>有且仅用一个特定的称为 根（root）的节点</li>
<li>当 n &gt; 1 时，其余结点可分为 m（m &gt; 0）个互不相交的有限集 T1, T2, …Tn, 其中每一个集合本身也是一棵树， 并且称为 根的子树， </li>
</ol>
</blockquote>
<p>对于树的存储方式， 可以使用三种表示法来存储树之间结点之间的相互关系：</p>
<p>双亲表示法， 孩子表示法， 孩子兄弟表示法</p>
<p>双亲表示法：</p>
<p>以一段连续的空间存储树的结点， 在每一个结点中，存储当前结点其双亲结点的存储位置：<br><img src="/2019/10/03/数据结构：树/image-20191003120639803.png"><br><img src="数据结构：树/image-20191003120639803.png" alt="image-20191003120639803"></p>
<p>data为数据域， 存储当前结点的相关数据， parent 为指针域， 存储当前节点的双亲结点在数组中的下标</p>
<p>比如下面的树使用双亲表示法表示：<br><img src="/2019/10/03/数据结构：树/image-20191003120919003.png"><br><img src="数据结构：树/image-20191003120919003.png" alt="image-20191003120919003"></p>
<p>根结点的双亲位置为 -1；</p>
<p>上面的表示法表示的树用于查找结点的双亲元素比较方便， 但是，如果这个结点下面包含有多个的子结点， 我们可以需要设置多个的指针域， 比如， 长子域， 右兄弟域等等。</p>
<p>孩子表示法：</p>
<p>孩子表示法的方式是：</p>
<p>将每个结点的孩子结点排列起来，以单链表作为存储结构，则 n 个结点有 n 个孩子链表，如果是叶子结点， 那么这个单链表为空，然后 n 个头指针又组成一个线性表，存放在一个一维数组中。</p>
<p>使用孩子表示法表示上面的树形结构：<br><img src="/2019/10/03/数据结构：树/image-20191003131535048.png"><br><img src="数据结构：树/image-20191003131535048.png" alt="image-20191003131535048"></p>
<p>在上面的孩子表示法中，设计有两种结构：</p>
<ol>
<li><p>孩子链表</p>
<img src="/2019/10/03/数据结构：树/image-20191003131750956.png">
<p><img src="数据结构：树/image-20191003131750956.png" alt="image-20191003131750956"></p>
<p>child 为数据域， 用来存储当前的子结点在表头数组中的下标， next 为指针域，存放的是下一个孩子的这个结构指针地址。</p>
</li>
<li><p>表头结点</p>
<img src="/2019/10/03/数据结构：树/image-20191003131943353.png">
<p><img src="数据结构：树/image-20191003131943353.png" alt="image-20191003131943353"></p>
<p>表头结点存储每个结点， 用于树形结点的遍历使用，另外， 存储长子结点的指针域；</p>
</li>
</ol>
<p>孩子兄弟表示法：</p>
<p>孩子兄弟表示法的数据结构如下：<br><img src="/2019/10/03/数据结构：树/image-20191003132343485.png"><br><img src="数据结构：树/image-20191003132343485.png" alt="image-20191003132343485"></p>
<p>data 为数据域</p>
<p>firstchild 为该结点第一个孩子结点的指针域</p>
<p>rightsib 为该结点的兄弟结点指针域</p>
<p>使用 孩子兄弟表示法组织后的数据结构如下：<br><img src="/2019/10/03/数据结构：树/image-20191003132738591.png"><br><img src="数据结构：树/image-20191003132738591.png" alt="image-20191003132738591"></p>
<p>上面的重新组织后的结构将一棵树转换为了一棵二叉树</p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><blockquote>
<p>二叉树是 n 个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的，分别称为 根结点的左子树和右子树的二叉树组成 </p>
</blockquote>
<p>二叉树的特点：</p>
<ol>
<li>每个结点最多有两棵子树</li>
<li>左子树和右子树是有顺序的， 并且不能颠倒</li>
<li>即使树中某结点只有一棵子树，也要区分顺序</li>
</ol>
<p>如下图， 是一棵二叉树的示意图：<br><img src="/2019/10/03/数据结构：树/image-20191003190231702.png"><br><img src="数据结构：树/image-20191003190231702.png" alt="image-20191003190231702"></p>
<p>根据二叉树的结构显示， 可以将二叉树分为：满二叉树， 斜树 和 完全二叉树；</p>
<p>如下， 是满二叉树的图示：<br><img src="/2019/10/03/数据结构：树/image-20191003190415734.png"><br><img src="数据结构：树/image-20191003190415734.png" alt="image-20191003190415734"></p>
<p>树的每个结点都有左右两个结点， 故称为满二叉树。</p>
<h3 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h3><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><p>按照顺序存储二叉树， 主要是使用一维数组来顺序存储树中的各个结点，比如， 存储如下树结构：<br><img src="/2019/10/03/数据结构：树/image-20191003190805122.png"><br><img src="数据结构：树/image-20191003190805122.png" alt="image-20191003190805122"></p>
<p>使用顺序存储如下：<br><img src="/2019/10/03/数据结构：树/image-20191003190824306.png"><br><img src="数据结构：树/image-20191003190824306.png" alt="image-20191003190824306"></p>
<p>对于不存在的结点， 我们将不存在的结点设为 <code>^</code> 即可。</p>
<p>使用顺序存储存在的问题在于， 我们需要对于不存在的结点分配存储空间，比如，对于下面这个右斜树而言：<br><img src="/2019/10/03/数据结构：树/image-20191003191127941.png"><br><img src="数据结构：树/image-20191003191127941.png" alt="image-20191003191127941"></p>
<p>这样造成了存储空间的浪费。</p>
<h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><p>对于二叉树结点的存储， 我们使用一种被称为 “二叉链表” 的链式存储结构来存储，</p>
<p>二叉链表是下面的这种结构：<br><img src="/2019/10/03/数据结构：树/image-20191003191435274.png"><br><img src="数据结构：树/image-20191003191435274.png" alt="image-20191003191435274"></p>
<p>这个结构中包含有一个数据域和两个指针域， 数据域表明当前结点的数据，指针域分别为二叉树左右两个结点的地址指针。</p>
<p>使用链式存储后的最终的存储链表结构如下：<br><img src="/2019/10/03/数据结构：树/image-20191003191659327.png"><br><img src="数据结构：树/image-20191003191659327.png" alt="image-20191003191659327"></p>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>二叉树的遍历是指从根结点出发， 依次访问到二叉树中的每一个结点，使得每个结点被访问到并且仅被访问到一次。</p>
<p>二叉树的遍历方法， 按照访问次序的不同， 可以分为 前序遍历， 中序遍历 以及 后序遍历</p>
<h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>前序遍历的遍历顺序是先访问二叉树的左子树， 然后访问二叉树的右子树</p>
<img src="/2019/10/03/数据结构：树/image-20191012122817189.png">
<p><img src="数据结构：树/image-20191012122817189-0854497.png" alt="image-20191012122817189"></p>
<p>如， 上图， 二叉树的访问顺序是：</p>
<p>ABDGHCEIF</p>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树</p>
<img src="/2019/10/03/数据结构：树/image-20191014162511259.png">
<p><img src="数据结构：树/image-20191014162511259-1041511.png" alt="image-20191014162511259"></p>
<p>如上图， 那么 二叉树的访问顺序是：</p>
<p>GDHBAEICF</p>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>判断二叉树是否为空， 如果是空， 那么空操作返回，否则的话， 从左到 右通过先叶子后结点的方式遍历访问左右子树</p>
<img src="/2019/10/03/数据结构：树/image-20191014163237408.png">
<p><img src="数据结构：树/image-20191014163237408-1041957.png" alt="image-20191014163237408"></p>
<p>使用后序遍历的方法来访问二叉树的顺序是：</p>
<p>GHDBIEFCA</p>
<h3 id="二叉树的创建"><a href="#二叉树的创建" class="headerlink" title="二叉树的创建"></a>二叉树的创建</h3><p>二叉树的创建可以像二叉树创建方法中传入一串树来实现，通过一定的二叉树的遍历顺序来依次创建结点， 对于空结点， 二叉树中的字符串可以为 ‘#’</p>
<p>按照前序遍历创建的二叉树的方法如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建二叉树</span></span><br><span class="line"><span class="comment">// treeStr: 树的字符串， 空结点 ‘#’</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTree</span>(<span class="params">treeStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> tree = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 创建树节点</span></span><br><span class="line">  <span class="keyword">let</span> treeStack = treeStr.split(<span class="string">''</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createNode</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> nodeData = treeStack.shift();</span><br><span class="line">    <span class="keyword">if</span> (!nodeData) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (nodeData !== <span class="string">'#'</span>) &#123;</span><br><span class="line">      node.data = nodeData;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当父节点没有左结点的时候， 创建左结点</span></span><br><span class="line">    <span class="keyword">if</span> (!node.lChild || !node.lChild.hasOwnProperty(<span class="string">'data'</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (treeStack.length &gt;= <span class="number">1</span>) node.lChild = &#123;&#125;;</span><br><span class="line">      <span class="keyword">if</span> (createNode(node.lChild)) <span class="keyword">delete</span> node.lChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!node.rChild || !node.rChild.hasOwnProperty(<span class="string">'data'</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (treeStack.length &gt;= <span class="number">1</span>) node.rChild = &#123;&#125;;</span><br><span class="line">      <span class="keyword">if</span> (createNode(node.rChild)) <span class="keyword">delete</span> node.rChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  createNode(tree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于树的创建和访问一样， 也是进行依次遍历， 使用递归进行遍历访问， 需要注意的是：</p>
<p>要存在相应的条件， 使得能够跳出递归。</p>
<p>对于递归而言， 注意递归循环的跳出是比较重要的。</p>
<p>同样，也可以按照中序遍历和后序遍历的次序来创建树， 只是递归的顺序不同而已。</p>
<p>另外， 判断对象中某个属性是否存在， 最好不要用直接访问属性的方式进行判断， 因为不知道这个属性的值可能是 <code>undefined</code>,  或者 <code>0</code> 等导致属性访问后为 <code>false</code> 的值。</p>
<p>可以使用 <code>hasOwnProperty</code> 的方式来判断属性是否在对象上面:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.hasOwnPropery(prop);</span><br></pre></td></tr></table></figure>
<p>注意： 这个方法只能够获取到该对象上面的自身属性， 不能获取到该对象原型上面的属性</p>
<p>（for in 是可以获取到继承的属性的， 并且继承的属性是可枚举的）</p>
<p>为了防止对象上面有 <code>hasOwnProperty</code> 属性覆盖掉从对象上面继承的， 我们需要通过 <code>Object</code> 来调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.hasOwnProperty.call(obj, &apos;property&apos;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构（一）：线性表</title>
    <url>/2019/09/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="数据结构简介"><a href="#数据结构简介" class="headerlink" title="数据结构简介"></a>数据结构简介</h2><blockquote>
<p>数据结构是相互之间存在一种或者多种特定关系的数据元素的集合</p>
</blockquote>
<p>数据结构分为<strong>逻辑结构</strong>和<strong>物理结构</strong>；</p>
<p>数据对象中数据元素之间的关系称为逻辑结构， 在数据结构中， 存在下面四种逻辑结构：</p>
<ul>
<li><p>集合结构</p>
<p>集合结构中的元素除了同属于同一集合之外。 没有其他的任何关系， 如同所示：</p>
<img src="/2019/09/21/数据结构：线性表/image-20190921203850921-9069530.png">
<p><img src="数据结构：线性表/image-20190921203850921-9069530.png" alt></p>
</li>
<li><p>线性结构： 线性结构中的元素是一对一的关系：</p>
<img src="/2019/09/21/数据结构：线性表/image-顺序表.jpg">
<p><img src="数据结构：线性表/image-顺序表.jpg" alt></p>
</li>
<li><p>树形结构：树形结构中的元素关系是一对多的层次关系, 比如： 二叉树</p>
<img src="/2019/09/21/数据结构：线性表/image-20190921211634571-9071794.png">
<p><img src="数据结构：线性表/image-20190921211634571-9071794.png" alt="image-20190921211634571"></p>
</li>
<li><p>图形结构： 图形结构中的元素之间的关系是一对多的关系</p>
<img src="/2019/09/21/数据结构：线性表/image-20190921211723626-9071843.png">
</li>
</ul>
<p>  <img src="数据结构：线性表/image-20190921211723626-9071843.png" alt="image-20190921211723626"></p>
<p>物理结构： 是指数据的逻辑结构在计算机中的存储方式；</p>
<p>物理结构包括顺序存储结构和链式存储结构；</p>
<p>顺序存储结构的数据逻辑关系和物理关系是一致的， 即是数据存放在地址连续的存储单元里面；</p>
<p>链式存储结构数据间的存储地址并不连续，数据之间的存储关系并不表示他们之间的逻辑关系，这些数据的地址信息存放在数据的指针中。通过数据的指针来表明数据之间的存储关系。</p>
<h2 id="数据结构之线性表"><a href="#数据结构之线性表" class="headerlink" title="数据结构之线性表"></a>数据结构之线性表</h2><blockquote>
<p>线性表是零个或者多个数据元素的有限序列</p>
</blockquote>
<p>线性表是一种序列， 这表明线性表中数据的关系之间都是一对一的关系，如果元素存在多个， 那么第一个元素没有前元素， 最后一个元素没有后元素， 其他元素有且只有一个前元素和后元素，</p>
<h3 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h3><p>顺序存储结构是物理结构和逻辑结构一致的一种结构， 比如， 我们使用一个一维数组来存储数据，实现顺序存储结构；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list  = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<p>在顺序存储结构中， 地址和数据之间的关系是一致的，比如， 我们想要获取 第 i 个元素， 我们可以通过   <code>list[i - 1]</code> 来获取数据。</p>
<h4 id="删除和插入元素"><a href="#删除和插入元素" class="headerlink" title="删除和插入元素"></a>删除和插入元素</h4><p>当我们需要删除或者插入元素的时候， 对于顺序存储结构需要移动比较多的元素， 当我们需要删除一个元素， 需要将该数据项后面的数据都需要向前提前一位：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从线性表中删除某个数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteData</span>(<span class="params">list, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (list.length === <span class="number">0</span>) <span class="keyword">return</span> list;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; list.length) <span class="keyword">return</span> list;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; list.length) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = i; index &lt; list.length; index ++) &#123;</span><br><span class="line">      list[index <span class="number">-1</span>] = list[index];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  list.length --;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(deleteData(list, <span class="number">2</span>));</span><br><span class="line"><span class="comment">// [1, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p>对于线性表的插入和删除数据操作，其时间复杂度为 O(n);</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>对于线性表的顺序存储结构， 其优点是：</p>
<ol>
<li>可以快速的存取表中任意位置的元素</li>
<li>无须为表中的逻辑关系增加额外的存储空间</li>
</ol>
<p>缺点：</p>
<p>对于线性表中插入和删除元素操作需要移动大量的元素</p>
<h3 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h3><p>顺序存储结构对于插入和删除元素需要移动大量元素的原因是数据之间的逻辑关系和存储关系一致且相互之间按照次序排列，需要移动大量的元素来保持相互之间的存储关系和逻辑关系的一致。</p>
<p>这种问题可以通过使用链式存储结构来解决，链式存储结果的特点是逻辑关系和存储关系分离， 当逻辑关系改变时， 不会引起存储关系的变化</p>
<p>线性表的链式结构由一个个的节点（Node）构成， 每个节点中包含有一个数据域和一个或者多个指针域， 顾名思义， 数据域用于存储当前节点的数据， 指针域用来存储下一个节点的位置信息， 根据节点中指针域的数量不同， 将链表分为单链表和双链表；</p>
<h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>单链表示意图如下：</p>
<img src="/2019/09/21/数据结构：线性表/image-20190921230012405-9078012.png">
<p><img src="数据结构：线性表/image-20190921230012405-9078012.png" alt="image-20190921230012405"></p>
<p>在上图中我们可以看到， 在链表中相邻的数据的存储位置并不连续，数据之间的关系通过节点中的指针域中的地址来表明。</p>
<p>一些要点：</p>
<ol>
<li>链表中的最后一个节点的指针为空， 我们常常将其置为 <code>null</code></li>
<li>为了更方便的对于链表进行操作， 我们在第一个节点之前设置一个头节点，这个节点的指针指向第一个节点， 节点中的数据可以包含有链表的长度等信息。</li>
<li>头指针不为空，是链表的必要元素</li>
</ol>
<p>链表中节点之间的逻辑关系如图所示：</p>
<img src="/2019/09/21/数据结构：线性表/image-20190921231032685-9078632.png">
<p><img src="数据结构：线性表/image-20190921231032685-9078632.png" alt="image-20190921231032685"></p>
<h5 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h5><p>链表中数据的关系是通过指针来表示的，想要读取单链表的数据，我们需要通过指针来操作， 比如读取程序如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的链表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">linkList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> list = &#123;</span><br><span class="line">    data: &#123; <span class="attr">length</span>: <span class="number">0</span> &#125;,</span><br><span class="line">    next: <span class="literal">null</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> headNodeData = list.data;</span><br><span class="line">  <span class="keyword">const</span> headNode = list;</span><br><span class="line">  <span class="comment">// 链表新增节点</span></span><br><span class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> node = &#123; <span class="attr">data</span>: value, <span class="attr">next</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> next = list.next;</span><br><span class="line">    <span class="keyword">let</span> currentNode = list;</span><br><span class="line">    <span class="keyword">while</span> (next) &#123;</span><br><span class="line">      currentNode = next;</span><br><span class="line">      next = next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    currentNode.next = node;</span><br><span class="line">    headNodeData.length ++;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取链表中的某个节点</span></span><br><span class="line">  <span class="keyword">this</span>.get = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; headNodeData.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> next = list.next;</span><br><span class="line">    <span class="keyword">let</span> nodeIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (next) &#123;</span><br><span class="line">      nodeIndex ++;</span><br><span class="line">      <span class="keyword">if</span> (i === nodeIndex) <span class="keyword">break</span>;</span><br><span class="line">      next = next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> linkedList = linkList();</span><br><span class="line">linkedList.add(<span class="number">1</span>)；</span><br><span class="line"><span class="comment">// &#123; data: &#123; length: 1 &#125;, next: &#123; data: 1, next: null &#125; &#125;</span></span><br><span class="line">linkedList.get(<span class="number">1</span>)；</span><br><span class="line"><span class="comment">// &#123; data: 1, next: null &#125;</span></span><br></pre></td></tr></table></figure>
<p>单链表的查找数据的核心思想是<strong>工作指针后移</strong>；</p>
<h5 id="单链表的插入和删除"><a href="#单链表的插入和删除" class="headerlink" title="单链表的插入和删除"></a>单链表的插入和删除</h5><p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在第 i 个数据后插入元素, 元素值为 value</span></span><br><span class="line"><span class="keyword">this</span>.append = <span class="function"><span class="keyword">function</span> (<span class="params">i, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">this</span>.get(i);</span><br><span class="line">  <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'node not exist'</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> newNode = &#123; <span class="attr">data</span>: value, <span class="attr">next</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">  newNode.next = node.next;</span><br><span class="line">  node.next = newNode;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> linkedList = linkList();</span><br><span class="line">linkedList.add(<span class="number">1</span>);</span><br><span class="line">linkedList.append(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// &#123; data: &#123; length: 1 &#125;,</span></span><br><span class="line"><span class="comment">// next: &#123; data: 1, next: &#123; data: 2, next: null &#125; &#125; &#125;</span></span><br></pre></td></tr></table></figure>
<p>对于单链表的插入数据项， 我们要做的仅仅是改变相应节点的指针的指向，原理如图所示：</p>
<img src="/2019/09/21/数据结构：线性表/image-20190922101043201-9118243.png">
<p><img src="数据结构：线性表/image-20190922101043201-9118243.png" alt="image-20190922101043201"></p>
<p>我们想要在<code>p</code> 节点之后插入节点 <code>s</code>, 我们要做的是将 p 节点的指针 <code>next</code> 指向要插入的节点， 同时将要插入的节点的指针指向插入前的下一个节点。</p>
<p>注意： 这里的顺序是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.next --&gt; p.next;</span><br><span class="line">p.next --&gt; s;</span><br></pre></td></tr></table></figure>
<p>顺序不可以更换；</p>
<p>插入成功之后的效果如下图所示：</p>
<img src="/2019/09/21/数据结构：线性表/image-20190922101526386-9118526.png">
<p><img src="数据结构：线性表/image-20190922101526386-9118526.png" alt="image-20190922101526386"></p>
<p>单链表的删除：</p>
<p>实现单链表的删除功能也是通过指针来完成的，实现原理如下图所示：</p>
<img src="/2019/09/21/数据结构：线性表/image-20190922102047839-9118847.png">
<p><img src="数据结构：线性表/image-20190922102047839-9118847.png" alt="image-20190922102047839"></p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除第 i 个节点的元素</span></span><br><span class="line"><span class="keyword">this</span>.delete = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> nodeNext = ((i - <span class="number">1</span> === <span class="number">0</span>) ? headNode : <span class="keyword">this</span>.get(i - <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (!nodeNext || !nodeNext.next) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> deleteNode = nodeNext.next;</span><br><span class="line">  nodeNext.next =  nodeNext.next.next;</span><br><span class="line">  headNodeData.length --;</span><br><span class="line">  deleteNode = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> linkedList = linkList();</span><br><span class="line">linkedList.add(<span class="number">1</span>);</span><br><span class="line">linkedList.add(<span class="number">2</span>);</span><br><span class="line">linkedList.delete(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// &#123; data: &#123; length: 1 &#125;, next: &#123; data: 2, next: null &#125; &#125;</span></span><br><span class="line">linkedList.delete(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// &#123; data: &#123; length: 0 &#125;, next: null &#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="单链表的整表删除"><a href="#单链表的整表删除" class="headerlink" title="单链表的整表删除"></a>单链表的整表删除</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.deleteAll = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> deleteNode = headNode</span><br><span class="line">  <span class="keyword">let</span> freeNode;</span><br><span class="line">  <span class="keyword">while</span> (deleteNode &amp;&amp; deleteNode.next) &#123;</span><br><span class="line">    freeNode = deleteNode.next;</span><br><span class="line">    deleteNode.next = <span class="literal">null</span>;</span><br><span class="line">    deleteNode = freeNode;</span><br><span class="line">    headNodeData.length --;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> linkedList = linkList();</span><br><span class="line">linkedList.add(<span class="number">1</span>);</span><br><span class="line">linkedList.add(<span class="number">2</span>);</span><br><span class="line">linkedList.deleteAll();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'list'</span>, linkedList.list);</span><br><span class="line"><span class="comment">// &#123; data: &#123; length: 0 &#125;, next: null &#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><blockquote>
<p>在单链表中终端节点的指针端由空指针指向头节点，就使得整个单链表形成一个环，这种头尾相接的链表称为循环链表</p>
</blockquote>
<p>循环链表如下图所示：</p>
<img src="/2019/09/21/数据结构：线性表/image-20190923224009682-9249609.png">
<p><img src="数据结构：线性表/image-20190923224009682-9249609.png" alt="image-20190923224009682"></p>
<p>循环链表相比于单链表不同的地方在于终端节点的指针指向不同的，使用循环链表的作用是可以从一个节点出发，查找到列表中的所有节点。</p>
<h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>双向链表和单链表的区别在于： 实现双向链表的节点中存在两个指针域，在单链表的基础上，创建另外一个指针指向上一个节点，如下图所示：</p>
<img src="/2019/09/21/数据结构：线性表/image-20190923224650271-9250010.png">
<p><img src="数据结构：线性表/image-20190923224650271-9250010.png" alt="image-20190923224650271"></p>
<p>相比于单链表而言， 使用双向链表可以实现在前后两个方向上面的节点查找， 比单链表相比，双向链表可以实现在前后两个方向上面的数据节点查找， 当然缺点是会多出一个指针域来指向上一个节点。</p>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>如果线性表需要频繁的查找， 很少进行插入和删除工作时， 适合采用顺序存储结构；</p>
<p>如果涉及到频繁的插入和删除数据工作， 那么适合采用链式存储结构</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式（一）：理论基础部分</title>
    <url>/2018/12/15/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<p>在 js 中，利用正则表达式进行验证是我们经常会遇到的功能需求， 今天就讲解一些正则表达式的理论基础；</p>
<p>正则表达式是用来判断一段字符串是否匹配某一个规则， 通过正则表达式我们可以匹配到我们想要匹配的字符， 判断匹配字符是否存在， 一段字符串是否符合我们的匹配规则等等。</p>
<h3 id="创建正则表达式的两种方式："><a href="#创建正则表达式的两种方式：" class="headerlink" title="创建正则表达式的两种方式："></a>创建正则表达式的两种方式：</h3><p>创建两种正则表达式有两种方法：</p>
<ol>
<li><code>let reg = new RegExp(pattern[, flags])</code></li>
<li><code>let reg = /pattern/flags</code></li>
</ol>
<p>上面两种方法创建正则除了包含有一个表达式 <code>pattern</code> 之外， 还包括一个可选的 <code>flags</code>  字段， 这个字段包含有几种字段：</p>
<ul>
<li>g： 全局匹配正则表达式</li>
<li>i： 表示不区分大小写， 匹配的时候忽略大小写的匹配。</li>
<li>m: 表示多行匹配， 即到达某一行文本结束的时候还会继续查找下一行中是否包含有与模式匹配的值</li>
</ul>
<p>通过上面两种方法创建的正则表达式返回的都是一个正则对象， 这个正则对象中包含有正则表达式中的一些方法例如： <code>exec</code>, <code>match</code> <code>test</code> 等方法。</p>
<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p>正则表达式中的元字符是用来匹配<strong>一个位置</strong>或者<strong>字符集合</strong>中的一个字符， 元字符可以分为两种类型， 匹配位置的元字符和匹配字符的元字符；</p>
<p>匹配位置的元字符：</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>^</code></td>
<td>匹配行的开始位置</td>
</tr>
<tr>
<td><code>$</code></td>
<td>匹配行的结束位置</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>可以用来匹配单词的开始或者结尾位置， 也就是单词的分界处</td>
</tr>
</tbody>
</table>
<p>匹配字符的元字符：</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.</code></td>
<td>匹配除换行符之外的任意字符</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>匹配单词字符（包括字母， 数字，下划线和汉字）</td>
</tr>
<tr>
<td><code>\W</code></td>
<td>匹配任意的非单词字符（和 <code>\w</code>） 相反</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>匹配任意的空白字符， 比如空格符， 制表符或者换行符</td>
</tr>
<tr>
<td><code>\S</code></td>
<td>匹配任意的非空白符</td>
</tr>
<tr>
<td><code>\d</code></td>
<td>用于匹配任意的数字</td>
</tr>
<tr>
<td><code>\D</code></td>
<td>用于匹配任意的非数字字符</td>
</tr>
</tbody>
</table>
<h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3><p>字符类是一个字符集合， 使用方括号 <code>[]</code> 定义， 表示匹配到方括号中的任意一个：</p>
<p><em>注意： 除了 <code>-</code> 以及 <code>^</code> (只能用在开头， 表示否定) 这两个特殊字符之外， 其他的的特殊字符没有任何特殊的含义</em></p>
<p>例如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">/&lt;<span class="type">H</span>[<span class="number">123456</span>]&gt;/</span><br></pre></td></tr></table></figure>
<p>表示匹配 <code>H1</code> <code>H2</code> … <code>H6</code>  中的任意一个标签</p>
<p>在方括号中可以使用 <code>-</code> 用作连接符表示字符的范围：</p>
<p><code>[0-9]</code> 表示匹配 0 到 9  范围类的数字</p>
<p><code>[a-z]</code> 表示匹配 a 到 z 范围内的小写字母</p>
<p><code>[a-zA-Z]</code> 表示匹配 a到 z 或者 A 到 Z 范围内的英文字母</p>
<p>在方括号中当 <code>^</code> 符号位于开头的时候， 表示对于当前字符集表示否定， 匹配的是排除在当前字符集中的字符：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/[^<span class="number">0</span><span class="number">-8</span>]/.test(<span class="number">9</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>要匹配上面的两个特殊符号， 那么需要我们使用反引号进行转义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/[a\-c]/.test(<span class="string">'-'</span>);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>使用字符类方括号 <code>[]</code> 或者 元字符只能表示匹配单个字符， 如果我们想要匹配多个字符的时候， 我们可以使用限定符进行范围的限定：</p>
<p>限定符紧跟在单个字符后面，表示这个字符或者字符集重复的次数。 </p>
<p>对于限定符有下面几种情况 ：</p>
<p>对于限定符也可分为贪婪匹配以及懒惰匹配， 下面的六种限定符为贪婪匹配， 懒惰匹配为在贪婪匹配后面添加 <code>?</code> 表示懒惰匹配；</p>
<table>
<thead>
<tr>
<th>字符或者表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>{n}</code></td>
<td>重复 n 次</td>
</tr>
<tr>
<td><code>{n, }</code></td>
<td>表示至少重复 n 次</td>
</tr>
<tr>
<td><code>{n, m}</code></td>
<td>重复至少n 次， 至多 m 次</td>
</tr>
<tr>
<td><code>*</code></td>
<td>重复至少0次， 等同于 <code>{0, }</code></td>
</tr>
<tr>
<td><code>+</code></td>
<td>重复至少 1 次， 等同于 <code>{1, }</code></td>
</tr>
<tr>
<td><code>?</code></td>
<td>重复 0 次 或者 1</td>
</tr>
</tbody>
</table>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/a.*b/</span>;</span><br><span class="line"><span class="string">"aabab"</span>.match(reg); <span class="comment">// aabab</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/a.&#123;0,1&#125;b/</span>;</span><br><span class="line"><span class="string">"aabab"</span>.match(reg); <span class="comment">// aab</span></span><br></pre></td></tr></table></figure>
<p>使用贪婪匹配与懒惰匹配的区别在于， 使用贪婪匹配会尽可能多的匹配字符， 使用懒惰匹配则是查找到满足匹配条件的字符串中字符较少的字符。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reg1 = <span class="regexp">/a.+b/</span>;</span><br><span class="line"><span class="keyword">const</span> reg2 = <span class="regexp">/a.+?b/</span>;</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">"avbaab"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 贪婪匹配</span></span><br><span class="line">str.match(reg1);  <span class="comment">// avbaab</span></span><br><span class="line"><span class="comment">// 懒惰匹配</span></span><br><span class="line">str.match(reg2); <span class="comment">// avb</span></span><br></pre></td></tr></table></figure>
<h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p>在正则表达式中 <code>|</code> 用于表示当字符串匹配了 <code>|</code> 左边或者右边的规则的时候， 表示这个字符串匹配了当前的正则表达式，</p>
<p>类似于 js 中的 <code>||</code> 操作符， 当 <code>|</code> 左边的正则不匹配， 那么进行右边的正则匹配。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg1 = \d&#123;<span class="number">5</span>&#125; - \d&#123;<span class="number">3</span>&#125; | d&#123;<span class="number">5</span>&#125;; <span class="comment">// 同时可以匹配 12345-678 或者 12345</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意： 使用 <code>|</code> 进行匹配的时候， 如果当左边的元素被匹配到的时候， 右边的元素将不会进行匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> str = <span class="string">'goodbye'</span>;</span><br><span class="line">&gt; <span class="comment">// | 两边不能有空格</span></span><br><span class="line">&gt; <span class="keyword">let</span> regex = <span class="regexp">/goodbye|good/g</span>;</span><br><span class="line">&gt; str.match(regex); <span class="comment">// ['goodbye']</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>使用 <code>()</code> 包裹起来的表达式在正则表达式中表示一个整体， 我们可以对这个整体进行限定符限制， 重复匹配</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配一个 ip 地址</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/(\d&#123;1,3&#125;\.)&#123;3&#125;/</span>d&#123;<span class="number">1</span>,<span class="number">3</span>&#125;/;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在正则中使用 <code>[]</code> 以及 <code>|</code> 都有 “或者” 的意思， 这两者可以根据不同的请求可以选择使用， 具体的对比如下：</p>
<table>
<thead>
<tr>
<th>描述符</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[]</code></td>
<td>适合单个字符之间的匹配， 需要转义的特殊字符比较少（<code>^</code>  和 <code>-</code>）</td>
<td>不能匹配多个字符结合的字符串，相对表达意思比较少， 只能表示匹配或者不匹配（使用<code>^</code>） 两种逻辑</td>
</tr>
<tr>
<td>竖直</td>
<td>可以匹配多个字符的字符串</td>
<td>当匹配正则中的特殊字符的时候需要进行转义</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式（三）：一些例子</title>
    <url>/2019/01/27/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%B8%80%E4%BA%9B%E4%BE%8B%E5%AD%90/</url>
    <content><![CDATA[<h3 id="下面是使用正则表达式的一些示例："><a href="#下面是使用正则表达式的一些示例：" class="headerlink" title="下面是使用正则表达式的一些示例："></a>下面是使用正则表达式的一些示例：</h3><ol>
<li><p>实现密码输入以英文字母开头， 密码长度为 8 到 16 位， 密码限为字符， 数字和下划线。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let pattern = /^[a-zA-a]\w&#123;7, 15&#125;/;</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证是否含有^%&amp;’’,;=?$”等字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let pattern = /[\^%&amp;$&quot;.&apos;=?]/;</span><br><span class="line">// &quot;\&quot; 用于转义 `^`</span><br></pre></td></tr></table></figure>
</li>
<li><p>整数正则</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let pattern = /^-?\d+$/;</span><br></pre></td></tr></table></figure>
</li>
<li><p>匹配数字， 小数点后最大两位小数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/^\d+/</span>.?\d&#123;<span class="number">0</span>, <span class="number">2</span>&#125;$/;</span><br></pre></td></tr></table></figure>
</li>
<li><p>手机号码的匹配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let pattern = /^1[34578]\d&#123;9&#125;$/;</span><br></pre></td></tr></table></figure>
</li>
<li><p>匹配16进制颜色值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 比如匹配如下的颜色</span><br><span class="line">// #ffbbad  #Fc01DF  #FFF  #ffE</span><br><span class="line">let pattern = /[0-9a-fA-F]&#123;6&#125; | [0-9a-fA-F]&#123;3&#125;/;</span><br><span class="line">// 使用 | 用来表示正则表达式中分支结构</span><br></pre></td></tr></table></figure>
</li>
<li><p>匹配 24 小时时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 例如匹配 23:59 和 02:12</span><br><span class="line">// 使用 () 对于正则表达式进行分组使用， 在 （） 内使用 | 只会作用到括号内的正则内容</span><br><span class="line">let pattern = /^([01][0-9] | [2][0-4]):[0-5][0-9]/;</span><br></pre></td></tr></table></figure>
</li>
<li><p>匹配日期</p>
<p>例如： 我们想要匹配 “YYYY-mm-dd” 的日期格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let pattern = /^[0-9]&#123;4&#125;-([0][0-9] | [1][0-2])-(0[1-9] | [12][0-9] | [3][01])/;</span><br></pre></td></tr></table></figure>
</li>
<li><p>匹配 innerHTML 中的类名</p>
<p>如果我们想要进行匹配这样一个innterHtml 中的类名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> innerHtml = <span class="string">'&lt;div class="content"&gt;&lt;div class="body"&gt;&lt;/div&gt;&lt;/div&gt;'</span>;</span><br><span class="line"></span><br><span class="line">pattern = <span class="regexp">/class=".*?"/i</span>;</span><br><span class="line"></span><br><span class="line">test = innerHtml.match(pattern)[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// class="content"</span></span><br><span class="line"><span class="comment">// 使用 ？进行的是贪婪匹配， 会      匹配尽量少的字符</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于字符串中的 <code>trim</code> 方法：使用正则表达式清除字符串两边的空格：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'  hello  '</span>;</span><br><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/^\s+|\s+$/g</span>;</span><br><span class="line"><span class="keyword">let</span> res = str.replace(regex, <span class="string">''</span>); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>验证 URL 为绝对路径</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A URL is considered absolute if it begins with "&lt;scheme&gt;://" or "//" (protocol-relative URL).</span></span><br><span class="line"><span class="comment">RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed by any combination of letters, digits, plus, period, or hyphen.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// ? 非贪婪匹配 表明前面匹配的 () 内字符的数量可能为 0 次 匹配 // 的情况</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isAbsoluteURL</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/^([a-z][a-z\d\+\-\.]*:)?\/\//i</span>.test(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式（五）：括号与正则符号优先级</title>
    <url>/2019/02/05/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><h3 id="提供分组和分支结构"><a href="#提供分组和分支结构" class="headerlink" title="提供分组和分支结构"></a>提供分组和分支结构</h3><p>分组和分支结构是括号中的基础使用， 作用是提供一个子表达式</p>
<h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>使用括号进行分组， 用来表明括号内的所有字符是一个组合， 从而对于括号内的字符组合进行范围限定， 可以对于整个括号添加量词， 表明匹配括号内的元素进行整体量词限定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'abababc ab'</span>;</span><br><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/(ab)+/g</span>;</span><br><span class="line">str.match(regex); <span class="comment">// Array(2) ["ababab", "ab"]</span></span><br></pre></td></tr></table></figure>
<h4 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h4><p>我们在正则中使用 <code>|</code> 表明匹配 <code>|</code>  符号左边或者右边的正则， 使用括号包裹<code>|</code> 用来限定 <code>|</code> 的作用范围， 例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'ab ac'</span>;</span><br><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/a(b|c)/g</span>;</span><br><span class="line"><span class="comment">// 如果不加上括号 regex = /ab | c/g 那么匹配的是 ab 或者 c</span></span><br><span class="line"><span class="comment">// 加上括号表明分支结构只有 b 和 c</span></span><br><span class="line">str.match(regex); <span class="comment">// ['ab', 'ac']</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在使用 match 的时候，添加全局标识符 <code>g</code> 加不加是不同的：</p>
<p>上面的代码如果不用添加 <code>g</code> 标识符， 那么返回结果如下：不会进行全局匹配， 只会匹配到 <code>ab</code> 就会返回。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> str = <span class="string">'ab ac'</span>;</span><br><span class="line">&gt; <span class="keyword">let</span> regex = <span class="regexp">/a(b|c)/</span>;</span><br><span class="line">&gt; str.match(regex);</span><br><span class="line">&gt; <span class="comment">// ['ab', 'b']</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分组引用"><a href="#分组引用" class="headerlink" title="分组引用"></a>分组引用</h3><p>在正则中使用括号进行包裹正则表达式时， 正则引擎会对于正则表达式进行分组，正则引擎会在匹配过程中， 给每一个分组都开辟一个内存空间， 用来存储每一个分组匹配到的数据。</p>
<p>例如， 我们想要对于日期进行匹配：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let date = &apos;2019-02-05&apos;;</span><br><span class="line">let regex = /(\d&#123;4&#125;-(\d&#123;2&#125;)-(\d&#123;2&#125;))/;</span><br><span class="line">date.match(regex); //  [&quot;2018-02-02&quot;, &quot;2018&quot;, &quot;02&quot;, &quot;02&quot;]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里使用 match 进行匹配的正则表达式中没有包含有标识符 g， 因此使用 match 与使用 exec 的返回结果是一样的。</p>
</blockquote>
<h1 id="符号的优先级"><a href="#符号的优先级" class="headerlink" title="符号的优先级"></a>符号的优先级</h1><p>在正则表达式中， 使用操作符进行操作的时候， 需要规定操作符的优先级， 用来表示操作符是谁先操作， 谁后操作， 在正则表达式中， 各种操作符的优先级如下：</p>
<p>从上到下：</p>
<table>
<thead>
<tr>
<th>描述符</th>
<th>操作符</th>
</tr>
</thead>
<tbody>
<tr>
<td>转义符</td>
<td><code>\</code></td>
</tr>
<tr>
<td>括号与方括号</td>
<td><code>(...)</code> <code>(?:...)</code> <code>(?=...)</code> <code>(?!...)</code> <code>[...]</code></td>
</tr>
<tr>
<td>量词限定符</td>
<td><code>{m}</code> <code>{m, n}</code> <code>{m, }</code> <code>?</code>  <code>*</code> <code>+</code></td>
</tr>
<tr>
<td>位置和序列</td>
<td><code>^</code>  <code>$</code>  <code>\元字符</code>  <code>一般字符</code></td>
</tr>
<tr>
<td>管道符</td>
<td>`</td>
<td>`</td>
</tr>
</tbody>
</table>
<p>上面的操作符从上到下， 优先级从高到低；</p>
<p>示例： <code>/ab?(c|de*)+|fg/</code></p>
<p>上面的操作过程如下：</p>
<p>因为在正则中存在管道符 <code>|</code> 用于分割为 <code>ab?(c|de*)+</code>  和 <code>fg</code> 两个部分， 先执行这两个部分：</p>
<p>执行 <code>ab?(c|de*)+</code>: 在这个过程中，先执行括号内的正则， 然后执行字符 <code>a</code>, <code>b</code> <code>?</code> 以及 <code>+</code>, 在括号内</p>
<p><code>c|de*</code> 的执行顺序中， 先执行 <code>c</code>, <code>de*</code>,  其中 <code>*</code> 是和 <code>e</code> 在一起的， 因此 <code>*</code> 限定的量词是 <code>e</code>;</p>
<p>如下：  匹配一个字符串， 字符串中的字符为  <code>a</code> , <code>b</code>, <code>c</code> 中的一个， 并且， 字符串的长度为 3 的倍数；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/([abc]&#123;3&#125;)+/</span>;</span><br></pre></td></tr></table></figure>
<p> 这里是将量词 3 使用括号进行包裹</p>
<p>如下： 匹配一个 ipv4 的地址：IP4 的地址的结构为这种形式：</p>
<p>3位数.3位数.3位数.3位数</p>
<p>其中 3 位数的数字范围为 0 - 255， 因此， 对于一位数而言， 可以这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/<span class="number">0</span>&#123;<span class="number">0</span>,<span class="number">2</span>&#125;\d+<span class="regexp">/ /</span><span class="regexp">/ 匹配 000 - 009</span></span><br></pre></td></tr></table></figure>
<p>对于两位数而言， 进行匹配：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/<span class="number">0</span>?\d&#123;<span class="number">2</span>&#125;/</span><br></pre></td></tr></table></figure>
<p>对于三位数而言， 需要进行匹配：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/<span class="number">1</span>\d&#123;<span class="number">2</span>&#125;/ <span class="comment">// 匹配 100 - 199</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]\d/ <span class="comment">// 匹配 200 - 249</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]/ <span class="comment">// 匹配 250 -255</span></span><br></pre></td></tr></table></figure>
<p>上面的这几种匹配结构为或的关系， 因此， 上面几种结构使用管道符 <code>|</code> 进行连接：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">0</span>&#123;<span class="number">0</span>,<span class="number">2</span>&#125;\d|<span class="number">0</span>?\d&#123;<span class="number">2</span>&#125;|<span class="number">1</span>\d&#123;<span class="number">2</span>&#125;|<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]\d|<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>])</span><br></pre></td></tr></table></figure>
<p>匹配<code>.</code> 号：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/^((<span class="number">0</span>&#123;<span class="number">0</span>,<span class="number">2</span>&#125;\d|<span class="number">0</span>?\d&#123;<span class="number">2</span>&#125;|<span class="number">1</span>\d&#123;<span class="number">2</span>&#125;|<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]\d|<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>])\.)(<span class="number">0</span>&#123;<span class="number">0</span>,<span class="number">2</span>&#125;\d|<span class="number">0</span>?\d&#123;<span class="number">2</span>&#125;|<span class="number">1</span>\d&#123;<span class="number">2</span>&#125;|<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]\d|<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>])$/</span><br></pre></td></tr></table></figure>
<p>上面的也可以第二部分可以使用 <code>\2</code>  进行代替：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/^((<span class="number">0</span>&#123;<span class="number">0</span>,<span class="number">2</span>&#125;\d|<span class="number">0</span>?\d&#123;<span class="number">2</span>&#125;|<span class="number">1</span>\d&#123;<span class="number">2</span>&#125;|<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]\d|<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>])\.)\<span class="number">2</span>$/</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式（四）：匹配</title>
    <url>/2019/02/04/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6%EF%BC%8C-%E5%8C%B9%E9%85%8D%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>正则表达式中的位置匹配：</p>
<p><strong>正则表达式是匹配模式， 要么匹配字符， 要么匹配位置</strong></p>
<p>对于位置匹配， 这里的位置是字符之间的间隙， 进行位置匹配时， 使用正则表达式中存在下面几个‘锚’：</p>
<p><code>^</code>   <code>$</code>  <code>\b</code>  <code>\B</code>    <code>(?=p)</code> <code>(?!p)</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th>匹配含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>^</code></td>
<td>匹配字符串的开头</td>
</tr>
<tr>
<td style="text-align:center"><code>$</code></td>
<td>匹配字符串的结尾</td>
</tr>
<tr>
<td style="text-align:center"><code>\b</code></td>
<td>单词边界， 具体就是 <code>\w</code> 与 <code>\W</code> 之间的位置, 以及字符串的开始位置和结尾位置</td>
</tr>
<tr>
<td style="text-align:center"><code>\B</code></td>
<td>是 <code>/b</code> 之外的位置</td>
</tr>
<tr>
<td style="text-align:center"><code>(?=P)</code></td>
<td><code>p</code> 是一个模式， 这个正则表达式匹配的是<code>P</code> 之前的位置， 或者当前位置之后的字符要匹配正则表达式 <code>P</code></td>
</tr>
<tr>
<td style="text-align:center"><code>(?!P)</code></td>
<td>这个与 <code>(?=P)</code> 意思相反， 是除了 <code>(?=P)</code> 之外的位置</td>
</tr>
</tbody>
</table>
<h4 id="以及"><a href="#以及" class="headerlink" title="^ 以及 $"></a><code>^</code> 以及 <code>$</code></h4><p>用于匹配字符串开头或者字符串结尾的位置：</p>
<p>如下例子：将字符的开头和结尾添加特定的字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let str = &apos;hello&apos;;</span><br><span class="line">let regex = /^|$/g;</span><br><span class="line">let res = str.replace(regex, &apos;*&apos;);</span><br><span class="line">console.log(res); // &apos;*hello*&apos;</span><br></pre></td></tr></table></figure>
<p>例如下面， 使用 <code>replace</code>  代替     <code>trim</code>  方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'  hell o   '</span>;</span><br><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/^\s+|\s+$/g</span>;</span><br><span class="line"><span class="keyword">let</span> res = str.replace(regex, <span class="string">''</span>);</span><br><span class="line"><span class="comment">// hell o</span></span><br></pre></td></tr></table></figure>
<h4 id="b-以及-B"><a href="#b-以及-B" class="headerlink" title="\b 以及 \B"></a><code>\b</code> 以及 <code>\B</code></h4><p>使用 <code>\b</code> 的作用是匹配单词边界之间的位置， 具体而言是 <code>\w</code> 以及 <code>\W</code>   之间的位置：</p>
<p><code>\w</code>: 匹配单词字符， 字符包括字母， 汉字， 下划线以及数字</p>
<p>示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'hel lo'</span>;</span><br><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/\b/g</span>;</span><br><span class="line"><span class="keyword">let</span> res = str.replace(regex, <span class="string">'#'</span>);</span><br><span class="line"><span class="comment">// #hel# #lo#</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>\B</code> 则和 <code>\b</code>  相反， 匹配的位置是单词字符内的位置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">regex = <span class="regexp">/\B/g</span>;</span><br><span class="line">res = str.replace(regex, <span class="string">'#'</span>);</span><br><span class="line"><span class="comment">// h#e#l l#o;</span></span><br></pre></td></tr></table></figure>
<h4 id="P-以及-P"><a href="#P-以及-P" class="headerlink" title="(?=P) 以及 (?!P)"></a><code>(?=P)</code> 以及 <code>(?!P)</code></h4><p>使用 <code>(?=P)</code> 用来匹配特定字符前的位置, <code>P</code> 是一个正则表达式；</p>
<p>如下： 给单词中的 l 字符前面添加字符 <code>#</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">regex = <span class="regexp">/(?=l)/g</span>;</span><br><span class="line">str = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">let</span> res = str.replace(regex, <span class="string">'#'</span>);</span><br><span class="line"><span class="comment">// he#l#lo</span></span><br></pre></td></tr></table></figure>
<p>给每一个单词字符前面添加一个字符 <code>*</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">regex = /(?=\w)/g;</span><br><span class="line">str = &apos;hello&apos;;</span><br><span class="line">let res = str.replace(regex, &apos;*&apos;);</span><br><span class="line">// *h*e*l *l*o</span><br></pre></td></tr></table></figure>
<p>使用 <code>(?!P)</code> 用来匹配除了匹配到的正则表达式 P 之前位置之外的其他位置：</p>
<p>例如上面的例子， 我们使用 <code>(?!P)</code> 来代替 <code>(?=P)</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">regex = <span class="regexp">/(?!l)/</span>;</span><br><span class="line">str = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">let</span> res = str.replace(regex, <span class="string">'*'</span>);</span><br><span class="line"><span class="comment">// *h*ell*o*</span></span><br><span class="line"><span class="comment">// 当我们仅仅想匹配到单词内部的时候</span></span><br><span class="line">regex = <span class="regexp">/(?!l)(?!^)(?!$)/</span>;</span><br><span class="line"><span class="comment">// h*ell*o</span></span><br></pre></td></tr></table></figure>
<p>这里的 <code>(?!^)(?!$)</code> 是匹配除了单词开头和结尾的位置， 这里可以使用 <code>/B</code> 来进行代替;  </p>
<p><code>regex = /(?!l)(\B)/</code> </p>
<p>如下， 给一个数字添加千位分隔符 ‘,’  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"12345678"</span>;</span><br><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/(?!^)(?=(\d&#123;3&#125;)+$))/g</span>;</span><br><span class="line"><span class="keyword">let</span> res = str.replace(regex, <span class="string">','</span>); <span class="comment">// 12,345,678</span></span><br></pre></td></tr></table></figure>
<p>分析：</p>
<p>给一个数字添加一个千位字符的时候， 我们需要在字符尾部向前查找三位字符， 在三位字符前面的位置处添加分隔符 ‘ ,’;  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(\d&#123;<span class="number">3</span>&#125;)+$ <span class="comment">// 匹配结尾处向前 3 个或者多个 3 字符倍数的字符</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(?=(\d&#123;<span class="number">3</span>&#125;)+$) <span class="comment">// 匹配 3 个字符或者 3 个字符倍数的字符前面的位置</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(?!^) <span class="comment">// 匹配非开头的位置</span></span><br></pre></td></tr></table></figure>
<p>如下， 给钱数添加人民币符号 <code>¥</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="string">'1234'</span>;</span><br><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/(?=^)/</span>;</span><br><span class="line"><span class="keyword">let</span> res = number.replace(regex, <span class="string">'¥ '</span>);</span><br><span class="line"><span class="comment">// ¥ 1234</span></span><br></pre></td></tr></table></figure>
<p>如下： 判断一段字符中必须包含有数字：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'str123'</span>;</span><br><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/(?=.*[0-9])^/g</span>;</span><br><span class="line"><span class="comment">// 这里的 ^ 表示开头， 这个正则表达式表示开头的位置， 也就是开头之后的字符需要匹配 .*[0-9]</span></span><br><span class="line"><span class="comment">// .*[0-9] 表示任意字符长度后面都需要一个数字， 也就是需要匹配到的字符串必须包含有数字</span></span><br><span class="line"><span class="keyword">let</span> res = regex.test(str); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如下： 判断字符中不能全部为数字,  可以使用 <code>?!P</code> 进行判断</p>
<p>判断字符中不能全部为数字的反义为全部为数字：那么判断全部为数字的正则表达式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 判断6位字符串中全部为数字</span><br><span class="line">let regex = /(?=[0-9]&#123;6&#125;)/</span><br></pre></td></tr></table></figure>
<p>因为 <code>?!</code> 和 <code>?=</code> 互为反义， 因此， 判断不能全部为数字的正则如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/(?![0-9]&#123;6&#125;)/</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'123456'</span>;</span><br><span class="line">regex.test(str); <span class="comment">// false</span></span><br><span class="line">str = <span class="string">'a23456'</span>;</span><br><span class="line">regex.test(str); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>日历</title>
    <url>/2017/08/31/%E6%97%A5%E5%8E%86/</url>
    <content><![CDATA[<h4 id="使用面向对象的-js-代码写法，写了一个日历，代码如下"><a href="#使用面向对象的-js-代码写法，写了一个日历，代码如下" class="headerlink" title="使用面向对象的 js 代码写法，写了一个日历，代码如下"></a>使用面向对象的 js 代码写法，写了一个日历，代码如下</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    单个时间&lt;input type=&quot;text&quot; id=&quot;startTime&quot;&gt;</span><br><span class="line">    时间段&lt;input type=&quot;text&quot; id=&quot;longTime&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;content&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">    (function (window)&#123;</span><br><span class="line">        function $(tag, parent) &#123;</span><br><span class="line">            var children = [];</span><br><span class="line">            if (tag.indexOf(&apos;#&apos;) !== -1) &#123;</span><br><span class="line">                children = document.getElementById(tag.slice(1));</span><br><span class="line">            &#125; else if (tag.indexOf(&apos;.&apos;) !== -1) &#123;</span><br><span class="line">                children = parent ? parent.getElementsByClassName(tag.slice(1)) : document.getElementsByClassName(tag.slice(1));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                children = parent ? parent.getElementsByTagName(tag) : document.getElementsByTagName(tag);</span><br><span class="line">            &#125;</span><br><span class="line">            return children;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function listenEvent(dom,event,fn) &#123;</span><br><span class="line">            </span><br><span class="line">            if (dom.attachEvent) &#123;</span><br><span class="line">                dom.attachEvent(&apos;on&apos; + event, fn);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dom.addEventListener(event, fn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function dateUI (isSingle ,inputIdName, callBack) &#123;</span><br><span class="line">            this.isSingle = isSingle;</span><br><span class="line">            this.inputIdName = inputIdName;</span><br><span class="line">            this.callBack = callBack;</span><br><span class="line">            </span><br><span class="line">            var date = new Date();</span><br><span class="line"></span><br><span class="line">            this.data = &#123;</span><br><span class="line">                weekDay: [&apos;日&apos;, &apos;一&apos;, &apos;二&apos;, &apos;三&apos;, &apos;四&apos;, &apos;五&apos;, &apos;六&apos;],</span><br><span class="line">                minDate: &apos;&apos;,</span><br><span class="line">                maxData: &apos;&apos;,</span><br><span class="line">                year: 2017,</span><br><span class="line">                month: 8,</span><br><span class="line">                selectDays: []</span><br><span class="line">            &#125;</span><br><span class="line">            this.data.year = 2017;</span><br><span class="line">            this.data.month = 8;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dateUI.prototype = &#123;</span><br><span class="line">            $ : function (tag, parent) &#123;</span><br><span class="line">                var children = [];</span><br><span class="line">                if (tag.indexOf(&apos;#&apos;) !== -1) &#123;</span><br><span class="line">                    children = document.getElementById(tag.slice(1));</span><br><span class="line">                &#125; else if (tag.indexOf(&apos;.&apos;) !== -1) &#123;</span><br><span class="line">                    children = parent ? parent.getElementsByClassName(tag.slice(1)) : document.getElementsByClassName(tag.slice(1));</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    children = parent ? parent.getElementsByTagName(tag) : document.getElementsByTagName(tag);</span><br><span class="line">                &#125;</span><br><span class="line">                return children;</span><br><span class="line">            &#125;,</span><br><span class="line">            listenEvent: function (dom, event, fn) &#123;</span><br><span class="line">                if (dom.attachEvent) &#123;</span><br><span class="line">                    dom.attachEvent(&apos;on&apos; + event, fn);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dom.addEventListener(event, fn);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            initTable: function () &#123;</span><br><span class="line">                var that = this;</span><br><span class="line">                var title = document.createElement(&apos;div&apos;);</span><br><span class="line">                title.setAttribute(&apos;id&apos;, &apos;title&apos;);</span><br><span class="line">                title.innerHTML = &apos;&lt;span id=&quot;pre&quot;&gt;back&lt;/span&gt;&lt;input type=&quot;number&quot; id=&quot;month&quot;&gt;&lt;input type=&quot;number&quot; id=&quot;year&quot;&gt;&lt;span id=&quot;back&quot;&gt;pre&lt;/span&gt;&apos;</span><br><span class="line">                var main = document.createElement(&apos;div&apos;);</span><br><span class="line">                main.setAttribute(&apos;id&apos;, &apos;main&apos;);</span><br><span class="line">                var table = document.createElement(&apos;table&apos;);</span><br><span class="line">                table.innerHTML = &apos;&lt;thead&gt;&lt;tr&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;/tbody&gt;&apos;;</span><br><span class="line">                main.appendChild(table);</span><br><span class="line">                that.$(&apos;#content&apos;).appendChild(title);</span><br><span class="line">                that.$(&apos;#content&apos;).appendChild(main);</span><br><span class="line">                for (let i = 0; i &lt; that.data.weekDay.length; i++) &#123;</span><br><span class="line">                    that.$(&apos;tr&apos;, that.$(&apos;thead&apos;)[0])[0].innerHTML += &apos;&lt;th&gt;&apos; + that.data.weekDay[i] + &apos;&lt;/th&gt;&apos;;</span><br><span class="line">                &#125;</span><br><span class="line">                var _ROW = 6;</span><br><span class="line">                var _COL = 7;</span><br><span class="line">                for (var i = 0; i &lt; _ROW; i++) &#123;</span><br><span class="line">                    that.$(&apos;tbody&apos;)[0].innerHTML += &apos;&lt;tr&gt;&lt;/tr&gt;&apos;;</span><br><span class="line">                    for (var j = 0; j &lt; _COL; j++) &#123;</span><br><span class="line">                        that.$(&apos;tr&apos;, that.$(&apos;tbody&apos;)[0])[i].innerHTML += &apos;&lt;td&gt;&lt;/td&gt;&apos;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                that.tds = document.getElementsByTagName(&apos;td&apos;);</span><br><span class="line">                that.tds = [].slice.call(that.tds);</span><br><span class="line">               </span><br><span class="line">            &#125;,</span><br><span class="line">            reactData: function () &#123;</span><br><span class="line">                var that = this;</span><br><span class="line">                var props = [&apos;year&apos;, &apos;month&apos;];</span><br><span class="line">                props.map(function (item) &#123;</span><br><span class="line">                    var dom = null;</span><br><span class="line">                    item === &apos;year&apos; ? dom = that.$(&apos;#year&apos;) : dom = that.$(&apos;#month&apos;);</span><br><span class="line">                    Object.defineProperty(that.data, item, &#123;</span><br><span class="line">                        get: function () &#123;</span><br><span class="line">                            return dom.value; // 绑定dom, 自动获取到value值</span><br><span class="line">                        &#125;,</span><br><span class="line">                        set: function (newVal) &#123;</span><br><span class="line">                            if (item === &apos;month&apos;) &#123;</span><br><span class="line">                                if (newVal &gt; 12) &#123;</span><br><span class="line">                                    newVal = 1;</span><br><span class="line">                                    that.data.year++;</span><br><span class="line">                                &#125; else if (newVal &lt;= 0) &#123;</span><br><span class="line">                                    newVal = 12;</span><br><span class="line">                                    that.data.year--;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            dom.value = newVal;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">            dateAct: function () &#123;</span><br><span class="line">                var that = this;</span><br><span class="line">                var inputAdd = [&apos;#month&apos;, &apos;#year&apos;];</span><br><span class="line">                that.listenEvent(that.$(&apos;#back&apos;) ,&apos;click&apos;, function () &#123;</span><br><span class="line">                    that.data.month++;</span><br><span class="line">                    that.initDate();</span><br><span class="line">                &#125;);</span><br><span class="line">                that.listenEvent(that.$(&apos;#pre&apos;) ,&apos;click&apos;, function () &#123;</span><br><span class="line">                    that.data.month--;</span><br><span class="line">                    that.initDate();</span><br><span class="line">                &#125;);</span><br><span class="line">                inputAdd.map(function (item) &#123;</span><br><span class="line">                    that.listenEvent($(item) ,&apos;change&apos;, function () &#123;</span><br><span class="line">                        if (item === &apos;#month&apos;) &#123;</span><br><span class="line">                            that.data.month = $(item).value;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            that.data.year = $(item).value;</span><br><span class="line">                        &#125;</span><br><span class="line">                        that.initDate();</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">            initDate: function () &#123;</span><br><span class="line">                var that = this;</span><br><span class="line">                var date = new Date(that.data.year,  that.$(&apos;#month&apos;).value - 1, 1);</span><br><span class="line">                var startDate = date.getDay();</span><br><span class="line">                var allDates =  new Date(that.data.year, that.$(&apos;#month&apos;).value, 0).getDate();</span><br><span class="line">                var tds = document.getElementsByTagName(&apos;td&apos;);</span><br><span class="line">                that.initColor();</span><br><span class="line">                var j = 0;</span><br><span class="line">                startDate = (startDate ? startDate : 7);</span><br><span class="line">                // startDate 表示这一个月份的一号是星期几，当是星期天的时候，要从下一行开始</span><br><span class="line">                for (let i = 0 ; i &lt; 42; i++) &#123;</span><br><span class="line">                    if (i &gt;= startDate) &#123;</span><br><span class="line">                        j &gt;= allDates ? j = 1 : j++;</span><br><span class="line">                        tds[i].innerHTML = j;</span><br><span class="line">                        if(i &lt; allDates + startDate ) &#123;</span><br><span class="line">                            tds[i].onclick = function () &#123;</span><br><span class="line">                                // 这里有bug</span><br><span class="line"></span><br><span class="line">                                </span><br><span class="line">                                that.initColor(that.data.year, that.data.month, i);</span><br><span class="line">                                that.initColor();</span><br><span class="line">                                that.$(&apos;#&apos; + that.inputIdName).value = &apos;&apos;;</span><br><span class="line">                                that.data.selectDays.map(function (item, index, array) &#123;</span><br><span class="line">                                    </span><br><span class="line">                                    that.$(&apos;#&apos; + that.inputIdName).value = item.year + &apos;-&apos; + item.month + &apos;-&apos; + that.tds[item.day].innerHTML;</span><br><span class="line">                                    if (!that.isSingle) &#123;</span><br><span class="line">                                        var min;</span><br><span class="line">                                        that.data.selectDays.map(function (item, index, array) &#123;</span><br><span class="line">                                                if (item.day &lt; that.data.selectDays[0].day) &#123;</span><br><span class="line">                                                    min = item;</span><br><span class="line">                                                &#125; else &#123;</span><br><span class="line">                                                    min = that.data.selectDays[0];</span><br><span class="line">                                                &#125;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        );</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;);</span><br><span class="line">                                that.callBack();</span><br><span class="line">                            &#125;;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            tds[i].onclick = null;</span><br><span class="line">                            tds[i].className = &apos;notClick&apos;;</span><br><span class="line">                             &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        tds[i].className = &apos;notClick&apos;;</span><br><span class="line">                        document.getElementsByTagName(&apos;td&apos;)[i].onclick = null; // 回收 click 事件</span><br><span class="line">                        tds[i].innerHTML = new Date(that.data.year, that.$(&apos;#month&apos;).value - 1, 0).getDate() + 1 -startDate + i ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            initColor: function (year, month, day) &#123;</span><br><span class="line">                </span><br><span class="line">                    var that = this;</span><br><span class="line">                    var _minDate;</span><br><span class="line">                    var _maxDate;</span><br><span class="line">                    if (year) &#123;</span><br><span class="line">                        var obj = &#123;&#125;;</span><br><span class="line">                        obj.year = year;</span><br><span class="line">                        obj.month = month;</span><br><span class="line">                        obj.day = day;</span><br><span class="line">                        if (that.isSingle) &#123;</span><br><span class="line">                            that.data.selectDays[0] = obj;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            that.data.selectDays.push(obj);</span><br><span class="line">                            if (that.data.selectDays.length &gt;= 2) &#123;</span><br><span class="line">                                that.data.selectDays[1] = obj;</span><br><span class="line">                                that.data.selectDays.length = 2;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        that.tds.map(function (item) &#123;</span><br><span class="line">                            item.className = &apos;&apos;;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        </span><br><span class="line">                        that.data.selectDays.map(function (key) &#123;</span><br><span class="line">                </span><br><span class="line">                            ((key.year === that.data.year) &amp;&amp; (key.month === that.data.month)) ? that.tds[key.day].className = &apos;tdActive&apos;  : &apos;&apos; ;</span><br><span class="line">                        &#125;);</span><br><span class="line"></span><br><span class="line">                        if (that.data.selectDays.length === 2) &#123;</span><br><span class="line">                            if (that.data.selectDays.length === 2) &#123;</span><br><span class="line">                                if (that.data.selectDays[0].day &lt; that.data.selectDays[1].day) &#123;</span><br><span class="line">                                    _minDate = that.data.selectDays[0].day;</span><br><span class="line">                                    _maxDate = that.data.selectDays[1].day;</span><br><span class="line">                                &#125; else &#123;</span><br><span class="line">                                    _maxDate = that.data.selectDays[0].day;</span><br><span class="line">                                    _minDate = that.data.selectDays[1].day;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            for (var j = _minDate + 1; j &lt; _maxDate; j++) &#123;</span><br><span class="line">                                if (that.data.selectDays[0].month === that.data.selectDays[1].month &amp;&amp; that.data.selectDays[0].month === that.data.month) &#123;</span><br><span class="line">                                    that.tds[j].className = &apos;timeBar&apos;;</span><br><span class="line">                                &#125; else &#123;</span><br><span class="line">                                    that.tds[j].className = &apos;&apos;;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        // 使用 $() 类似于 jQuery 中的调用写法，用来调用 dom 元素</span><br><span class="line">        // data.year // data.month 表示真实的年和月</span><br><span class="line">        // data 对象， 用来集中管理数据信息</span><br><span class="line"></span><br><span class="line">        // initTable 用于初始化表格，构建日期选择框</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // initData 将data 内的数据和 input 输入框内的数据进行同步，</span><br><span class="line">        // 自动同步</span><br><span class="line">        if (window.dateCanlender !== &apos;undefined&apos;) &#123;</span><br><span class="line">            listenEvent(document.getElementById(&apos;startTime&apos;), &apos;click&apos;, function () &#123;</span><br><span class="line">                $(&apos;#content&apos;).style.display = &apos;block&apos;</span><br><span class="line">            &#125;);</span><br><span class="line">            var dateCanlender = new dateUI(true, &apos;startTime&apos;, function () &#123;</span><br><span class="line">               </span><br><span class="line">            &#125;)</span><br><span class="line">                dateCanlender.initTable();</span><br><span class="line">                dateCanlender.tds = document.getElementsByTagName(&apos;td&apos;);</span><br><span class="line">                dateCanlender.tds = [].slice.call(dateCanlender.tds);</span><br><span class="line">                dateCanlender.reactData();</span><br><span class="line">                var date = new Date();</span><br><span class="line">                dateCanlender.data.year = date.getFullYear();</span><br><span class="line">                dateCanlender.data.month = date.getMonth() + 1;</span><br><span class="line">               </span><br><span class="line">                dateCanlender.initDate();</span><br><span class="line">                dateCanlender.dateAct();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(window))</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    #content &#123;</span><br><span class="line">        display: none;</span><br><span class="line">        border: 2px solid darkgray;</span><br><span class="line">        padding: 10px;</span><br><span class="line">        margin: 50px auto;</span><br><span class="line">        width: 300px;</span><br><span class="line">    &#125;</span><br><span class="line">    #title &#123;</span><br><span class="line">        margin: 10px 0;</span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: space-between;</span><br><span class="line">    &#125;</span><br><span class="line">    #title span, #title input &#123;</span><br><span class="line">        display: inline-block;</span><br><span class="line">        width: 25%;</span><br><span class="line">        text-align: center;</span><br><span class="line">        flex: 1;</span><br><span class="line">    &#125;</span><br><span class="line">    #title input &#123;</span><br><span class="line">        margin: 0 10px;</span><br><span class="line">    &#125;</span><br><span class="line">    #main &#123;</span><br><span class="line">        width: 300px;</span><br><span class="line">    &#125;</span><br><span class="line">    table, table thead &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">    &#125;</span><br><span class="line">    table thead tr &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        margin: 10px 0;</span><br><span class="line">        /*</span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: space-between;</span><br><span class="line">        */</span><br><span class="line">    &#125;</span><br><span class="line">    table td &#123;</span><br><span class="line">        text-align: center;</span><br><span class="line">    &#125;</span><br><span class="line">    .tdActive &#123;</span><br><span class="line">        color: white;</span><br><span class="line">        background-color: skyblue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .timeBar &#123;</span><br><span class="line">        background-color: gray;</span><br><span class="line">    &#125;</span><br><span class="line">    .notClick&#123;</span><br><span class="line">        color: lightgray;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这段代码是使用面向对象的语法写的，面向对象程序设计的主要使用了构造函数和原型的语法。</p>
<p>代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function person () &#123;</span><br><span class="line">    &#125;</span><br><span class="line">person.prototype.eye = 2;</span><br><span class="line">var he = new person();</span><br><span class="line">he.eye // 2</span><br></pre></td></tr></table></figure>
<p>上面的代码中，通过使用 <code>new</code> 操作符创建了 <code>person</code> 构造函数的一个实例，在构造函数中定义了一个属性 <code>eye</code> ，根据在原型链中的继承的特性，使用 <code>new</code> 操作符创建的实例，会继承构造函数上定义的属性和方法，因此，我们可以在构造函数上定义公共属性和方法。</p>
<blockquote>
<p>在通过 <code>new</code> 操作符的过程中发生了什么？</p>
<p>1.创建一个新对象</p>
<p>2.将构造函数的作用域赋给新对象，（这时候 <code>this</code> 指向这个新对象）</p>
<p>3.执行构造函数的代码 （这个新对象添加属性）</p>
<p>4.返回新对象</p>
</blockquote>
<p>在上面的代码中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var dateCanlender = new dateUI(true, &apos;startTime&apos;, function () &#123;</span><br><span class="line">              </span><br><span class="line">           &#125;)</span><br></pre></td></tr></table></figure>
<p>这段代码创建了构造函数 <code>dateUI</code> 的一个新实例。</p>
<p>在构造函数的原型上，给原型添加方法 : <code>initTable</code>   <code>reactData</code>  <code>initDate</code>     <code>initColor</code>     <code>dateAct</code></p>
<p><code>initTable</code>  用来初始化表格，生成表格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">initTable: function () &#123;</span><br><span class="line">               var that = this;</span><br><span class="line">               var title = document.createElement(&apos;div&apos;);</span><br><span class="line">               title.setAttribute(&apos;id&apos;, &apos;title&apos;);</span><br><span class="line">               title.innerHTML = &apos;&lt;span id=&quot;pre&quot;&gt;back&lt;/span&gt;&lt;input type=&quot;number&quot; id=&quot;month&quot;&gt;&lt;input type=&quot;number&quot; id=&quot;year&quot;&gt;&lt;span id=&quot;back&quot;&gt;pre&lt;/span&gt;&apos;</span><br><span class="line">               var main = document.createElement(&apos;div&apos;);</span><br><span class="line">               main.setAttribute(&apos;id&apos;, &apos;main&apos;);</span><br><span class="line">               var table = document.createElement(&apos;table&apos;);</span><br><span class="line">               table.innerHTML = &apos;&lt;thead&gt;&lt;tr&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;/tbody&gt;&apos;;</span><br><span class="line">               main.appendChild(table);</span><br><span class="line">               that.$(&apos;#content&apos;).appendChild(title);</span><br><span class="line">               that.$(&apos;#content&apos;).appendChild(main);</span><br><span class="line">               for (let i = 0; i &lt; that.data.weekDay.length; i++) &#123;</span><br><span class="line">                   that.$(&apos;tr&apos;, that.$(&apos;thead&apos;)[0])[0].innerHTML += &apos;&lt;th&gt;&apos; + that.data.weekDay[i] + &apos;&lt;/th&gt;&apos;;</span><br><span class="line">               &#125;</span><br><span class="line">               var _ROW = 6;</span><br><span class="line">               var _COL = 7;</span><br><span class="line">               for (var i = 0; i &lt; _ROW; i++) &#123;</span><br><span class="line">                   that.$(&apos;tbody&apos;)[0].innerHTML += &apos;&lt;tr&gt;&lt;/tr&gt;&apos;;</span><br><span class="line">                   for (var j = 0; j &lt; _COL; j++) &#123;</span><br><span class="line">                       that.$(&apos;tr&apos;, that.$(&apos;tbody&apos;)[0])[i].innerHTML += &apos;&lt;td&gt;&lt;/td&gt;&apos;;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               that.tds = document.getElementsByTagName(&apos;td&apos;);</span><br><span class="line">               that.tds = [].slice.call(that.tds);</span><br></pre></td></tr></table></figure>
<p>上面中的代码 <code>[].slice.call(that.tds)</code> 将类数组对象 <code>tds</code> 转化为数组，从而可以使用数组的方法</p>
<blockquote>
<p>数组中 <code>slice</code> 的方法</p>
</blockquote>
<p><code>reactData</code>: 将数据变为可以跟踪变化的形式，类似于在 <code>vue</code> 中的，将  <code>data</code> 数据变为可响应式的，使用的是 </p>
<p><code>Object.defineProperty()</code> 方法, <code>getter</code>  <code>setter</code> 等方法构建响应式数据。通过这种方法创建的数据是可以响应式的。</p>
<p>代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reactData: function () &#123;</span><br><span class="line">                var that = this;</span><br><span class="line">                var props = [&apos;year&apos;, &apos;month&apos;];</span><br><span class="line">                props.map(function (item) &#123;</span><br><span class="line">                    var dom = null;</span><br><span class="line">                    item === &apos;year&apos; ? dom = that.$(&apos;#year&apos;) : dom = that.$(&apos;#month&apos;);</span><br><span class="line">                    Object.defineProperty(that.data, item, &#123;</span><br><span class="line">                        get: function () &#123;</span><br><span class="line">                            return dom.value; // 绑定dom, 自动获取到value值</span><br><span class="line">                        &#125;,</span><br><span class="line">                        set: function (newVal) &#123;</span><br><span class="line">                            if (item === &apos;month&apos;) &#123;</span><br><span class="line">                                if (newVal &gt; 12) &#123;</span><br><span class="line">                                    newVal = 1;</span><br><span class="line">                                    that.data.year++;</span><br><span class="line">                                &#125; else if (newVal &lt;= 0) &#123;</span><br><span class="line">                                    newVal = 12;</span><br><span class="line">                                    that.data.year--;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            dom.value = newVal;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;,</span><br></pre></td></tr></table></figure>
<p><code>initDate</code> 用来像表格中填入数据：</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">initDate: function () &#123;</span><br><span class="line">				// 将 this 值存入 that,为了防止在 onclick  事件中 this  值改变的情况</span><br><span class="line">               var that = this;</span><br><span class="line">               var date = new Date(that.data.year,  that.$(&apos;#month&apos;).value - 1, 1);</span><br><span class="line">               // startDate 得到的是当月 1 号的星期几</span><br><span class="line">               var startDate = date.getDay();</span><br><span class="line">               // allDates 得到的是当前月全部的日期</span><br><span class="line">               var allDates =  new Date(that.data.year, that.$(&apos;#month&apos;).value, 0).getDate();</span><br><span class="line">               var tds = document.getElementsByTagName(&apos;td&apos;);</span><br><span class="line">               that.initColor();</span><br><span class="line">               var j = 0;</span><br><span class="line">               startDate = (startDate ? startDate : 7);</span><br><span class="line">               // startDate 表示这一个月份的一号是星期几，当是星期天的时候，要从下一行开始</span><br><span class="line">               // 下面的程序用来向表格内填入天的号数</span><br><span class="line">               for (let i = 0 ; i &lt; 42; i++) &#123;</span><br><span class="line">               	// 判断开始时间，即判断表格中位于 1 号之前的表格</span><br><span class="line">                   if (i &gt;= startDate) &#123;</span><br><span class="line">                       j &gt;= allDates ? j = 1 : j++;</span><br><span class="line">                       tds[i].innerHTML = j;</span><br><span class="line">                       // 定义位于中间的表格可以点击区域</span><br><span class="line">                       if(i &lt; allDates + startDate ) &#123;</span><br><span class="line">                           tds[i].onclick = function () &#123;                                         </span><br><span class="line">                               // 将当前的年 月 表格输存入数组                                </span><br><span class="line">                               that.initColor(that.data.year, that.data.month, i);</span><br><span class="line">                               that.initColor();</span><br><span class="line">                               // 清空input 框内的数据</span><br><span class="line">                               that.$(&apos;#&apos; + that.inputIdName).value = &apos;&apos;;</span><br><span class="line">                               that.data.selectDays.map(function (item, index, array) &#123;                                    </span><br><span class="line">                                   that.$(&apos;#&apos; + that.inputIdName).value = item.year + &apos;-&apos; + item.month + &apos;-&apos; + that.tds[item.day].innerHTML;</span><br><span class="line">                                   if (!that.isSingle) &#123;</span><br><span class="line">                                       var min;</span><br><span class="line">                                       that.data.selectDays.map(function (item, index, array) &#123;</span><br><span class="line">                                               if (item.day &lt; that.data.selectDays[0].day) &#123;</span><br><span class="line">                                                   min = item;</span><br><span class="line">                                               &#125; else &#123;</span><br><span class="line">                                                   min = that.data.selectDays[0];</span><br><span class="line">                                               &#125;</span><br><span class="line">                                           &#125;</span><br><span class="line">                                       );</span><br><span class="line">                                   &#125;</span><br><span class="line">                               &#125;);</span><br><span class="line">                               // 点击事件完成之后调用回调函数</span><br><span class="line">                               that.callBack();</span><br><span class="line">                           &#125;;</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                       // 使用 onclick = null 回收点击事件</span><br><span class="line">                           tds[i].onclick = null;</span><br><span class="line">                           tds[i].className = &apos;notClick&apos;;</span><br><span class="line">                            &#125;</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       tds[i].className = &apos;notClick&apos;;</span><br><span class="line">                       document.getElementsByTagName(&apos;td&apos;)[i].onclick = null; // 回收 click 事件</span><br><span class="line">                       tds[i].innerHTML = new Date(that.data.year, that.$(&apos;#month&apos;).value - 1, 0).getDate() + 1 -startDate + i ;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;,</span><br></pre></td></tr></table></figure>
<p>在上段代码中使用的日期对象的一些方法；</p>
<p><code>initColor</code> ：用来重置表格的颜色</p>
<p><code>dateAct</code> 用来定义日历的一些行为</p>
<h4 id="代码总结"><a href="#代码总结" class="headerlink" title="代码总结:"></a>代码总结:</h4><p>1.使用面向对象的写法进行编写的，而非之前的面向过程编写</p>
<p>2.熟悉 js 中关于使用日期事件的一些方法</p>
<h4 id="在代码中的一些问题"><a href="#在代码中的一些问题" class="headerlink" title="在代码中的一些问题:"></a>在代码中的一些问题:</h4><p>1.代码逻辑混乱，这一部分需要加强</p>
<p>2.代码中需要规范，包括注释，变量的定义</p>
<p>3.使用面向对象的写法的时候，需要知道使用 使用 <code>property</code> 构建函数的时候发生了什么，以及代码中 <code>this</code> 的指向值</p>
<h4 id="little-Tips"><a href="#little-Tips" class="headerlink" title="little  Tips"></a>little  Tips</h4><ol>
<li><p><code>addEventListener</code>  <code>attachEvent</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&apos;btn&apos;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	window.onload = function () &#123;</span><br><span class="line">      var button = document.getElementById(&apos;btn&apos;);</span><br><span class="line">      Good.addEventListener(&apos;click&apos;, function () &#123;</span><br><span class="line">			console.log(this); // this 指向的是 id 为 good 的 dom 元素</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>addEventistener</code> 用于监听事件</p>
<p><code>target.addEventListenter(event, fn , [userCapture])</code></p>
<p><code>event</code> : 表示要进行监听的事件 [string]</p>
<p><code>fn</code> :表示 监听到事件之后的回调函数</p>
<p><code>userCapture</code> : 表示事件是应用到冒泡阶段还是应用到捕获阶段  [boolean]</p>
</blockquote>
<p><strong>在 <code>addEventListener</code>中定义的 <code>this</code> 值指向的是 tartget 对象</strong></p>
<p>在 IE 下 使用 <code>attachEvent</code> 来实现类似 <code>addEventListener</code> 的行为:</p>
<p>实现兼容性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function listenEvent(dom,event,fn) &#123;</span><br><span class="line">            </span><br><span class="line">            if (dom.attachEvent) &#123;</span><br><span class="line">                dom.attachEvent(&apos;on&apos; + event, fn);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dom.addEventListener(event, fn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>2.使用 <code>Date</code>对象对于得到月份的天数以及当前月第一天的星期几的求法是不同的</p>
]]></content>
      <categories>
        <category>代码集</category>
      </categories>
      <tags>
        <tag>日历</tag>
      </tags>
  </entry>
  <entry>
    <title>生活</title>
    <url>/2017/08/26/%E7%94%9F%E6%B4%BB/</url>
    <content><![CDATA[<h4 id="圣经"><a href="#圣经" class="headerlink" title="圣经"></a>圣经</h4><blockquote>
<p><code>你们看那天上的飞鸟，也不种，也不收，也不积蓄在仓里，你们的天父尚且养活它。你们不比飞鸟贵重得多吗？”</code></p>
<p>​                                                                                                                    (耶稣所讲的比喻，载于 马太福音 6:26)</p>
</blockquote>
<p>前两天心里面有些焦虑，就想到了这句话。这句话在知乎里面看到过，当时记了下来，现在想一想，这句话挺适合现在的我的心态的。这句话在圣经书上看到过，当时还比较小，只是那圣经书当作故事书来读的，一来那时候家里没有什么书，父亲是农民，也没有给我买过什么书，那本圣经看的挺有趣。二来，其实那本书还挺不错的，家里的圣经书是带插画的，从上帝创造天地开始到耶稣基督升天结束，大约五十几章，每一章都是一个故事，配有插图。故事讲的生动有趣。自己看的津津有味的。现在回头想想，圣经的故事连小孩子都能吸引，基督教成为三大宗教之一也不是没有道理的。</p>
<p>人生哪里有这么多的挫折与逆境，不如意这十之八九，可与人言着不过二三，你自认为的困苦，只是一辈子的常态。</p>
<p>每天保持向上的力量，努力工作，认真学习，不要想遥远的未来，未来如何，你怎么也想不到，不要幻想将来，将来不是来自于幻想，来自于每天一点一滴的积累。</p>
<p>世上的工作无非苦与累，想要安逸，没有错，你是否为了安逸去努力。</p>
<p>脚踏实地，才能一步步的走的更远，不要想将来，不要想过去，把自己每天的事情做好。</p>
<p>你太懒了，也太怂了，你能否可以克服自己？</p>
<p>饮冰十年，难凉热血。</p>
<p>不要想着战胜困难，先要战胜自己。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>浏览器渲染过程</title>
    <url>/2018/03/12/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="浏览器渲染过程以及原理"><a href="#浏览器渲染过程以及原理" class="headerlink" title="浏览器渲染过程以及原理"></a>浏览器渲染过程以及原理</h2><h3 id="浏览器渲染的过程"><a href="#浏览器渲染的过程" class="headerlink" title="浏览器渲染的过程"></a>浏览器渲染的过程</h3><p>对于浏览器而言， 浏览器请求， 加载， 渲染一个页面的时候，所要花费的时间主要在下面几个过程中:</p>
<ol>
<li>DNS 查询（DNS 根据服务器地址查找到IP地址）</li>
<li>TCP 连接（用于连接客户端与服务器， 包含三次握手，四次挥手的过程）</li>
<li>HTTP 请求以及响应（请求响应数据）</li>
<li>服务器响应（后端响应数据）</li>
<li>客户端渲染  </li>
</ol>
<p>对于第五个部分客户端渲染的过程中， 这一部分过程主要是渲染树的构建，布局，以及绘制， 具体而言， 主要是下面几个过程：</p>
<ol>
<li>处理 HTML 标记并且构建 DOM 树。</li>
<li>处理 CSS 标记并且构建 CSSOM 树。</li>
<li>将 DOM 以及 CSSOM 合并为一个渲染树。</li>
<li>根据渲染树进行布局,以计算每个节点的几何信息。</li>
<li>将各个节点绘制到屏幕上去。</li>
</ol>
<p>在上面的过程中，如果DOM或者CSSOM被修改,那个这个过程需要重复执行，重新在屏幕上进行渲染。</p>
<h3 id="阻塞渲染"><a href="#阻塞渲染" class="headerlink" title="阻塞渲染"></a>阻塞渲染</h3><p>在一个网页中， CSS被视为阻塞性的资源， 当 CSSOM 被构建的时候， 其他的内容将不会被处理， 因此， 只有当 CSSOM 构建完毕之后其他内容才可能被加载。对于 <code>javascript</code> 也是类似的效果， 当浏览器遇到一个 script 标记的时候，DOM 构建将会暂停，知道脚本完成执行。</p>
<p>使用 javascript 可以改变 DOM 以及 CSSOM， 而当 DOM 或者 CSSOM 被改变的时候， 这两个树均会重新进行绘制， 对于 CSSOM 因为是阻塞性资源, 在构建的时候， JavaScript 将会延迟执行， 直到CSSOM 构建完毕。</p>
<p>在实际使用的时候应该遵循下面两个原则：</p>
<ol>
<li>CSS资源要优于JavaScript 资源进行加载。</li>
<li>尽量避免使用 JavaScript 进行DOM 的操作。</li>
</ol>
<h3 id="解决渲染阻塞的几种方法"><a href="#解决渲染阻塞的几种方法" class="headerlink" title="解决渲染阻塞的几种方法"></a>解决渲染阻塞的几种方法</h3><h4 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h4><p>对于 CSS 而言， 浏览器解析 CSS 用于创建  CSSOM 树， 因此在 CSS 编写的过程中要注意对于 CSS 解析速度的影响：</p>
<ol>
<li><p>提高CSS页面的加载速度</p>
<p>提高页面的加载速度主要是通过将样式尽量写在单独的文件里面， 将 CSS样式作为单独的文件进行引入， 这样做的目的不仅仅是减少页面体积， 并且可以利用 CSS 文件的缓存以及重用， 提高文件的加载速度。</p>
<p>少用 <code>@import</code> 用于引入 CSS 文件, 使用 <code>@import</code> 会影响 CSS 文件的加载速度。</p>
</li>
<li><p>加快解析速度， 提高解析性能。</p>
<p>减少css 样式的嵌套层数， 对于 CSS 的嵌套层数尽量不要超过三层, 过多的嵌套层数会影响到CSS的解析速度。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>浏览器渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式：基础方法</title>
    <url>/2019/01/20/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>下面是一些正则表达式的一些常用方法：</p>
<h1 id="正则表达式中的属性和方法"><a href="#正则表达式中的属性和方法" class="headerlink" title="正则表达式中的属性和方法"></a>正则表达式中的属性和方法</h1><p>创建了正则表达式之后， 返回的是一个正则表达式的实例，返回的实例中包含有正则的一些属性方法。</p>
<p>我们可以在 控制台中打印正则实例， 可以看到其继承的所有的属性和方法如下：</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let pattern = /.at/g;</span><br><span class="line">let str = &apos;bat, cat&apos;;</span><br><span class="line">let matches = pattern.exec(str);</span><br><span class="line">console.log(&apos;lastIndex&apos;, pattern.lastIndex); // 3</span><br></pre></td></tr></table></figure>
<h3 id="一些属性"><a href="#一些属性" class="headerlink" title="一些属性"></a>一些属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lastIndex</code></td>
<td>下一次匹配在字符串中的起始位置,  当前匹配到字符串的下一个字符的位置 ， 注意， 当前缺少修饰符 <code>g</code> 的时候， 这个值始终是 0</td>
<td>上面的例子中， 匹配完了  bat 之后， 后面将要进行匹配的是 <code>,</code> 位置为 3</td>
</tr>
<tr>
<td><code>flags</code>(es6)</td>
<td>获取当前正则的修饰符</td>
<td>g</td>
</tr>
<tr>
<td><code>global</code></td>
<td>布尔值， 表示是否设置了 g 标志</td>
<td><code>pattern.global</code>: true</td>
</tr>
<tr>
<td><code>ignoreCase</code></td>
<td>布尔值， 表示是否设置了 i 标志</td>
<td></td>
</tr>
<tr>
<td><code>multiline</code></td>
<td>表示是否设置了 m</td>
<td></td>
</tr>
<tr>
<td><code>sticky</code></td>
<td>表示是否这种了 y 标志</td>
<td></td>
</tr>
<tr>
<td><code>dotall</code> es2018</td>
<td>表示是否含有 s 修饰符</td>
<td></td>
</tr>
<tr>
<td><code>source</code></td>
<td>表示当前的匹配字符串</td>
<td>“.at”</td>
</tr>
</tbody>
</table>
<p>Tips:</p>
<ul>
<li><p>使用 <code>lastIndex</code> 是可以改变的， 使用 <code>lastIndex</code> 可以决定需要进行开始匹配的位置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'.at'</span>, <span class="string">'g'</span>);</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">"cat, bat"</span>;</span><br><span class="line"></span><br><span class="line">pattern.lastIndex = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">let</span> matches = pattern.exec(str);</span><br><span class="line"><span class="comment">// matches</span></span><br><span class="line"><span class="comment">// [ 'bat', index: 5, input: 'cat, bat', groups: undefined ]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="一些方法"><a href="#一些方法" class="headerlink" title="一些方法"></a>一些方法</h3><h4 id="RegExp-prototype-test"><a href="#RegExp-prototype-test" class="headerlink" title="RegExp.prototype.test"></a>RegExp.prototype.test</h4><p>使用 test 方法用于判断在一个字符串中是含有能够匹配的到字符：</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/test/g</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'test string'</span>;</span><br><span class="line">pattern.test(str); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/[cb]at/g</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">"cat, bat"</span>;</span><br><span class="line">pattern.test(str); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="RegExp-prototype-exec"><a href="#RegExp-prototype-exec" class="headerlink" title="RegExp.prototype.exec"></a><code>RegExp.prototype.exec</code></h4><p> 使用  <code>exec</code> 方法用于获取到匹配到的数组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let pattern = /.at/;</span><br><span class="line">let str = &quot;cat, bat&quot;;</span><br><span class="line"></span><br><span class="line">let matches = pattern.exec(str);</span><br><span class="line">// [ &apos;cat&apos;, index: 0, input: &apos;cat, bat&apos;, groups: undefined ]</span><br><span class="line">// 当前匹配到 字符串是 cat， 匹配的字符串在原字符串中的开始位置为 0， input： 当前被匹配的字符串为 </span><br><span class="line">// &apos;cat, bat&apos;</span><br></pre></td></tr></table></figure>
<p>如果有匹配到值的话， 返回一个数组， 如果没有匹配到值， 返回 <code>null</code>;</p>
<p>使用 <code>exec</code> 方法返回的是一个数组，这个数组包含被匹配到的字符串，（在存在捕获组的情况下， 获取到的被匹配的字符串不止一个） 比如上面的代码中， 匹配到了 <code>cat</code>  但是这个数组实例上面还定义了一些属性, 例如上面的数组中包含了 <code>index</code>, <code>input</code> 以及 <code>groups</code> ， 这些属性表示的是被匹配到的字符串的相关信息， 这些属性的含义如下：</p>
<ul>
<li><code>index</code>: index 表明匹配数组中第一个值在字符串中的位置。</li>
<li><code>input</code>：input 表明当前匹配的字符串</li>
<li><code>groups</code>: groups 是 es2018 中提出的一个新的方法  </li>
</ul>
<blockquote>
<p>注意： 当正则表达式中包含有全局匹配 <code>g</code> 的时候，每次调用 <code>exec</code> 都会在上一次匹配的位置之后继续进行匹配,  当没有设置全局匹配 g 的时候， 多次调用  <code>exec</code> 只会调用第一次匹配到的信息。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'.at'</span>, <span class="string">'g'</span>);</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">"cat, bat, dat"</span>;</span><br><span class="line"><span class="keyword">let</span> matches = pattern.exec(str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(matches) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(pattern.lastIndex, matches[<span class="number">0</span>]);</span><br><span class="line">  matches = pattern.exec(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3 'cat'</span></span><br><span class="line"><span class="comment">// 8 'bat'</span></span><br><span class="line"><span class="comment">// 13 'dat'</span></span><br></pre></td></tr></table></figure>
<h3 id="应用正则表达式的一些方法："><a href="#应用正则表达式的一些方法：" class="headerlink" title="应用正则表达式的一些方法："></a>应用正则表达式的一些方法：</h3><h4 id="String-prototype-match"><a href="#String-prototype-match" class="headerlink" title="String.prototype.match"></a><code>String.prototype.match</code></h4><p><code>str.match(regexp)</code></p>
<p>接收一个正则表达式， 如果有匹配到的字符串， 将会返回一个数组， 数组的第一项是进行匹配的字符串， 后面几项是获取到的捕获组的结果， 如果没有匹配到的字符串， 那么将会返回 null。</p>
<blockquote>
<p>注意， 在使用 <code>match</code> 方法的时候加不加标识符 g 是有区别的， 当正则中不含有 g 标识符的时候， 返回的结果是标准的匹配格式： 数组的第一个元素是整体匹配的内容，其他元素是分组捕获的内容， 如果加上了 g 符号， 那么返回的是包含有所有匹配的字符串内容：</p>
<p>例如下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/g;</span><br><span class="line">&gt; var string = &quot;2017-06-12&quot;;</span><br><span class="line">&gt; console.log( string.match(regex) );</span><br><span class="line">&gt; // [&quot;2017-06-12&quot;] 没有获得到捕获组 括号内的匹配项</span><br><span class="line">&gt; // 当正则表达式中不含有 g 标识符的时候</span><br><span class="line">&gt; regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">&gt; // [&quot;2017-06-12&quot;, &quot;2017&quot;, &quot;06&quot;, &quot;12&quot;]`String.prototype.search`</span><br><span class="line">&gt; // 返回内容为整体匹配以及分组匹配的内容. 	l;`	</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="String-prototype-search"><a href="#String-prototype-search" class="headerlink" title="String.prototype.search"></a><code>String.prototype.search</code></h4><p><code>str.search(regexp)</code></p>
<p>接收一个正则表达式， 返回在字符串中第一次被匹配到的位置， 如果没有匹配到， 返回 -1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let str = &apos;hello world&apos;;</span><br><span class="line">str.search(/world/); // 6</span><br></pre></td></tr></table></figure>
<p>使用 <code>indexOf</code> 方法也可以用来查找到字符串中的某一个字符， 相比 <code>indexOf</code> 方法， 个人认为 <code>search</code></p>
<p> 方法的优点在于可以借助于正则表达式中的一些功能， 比如， 我们可以不区分大小写的进行查找字符串中的某一个单词：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"search Word"</span>;</span><br><span class="line">str.search(<span class="regexp">/word/i</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p><strong>当我们使用 <code>search</code> 方法的时候， 当向 search中传入字符串的参数的时候， 字符串参数会被转换为正则表达式</strong></p>
<p>如下：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"2019.02.05"</span>;</span><br><span class="line">str.search(<span class="string">'.'</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 因为上面的方法中转换为了 str.search(/./); 相当于匹配任意的字符， 从而匹配到第一个字符， 匹配到的位置为 0</span></span><br></pre></td></tr></table></figure>
<h4 id="String-prototype-replace"><a href="#String-prototype-replace" class="headerlink" title="String.prototype.replace"></a><code>String.prototype.replace</code></h4><p><code>str.replace(regexp, replaceStr)</code></p>
<p>使用 replace 方法可以实现对于匹配到的字符串进行替换, 匹配过程中不会改变原来的进行匹配的字符串，返回值为进行匹配完成的字符串。</p>
<p>注意： 使用 <code>replace</code> 方法的时候 <code>replaceStr</code> 中使用 <code>$1</code>, <code>$2</code> 以及 <code>$3</code> 可以表示 <code>RegExp.$1</code>, <code>RegExp.$2</code></p>
<p><code>RegExp.$3</code>  </p>
<p>如下， 转换日期的格式问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let str = &apos;2018-02-02&apos;;</span><br><span class="line">let regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">str.replace(regex, &apos;$3/$2/$1&apos;); // 02/02/2018</span><br></pre></td></tr></table></figure>
<p>如下， 隐藏手机号码中间四位的数字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let str = &apos;15656568620&apos;;</span><br><span class="line">let regex = /(\d&#123;3&#125;)(\d&#123;4&#125;)(\d&#123;4&#125;)/;</span><br><span class="line">str.replace(regex, &apos;$1****$3&apos;);</span><br><span class="line">// 156****8620</span><br></pre></td></tr></table></figure>
<p>使用 <code>replace</code> 可以实现更为强大的功能， 因为第二个参数的 <code>replaceStr</code> 可以有多个具有特殊含义的字符：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述符</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$1</code> <code>$2</code> … <code>$99</code></td>
<td>匹配地 <code>$1</code> , <code>$2</code> … <code>$99</code> 分组捕获的文本</td>
</tr>
<tr>
<td><code>$&amp;</code></td>
<td>匹配到的子串文本</td>
</tr>
<tr>
<td>$`</td>
<td>匹配到的子串的左边文本</td>
</tr>
<tr>
<td>$’</td>
<td>匹配到的子串的</td>
</tr>
<tr>
<td>$$</td>
<td>表示美元符号</td>
</tr>
<tr>
<td>其他符号</td>
<td>符号本身</td>
</tr>
</tbody>
</table>
<p>如下， 我们想要将一段金钱文字都添加上一个 <code>$</code> 符号：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'100, 200, 300'</span>;</span><br><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/(\d+)/g</span>;</span><br><span class="line">str.replace(regex, <span class="string">'$$ $&amp;'</span>);</span><br><span class="line"><span class="comment">// $100, $200, $300</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 <code>replace</code> 我们不仅仅可以实现对于一串字符串中某个字符的替换， 更强大的作用在于， 使用 <code>replace</code> 可以实现对于匹配到的字符串进行统一处理， 这样， 我们就无需手动查找字符串中的某个值，然后逐个替换了。</p>
</blockquote>
<p><strong><a name="replaceFn">replace 第二个参数除了接受一个字符串之外， 还可以接受一个函数</a></strong></p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceStr</span> (<span class="params">matchChar, captureChar, charIndex, matchStr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.table([&#123; matchChar, captureChar, charIndex, matchStr &#125;]);</span><br><span class="line">  <span class="keyword">return</span> captureChar ? captureChar.toUpperCase() : <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将连字符相连的单词转换为驼峰式的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">camelize</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="regexp">/-(\w)/g</span>, replaceStr)</span><br><span class="line">&#125;</span><br><span class="line">camelize(<span class="string">"my-component"</span>);</span><br></pre></td></tr></table></figure>
<p>最终打印结果如下：</p>
<img src="/2019/01/20/正则表达式：基础方法/replace.jpg">
<p>上面各个参数如下：</p>
<table>
<thead>
<tr>
<th>matchChar(第一个参数)</th>
<th>captureChar(第二个参数)</th>
<th>charIndex(第三个参数)</th>
<th>matchStr(第四个参数)</th>
</tr>
</thead>
<tbody>
<tr>
<td>正则匹配匹配到的字符串</td>
<td>捕获组捕获到的字符</td>
<td>matchChar 在整个字符串中的起始位置</td>
<td>被匹配的字符串</td>
</tr>
</tbody>
</table>
<p>注意： 当匹配正则中没有 <code>()</code> 也就是没有捕获组的时候， 参数总体向前挪动， 最后一个参数为  <code>undefined</code></p>
<p>例如上面的代码中：修改为如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceStr</span> (<span class="params">matchChar, captureChar, charIndex, matchStr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.table([&#123; matchChar, captureChar, charIndex, matchStr &#125;]);</span><br><span class="line">  <span class="comment">// return captureChar ? captureChar.toUpperCase() : '';</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">camelize</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="regexp">/-\w/g</span>, replaceStr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">camelize(<span class="string">"my-component"</span>);</span><br></pre></td></tr></table></figure>
<p>最终打印结果如下：</p>
<img src="/2019/01/20/正则表达式：基础方法/vueCodeReplace1.jpg">
<p>上面可以看到， 当正则中没有捕获组了之后， 捕获组参数 <code>captureChar</code> 消失掉了， <code>charIndex</code> 以及 <code>matchStr</code> 参数向前挪动了一位， 从而导致最后一位为 <code>undefined</code></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol>
<li><p>使用 <code>$1</code> <code>$2</code> .. 可以获取到被匹配到的捕获组中的数据， <code>$1</code> 获取到第一个捕获组数据， <code>$2</code> 获取到第二个捕获组数据， 依次类推</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">str = <span class="string">'2018-02-02'</span>;</span><br><span class="line">regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line">regex.test(str);</span><br><span class="line"><span class="built_in">RegExp</span>.$<span class="number">1</span> <span class="comment">// 2018</span></span><br><span class="line"><span class="built_in">RegExp</span>.$<span class="number">2</span> <span class="comment">// 02</span></span><br><span class="line"><span class="built_in">RegExp</span>.$<span class="number">3</span> <span class="comment">// 02</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以在正则中使用 <code>\1</code> 或者 <code>\2</code> 之类的表示引用分组 <code>$1</code>  <code>$2</code> ….， 例如： </p>
<p>我们想要匹配如下的日期格式：</p>
<p>2019-02-05</p>
<p>2019.02.05</p>
<p>2019/02/05</p>
<p>我们注意到， 对于   <code>-</code> 或 <code>.</code> 或 <code>/</code> 是重复使用的， 因此， 我们可以在正则表达式中引用这个分组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let regex = /\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;(-|\/|\.)\d&#123;2&#125;/;</span><br><span class="line">let str = &apos;2019-02-05&apos;;</span><br><span class="line">regex.test(str); // true</span><br></pre></td></tr></table></figure>
<p>但是上面的正则也可以匹配到 2019-02.05 这样的格式；</p>
<p>当匹配的字符串中出现重复匹配的内容， 并且匹配规则相同的时候， 我们可以使用分组引用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let regex = /\d&#123;4&#125;(-|/\|\.)\d&#123;2&#125;\1\d&#123;2&#125;/;</span><br></pre></td></tr></table></figure>
<p>如下： 匹配 html 中的匹配标签：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> html = <span class="string">"&lt;p&gt;我是一段文字&lt;/p&gt;"</span>;</span><br><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/&lt;([^&gt;]+)&gt;[\d\D]*&lt;\/\1&gt;/</span>;</span><br><span class="line">regex.test(html); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 注： 这里的 [\d\D] 表示匹配 \d 或 \D, 也就是匹配任意的字符</span></span><br><span class="line"><span class="comment">// 匹配含有 class 的元素属性</span></span><br><span class="line">html = <span class="string">"&lt;p class="</span>content<span class="string">"&gt;我是一段文字&lt;/p&gt;"</span>;</span><br><span class="line">regex = <span class="regexp">/&lt;([^&gt;]+).*&gt;[\d\D]*&lt;\/\1&gt;/</span>;</span><br><span class="line">regex.test(html) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>获取数组中特定值的数组</title>
    <url>/2018/06/11/%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E4%B8%AD%E7%89%B9%E5%AE%9A%E5%80%BC%E7%9A%84%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>有如下题目：</p>
<p>根据指定元素，在数组里面找出类数组。比如数组 [2, 3, 5, 7] ，指定元素 5，则类数组是 [2,, 3] 和 [5]，因为上面两个数组的元素之和相加为5。</p>
<p>自己想了一下， 实现方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">** description 得到</span></span><br><span class="line"><span class="comment">** arr 传入的数组</span></span><br><span class="line"><span class="comment">** value 得到的类数组的值</span></span><br><span class="line"><span class="comment">** maxLen 类数组的最大长度</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compile</span>(<span class="params">arr, value, maxLen = arr.length</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!arr.length || !value) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> tempArr = [];</span><br><span class="line">    <span class="keyword">const</span> len = arr.length;</span><br><span class="line">    <span class="keyword">let</span> nowIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (nowIndex &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tempArr.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> temp = [];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> tempArr) &#123;</span><br><span class="line">                temp.push([...item, arr[nowIndex]]);</span><br><span class="line">            &#125;</span><br><span class="line">            tempArr = [...tempArr, ...temp];</span><br><span class="line">        &#125;</span><br><span class="line">        tempArr.push([arr[nowIndex]]);</span><br><span class="line">        nowIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">    result = tempArr.filter(<span class="function"><span class="params">arr</span> =&gt;</span> <span class="function">(<span class="params">arr.reduce((pev, now</span>) =&gt;</span> (pev = pev + now) &amp;&amp; pev, <span class="number">0</span>) === value) &amp;&amp; (arr.length &lt;= maxLen) );</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现的效果如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">compile([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">5</span>)  <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>代码集</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端touch事件</title>
    <url>/2017/08/19/%E7%A7%BB%E5%8A%A8%E7%AB%AFtouch%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h4 id="touch事件"><a href="#touch事件" class="headerlink" title="touch事件"></a>touch事件</h4><p>当我们手指触摸屏幕的时候，touch事件有这几个事件:</p>
<p>touchstart : 当手指触摸手机屏幕的时候触发  </p>
<p>touchmove : 当手指当手机屏幕上移动的时候触发  </p>
<p>touchend: 当手指移开手机屏幕的时候触发  ，事件方法应该在 <code>touchend</code> 中定义调用。</p>
<p>touchcancel: 这个事件在 uc 浏览器上，当我们在页面上进行左右滑动的时候会被触发  ,用于防止误操作</p>
<a id="more"></a>
<h4 id="touch-事件对象"><a href="#touch-事件对象" class="headerlink" title="touch 事件对象"></a>touch 事件对象</h4><p>touch事件对象返回了下面几个属性:  </p>
<p>touches: 当前屏幕上所有触摸点的集合 ,当只有一个触摸点的时候，使用 touches[0] 获得触摸对象</p>
<p>targetTouches: 当前对象上所有触摸点的集合  </p>
<p>changedTouched: 自从变化之后的所有touch对象数组  </p>
<h5 id="touch-事件返回的对象中的属性集合"><a href="#touch-事件返回的对象中的属性集合" class="headerlink" title="touch 事件返回的对象中的属性集合"></a>touch 事件返回的对象中的属性集合</h5><p>返回的触摸点对象如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TouchList &#123;</span><br><span class="line">length: 1</span><br><span class="line">0: Touch</span><br><span class="line">clientX: 57.36600112915039</span><br><span class="line">clientY: 31.8700008392334</span><br><span class="line">force: 1</span><br><span class="line">identifier: 0</span><br><span class="line">pageX: 57.36600112915039</span><br><span class="line">pageY: 31.8700008392334</span><br><span class="line">radiusX: 36.65040588378906</span><br><span class="line">radiusY: 36.65040588378906</span><br><span class="line">rotationAngle: 0</span><br><span class="line">screenX: 547</span><br><span class="line">screenY: 167</span><br><span class="line">target: div#demo</span><br><span class="line">__proto__: Touch</span><br><span class="line">__proto__: TouchList</span><br></pre></td></tr></table></figure>
<p>各个触摸点的属性解释如下:  </p>
<p>clientX，clientY: 触摸点在视口中的距离  </p>
<p>pageX, pageY:触摸点在html文档中的距离，当html文档的宽度超过视口的宽度的时候， pageX = clientX + 超出的那一部分距离  </p>
<p>screenX, screenY: 触摸点距离屏幕的距离  </p>
<p>target: touch事件作用到的事件对象  </p>
<h4 id="在uc浏览器下遇到的问题"><a href="#在uc浏览器下遇到的问题" class="headerlink" title="在uc浏览器下遇到的问题"></a>在uc浏览器下遇到的问题</h4><p>使用uc浏览器的时候遇到了一个问题，我想要做导航栏随着手指移动而滑动的效果，在android 系统上chrome浏览器表现正常，但是在uc浏览器上出现bug, 手指滑动屏幕的时候导航栏不滑动，当手指离开的时候，导航栏出现滑动效果，貌似滑动效果只被触发了一次，touchend 事件消失，被touchcancel替代:</p>
<p>解决办法: 在touchmove的时候阻止默认行为，<del>监听touchcancel 替代 touchend事件:</del></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch(event) &#123;</span><br><span class="line">  switch (event.type) &#123;</span><br><span class="line">    case &apos;touchstart&apos;:</span><br><span class="line">    	....</span><br><span class="line">    	break;</span><br><span class="line">    case &apos;touchmove&apos;:</span><br><span class="line">    	....</span><br><span class="line">    	event.preventDefault();</span><br><span class="line">    	break;</span><br><span class="line">    case &apos;touchend&apos;:</span><br><span class="line">    	....</span><br><span class="line">    	break;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>情况并不像我之前想的那样，<code>touchcancel</code> 的行为并不是类似于 <code>touchend</code> </p>
<h4 id="touchcancel-事件"><a href="#touchcancel-事件" class="headerlink" title="touchcancel 事件"></a>touchcancel 事件</h4><p><code>touchcancel</code> 从字面意思上来讲，是取消<code>touch</code> 操作的意思，在 MDN 上是这样解释的: </p>
<blockquote>
<p>The <code>touchcancel</code> event is fired when a touch point has been disrupted in an implementation-specific manner (for example, too many touch points are created).\</p>
<p><code>touchcancel</code> 事件是这样被触发的：当触摸点被一种特殊的执行方法被破坏，（例如，创建了太多的触摸点）</p>
</blockquote>
<p>我是这样理解的： <code>touchcancel</code> 事件被触发是因为:当我们使用手机操作的时候，例如点击按钮操作，我们在 <code>touchend</code> 事件中定义了点击按钮后调用的方法，如果我们误操作，比如手指在按钮上左右滑动的时候，<code>touchcancel</code> 事件就会被紧跟着被调用（不同于点击事件，浏览器会认为在手机屏幕上的左右滑动是误操作），取消 <code>touchend</code> 事件，从<code>touchend</code> 事件中的方法不会被执行。</p>
<p>当手指在按钮上下滑动的时候，<code>touchcancel</code> 事件是不会被调用的。可以把<code>touchcancel</code> 事件视为防止误操作事件。</p>
]]></content>
      <tags>
        <tag>移动端touch事件</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊js中的类</title>
    <url>/2018/05/15/%E8%81%8A%E8%81%8Ajs%E4%B8%AD%E7%9A%84%E7%B1%BB/</url>
    <content><![CDATA[<p>对于js 中类的使用，自己平常工作的时候也有用到， 但是只是一些浅显的知识，实际上， 在 js 中如何使用类， 对于类的更深一步的理解，还是有很多的东西需要进行了解, 纸上得来终觉浅， 绝知此事要躬行，作为一名程序员更重要的还是要多写， 多练， 在练习中不断成长。</p>
<p>实现类的机制在 js 中有两种方法： <code>prototype</code> 以及   es6 中<code>class</code> 关键字， 下面分别就这两种探讨一下 <code>js</code> 中类的形成：</p>
<h3 id="使用-prototype-实现类"><a href="#使用-prototype-实现类" class="headerlink" title="使用 prototype 实现类"></a>使用 <code>prototype</code> 实现类</h3><h4 id="什么是-prototype"><a href="#什么是-prototype" class="headerlink" title="什么是 prototype"></a>什么是 <code>prototype</code></h4><p>在 <code>js</code> 中创建对象的时候，对象中默认存在一个 <code>prototype</code>（在 Chrome,  Safari, Firefox 中的对象上这个属性被称作 <code>_proto_</code>） 属性，这个属性是一个 <code>指针</code>，指向一个对象， 这个对象被称作原型对象， 原型对象上的属性是可以通过对象访问到的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">obj._proto_ = &#123; <span class="attr">name</span>: <span class="string">"张宁宁"</span> &#125;;</span><br><span class="line">obj.name <span class="comment">// 张宁宁</span></span><br></pre></td></tr></table></figure>
<p>想要了解这个过程，我们需要知道当我们在使用 <code>.</code> 或者 <code>[]</code> 查找元素属性的时候，元素属性是如何被查找到的。</p>
<p><strong>当在对象中查找某一个元素属性的时候， 会首先在对象本身上进行属性查找， 如果对象本身上没有查找到对象属性， 那么就会在对象的原型上进行查找。如果在对象本身上已经查找到了， 那么返回这个属性的值</strong></p>
<p>上面的例子中， 虽然我们没有在 <code>obj</code> 上面定义一个 <code>name</code> 属性，但是我们在 <code>obj</code> 对象的原型上定义了一个 <code>name</code> 属性，因此还是可以查找到的。同样， 对于定义在 <code>prototype</code> 上的属性，使用 <code>for in</code> 操作符也是可以访问到的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name*</span></span><br></pre></td></tr></table></figure>
<p>使用<code>hasOwnProperty</code> 方法可以判断定义的属性是在对象本身上面还是在原型上面。</p>
<p>注意： 使用 <code>Object.keys</code> 是不能获得到定义在对象原型上面的属性的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(obj); <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<h4 id="了解原型链"><a href="#了解原型链" class="headerlink" title="了解原型链"></a>了解原型链</h4><h5 id="原型链的实现方式"><a href="#原型链的实现方式" class="headerlink" title="原型链的实现方式"></a>原型链的实现方式</h5><p>在 <code>javascript</code> 中，原型链是被用来实现继承的主要方法， 基本的原理如下：</p>
<blockquote>
<p>使用原型链实现在 <code>js</code> 中继承的方式是让一个构造函数的原型对象等于另外一个构造函数的实例</p>
</blockquote>
<p>我们知道，对于一个构造函数而言，存在一个原型对象， 该构造函数形成的实例包含一个指向原型对象的指针， 如果我们将这个原型对象变为另外一个构造函数的实例，那个同样在这个原型对象中包含一个指向另外一个构造函数的原型对象的指针，这样层层递进，从而形成了一条原型链。</p>
<p>代码实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.value = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">func2.prototype.getValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">&#125;</span><br><span class="line">func1.prototype = <span class="keyword">new</span> func2()</span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> func1();</span><br><span class="line"><span class="comment">// 或者 const instance = Object.create(func1.prototype);</span></span><br><span class="line"><span class="comment">// 使用 Object.create(obj) 会创建一个新对象， 并且对象内部的 prototype 指向 obj</span></span><br><span class="line">instance.getValue(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面的这个过程其实也可以说是我们重写了构造函数的原型;</p>
<h5 id="原型链的终点"><a href="#原型链的终点" class="headerlink" title="原型链的终点"></a>原型链的终点</h5><p>对于一个原型链而言，是否原型链存在终点呢？实际上， 原型链的终点是存在的。</p>
<p>我们知道在 <code>javascript</code> 中， 存在下面几种基本类型：</p>
<p><code>undefined</code>, <code>null</code> , <code>Boolean</code> , <code>Number</code>, <code>String</code> 这五种基本类型和一种复杂的数据类型： <code>Object</code>.</p>
<p>实际上， 例如我们创建一个新的对象的时候， 创建的这个新的对象实际上是 <code>Object</code> 的实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newObj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>
<p>这个时候， 这个对象的原型指向的是对象的原型； 例如我们在对象上经常使用的一些对象方法例如： <code>Object.keys</code>, <code>Object.values</code> 这些方法实际上是定义在对象的原型上面的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">obj._proto_  <span class="comment">// Object.prototype</span></span><br></pre></td></tr></table></figure>
<p>而对于 <code>Object.prototype</code> 上面，实际上也是存在一个 <code>prototype</code> 属性， 只不过这个属性指向的是 <code>null</code>;</p>
<h3 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a><code>new</code> 操作符</h3><p>我们使用 <code>new</code> 操作符用来创造一个构造函数， 或者可以说， 我们通过使用 <code>new</code> 标识符号将一个普通函数转变为一个构造函数:</p>
<p>使用 <code>new</code> 操作符创造构造函数的实例的时候发生的过程如下：</p>
<ol>
<li>创建一个新对象。</li>
<li>将这个新对象的原型对象指向构造函数的原型</li>
<li>返回这个新对象。</li>
</ol>
<p>在 <code>高级程序设计</code> 这本书中有这样一句话：</p>
<blockquote>
<p>这两个对象( <code>person</code> 的实例)都有一个<code>constructor(构造函数)</code>属性，这个属性指向 <code>person</code>.</p>
</blockquote>
<p>上面这句话第一次读的时候不好理解，看起来感觉像是 <code>constructor</code> 属性是定义在实例上面的，实际上， 这里在实例上能够获得 <code>constructor</code> 属性，其实这里是继承来自于构造函数的原型上面的，因为构造函数的原型上面有个 <code>constructor</code> 属性，这个属性指向构造函数。 </p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>js 类</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式：单例模式</title>
    <url>/2019/04/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="单例模式（The-Singleton-Pattern）"><a href="#单例模式（The-Singleton-Pattern）" class="headerlink" title="单例模式（The Singleton Pattern）"></a>单例模式（The Singleton Pattern）</h3><p>单例模式的特征是限制创建的类的实例为一个单独的对象， 比较典型的例子是： 如果实例不存在， 那么通过方法创建类的实例， 否则， 返回这个实例， 单例模式的实例仅有一个， 因此被称作单例模式；</p>
<p>例如下面的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> singleton = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      publicName: name,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getInstance: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (instance === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        instance = init();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>当我们引用上面的实例时， 我们始终引用到的是一个实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">singleton.getInstance() === singleton.getInstance() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>使用单例模式有什么好处呢？</p>
<ol>
<li>当当前页面需要一个公共的对象或者全局缓存的时候， 我们需要使用单例模式， 实现例如全局变量存储，线程池之类的功能， 使用单例可以让多个引用的实例状态保持一致， 因此这些多次引用只是引用的同一个实例</li>
<li>划分命名空间， 避免全局变量污染</li>
<li>在使用的时候实例化对象， 可以防止如果引入大的资源的时候出现较大的内存占用， 特别当创建实例的 cost 较大的时候</li>
</ol>
<p>我们可以使用单例模式的情况：</p>
<blockquote>
<ul>
<li>There must be exactly one instance of a class, and it must be accessible to clients from a well-known access point.</li>
<li>When the sole instance should be extensible by subclassing, and clients should be able to use an extended instance without modifying their code.</li>
</ul>
</blockquote>
<ul>
<li><p>对于一个类而言， 必须有只有一个确定的实例， 而且对于使用者来说， 这个实例可以通过一个很明确的地方获取到, 比如上面的 <code>getInstance</code> 方法</p>
</li>
<li><p>通过添加子类， 这个唯一的实例应该能够是可扩展的， 使用者应该在不改变原来代码的情况下是使用扩展的实例， 例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getInstance: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (instance === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// 通过 if 的方式切换应用的类</span></span><br><span class="line">  	<span class="keyword">if</span> (useClassA) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> classA();</span><br><span class="line">  	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      instance = init();</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>由目录搜索想到的多叉树向二叉树的转换</title>
    <url>/2018/04/21/%E7%94%B1%E7%9B%AE%E5%BD%95%E6%90%9C%E7%B4%A2%E6%83%B3%E5%88%B0%E7%9A%84%E5%A4%9A%E5%8F%89%E6%A0%91%E5%90%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="目录搜索"><a href="#目录搜索" class="headerlink" title="目录搜索"></a>目录搜索</h2><p>在上个星期一轮迭代之后， 自己手上暂时还没有工作要做，在上一期迭代中， 需求表示目录太长了，用户不好操作，虽然这个问题通过添加滚动条解决了，但是我想着加一个搜索框实现对于目录的搜索， 效果如下：</p>
<video src="http://ov3b9jngp.bkt.clouddn.com/menus.mp4" controls="controls" style="max-width: 100%; display: block; margin-left: auto; margin-right: auto;"><br>your browser does not support the video tag<br></video>

<p>如上面所示我们想要进行一个对于目录的搜索，其中目录部分的结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    children: [</span><br><span class="line">        children: [...],</span><br><span class="line">      	title: ...,</span><br><span class="line">        ...</span><br><span class="line">    ],</span><br><span class="line">    title: ...,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>title</code> 表示目录的名字， children 表示当前目录下的子目录，如果当前目录没有子目录， 那么 <code>children</code> 属性就不会存在。</p>
<p><code>html</code> 部分：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">"searchContent"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>vue</code> 部分</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">      searchContent: <span class="string">""</span>,</span><br><span class="line">      originMenus: <span class="string">""</span></span><br><span class="line">  &#125;,</span><br><span class="line">  watch： &#123;</span><br><span class="line">    <span class="string">"route"</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  		<span class="comment">// 这里用来保存原始数组</span></span><br><span class="line">  		<span class="keyword">this</span>.originMenus = Util.clone(<span class="keyword">this</span>.menus);</span><br><span class="line">	&#125;,</span><br><span class="line">    <span class="string">"searchContent"</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (val.trim().length === <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="keyword">this</span>.menus = <span class="keyword">this</span>.originMenus;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.filterMenus(val, <span class="keyword">this</span>.orginMenus);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      filterMenus(val, menus) &#123;</span><br><span class="line">        <span class="keyword">const</span> filterVal = val;</span><br><span class="line">        <span class="comment">// 深拷贝对象</span></span><br><span class="line">        <span class="keyword">const</span> filterMenus = Util.clone(menus);</span><br><span class="line">        <span class="keyword">const</span> filterFn = <span class="function"><span class="params">theMenus</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (theMenus.children) &#123;</span><br><span class="line">            <span class="keyword">let</span> spliceIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 当我们想要对于一个数组进行条件判断并且删除数组中的元素的时候， 可以使用 Array.splice 进行操作</span></span><br><span class="line">            <span class="keyword">while</span> (spliceIndex &lt; theMenus.children.length) &#123;</span><br><span class="line">              <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(theMenus.children[spliceIndex].children) &amp;&amp;theMenus.children[spliceIndex].children.length !== <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 这里使用递归， 因为对于children 下的各个目录， 判断条件也是基本上一样的</span></span><br><span class="line">                filterFn(theMenus.children[spliceIndex]);</span><br><span class="line">                <span class="comment">// 如果当前目录下存在符合条件的， spliceIndex ++ 使用 continue 跳过当前的 while 循环</span></span><br><span class="line">                <span class="keyword">if</span> (theMenus.children[spliceIndex].children.length !== <span class="number">0</span>) &#123;</span><br><span class="line">                  spliceIndex++;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 这一部分， 如何实现有选择性的删除的？</span></span><br><span class="line">              <span class="comment">// 使用 splice 用于数组的删除，如果满足某一个条件， splice 跳过条件删除</span></span><br><span class="line">              <span class="keyword">if</span> (theMenus.children[spliceIndex] &amp;&amp; theMenus.children[spliceIndex].title &amp;&amp; theMenus.children[spliceIndex].title.indexOf(val) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">                spliceIndex++;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                theMenus.children.splice(spliceIndex, <span class="number">1</span>);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        filterFn(filterMenus);</span><br><span class="line">        <span class="keyword">return</span> filterMenus;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中， 使用到了 <code>while</code> 循环以及一些递归的东西。</p>
<h2 id="由多叉树向二叉树的转换"><a href="#由多叉树向二叉树的转换" class="headerlink" title="由多叉树向二叉树的转换"></a>由多叉树向二叉树的转换</h2><p>在上面的目录搜索中，其实自己想要将目录搜索转化为二叉树进行搜索的， 只不过后面发现没有必要，但是自己也是做了一个多叉树转化二叉树的函数。</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树是这样的一种树：</p>
<blockquote>
<p>二叉树是 n ( n &gt;=0 ) 个结点的有限集合， 该集合或者为空集( 空二叉树 ), 或者有一个根节点和两棵互不相交的， 分别称为根节点和左子树和右子树的二叉树组成。</p>
</blockquote>
<h4 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h4><p>每一个节点最多有两棵子树， 二叉树中每一个节点都是一个对象， 对于一个完整的二叉树而言， 每一个二叉树节点存在三个指针， 分别指向父母， 左孩子以及右孩子的指针， 每一个节点都是通过指针相互连接的， 连接指针的关系都是父子关系。</p>
<p><img src="https://segmentfault.com/img/bVdgFE" alt></p>
<p>二叉树节点的代码定义：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">node &#123;</span><br><span class="line">  value: <span class="string">""</span>,</span><br><span class="line">  <span class="comment">// 左孩子</span></span><br><span class="line">  left: &#123;</span><br><span class="line">    left : &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;,</span><br><span class="line">    right ： &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 右孩子</span></span><br><span class="line">  right: &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>对于二叉树而言， 存在三种遍历方式：</p>
<ol>
<li>前序遍历： 首先访问根节点， 然后遍历左子树， 最后遍历右子树。</li>
<li>中序遍历：首先遍历左子树， 然后访问根节点，最后遍历右子树。</li>
<li>后序遍历：首先遍历左子树， 然后遍历右子树， 最后访问根节点。</li>
</ol>
<p>下面是三种遍历的示意图：</p>
<p>前序遍历：</p>
<p>​                <img src="https://segmentfault.com/img/bVdgIK" alt></p>
<p>代码实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preOrder</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">      getNode(node);</span><br><span class="line">      preOrder(node.left);</span><br><span class="line">      preOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中序遍历：</p>
<p><img src="https://segmentfault.com/img/bVdgIM" alt></p>
<p>代码实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inOrder</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 先访问左子树</span></span><br><span class="line">    inOrder(node.left);</span><br><span class="line">    <span class="comment">// 访问根节点</span></span><br><span class="line">    getNode(node);</span><br><span class="line">    <span class="comment">// 访问右子树</span></span><br><span class="line">    inOrder(node.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后序遍历：</p>
<p><img src="https://segmentfault.com/img/bVdgJs" alt></p>
<p>代码实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postOrder</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 先访问左节点</span></span><br><span class="line">    postOrder(node.left);</span><br><span class="line">    <span class="comment">// 再访问右节点</span></span><br><span class="line">    postOrder(node.right);</span><br><span class="line">    getNode(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用二叉树的目的"><a href="#使用二叉树的目的" class="headerlink" title="使用二叉树的目的"></a>使用二叉树的目的</h4><p>上面说了这么多， 那么我们为什么构建二叉树呢？二叉树相对于其它的数据结构而言具有什么优点呢？</p>
<blockquote>
<p>对于数组而言， 实现数组的搜索比较方便， 可以直接使用下标访问到， 但是如果对于数组进行删除和插入就比较麻烦了， 而对于链表而言， 插入和删除比较简单， 但是访问却相对来说慢了一些。</p>
</blockquote>
<blockquote>
<p>对于有序数组而言， 对于有序数组在查找的时候有较高的效率。而无序链表在插入的时候具有较高的灵敏性。而对于二叉树而言， 二叉树综合了上面两种数据结构的优点。  </p>
</blockquote>
<h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><p>二叉查找数用来寻找到一组数组中的值的大小是非常有用的，因为二叉查找树在定义的时候定义到节点的左节点的值要小于右节点的值。</p>
<p>如下使用数组建立一个二叉查找树：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建左节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setLeftNode</span>(<span class="params">array, node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = array.length;</span><br><span class="line">  <span class="keyword">if</span> (len % <span class="number">2</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[(len - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">      node.left = &#123;</span><br><span class="line">        value: array[(len - <span class="number">1</span>) / <span class="number">2</span>]</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (array[len / <span class="number">2</span>]) &#123;</span><br><span class="line">    node.left = &#123;</span><br><span class="line">      value: array[len / <span class="number">2</span>]</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构建右节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setRightNode</span>(<span class="params">array, node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = array.length;</span><br><span class="line">  <span class="keyword">if</span> (len % <span class="number">2</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[(len - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">      node.right = &#123;</span><br><span class="line">        value: array[(len - <span class="number">1</span>) / <span class="number">2</span>]</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (array[len / <span class="number">2</span>]) &#123;</span><br><span class="line">    node.right = &#123;</span><br><span class="line">      value: array[len / <span class="number">2</span>]</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将数组转化为二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayToTree</span>(<span class="params">array, node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = array.length;</span><br><span class="line">  array.sort();</span><br><span class="line">  node.value = (len % <span class="number">2</span>) !== <span class="number">0</span> ? array[(len - <span class="number">1</span>) / <span class="number">2</span>] : array[len / <span class="number">2</span>];</span><br><span class="line">  <span class="keyword">const</span> leftArr = array.slice(<span class="number">0</span>, (len % <span class="number">2</span>) !== <span class="number">0</span> ? (len - <span class="number">1</span>) / <span class="number">2</span> : len / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> rightArr = array.slice(((len) % <span class="number">2</span>) !== <span class="number">0</span> ? (len + <span class="number">1</span>) / <span class="number">2</span> : ((len / <span class="number">2</span>) + <span class="number">1</span>), array.length);</span><br><span class="line">  setLeftNode(leftArr, node);</span><br><span class="line">  setRightNode(rightArr, node);</span><br><span class="line">  (leftArr.length !== <span class="number">0</span>) &amp;&amp; arrayToTree(leftArr, node.left);</span><br><span class="line">  (rightArr.length !== <span class="number">0</span>) &amp;&amp; arrayToTree(rightArr, node.right);</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">let</span> tree = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(arrayToTree(arr, tree));</span><br></pre></td></tr></table></figure>
<p>最终结果如下：</p>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%BB%93%E6%9E%9C.png" alt></p>
<h4 id="多叉树"><a href="#多叉树" class="headerlink" title="多叉树"></a>多叉树</h4><p>如果一个节点下面有多个节点， 那么可以称这样的数据结构为多叉树,这里可以类比二叉树中的两个子节点：</p>
<p>例如上面中的目录部分就是一个多叉树，根目录下面有多个子目录， 子目录下面还有可能有别的目录，如果将这样的多叉树转换为二叉树呢？只要记住一个转换原则就可以了：</p>
<blockquote>
<p>多叉树向二叉树转换的原则是： 左孩子，右兄弟。也就是说，一颗转换完成的二叉树的任意一个节点的左节点都是在转换之前的多叉树中的子节点， 任意一个节点的右节点都是当前节点在转换之前的多叉树中的兄弟节点。</p>
</blockquote>
<p>转化示意图如下：</p>
<p><img src="http://ov3b9jngp.bkt.clouddn.com/%E5%A4%9A%E5%8F%89%E6%A0%91%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt></p>
<p>转化代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> treeRight = <span class="function">(<span class="params">tree, fatherChild</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (fatherChild &amp;&amp; fatherChild.length !== <span class="number">0</span>) &#123;</span><br><span class="line">    fatherChild.splice(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    tree.right = fatherChild[<span class="number">0</span>];</span><br><span class="line">    treeLeft(tree.right, fatherChild);</span><br><span class="line">    treeRight(tree.right, fatherChild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> treeLeft = <span class="function">(<span class="params">tree</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (tree &amp;&amp; tree.children) &#123;</span><br><span class="line">    tree.left = tree.children[<span class="number">0</span>];</span><br><span class="line">    treeLeft(tree.left);</span><br><span class="line">    treeRight(tree.left, tree.children);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈 window.location 对象</title>
    <url>/2019/01/20/%E8%B0%88%E8%B0%88-window-location-%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="谈谈-window-location-对象"><a href="#谈谈-window-location-对象" class="headerlink" title="谈谈 window.location 对象"></a>谈谈 <code>window.location</code> 对象</h2><p><code>window.location</code> 是一个只读属性， 用于获取到页面文档的位置信息， 如果我们在浏览器控制台中打印， 那么打印出来的结果如下：</p>
<p>以我们在 页面 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/location" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/location</a> 下获取 <code>window.location</code> 为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ancestorOrigins: DOMStringList &#123;length: 0&#125;</span><br><span class="line">assign: ƒ ()</span><br><span class="line">hash: &quot;&quot;</span><br><span class="line">host: &quot;developer.mozilla.org&quot;</span><br><span class="line">hostname: &quot;developer.mozilla.org&quot;</span><br><span class="line">href: &quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Window/location&quot;</span><br><span class="line">origin: &quot;https://developer.mozilla.org&quot;</span><br><span class="line">pathname: &quot;/zh-CN/docs/Web/API/Window/location&quot;</span><br><span class="line">port: &quot;&quot;</span><br><span class="line">protocol: &quot;https:&quot;</span><br><span class="line">reload: ƒ reload()</span><br><span class="line">replace: ƒ ()</span><br><span class="line">search: &quot;&quot;</span><br><span class="line">toString: ƒ toString()</span><br><span class="line">valueOf: ƒ valueOf()</span><br><span class="line">Symbol(Symbol.toPrimitive): undefined</span><br><span class="line">__proto__: Location</span><br></pre></td></tr></table></figure>
<p>上面的这些值表明了在 <code>window.location</code> 中的一些属性和方法：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>href</td>
<td>当前页面的url</td>
<td><a href="https://example.com:8080/page/childpage?pageId=1#identify" target="_blank" rel="noopener">https://example.com:8080/page/childpage?pageId=1#identify</a></td>
</tr>
<tr>
<td>host</td>
<td>host  包含端口名</td>
<td>example.com:8080</td>
</tr>
<tr>
<td>hostname</td>
<td>不包含端口名</td>
<td>example.com</td>
</tr>
<tr>
<td>pathname</td>
<td>路径名</td>
<td>/page/childpage</td>
</tr>
<tr>
<td>origin</td>
<td>源网址</td>
<td><a href="https://example.com:8080" target="_blank" rel="noopener">https://example.com:8080</a> 是 网址在第一个 ‘/‘ 之前的部分</td>
</tr>
<tr>
<td>port</td>
<td>端口号</td>
<td>8080</td>
</tr>
<tr>
<td>protocol</td>
<td>协议名</td>
<td>https</td>
</tr>
<tr>
<td>search</td>
<td>截取到的链接的 ？ 之后的字符串, 不包含标识符 # 之后的内容</td>
<td>?pageId=1</td>
</tr>
<tr>
<td>hash</td>
<td>标识符</td>
<td><code>#identify</code></td>
</tr>
</tbody>
</table>
<p>除了上面几种属性之外， 还包括一些方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.location.reload() // 对于当前页面进行重载操作</span><br><span class="line">window.location.replace(rul) // 对于当前页面进行替换</span><br><span class="line">window.location.assign(url) // 会触发页面重载并且跳转到指定的 url</span><br></pre></td></tr></table></figure>
<p>tips：</p>
<ul>
<li>使用 replace 和 assign 不同的区别在于： 使用 replace 替换的当前页面不会保存到页面浏览会话历史中，因此当跳转完成之后， 点击浏览器的后退按钮， 是不会进入到使用 replace 的那个页面资源的。而使用 assign 会回到之前跳转的页面。</li>
</ul>
]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>window.location</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式：观察者模式</title>
    <url>/2019/04/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>使用观察者模式的一个常见的场景是： 一个观察对象需要通知一组相互独立的观察者发生变化， 并且这个观察对象和观察者之间是松耦合的关系。</p>
<p>观察者模式是由观察者和观察对象组成的， 观察对象维护一组观察者，这组观察者依赖观察对象， 当观察对象的状态发生变化的时候， 会自动通知这组观察者发生动作。</p>
<p>一个观察对象由属于自己的一组观察者， 观察对象的作用是注册， 删除观察者， 以及在合适的时机触发观察者。</p>
<p>在其他书籍中对于观察者模式的一些定义如下：</p>
<blockquote>
<p>“One or more observers are interested in the state of a subject and register their interest with the subject by attaching themselves. When something changes in our subject that the observer may be interested in, a notify message is sent which calls the update method in each observer. When the observer is no longer interested in the subject’s state, they can simply detach themselves.”</p>
</blockquote>
<p>在观察者模式中， 存在下面四种组成部分：</p>
<ul>
<li>观察对象：维护一组观察者， 可以新增 / 删除观察者， 通知观察者发生变化的逻辑</li>
<li>观察者： 提供一个当观察者对象状态发生变化的时候进行状态变化的一个接口</li>
<li>观察对象实例： 当相关状态发生变化的时候通知观察者,</li>
<li>观察者实例： 具体化一个数据改变的接口， 这个观察者实例是和观察对象相关联的</li>
</ul>
<p>下面是一个观察者模式的模型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一组观察者， 扩展了一些删除， 添加观察者的一些方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObserverList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers = [];</span><br><span class="line">  &#125;</span><br><span class="line">  append(ob) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.push(ob);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span>(obIndex) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.splice(obIndex, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span>(obIndex) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.observers[obIndex];</span><br><span class="line">  &#125;</span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers = [];</span><br><span class="line">  &#125;</span><br><span class="line">  count() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.observers.length;</span><br><span class="line">  &#125;</span><br><span class="line">  getList() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.observers;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者， 提供了一个 update 接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (cb) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cb = cb;</span><br><span class="line">  &#125;</span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="keyword">this</span>.cb();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 维护一组观察者</span></span><br><span class="line">    <span class="keyword">this</span>.observerList = <span class="keyword">new</span> ObserverList();</span><br><span class="line">  &#125;</span><br><span class="line">  add(ob) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observerList.append(ob);</span><br><span class="line">  &#125;</span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> ob <span class="keyword">of</span> <span class="keyword">this</span>.observerList.getList()) &#123;</span><br><span class="line">      ob.update();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  remove(obIndex) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observerList.delete(obIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subject = <span class="keyword">new</span> Subject();</span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> Observer(action);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> action = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册观察者</span></span><br><span class="line">subject.add(observer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知与之依赖的观察者动作</span></span><br><span class="line">subject.notify();</span><br></pre></td></tr></table></figure>
<p>上面的观察者模式， 其实可以使用下面的图进行说明：</p>
<img src="/2019/04/14/设计模式：观察者模式/observer.jpg">
<p>在上面的代码中， 我们可以发现， 观察者和观察者对象之间是松耦合的， 观察者对象维护者一组观察者， 观察者对象需要做的是通知相关观察者进行更新。</p>
<h3 id="和发布-订阅模式的区别"><a href="#和发布-订阅模式的区别" class="headerlink" title="和发布/订阅模式的区别"></a>和发布/订阅模式的区别</h3><p>上面的代码使用发布/订阅模式实现如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventMananger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.events = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  publish(event) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.events[event]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> eventCount = <span class="keyword">this</span>.events[event].length;</span><br><span class="line">    <span class="keyword">while</span> (eventCount--) &#123;</span><br><span class="line">      <span class="keyword">this</span>.events[event][eventCount]();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  subscribe(event, fn) &#123;</span><br><span class="line">    (<span class="keyword">this</span>.events[event] || (<span class="keyword">this</span>.events[event] = [])).push(fn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mananger = <span class="keyword">new</span> EventMananger();</span><br><span class="line"></span><br><span class="line">mananger.subscribe(<span class="string">'action'</span>, action);</span><br><span class="line"></span><br><span class="line">mananger.publish(<span class="string">'action'</span>);</span><br></pre></td></tr></table></figure>
<p>两者区别：</p>
<ol>
<li>对于观察者模式， 其订阅和发布消息是在同一个对象上面进行的（subject）， 对于发布订阅模式， 其角色有三种， 订阅者， 发布者 以及 中间存放方法的事件列表。发布者向事件列表中推送消息， 订阅者从事件列表中订阅消息， 并且当发布者推送消息的时候来触发订阅的事件。</li>
<li>发布订阅模式发布者和订阅者之间不存在耦合关系， 对于观察者模式， 观察者依赖观察对象， 这两者之间是松耦合关系</li>
<li>发布订阅模式应用于跨应用的情况下， 当多个应用之间进行通信的时候， 可以使用这种模式是实现通信， 对于 观察者模式， 主要应用于单个应用的情况。</li>
</ol>
<p>一些缺点：</p>
<p>使用观察者模式存在着一些缺点：</p>
<ul>
<li>观察对象不知晓观察者的状态， 当某个观察者中包含有一些自增代码的时候， 调用 观察对象的 update 方法，可能会造成观察者状态的重复更新。</li>
</ul>
<h3 id="两种方式在-vue-中的应用："><a href="#两种方式在-vue-中的应用：" class="headerlink" title="两种方式在 vue 中的应用："></a>两种方式在 vue 中的应用：</h3><p>在 vue 源码中的 <code>$emit</code>  <code>$on</code> 方法中使用了发布/订阅模式：<code>vm._events</code> 作为事件通道， 存放函数列表。</p>
<p><code>$on</code></p>
<p>订阅者</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.prototype.$on = <span class="function"><span class="keyword">function</span> (<span class="params">event, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> vm = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(event)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = event.length; i &lt; l; i++) &#123;</span><br><span class="line">      vm.$on(event[i], fn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 将相关函数存入到 vm._events 中</span></span><br><span class="line">    <span class="comment">// vm._events 作为事件列表方法事件</span></span><br><span class="line">    (vm._events[event] || (vm._events[event] = [])).push(fn);</span><br><span class="line">    <span class="comment">// optimize hook:event cost by using a boolean flag marked at registration</span></span><br><span class="line">    <span class="comment">// instead of a hash lookup</span></span><br><span class="line">    <span class="keyword">if</span> (hookRE.test(event)) &#123;</span><br><span class="line">      vm._hasHookEvent = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>$emit</code></p>
<p>发布者</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.prototype.$emit = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> vm = <span class="keyword">this</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> lowerCaseEvent = event.toLowerCase();</span><br><span class="line">    <span class="keyword">if</span> (lowerCaseEvent !== event &amp;&amp; vm._events[lowerCaseEvent]) &#123;</span><br><span class="line">      tip(</span><br><span class="line">        <span class="string">"Event \""</span> + lowerCaseEvent + <span class="string">"\" is emitted in component "</span> +</span><br><span class="line">        (formatComponentName(vm)) + <span class="string">" but the handler is registered for \""</span> + event + <span class="string">"\". "</span> +</span><br><span class="line">        <span class="string">"Note that HTML attributes are case-insensitive and you cannot use "</span> +</span><br><span class="line">        <span class="string">"v-on to listen to camelCase events when using in-DOM templates. "</span> +</span><br><span class="line">        <span class="string">"You should probably use \""</span> + (hyphenate(event)) + <span class="string">"\" instead of \""</span> + event + <span class="string">"\"."</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> cbs = vm._events[event];</span><br><span class="line">  <span class="keyword">if</span> (cbs) &#123;</span><br><span class="line">    cbs = cbs.length &gt; <span class="number">1</span> ? toArray(cbs) : cbs;</span><br><span class="line">    <span class="keyword">var</span> args = toArray(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> info = <span class="string">"event handler for \""</span> + event + <span class="string">"\""</span>;</span><br><span class="line">    <span class="comment">// 触发相应的函数方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = cbs.length; i &lt; l; i++) &#123;</span><br><span class="line">      invokeWithErrorHandling(cbs[i], vm, args, vm, info);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 vue 的依赖收集过程中， 使用了观察者模式：</p>
<img src="/2019/04/14/设计模式：观察者模式/vue.png">
<p>在 vue 源码中， 初始化data 的时候， vue 会通过一个 <code>defineReactive</code> 函数， 这个函数是实现当数据更新时相关依赖进行更新的关键， 这个函数里面对于数据的 <code>getter</code> 和 <code>setter</code> 函数内进行了一些处理， 当触发 <code>getter</code> 函数（读取）的时候会进行依赖收集， 当 触发 <code>setter</code> 函数（设置）的时候会通知相关依赖进行更新。</p>
<p>具体代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">obj, key, val, customSetter, shallow</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里的 new Dep() 是维护了一组观察者</span></span><br><span class="line">  <span class="comment">// Dep 是观察者对象， 维护者一组观察者</span></span><br><span class="line">  <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">  <span class="keyword">var</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key);</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">var</span> getter = property &amp;&amp; property.get;</span><br><span class="line">  <span class="keyword">var</span> setter = property &amp;&amp; property.set;</span><br><span class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> childOb = !shallow &amp;&amp; observe(val);</span><br><span class="line">  <span class="comment">// 使用 defineProperty  对于对象进行拦截处理</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter () &#123;</span><br><span class="line">      <span class="keyword">var</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">      <span class="comment">// 收集依赖</span></span><br><span class="line">      <span class="comment">// traget 全局变量</span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.depend();</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.dep.depend();</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            dependArray(value);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line">      <span class="keyword">var</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (customSetter) &#123;</span><br><span class="line">        customSetter();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">      <span class="keyword">if</span> (getter &amp;&amp; !setter) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal;</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">      <span class="comment">//  通知依赖发生变化</span></span><br><span class="line">      dep.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>dep</code> 是 用来维护者一组的观察者， 通过 <code>dep.depend</code> 方法收集到依赖， 然后通过 <code>dep.notify()</code> 来通知变动。</p>
<p>具体到 <code>Dep</code> 的类：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> target: ?Watcher;</span><br><span class="line">  id: number;</span><br><span class="line">  subs: <span class="built_in">Array</span>&lt;Watcher&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = uid++</span><br><span class="line">    <span class="comment">// 维护一组观察者 subs 内部存放了 Watcher 类的实例</span></span><br><span class="line">    <span class="keyword">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 新增观察者</span></span><br><span class="line">  addSub (sub: Watcher) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移除观察者</span></span><br><span class="line">  removeSub (sub: Watcher) &#123;</span><br><span class="line">    remove(<span class="keyword">this</span>.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Dep.target 是一个 watcher 实例, 这里调用的 addDep 方法是调用在 watcher 上面的方法</span></span><br><span class="line">  <span class="comment">// 在 watcher 方法上面的 addDep 方法也是调用了 addSub 方法</span></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      Dep.target.addDep(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 用来通知这组观察者进行更新， 调用观察者中的 update 方法来更新</span></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">      <span class="comment">// subs aren't sorted in scheduler if not running async</span></span><br><span class="line">      <span class="comment">// we need to sort them now to make sure they fire in correct</span></span><br><span class="line">      <span class="comment">// order</span></span><br><span class="line">      subs.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对于改观察者对象下面的每一个观察者都进行数据的更新处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注： <code>depend</code> 方法中的 <code>addDep</code> 方法引用的是 <code>Watcher</code> 实例上面的方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add a dependency to this directive.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">addDep (dep: Dep) &#123;</span><br><span class="line">  <span class="keyword">const</span> id = dep.id</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.newDepIds.add(id)</span><br><span class="line">    <span class="keyword">this</span>.newDeps.push(dep)</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</span><br><span class="line">      dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些观察者是 <code>Watcher</code> 的实例， <code>Watcher</code> 位于源码中的 <code>Watcher.js</code> 文件中， 一些更新观察者信息的方法作为实例方法。</p>
<p>在 <code>Watcher</code> 的类中， 上面定义了<code>update</code> 的方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">update () &#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">    <span class="comment">// 执行run 函数</span></span><br><span class="line">    <span class="keyword">this</span>.run()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Scheduler job interface.</span></span><br><span class="line"><span class="comment">   * Will be called by the scheduler.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">run () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="keyword">this</span>.get()</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      value !== <span class="keyword">this</span>.value ||</span><br><span class="line">      <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">      <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">      <span class="comment">// have mutated.</span></span><br><span class="line">      isObject(value) ||</span><br><span class="line">      <span class="keyword">this</span>.deep</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// set new value</span></span><br><span class="line">      <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line">      <span class="keyword">this</span>.value = value</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 执行 this.cb 回调</span></span><br><span class="line">          <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          handleError(e, <span class="keyword">this</span>.vm, <span class="string">`callback for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><ol>
<li><p>可以在数组中查找到对象， 或者说， js 的数组中存放的是对象的引用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = [&#123;&#125;, a];</span><br><span class="line">arr.indexOf(a);</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读函数式编程（一）</title>
    <url>/2018/03/20/%E9%98%85%E8%AF%BB%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h3 id="函数式编程的定义"><a href="#函数式编程的定义" class="headerlink" title="函数式编程的定义"></a>函数式编程的定义</h3><p>在 <code>javascript</code> 中， 函数被作为一等公民， 属于内置对象, 函数是对象中的一个子类型， 因此， 函数可以当作参数传递， 可以放到数组之中，本质上和普通的对象是一样的， 只不过相对于普通的对象而言， 函数可以被调用， 因此可以被称作可调用的对象。</p>
<blockquote>
<p>在 js 中， 存在下面几种内置对象：</p>
<ol>
<li><code>String</code> </li>
<li><code>Number</code></li>
<li><code>Boolean</code></li>
<li><code>Object</code></li>
<li><code>Function</code></li>
<li><code>Array</code></li>
<li><code>Date</code></li>
<li><code>Regexp</code></li>
<li><code>Error</code></li>
</ol>
<p>这几种内置对象相当于语言中的类，可以通过使用 <code>new</code> 操作符进行调用。</p>
</blockquote>
<p>使用函数式编程的目的在于：</p>
<blockquote>
<p>我们希望去践行每一部分都能完美接合的理论，希望能以一种通用的、可组合的组<br>件来表示我们的特定问题，然后利用这些组件的特性来解决这些问题。</p>
</blockquote>
<h3 id="使用纯函数"><a href="#使用纯函数" class="headerlink" title="使用纯函数"></a>使用纯函数</h3><p>什么是纯函数， 在介绍纯函数之前， 我们先看下关于纯函数的概念：</p>
<blockquote>
<p>纯函数是这样一种函数，即相同的输入， 永远只能得到相同的输出，而且没有任何可以观察到的副作用。</p>
</blockquote>
<p>对于有些函数而言，在函数执行的过程中发生了一些可能会影响外部状态的副作用， 包括下面几种：</p>
<ol>
<li>外部状态发生了改变</li>
<li>读取文件</li>
<li>console.log 数据</li>
<li>发送请求</li>
</ol>
<p>总而言之， 在函数执行的过程中， 函数与外部环境发生了交互的过程，代表这个函数存在副作用， 存在副作用的不纯函数容易产生 bug, 数据状态难以追踪， 并且增加我们的认知负荷， 因此， 在函数编写的过程中要尽量较少函数执行的时候对于外部环境的影响。</p>
<hr>
<p>这里对于纯函数而言， 相同的输入总会得到相同的输出， 这里类似于数学中的函数的概念， 在数学中的函数的概念中， 存在一个映射的改变：</p>
<blockquote>
<p>函数只是两种数值之间的关系， 尽管相同的输入只能得到相同的输出， 但是不同的输入也可以得到相同的输出</p>
</blockquote>
<p>因为在纯函数中，相同的输入只能得到相同的输出， 因此对于输入值是一定的情况下，对于输出的值则是一定的， 这样的情况下， 我们所要关心的只是这个函数做了什么，而不同尽力了解函数实现的具体细节， 这样能够增强我们调试代码的便利性。</p>
<h3 id="使用纯函数的好处"><a href="#使用纯函数的好处" class="headerlink" title="使用纯函数的好处"></a>使用纯函数的好处</h3><ol>
<li><p>可缓存性</p>
<p>简单的一段代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> squareNumber = memorize(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) <span class="title">return</span> </span>&#123; x*x &#125;);</span><br><span class="line">squareNumber(<span class="number">4</span>) =&gt; <span class="number">16</span>;</span><br><span class="line">squareNumber(<span class="number">4</span>) =&gt; <span class="number">16</span>; <span class="comment">// 从缓存中获取到的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// memorize 函数如下</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memorize</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cacheData = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> arg = <span class="built_in">JSON</span>.stringify(<span class="built_in">arguments</span>);</span><br><span class="line">        cacheData[arg] = cacheData[arg] || f.apply(f, <span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> cacheData[arg];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的这种纯函数的可缓存性类似于在 <code>js</code> 中的闭包的效果， 可以将值保存在函数内部。</p>
</li>
<li><p>依赖明确， 易于调试</p>
<p>对于纯函数而言， 函数的依赖都是写在函数参数之中的， 更便于我们理解与调试， 对于纯函数而言， 与外部函数发生作用的仅仅是定义中传入的参数，函数内部则不会涉及到关于外部环境的变量。</p>
</li>
<li><p>引用透明性</p>
<blockquote>
<p>如果一段代码可以替换成它执行之后得到的结果， 而且是在不改变整个程序行为的情况下被替换的， 那么， 我们说这段函数具有引用透明性。</p>
</blockquote>
</li>
</ol>
<p>例如对于类似下面这类的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNewUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否是新用户</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loginIn</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 用户登录</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 注册新用户</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isNewUser(user)) &#123;</span><br><span class="line">       register(user);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    loginIn(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中， 三个行为， 判断是否是新用户， 登录， 注册， 三个部分的逻辑封装在三个函数中， 从而更容易理解。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>详解js中的线程，进程, eventLoop</title>
    <url>/2018/06/20/%E8%AF%A6%E8%A7%A3js%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>存在下面一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">1</span>) &#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        i === <span class="number">9999</span> &amp;&amp; resolve()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>上面的代码的执行顺序， 依次输出内容分别是什么？<br>正确的答案是： 2， 3， 5 ，4， 1；<br>在上面的代码中， 执行的代码顺序如下：</p>
<ol>
<li>执行 <code>promise</code> 实例内部的代码， 输出 <code>2</code>;</li>
<li>顺序执行后面的代码 <code>console.log(3)</code>, 输出 <code>3</code>;</li>
<li>执行 <code>console.log(5)</code>， 代码输出 <code>5</code>;</li>
<li>执行 <code>resolve</code> 函数， 执行 <code>resolve</code> 函数中的代码  <code>console.log(4)</code>, 输出 <code>4</code>;</li>
<li>最后执行 <code>setTimeout</code> 中的代码， 代码执行 <code>console.log(1)</code> ， 输出 <code>1</code>;<br>为什么会按照上面的顺序执行代码， 下面将要进行详细的讲解：  </li>
</ol>
<h3 id="js-中的线程"><a href="#js-中的线程" class="headerlink" title="js 中的线程"></a>js 中的线程</h3><p>在 js 中的线程和浏览器中的线程是不同的， 在 js 中是单线程， 在浏览器是多线程的。js 的单线程是指所有的 js 代码都是在 js 引擎上面的一个主线程上面运行的，js  同时只能执行一个任务， 其他的任务则会排队进行等待执行。这些任务被放在一个任务队列中等待执行。</p>
<p>在浏览器中， 包括下面这些线程：</p>
<ul>
<li>js 引擎线程（例如 v8 引擎）</li>
<li>UI 渲染线程</li>
<li>浏览器事件触发线程</li>
<li>定时触发器线程</li>
<li>http 请求线程</li>
</ul>
<p><strong>这些线程的作用分别是这样的：</strong></p>
<ul>
<li><p>UI渲染线程用于渲染页面、解析 HTMl CSS， 创建 DOM 树。当页面元素发生重构或者回流的时候， 这个线程就会执行， 重新渲染页面。</p>
</li>
<li><p>js引擎用于执行 js 脚本代码，等待任务队列中的任务到来， 并且加以处理</p>
</li>
<li><p>浏览器事件触发线程用于控制用户， 响应交互，当 js 引擎执行代码遇到相关事件的时候， 会将对应的任务添加到事件线程中， 当任务符合触发条件被触发的时候， 触发的任务会被添加到任务队列的队尾， 等待 js 引擎执行完成主线程上面的任务之后执行。</p>
</li>
<li><p>定时触发器线程用于对于 <code>setTimeout</code> 或者 <code>setInterval</code> 进行计数, 因为 js引擎是单线程的， 所以自然计数的任务就不能有 js 引擎来完成， 而是由浏览器单独开出一个定时触发器线程用于计数， 当计数完毕之后， 会将计数完成之后的函数添加到任务队列尾部， 等待 js引擎执行完成主线程上面的任务之后执行。</p>
<blockquote>
<p>这里也就是说有个常见的问题： setTimeout(() =&gt; {}, 0);回调是立即执行的吗？并不是， 因为， 需要js 引擎执行完主线程上面的任务之后， 才会执行 任务列表中的任务。</p>
</blockquote>
</li>
<li><p>http 请求线程， ajax 是委托给浏览器新开一个 http 线程</p>
</li>
</ul>
<p>在上面的这些线程中， js 引擎的线程和UI渲染的线程是互斥的， 因此， 当js执行代码的时候会出现阻塞页面渲染的情况， 这也就是许多前端性能优化中都有提到的将js代码在html代码尾部加载的原因， 同时， 在 js 中操作dom会引发页面的重构或者回流， 这个时候UI渲染线程就会开始工作， 重新渲染页面， js 引擎的主线程就会被挂起，暂停代码执行， 从而影响页面性能， 这也是前端性能优化的一种方式：尽量减少js中直接对于dom的操作。</p>
<h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a><code>setTimeout</code></h3><p><code>setTimeout</code> 在 js 中的作用是用来延迟代码执行， 规定代码在延迟多少时间之后执行回调函数代码，在上面关于线程的讲解中， 我们知道浏览器的定时触发器线程会在延迟时间达到之后将回调事件添加到js引擎中的任务队列中， 而在 js 引擎中， 引擎会在执行完成主线程上面的任务之后执行任务队列中的事件， 因此，当代码中存在 <code>setTimeout</code> 的时候， 内部的回调函数会在其他代码执行完毕之后才执行，  尽管我们将延迟时间设为0的情况也是如此：</p>
<p>有如下代码：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">2</span>) &#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>执行结果： 1， 2</p>
<p>上面 <code>setTimeout</code> 中的函数会等到 <code>console.log(1)</code> 执行完成之后执行结果。</p>
<h3 id="js-中的事件运行机制"><a href="#js-中的事件运行机制" class="headerlink" title="js 中的事件运行机制"></a>js 中的事件运行机制</h3><p>我们知道js是单线程运行的， 那么具体的运行机制是如何的？我们需要知道下面这些概念：</p>
<ul>
<li>js 中分为同步任务和异步任务</li>
<li>同步任务都是在主线程上面执行， 形成一个执行栈</li>
<li>在主线程之外， 事件触发线程管理着一个任务队列， 当异步任务有了运行结果时， 就在任务队列中添加一个事件</li>
<li>当执行栈中的所有的同步任务执行完毕之后， 任务队列中的任务将会添加到执行栈中， 开始执行  </li>
</ul>
<p>事件运行机制的详细图解如下：</p>
<p><img src="https://img.funteas.com/d39f926aa5d3d036a6d5e3bbe5695c45?imageView2/2/w/800" alt="img"></p>
<h3 id="js-中的-macrotask-与-microtask"><a href="#js-中的-macrotask-与-microtask" class="headerlink" title="js 中的 macrotask 与 microtask"></a>js 中的 <code>macrotask</code> 与 <code>microtask</code></h3><p>在 js 中， 存在两种任务类型： <code>macrotask</code>(宏任务) 和 <code>microtash</code> (微任务)， 这两种任务类型的区别在于执行任务的时机是不同的。</p>
<ul>
<li><p><code>macrotask</code>: 宏任务可以理解为执行栈中执行的任务， 在执行任务期间不会中断任务， 浏览器为了能够使 js 内部task与 dom 能够有序的执行， 在执行完成任务之后会进行渲染，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task ---&gt; 渲染 ---&gt; task</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>microtask</code>微任务会在宏任务执行完毕之后， 进行渲染之前执行  </p>
</li>
</ul>
<p><code>macrotask</code> 与 <code>microtask</code> 中分别包含的几种任务类型：</p>
<ul>
<li><code>macrotask</code> : 代码块， <code>setTimeout</code>, <code>setInterval</code> 等</li>
<li><code>microtask</code>: <code>Promise</code>  </li>
</ul>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://funteas.com/topic/5a64e9482630e6f31583701d" target="_blank" rel="noopener">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop</a></p>
]]></content>
      <categories>
        <category>js理论基础</category>
      </categories>
      <tags>
        <tag>js运行机制，线程</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读函数式编程（二）</title>
    <url>/2018/05/23/%E9%98%85%E8%AF%BB%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>在上一篇文章中，我们了解了关于纯函数的概念， 纯函数的好处体现了函数式编程的一大优点： 没有副作用， 那么什么是函数式编程， 与命令式编程有什么不同， 函数式编程有什么优点，这篇文章想要深入了解下函数式编程的基本概念以及特点；</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>在 <code>Wikipedia</code> 上面， 这样解释函数式编程：</p>
<blockquote>
<ul>
<li><p>In computer science, functional programming is a programming paradigm or pattern (a style of building the structure and elements of computer programs)</p>
</li>
<li><p>Functional Programming treats computation as the evaluation of mathematical functions.</p>
</li>
<li><p>Functional Programming avoids changing-state and mutable data.</p>
<p>​</p>
</li>
<li><p>在计算机中， 函数式编程是是一种编程范例或者模式（一种构建计算机程序的结构和元素的类型）。</p>
</li>
<li><p>函数式编程将计算视作数学上函数的评估。</p>
</li>
<li><p>函数编程中避免改变状态以及变化的数据。</p>
</li>
</ul>
</blockquote>
<p> 函数式编程与命令式编程最大的区别在于：</p>
<p>函数式编程关心数据的映射， 命令式编程关心解决问题的步骤。  </p>
<p>这里的函数式编程之所以被称作函数，实际上类似于数学上函数的概念；</p>
<blockquote>
<p>函数的定义：</p>
<p>设A，B是非空的数集，如果按照某种确定的对应关系f，使对于集合A中的任意一个数x，在集合B中都有唯一确定的数 y 和 x 对应，那么变称映射 f: A ===&gt; B 称为从集合 A 到 B 的一个映射</p>
</blockquote>
<p>同样在函数式编程中， 函数式编程中的函数中， 每一个输入值都有一个唯一确定的输出值和输出值对应， 但是不同的输入值可以得到相同的输出值， 这种关系是一种映射关系。当然，对于函数编程而言，它不仅仅可以实现数据的映射， 还可以实现函数之间的映射。</p>
<p>例如：如果我们想要对于数组中的每一个数加1:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  arr[index] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"arr"</span>, arr); <span class="comment">// [2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p>或者使用 <code>forEach</code>, <code>map</code> 中数组中定义的方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// forEach</span></span><br><span class="line">arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> item += <span class="number">1</span>);</span><br><span class="line"><span class="comment">// map</span></span><br><span class="line"><span class="keyword">const</span> newArr = arr.map(<span class="function"><span class="params">item</span> =&gt;</span> item += <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<hr>
<p>注意：使用 <code>map</code> 以及 <code>forEach</code> 的方法都是对于一个数组进行遍历，接收的参数也是相同的， 但是， 这两个方法之间还是存在着一些区别的，</p>
<p>使用 <code>map</code> 不会改变原数组，但是会返回经过函数运算之后的新数组。对于使用 <code>forEach</code> 而言， 使用 <code>forEach</code> 不会改变原来的数组，返回值为 <code>undefined</code>。</p>
<p>从函数式编程的角度而言，使用 <code>map</code> 更能体现函数式编程的特点： 不会产生副作用；</p>
<hr>
<p>在上面实现数组中每项加一的操作中， 使用两种代码实现的， 第一个代码中我们将想要计算机运行的步骤通过命令的方式写了下来，告诉计算机， 通过 for 循环循环这个数组，然后数组中的每一项进行加一操作， 而在第二种代码中， 我们通过类似于函数式编程的方式实现，我们不用关心这个过程是怎么实现的， 我们只要将这个数据转换的关系告诉函数就可以了，换句话说， 我们这里关心的是数据之间的映射。</p>
<h3 id="几大特性"><a href="#几大特性" class="headerlink" title="几大特性"></a>几大特性</h3><p>对于函数式编程而言，存在下面几种特性：</p>
<ul>
<li>高阶函数</li>
<li>没有副作用</li>
<li>函数柯里化</li>
<li>闭包</li>
</ul>
<h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><p>高阶函数是这样一种函数： 函数被作为参数传入或者被作为返回值被返回的一类函数被称作高阶函数；</p>
<p>例如下面一段 <code>polifill</code> <code>es6</code> 中 <code>promise</code> 的代码中， 对于<code>promise</code> 返回成功状态或者失败状态的调用函数中是下面这样调用的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> that = <span class="keyword">this</span>;</span><br><span class="line">  that.status = PENDDING;</span><br><span class="line">  that.value = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">  that.handlerQueue = [];</span><br><span class="line">  <span class="comment">// 执行函数， 传递进入 value</span></span><br><span class="line">  <span class="comment">// executor(成功函数， 失败函数);</span></span><br><span class="line">  executor(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 成功函数执行，传递进入 transition 状态: FULFILLED</span></span><br><span class="line">    that.transition(FULFILLED, value);</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 失败函数执行， 传递进入 transition 状态: REJECTED</span></span><br><span class="line">    that.transition(REJECTED, value);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中， 这个 <code>executor</code> 函数是被作为参数传入到 <code>Promise</code> 函数中的， 同时这个  <code>executor</code> 也是接受两个函数作为参数， 一个是作为函数返回值为成功状态的函数， 另一个是作为函数返回值为失败状态的函数。</p>
<p>例如计算下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params">a, b, sum = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> getSum(a + <span class="number">1</span>, b, sum + a + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSquare</span>(<span class="params">a, b, sum = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> getSquare(a + <span class="number">1</span>, b, sum + <span class="built_in">Math</span>.pow(a + <span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> sums = getSum(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">const</span> squareSums = getSquare(<span class="number">1</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>上面两段代码分别是求两个数之间的整数和以及平方和;（不包括这两个数）</p>
<p>实际上， 上面的两种方法都是进行函数求和的运算， 只是求和的过程是不一样的，上面的代码我们可以重写如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumFn</span>(<span class="params">a, b, cb, sum = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sumFn(a + <span class="number">1</span>, b, cb, cb(sum, a));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> addSum = sumFn(<span class="number">1</span>, <span class="number">4</span>, (sum, a) =&gt; sum + <span class="number">1</span> + a);</span><br><span class="line"><span class="keyword">const</span> squareSum = sumFn(<span class="number">1</span>, <span class="number">4</span>, (sum, a) =&gt; sum + <span class="built_in">Math</span>.pow(a + <span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<p>在上面的代码中， 我们抽取出了求和的函数， 通过向求和函数中的参数 <code>cb</code> 中传入一个函数进行求取。</p>
<p>我们可以看到， 在 <code>sumFn</code> 这个函数中， 函数的逻辑取决于传入的参数<code>cb</code>的逻辑， 通过传入函数为参数的这种形式， 将程序的粒度控制在函数的层面上面。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>axios + vue 实现页面销毁时请求取消</title>
    <url>/2020/09/22/axios%20+%20vue%20%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E9%94%80%E6%AF%81%E6%97%B6%E8%AF%B7%E6%B1%82%E5%8F%96%E6%B6%88/</url>
    <content><![CDATA[<p>在日常的开发中，会遇到这样的需求：</p>
<p>我们想要当离开当前页面的时候， 这个页面上的请求的接口不会继续请求</p>
<p>使用 <code>vue</code> + <code>axios</code> 来实现手动取消请求的功能：</p>
<p>代码如下：</p>
<p><code>cancelRequest.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collector</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">axiosIns, cancelList</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.axiosIns = axiosIns</span><br><span class="line">    <span class="built_in">this</span>.cancelList = cancelList || []</span><br><span class="line">    <span class="keyword">const</span> handlersCount = <span class="built_in">this</span>.getAllHandlers().length</span><br><span class="line">    <span class="built_in">this</span>.handlerIndex = handlersCount ? handlersCount - <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">    <span class="built_in">this</span>.insertInterceptors = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getCancelKeys</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.cancelList.map(<span class="function">(<span class="params">&#123; key &#125;</span>) =&gt;</span> key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">hasKey</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getCancelKeys().includes(key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">cancelKey</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.cancelList.find(<span class="function">(<span class="params">&#123; key &#125;</span>) =&gt;</span> cancelKey === key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getAllHandlers</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.cancelList.reduce(<span class="function">(<span class="params">allHandlers, &#123; handlerList &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      allHandlers = [...allHandlers, ...handlerList]</span><br><span class="line">      <span class="keyword">return</span> allHandlers</span><br><span class="line">    &#125;, [])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getHandlers</span>(<span class="params">cancelKey</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.hasKey(cancelKey)) &#123;</span><br><span class="line">      <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.get(cancelKey).handlerList</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">removeInsertInterceptors</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> interceptors = <span class="built_in">this</span>.axiosIns.interceptors</span><br><span class="line">    <span class="built_in">Object</span>.entries(<span class="built_in">this</span>.insertInterceptors).forEach(<span class="function">(<span class="params">[type, incpts]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> handlers = interceptors[type].handlers</span><br><span class="line">      incpts.forEach(<span class="function"><span class="params">interceptor</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> incptIndex = handlers.indexOf(interceptor)</span><br><span class="line">        <span class="keyword">if</span> (incptIndex !== -<span class="number">1</span>) &#123;</span><br><span class="line">          interceptors[type].handlers.splice(incptIndex, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">this</span>.insertInterceptors = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">removeHandler</span>(<span class="params">removeKey, handlerIndex</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handlerList = <span class="built_in">this</span>.getHandlers(removeKey)</span><br><span class="line">    handlerList.length &amp;&amp; handlerList.splice(handlerIndex, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (!handlerList.length) &#123;</span><br><span class="line">      <span class="built_in">this</span>.remove(removeKey)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.hasKey(key)) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">const</span> keyIndex = <span class="built_in">this</span>.getCancelKeys().indexOf(key)</span><br><span class="line">    <span class="built_in">this</span>.cancelList.splice(keyIndex, <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">cancel</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> handlerList = <span class="built_in">this</span>.getHandlers(key)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; handlerList.length; i++) &#123;</span><br><span class="line">        handlerList[i]()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.remove(key)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> handlerList = <span class="built_in">this</span>.getAllHandlers()</span><br><span class="line">      handlerList.forEach(<span class="function"><span class="params">handler</span> =&gt;</span> handler())</span><br><span class="line">      <span class="built_in">this</span>.cancelList = []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">cancelObj</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; key, handler &#125; = cancelObj</span><br><span class="line">    <span class="built_in">this</span>.handlerIndex++</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.hasKey(key)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.cancelList.push(&#123; key, <span class="attr">handlerList</span>: [handler] &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> existHandlers = <span class="built_in">this</span>.getHandlers(key)</span><br><span class="line">      <span class="built_in">this</span>.get(key).handlerList = [...existHandlers, handler]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CancelRequest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">config</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> defaultConfig = &#123;</span><br><span class="line">      vm: <span class="literal">null</span>,</span><br><span class="line">      includes: []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.config = <span class="built_in">Object</span>.assign(&#123;&#125;, defaultConfig, config)</span><br><span class="line">    <span class="built_in">this</span>.cancelReqCollectorList = []</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.config.vm) &#123;</span><br><span class="line">      <span class="built_in">this</span>._vmDestroyedCancel()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(<span class="string">&#x27;config vm is null, request will not be canceld when component destroyed&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getAllAxiosInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.cancelReqCollectorList.map(<span class="function">(<span class="params">&#123; axiosIns &#125;</span>) =&gt;</span> axiosIns)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getCollector</span>(<span class="params">instance</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> existCollector = <span class="built_in">this</span>.cancelReqCollectorList.find(<span class="function">(<span class="params">&#123; axiosIns &#125;</span>) =&gt;</span> axiosIns === instance)</span><br><span class="line">    <span class="keyword">if</span> (!existCollector) &#123;</span><br><span class="line">      existCollector = <span class="keyword">new</span> Collector(instance)</span><br><span class="line">      <span class="built_in">this</span>.cancelReqCollectorList.push(existCollector)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> existCollector</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 拦截 vue 中的 _isDestroyed 属性， 当组件销毁时，取消请求</span></span><br><span class="line">  <span class="function"><span class="title">_vmDestroyedCancel</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> isDestroyed = <span class="built_in">this</span>.config.vm._isDestroyed</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>.config.vm, <span class="string">&#x27;_isDestroyed&#x27;</span>, &#123;</span><br><span class="line">      set: <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        isDestroyed = val</span><br><span class="line">        <span class="keyword">if</span> (val) <span class="built_in">this</span>.cancel(<span class="literal">true</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isDestroyed</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getTokenKey</span>(<span class="params">config</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; baseURL, url &#125; = config</span><br><span class="line">    <span class="keyword">if</span> (url.startsWith(<span class="string">&#x27;http&#x27;</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> url</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;baseURL&#125;</span><span class="subst">$&#123;url&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getSource</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> cancelToken = axios.CancelToken</span><br><span class="line">    <span class="keyword">let</span> source = cancelToken.source()</span><br><span class="line">    <span class="keyword">return</span> source</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">insertInterceptor</span>(<span class="params">interceptors, collector</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; request, response &#125; = interceptors</span><br><span class="line">    <span class="keyword">const</span> requestInt = &#123;</span><br><span class="line">      fulfilled: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> setKey = <span class="built_in">this</span>.getTokenKey(config)</span><br><span class="line">        <span class="keyword">const</span> source = <span class="built_in">this</span>.getSource()</span><br><span class="line">        <span class="keyword">const</span> isValidIncludes = <span class="built_in">Array</span>.isArray(<span class="built_in">this</span>.config.includes) &amp;&amp; <span class="built_in">this</span>.config.includes.length</span><br><span class="line">        <span class="keyword">const</span> isMatch = isValidIncludes &amp;&amp; <span class="built_in">this</span>.config.includes.some(<span class="function"><span class="params">includeKey</span> =&gt;</span> setKey.includes(includeKey))</span><br><span class="line">        <span class="keyword">if</span> (!isValidIncludes || isMatch) &#123;</span><br><span class="line">          config.cancelToken = source.token</span><br><span class="line">          collector.add(&#123; <span class="attr">key</span>: setKey, <span class="attr">handler</span>: source.cancel &#125;)</span><br><span class="line">          config.cancelHandlerIndex = collector.handlerIndex</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config</span><br><span class="line">      &#125;,</span><br><span class="line">      rejected: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> successRespInt = &#123;</span><br><span class="line">      fulfilled: <span class="function"><span class="params">resp</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> handlerIndex = resp.config.cancelHandlerIndex</span><br><span class="line">        <span class="keyword">const</span> removeKey = <span class="built_in">this</span>.getTokenKey(resp.config)</span><br><span class="line">        collector.remove(removeKey, handlerIndex)</span><br><span class="line">        <span class="keyword">return</span> resp</span><br><span class="line">      &#125;,</span><br><span class="line">      rejected: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> errorRespInt = &#123;</span><br><span class="line">      fulfilled: <span class="literal">null</span>,</span><br><span class="line">      rejected: <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> isCancel = axios.isCancel(error)</span><br><span class="line">        <span class="keyword">if</span> (!isCancel) &#123;</span><br><span class="line">          <span class="keyword">const</span> handlerIndex = error.config.cancelHandlerIndex</span><br><span class="line">          collector.remove(<span class="built_in">this</span>.getTokenKey(error.config), handlerIndex)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    collector.insertInterceptors = &#123;</span><br><span class="line">      request: [requestInt],</span><br><span class="line">      response: [successRespInt, errorRespInt]</span><br><span class="line">    &#125;</span><br><span class="line">    request.handlers.unshift(requestInt)</span><br><span class="line">    response.handlers.unshift(successRespInt, errorRespInt)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向 axios 实例中注入token</span></span><br><span class="line">  <span class="function"><span class="title">insertToken</span>(<span class="params">axiosInstance</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> collector = <span class="built_in">this</span>.getCollector(axiosInstance)</span><br><span class="line">    <span class="keyword">const</span> interceptors = axiosInstance.interceptors</span><br><span class="line">    <span class="built_in">this</span>.insertInterceptor(interceptors, collector)</span><br><span class="line">    <span class="keyword">return</span> collector</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">cancel</span>(<span class="params">isDestroyed</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.cancelReqCollectorList.forEach(<span class="function"><span class="params">collector</span> =&gt;</span> &#123;</span><br><span class="line">      collector.cancel()</span><br><span class="line">      <span class="keyword">if</span> (isDestroyed) &#123;</span><br><span class="line">        collector.removeInsertInterceptors()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (isDestroyed) &#123;</span><br><span class="line">      <span class="built_in">this</span>.cancelReqCollectorList = []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> CancelRequest</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用方法如下：在组件中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> http = axios.create()</span><br><span class="line"><span class="comment">// this 为当前组件对象</span></span><br><span class="line"><span class="comment">// 在使用 http 来请求时，调用下面的方法</span></span><br><span class="line"><span class="keyword">const</span> cancelRes = <span class="keyword">new</span> CancelRequest(&#123; <span class="attr">vm</span>: <span class="built_in">this</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> cancelCollector = cancelRes.insertToken(http)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当需要取消请求时：</span></span><br><span class="line"><span class="comment">// 使用 cancel 方法来取消使用 http axios 实例来发起的请求</span></span><br><span class="line">cancelCollector.cancel() </span><br><span class="line"><span class="comment">// 或者传入配置 vm: this 时</span></span><br><span class="line"><span class="comment">// 当当前页面销毁时，会自动将当前页面正在发起的请求 cancel 掉</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>代码</category>
      </categories>
      <tags>
        <tag>cancel request</tag>
      </tags>
  </entry>
  <entry>
    <title>协商缓存和强缓存</title>
    <url>/2020/09/26/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E5%92%8C%E5%BC%BA%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p>缓存是指代理服务器或者客户端本地磁盘内保存的资源副本。使用缓存可以减少对于源服务器的访问，从而节省通信流量和通信时间。</p>
<p>在服务器与客户端的通信过程中，对于数据的缓存方式可以分为 <strong>强缓存</strong> 和 <strong>协商缓存</strong> 两种，通过http请求头中的 <code>Cache-Control</code> 可以决定是否采用上面两种方式</p>
<p>缓存涉及到的相关字段有：</p>
<p><code>Cache-Control</code>  <code>Expires</code>  <code>Last-Modified</code> <code>If-Modified-Since</code> <code>Etag</code>  <code>If-None-Match</code></p>
<h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>强缓存就是当客户端发起请求之前，首先检查浏览器缓存中是否有要请求的内容，并且根据结果的缓存规则来判断是否实际向服务器发起请求</p>
<p>客户端发起请求时，会有下面三种结果：</p>
<ol>
<li>没有缓存结果，那么需要向服务器请求内容</li>
<li>存在缓存结果，并且缓存规则未失效，那么直接使用缓存的内容</li>
<li>存在缓存结果，但缓存规则已经失效，那么也需要重新向服务器请求内容，效果同 1</li>
</ol>
<p>使用请求返回头中的：<code>Cache-Control</code> 字段来配置缓存的行为：</p>
<ul>
<li><p><code>public</code>:  可以向任意方提供响应的缓存，发送请求的客户端或者代理服务器都可以缓存数据</p>
</li>
<li><p><code>private</code>: 只有浏览器才能缓存内容</p>
</li>
<li><p><code>no-cache</code>: 强制所有缓存了该响应的用户，在使用已经缓存的数据前，发送带有验证的请求到服务器，需要等待服务器确认之后，才能使用浏览器缓存</p>
</li>
<li><p><code>no-store</code>: 不进行缓存，每次请求都需要向服务器重新请求数据</p>
</li>
<li><p><code>max-age</code>: 指定资源的缓存时间，</p>
<p>在客户端请求头中添加时，表示如果缓存资源的缓存时间数值比设置的 <code>max-age</code> 的数值小的话，那么客户端就接收缓存的资源</p>
<p>当服务器响应头中添加时，表示当前返回的资源内容在浏览器中的最大缓存时间，在没有禁用缓存并且没有超过有效时间的情况下，再次访问这个资源就命中了缓存，不会向服务器请求资源而是直接从浏览器缓存中取。</p>
</li>
</ul>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>协商缓存就是当强制缓存失效后，客户端和服务器根据请求头或者响应头的相关字段来判断是否采用浏览器缓存的资源，因为有可能客户端请求的资源过了有效期，但是此时资源内容和服务器上的资源没有差别，仍然可以使用浏览器缓存资源来避免再次请求服务器资源</p>
<p>协商缓存是由服务器来决定是否使用缓存的</p>
<p>因此关键是：<strong>如何判断服务器上的资源和浏览器上缓存的资源是不是相同的</strong>，下面的两种方式分别是根据文件修改时间和文件唯一标识来判断的，</p>
<p>两种方式：</p>
<ul>
<li><p><strong>Last-modified/If-Modified-Since</strong></p>
<p>这两个字段是一种时间戳的形式字符串</p>
<p>服务器响应头中带有： Last-modified 表示资源最后被修改的时间，当客户端再次请求相同资源时，在请求头中添加 <code>If-Modified-Since</code> 字段为上次请求资源时服务器返回的资源最后修改时间，服务器收到请求之后，会将 </p>
<p><code>If-Modified-Since</code> 的时间与  <code>Last-modified</code> 进行对比，如果不一致，则重新请求资源，如果一致，那么使用浏览器缓存的资源（304）</p>
</li>
<li><p><strong>Etag/If-None-Match</strong></p>
<p>这两个值都是请求当前资源文件的唯一标识，这个标识是由服务器生成的</p>
<p>类似于上面的过程，<code>Etag</code> 由服务器返回，<code>If-None-Match</code> 是再次请求资源时添加在请求头中的字段，值是上次请求时返回头中返回的 <code>Etag</code> 字段的值，在服务器中，根据 <code>If-None-Match</code>的字段值与该资源在服务器的Etag值做对比，如果不一致，重新请求资源，如果一致，同样使用浏览器缓存资源（304）</p>
</li>
</ul>
<blockquote>
<p>在 http 中，状态码 304 （Not Modified）返回的内容为空，因为这个时候表示当前请求的资源和服务器上的资源一致，可以直接使用浏览器缓存的内容</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>概括来说：</p>
<p><strong>强缓存</strong>是直接使用浏览器内缓存的内容，使用到的字段有：<strong>Expires</strong> 或者 <strong>Cache-Control: max-age=3600</strong> (表示资源的缓存时间是 3600 s)</p>
<p><strong>协商缓存</strong>是需要服务器参与确认是否使用浏览器缓存的内容的机制，应用在强缓存失效之后</p>
<p>这个过程可以用下面的示意图来说明：</p>
<p><img src="协商缓存和强缓存/1.png" alt="img"></p>
<img src="/2020/09/26/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E5%92%8C%E5%BC%BA%E7%BC%93%E5%AD%98/1.png" class="">
]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法（一）（选择，插入，冒泡，归并，快速）</title>
    <url>/2020/09/20/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%88%E9%80%89%E6%8B%A9%EF%BC%8C%E6%8F%92%E5%85%A5%EF%BC%8C%E5%86%92%E6%B3%A1%EF%BC%8C%E5%BD%92%E5%B9%B6%EF%BC%8C%E5%BF%AB%E9%80%9F%EF%BC%89/</url>
    <content><![CDATA[<p>下面是选择排序，插入排序，冒泡排序，归并排序，快速排序五种算法的原理以及具体的代码实现</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ol>
<li>从数组中选取一个元素 item，初次为第一个元素</li>
<li>在 item 剩余的元素中找到最小的元素</li>
<li>将这个最小的元素与 item 交换位置</li>
<li>重复 1，2， 3的过程，一直到数组结束</li>
</ol>
<p>示意图如下</p>
<img src="/2020/09/20/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%88%E9%80%89%E6%8B%A9%EF%BC%8C%E6%8F%92%E5%85%A5%EF%BC%8C%E5%86%92%E6%B3%A1%EF%BC%8C%E5%BD%92%E5%B9%B6%EF%BC%8C%E5%BF%AB%E9%80%9F%EF%BC%89/1.png" class="">
<p><img src="排序算法（一）（选择，插入，冒泡，归并，快速）/1.png" alt=""></p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">let</span> minIdx = i;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[i];</span><br><span class="line">        <span class="comment">// 从剩余的元素中查找到最小的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.length; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIdx]) &#123;</span><br><span class="line">                minIdx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = arr[minIdx];</span><br><span class="line">        arr[minIdx] = temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ol>
<li>从数组中的第二个元素开始抽取元素 item</li>
<li>将 item 与 item 左边第一个元素进行比较，如果左边的元素大于item，那么继续与左边第二个元素继续比较，直到遇到不大于item 的元素，然后将这个元素插入到 item 的右边</li>
<li>继续选取第 3， 4， 5 个元素， 重复 2 过程， 直到数组结束</li>
</ol>
<p>示意图如下</p>
<img src="/2020/09/20/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%88%E9%80%89%E6%8B%A9%EF%BC%8C%E6%8F%92%E5%85%A5%EF%BC%8C%E5%86%92%E6%B3%A1%EF%BC%8C%E5%BD%92%E5%B9%B6%EF%BC%8C%E5%BF%AB%E9%80%9F%EF%BC%89/2.png" class="">
<p><img src="排序算法（一）（选择，插入，冒泡，归并，快速）/2.png" alt=""></p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">let</span> k = i;</span><br><span class="line">        <span class="keyword">let</span> item = arr[i]</span><br><span class="line">        <span class="keyword">while</span> (k &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            k --;</span><br><span class="line">            <span class="comment">// 当找到比当前要插入的元素小的元素时</span></span><br><span class="line">            <span class="comment">// 将插入元素插入到小元素的右边</span></span><br><span class="line">            <span class="comment">// 或者 k &lt; 0 时，这个时候表示找到最左边</span></span><br><span class="line">            <span class="comment">// 都没有找到比 arr[i] 还要小的元素</span></span><br><span class="line">            <span class="keyword">if</span> (item &gt; arr[k] || k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                arr[k + <span class="number">1</span>] = item;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 整体向右边移</span></span><br><span class="line">                arr[k + <span class="number">1</span>] = arr[k]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ol>
<li>将第一个元素与第二个元素进行比较，如果第一个元素比第二个大，那么交换他们的位置，接着继续比较第二个元素和第三个元素</li>
<li>经过一轮比较之后，现在最右边的元素是数组里面最大的元素</li>
<li>除去最右边已经筛选后的元素之后，再对剩余的元素执行 1 过程</li>
</ol>
<p>示意图如下</p>
<img src="/2020/09/20/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%88%E9%80%89%E6%8B%A9%EF%BC%8C%E6%8F%92%E5%85%A5%EF%BC%8C%E5%86%92%E6%B3%A1%EF%BC%8C%E5%BD%92%E5%B9%B6%EF%BC%8C%E5%BF%AB%E9%80%9F%EF%BC%89/3.png" class="">
<p><img src="排序算法（一）（选择，插入，冒泡，归并，快速）/3.png" alt=""></p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr, sortedIndex = arr.length - <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> nextIdx = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; arr[nextIdx]) &#123;</span><br><span class="line">            <span class="keyword">let</span> temp = arr[i]</span><br><span class="line">            arr[i] = arr[nextIdx]</span><br><span class="line">            arr[nextIdx] = temp</span><br><span class="line">        &#125;</span><br><span class="line">        i ++</span><br><span class="line">    &#125;</span><br><span class="line">    sortedIndex --</span><br><span class="line">    <span class="keyword">return</span>  sortedIndex === <span class="number">0</span> ? arr : bubbleSort(arr, sortedIndex)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ol>
<li>将大数组拆分为小数组，再拆分小数组，一直拆分到数组内只有一个元素</li>
<li>对于小数组内的元素进行排序操作，然后将小数组进行组合</li>
<li>最后组合的大数组为已经排好序的数组</li>
</ol>
<p>示意图如下：</p>
<p><img src="排序算法（一）（选择，插入，冒泡，归并，快速）/4.png" alt=""></p>
<img src="/2020/09/20/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%88%E9%80%89%E6%8B%A9%EF%BC%8C%E6%8F%92%E5%85%A5%EF%BC%8C%E5%86%92%E6%B3%A1%EF%BC%8C%E5%BD%92%E5%B9%B6%EF%BC%8C%E5%BF%AB%E9%80%9F%EF%BC%89/4.png" class="">
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">arr, left, mid, right</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(right - left + <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">let</span> i = left;</span><br><span class="line">	<span class="keyword">let</span> j = mid + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 将两个数组进行组合</span></span><br><span class="line">  <span class="comment">// 这两个数组分别为 arr[left, ... mid] 以及 arr[mid + 1, ... right]</span></span><br><span class="line">	<span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">			a[k++] = arr[i++]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			a[k++] = arr[j++]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 当还有剩余的 i 数组元素时</span></span><br><span class="line">  <span class="comment">// 压入数组中</span></span><br><span class="line">	<span class="keyword">while</span>(i &lt;= mid) &#123;</span><br><span class="line">		a[k++] = a[i++]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 当还有剩余的 j 数组元素时</span></span><br><span class="line">  <span class="comment">// 同样压入数组中</span></span><br><span class="line">	<span class="keyword">while</span>(j &lt;= right) &#123;</span><br><span class="line">		a[k++] = a[j++]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将排好序的 a 数组复制到 arr 中</span></span><br><span class="line">  <span class="comment">// 这里的数组 a 已经排好序了</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; k; i ++) &#123;</span><br><span class="line">		arr[left ++] = a[i]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left !== right) &#123;</span><br><span class="line">		<span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((right + left) / <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 对于左边的元素进行排序</span></span><br><span class="line">		arr = mergeSort(arr, left, mid)</span><br><span class="line">    <span class="comment">// 对于右边的元素进行排序</span></span><br><span class="line">    arr = mergeSort(arr, mid + <span class="number">1</span>, right)</span><br><span class="line">		merge(arr, left, mid, right)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ol>
<li>选取数组中的一个元素为中轴元素，将数组中所有小于中轴元素的元素放在左边，所有大于或者等于中轴元素的元素放在右边</li>
<li>进行完过程 1 之后，这时候中轴元素的位置已经确定了，这个元素左边都是比它小的元素，右边都是比它大的元素</li>
<li>对于中轴元素左右两边的元素再分别进行 1 过程，直到所有的元素作为中轴元素位置都确定了为止</li>
</ol>
<p>示意图如下：</p>
<p><img src="排序算法（一）（选择，插入，冒泡，归并，快速）/5.png" alt=""></p>
<img src="/2020/09/20/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%88%E9%80%89%E6%8B%A9%EF%BC%8C%E6%8F%92%E5%85%A5%EF%BC%8C%E5%86%92%E6%B3%A1%EF%BC%8C%E5%BD%92%E5%B9%B6%EF%BC%8C%E5%BF%AB%E9%80%9F%EF%BC%89/5.png" class="">
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pivot = arr[left]</span><br><span class="line">    <span class="keyword">let</span> i = left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> j = right;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j &amp;&amp; arr[i] &lt;= pivot) &#123;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j &amp;&amp; arr[j] &gt;= pivot) &#123;</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[i]</span><br><span class="line">        arr[i] = arr[j]</span><br><span class="line">        arr[j] = temp</span><br><span class="line">    &#125;</span><br><span class="line">    arr[left] = arr[j]</span><br><span class="line">    arr[j] = pivot</span><br><span class="line">    <span class="keyword">return</span> j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = partition(arr, left, right)</span><br><span class="line">        arr = quickSort(arr, left, mid - <span class="number">1</span>)</span><br><span class="line">        arr = quickSort(arr, mid + <span class="number">1</span>, right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>深拷贝</title>
    <url>/2021/03/01/%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<p>深拷贝和浅拷贝的区别：</p>
<p><code>浅拷贝</code> : 当对于一个对象进行浅拷贝的时候，会创建一个新的对象，新对象包含有旧对象的所有属性，当属性值为基本类型时，拷贝的就是这个基本类型的值，当属性值为引用类型的时候，拷贝的是这个引用类型的内存地址</p>
<p><code>深拷贝</code>：将一个对象从内存中完整的拷贝出来，开辟一个新的区域存储新对象，并且修改新对象不会影响旧对象</p>
<h3 id="实现深拷贝"><a href="#实现深拷贝" class="headerlink" title="实现深拷贝"></a>实现深拷贝</h3><ul>
<li><p>使用 <code>JSON.parse(JSON.stringify())</code></p>
<p>这种最简单的实现深拷贝的方法同时存在许多的缺点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  date: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">  nan: <span class="literal">NaN</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>: <span class="title">new</span> <span class="title">Function</span>(<span class="params"></span>),</span></span><br><span class="line"><span class="function">  <span class="title">undefined</span>: <span class="title">undefined</span>,</span></span><br><span class="line"><span class="function">  <span class="title">regexp</span>: <span class="title">new</span> <span class="title">RegExp</span>(<span class="params"><span class="string">'\\w+'</span></span>),</span></span><br><span class="line"><span class="function">  <span class="title">symbol</span>: <span class="title">Symbol</span>(<span class="params"><span class="string">'symbol'</span></span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cloneObj = deepClone(obj)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cloneObj)</span><br><span class="line"><span class="comment">// 打印结果如下</span></span><br><span class="line">&#123; <span class="attr">date</span>: <span class="string">'2021-02-26T07:22:37.173Z'</span>, <span class="attr">nan</span>: <span class="literal">null</span>, <span class="attr">regexp</span>: &#123;&#125; &#125;</span><br></pre></td></tr></table></figure>
<p>使用这种方法进行深拷贝的时候，对于上面一些特殊的属性值，会出现拷贝异常的情况：</p>
<ul>
<li><code>undefined</code>, <code>symbol</code>, <code>函数</code> 会被忽略掉</li>
<li><code>NaN</code> 会被转换为 <code>null</code></li>
<li><code>regexp</code> 会被转换为 空对象</li>
<li><code>date</code> 对象会被转换为日期字符串</li>
</ul>
<p>同时，无法拷贝循环引用的对象</p>
</li>
<li><p>一种 <code>cloneDeep</code> 的方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> value === <span class="string">'object'</span> &amp;&amp; value !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> isArray = <span class="built_in">Array</span>.isArray(value)</span><br><span class="line">    <span class="keyword">let</span> result = isArray ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (isArray) &#123;</span><br><span class="line">      value.forEach(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        result.push(cloneDeep(val))</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> value) &#123;</span><br><span class="line">        result[k] = cloneDeep(value[k])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="lodash-中的-cloneDeep-方法"><a href="#lodash-中的-cloneDeep-方法" class="headerlink" title="lodash 中的 cloneDeep 方法"></a><code>lodash</code> 中的 <code>cloneDeep</code> 方法</h3><h4 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> baseClone <span class="keyword">from</span> <span class="string">'./.internal/baseClone.js'</span></span><br><span class="line"><span class="keyword">const</span> CLONE_DEEP_FLAG = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> CLONE_SYMBOLS_FLAG = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入口调用  <code>baseClone</code> 文件中的 <code>baseClone</code> 方法，向这个方法中传入了两个数据：</p>
<p><code>value</code>: 要进行复制的数据</p>
<p><code>CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG</code>:  掩码，表明使用 <code>baseClone</code> 来进行深拷贝以及 <code>symbol</code> 数据类型的拷贝</p>
<h4 id="baseClone"><a href="#baseClone" class="headerlink" title="baseClone"></a><code>baseClone</code></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The base implementation of `clone` and `cloneDeep` which tracks</span></span><br><span class="line"><span class="comment"> * traversed objects.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>value 需要克隆的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>bitmask 掩码标识</span></span><br><span class="line"><span class="comment"> *  1 - Deep clone</span></span><br><span class="line"><span class="comment"> *  2 - Flatten inherited properties</span></span><br><span class="line"><span class="comment"> *  4 - Clone symbols</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>[customizer] 定制 clone 的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>[key] value 的属性 key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>[object] 值的父对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>[stack] 用来追踪遍历的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;*&#125;</span> </span>Returns the cloned value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseClone</span>(<span class="params">value, bitmask, customizer, key, object, stack</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result</span><br><span class="line">  <span class="comment">// 三种克隆的配置值</span></span><br><span class="line">  <span class="keyword">const</span> isDeep = bitmask &amp; CLONE_DEEP_FLAG</span><br><span class="line">  <span class="keyword">const</span> isFlat = bitmask &amp; CLONE_FLAT_FLAG</span><br><span class="line">  <span class="keyword">const</span> isFull = bitmask &amp; CLONE_SYMBOLS_FLAG</span><br><span class="line">  <span class="comment">// 使用定制化的 clone 方法</span></span><br><span class="line">  <span class="keyword">if</span> (customizer) &#123;</span><br><span class="line">    result = object ? customizer(value, key, object, stack) : customizer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定制化的 clone 方法执行之后，返回结果</span></span><br><span class="line">  <span class="keyword">if</span> (result !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当非 引用类型的时候，返回值</span></span><br><span class="line">  <span class="keyword">if</span> (!isObject(value)) &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> isArr = <span class="built_in">Array</span>.isArray(value)</span><br><span class="line">  <span class="comment">// 获取当前数据的类型</span></span><br><span class="line">  <span class="keyword">const</span> tag = getTag(value)</span><br><span class="line">  <span class="keyword">if</span> (isArr) &#123;</span><br><span class="line">    <span class="comment">// 初始化 clone 数组</span></span><br><span class="line">    result = initCloneArray(value)</span><br><span class="line">    <span class="keyword">if</span> (!isDeep) &#123;</span><br><span class="line">      <span class="keyword">return</span> copyArray(value, result)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> isFunc = <span class="keyword">typeof</span> value === <span class="string">'function'</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当 value 是一种 buffer 数据的时候</span></span><br><span class="line">    <span class="keyword">if</span> (isBuffer(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> cloneBuffer(value, isDeep)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当当前的数据类型为 对象，参数对象，函数的时候</span></span><br><span class="line">    <span class="keyword">if</span> (tag == objectTag || tag == argsTag || (isFunc &amp;&amp; !object)) &#123;</span><br><span class="line">      <span class="comment">// 当是一个函数的时候，初始化为一个空对象，否则，调用 initCloneObject</span></span><br><span class="line">      result = (isFlat || isFunc) ? &#123;&#125; : initCloneObject(value)</span><br><span class="line">      <span class="keyword">if</span> (!isDeep) &#123;</span><br><span class="line">        <span class="keyword">return</span> isFlat</span><br><span class="line">          ? copySymbolsIn(value, copyObject(value, keysIn(value), result))</span><br><span class="line">          : copySymbols(value, <span class="built_in">Object</span>.assign(result, value))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 对于 typeof value === 'object' 但是 调用 `getTag` 方法并不是严格对象的值的处理</span></span><br><span class="line">      <span class="comment">// 例如：let n = new Number()</span></span><br><span class="line">      <span class="comment">// typeof n === 'number' but Object.prototype.toString.call(n) === '[object Number]'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isFunc || !cloneableTags[tag]) &#123;</span><br><span class="line">        <span class="keyword">return</span> object ? value : &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      result = initCloneByTag(value, tag, isDeep)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Check for circular references and return its corresponding clone.</span></span><br><span class="line">  <span class="comment">// 创建一个 Stack 的数据结果</span></span><br><span class="line">  <span class="comment">// 使用 stack 目的可以检查循环引用，返回对应的 clone 数据</span></span><br><span class="line">  stack || (stack = <span class="keyword">new</span> Stack)</span><br><span class="line">  <span class="keyword">const</span> stacked = stack.get(value)</span><br><span class="line">  <span class="keyword">if</span> (stacked) &#123;</span><br><span class="line">    <span class="keyword">return</span> stacked</span><br><span class="line">  &#125;</span><br><span class="line">  stack.set(value, result)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当当前数据为 map 结构的时候</span></span><br><span class="line">  <span class="comment">// result 为 map 数据</span></span><br><span class="line">  <span class="keyword">if</span> (tag == mapTag) &#123;</span><br><span class="line">    value.forEach(<span class="function">(<span class="params">subValue, key</span>) =&gt;</span> &#123;</span><br><span class="line">      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当 当前数据为。set 数据的时候</span></span><br><span class="line">  <span class="keyword">if</span> (tag == setTag) &#123;</span><br><span class="line">    value.forEach(<span class="function">(<span class="params">subValue</span>) =&gt;</span> &#123;</span><br><span class="line">      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isTypedArray(value)) &#123;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="keyword">const</span> keysFunc = isFull</span><br><span class="line">    ? (isFlat ? getAllKeysIn : getAllKeys)</span><br><span class="line">    : (isFlat ? keysIn : keys)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> props = isArr ? <span class="literal">undefined</span> : keysFunc(value)</span><br><span class="line">  arrayEach(props || value, (subValue, key) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (props) &#123;</span><br><span class="line">      key = subValue</span><br><span class="line">      subValue = value[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Recursively populate clone (susceptible to call stack limits).</span></span><br><span class="line">    <span class="comment">// 递归式的 clone</span></span><br><span class="line">    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack))</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> baseClone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="getTag"><a href="#getTag" class="headerlink" title="getTag"></a><code>getTag</code></h6><p><code>getTag</code> 方法用来获取元素的类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> toString = <span class="built_in">Object</span>.prototype.toString</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets the `toStringTag` of `value`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>value The value to query.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;string&#125;</span> </span>Returns the `toStringTag`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTag</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value === <span class="literal">undefined</span> ? <span class="string">'[object Undefined]'</span> : <span class="string">'[object Null]'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> toString.call(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> getTag</span><br></pre></td></tr></table></figure>
<h6 id="initCloneObject"><a href="#initCloneObject" class="headerlink" title="initCloneObject"></a><code>initCloneObject</code></h6><p><code>initCloneObject</code> 用来初始化克隆对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// object 用来初始化克隆的对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initCloneObject</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当 object 为非原型对象的时候，返回一个对象，这个对象的继承 obj 的原型</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">typeof</span> object.constructor === <span class="string">'function'</span> &amp;&amp; !isPrototype(object))</span><br><span class="line">    ? <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(object))</span><br><span class="line">    : &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> initCloneObject</span><br></pre></td></tr></table></figure>
<p>###### </p>
<h6 id="isPrototype"><a href="#isPrototype" class="headerlink" title="isPrototype"></a><code>isPrototype</code></h6><p>判断 <code>value</code> 是否为原型，如果是，返回 <code>true</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> objectProto = <span class="built_in">Object</span>.prototype</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Checks if `value` is likely a prototype object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>value The value to check.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;boolean&#125;</span> </span>Returns `true` if `value` is a prototype, else `false`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrototype</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Ctor = value &amp;&amp; value.constructor</span><br><span class="line">  <span class="keyword">const</span> proto = (<span class="keyword">typeof</span> Ctor === <span class="string">'function'</span> &amp;&amp; Ctor.prototype) || objectProto</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> value === proto</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>深拷贝</tag>
      </tags>
  </entry>
</search>
