<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深拷贝]]></title>
    <url>%2F2021%2F03%2F08%2F%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }深拷贝和浅拷贝的区别：浅拷贝 : 当对于一个对象进行浅拷贝的时候，会创建一个新的对象，新对象包含有旧对象的所有属性，当属性值为基本类型时，拷贝的就是这个基本类型的值，当属性值为引用类型的时候，拷贝的是这个引用类型的内存地址深拷贝：将一个对象从内存中完整的拷贝出来，开辟一个新的区域存储新对象，并且修改新对象不会影响旧对象实现深拷贝 使用 JSON.parse(JSON.stringify())这种最简单的实现深拷贝的方法同时存在许多的缺点12345678910111213141516171819let obj = &#123; date: new Date(), nan: NaN, function: new Function(), undefined: undefined, regexp: new RegExp('\\w+'), symbol: Symbol('symbol')&#125;function deepClone(obj) &#123; return JSON.parse(JSON.stringify(obj))&#125;let cloneObj = deepClone(obj)console.log(cloneObj)// 打印结果如下&#123; date: '2021-02-26T07:22:37.173Z', nan: null, regexp: &#123;&#125; &#125; 使用这种方法进行深拷贝的时候，对于上面一些特殊的属性值，会出现拷贝异常的情况： undefined, symbol, 函数 会被忽略掉 NaN 会被转换为 null regexp 会被转换为 空对象 date 对象会被转换为日期字符串 同时，无法拷贝循环引用的对象 一种 cloneDeep 的方法：12345678910111213141516function cloneDeep(value) &#123; if(typeof value === 'object' &amp;&amp; value !== null) &#123; const isArray = Array.isArray(value) let result = isArray ? [] : &#123;&#125; if (isArray) &#123; value.forEach(val =&gt; &#123; result.push(cloneDeep(val)) &#125;) &#125; else &#123; for (let k in value) &#123; result[k] = cloneDeep(value[k]) &#125; &#125; return result &#125; else return value&#125; lodash 中的 cloneDeep 方法 入口 1234567import baseClone from './.internal/baseClone.js'const CLONE_DEEP_FLAG = 1const CLONE_SYMBOLS_FLAG = 4function cloneDeep(value) &#123; return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG)&#125; 入口调用 baseClone 文件中的 baseClone 方法，向这个方法中传入了两个数据：value: 要进行复制的数据CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG: 掩码，表明使用 baseClone 来进行深拷贝以及 symbol 数据类型的拷贝baseClone 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118/** * The base implementation of `clone` and `cloneDeep` which tracks * traversed objects. * * @private * @param &#123;*&#125; value 需要克隆的数据 * @param &#123;number&#125; bitmask 掩码标识 * 1 - Deep clone * 2 - Flatten inherited properties * 4 - Clone symbols * @param &#123;Function&#125; [customizer] 定制 clone 的方法 * @param &#123;string&#125; [key] value 的属性 key * @param &#123;Object&#125; [object] 值的父对象 * @param &#123;Object&#125; [stack] 用来追踪遍历的对象 * @returns &#123;*&#125; Returns the cloned value. */function baseClone(value, bitmask, customizer, key, object, stack) &#123; let result // 三种克隆的配置值 const isDeep = bitmask &amp; CLONE_DEEP_FLAG const isFlat = bitmask &amp; CLONE_FLAT_FLAG const isFull = bitmask &amp; CLONE_SYMBOLS_FLAG // 使用定制化的 clone 方法 if (customizer) &#123; result = object ? customizer(value, key, object, stack) : customizer(value) &#125; // 定制化的 clone 方法执行之后，返回结果 if (result !== undefined) &#123; return result &#125; // 当非 引用类型的时候，返回值 if (!isObject(value)) &#123; return value &#125; const isArr = Array.isArray(value) // 获取当前数据的类型 const tag = getTag(value) if (isArr) &#123; // 初始化 clone 数组 result = initCloneArray(value) if (!isDeep) &#123; return copyArray(value, result) &#125; &#125; else &#123; const isFunc = typeof value === 'function' // 当 value 是一种 buffer 数据的时候 if (isBuffer(value)) &#123; return cloneBuffer(value, isDeep) &#125; // 当当前的数据类型为 对象，参数对象，函数的时候 if (tag == objectTag || tag == argsTag || (isFunc &amp;&amp; !object)) &#123; // 当是一个函数的时候，初始化为一个空对象，否则，调用 initCloneObject result = (isFlat || isFunc) ? &#123;&#125; : initCloneObject(value) if (!isDeep) &#123; return isFlat ? copySymbolsIn(value, copyObject(value, keysIn(value), result)) : copySymbols(value, Object.assign(result, value)) &#125; // 对于 typeof value === 'object' 但是 调用 `getTag` 方法并不是严格对象的值的处理 // 例如：let n = new Number() // typeof n === 'number' but Object.prototype.toString.call(n) === '[object Number]' &#125; else &#123; if (isFunc || !cloneableTags[tag]) &#123; return object ? value : &#123;&#125; &#125; result = initCloneByTag(value, tag, isDeep) &#125; &#125; // Check for circular references and return its corresponding clone. // 创建一个 Stack 的数据结果 // 使用 stack 目的可以检查循环引用，返回对应的 clone 数据 stack || (stack = new Stack) const stacked = stack.get(value) if (stacked) &#123; return stacked &#125; stack.set(value, result) // 当当前数据为 map 结构的时候 // result 为 map 数据 if (tag == mapTag) &#123; value.forEach((subValue, key) =&gt; &#123; result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack)) &#125;) return result &#125; // 当 当前数据为。set 数据的时候 if (tag == setTag) &#123; value.forEach((subValue) =&gt; &#123; result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack)) &#125;) return result &#125; if (isTypedArray(value)) &#123; return result &#125; // const keysFunc = isFull ? (isFlat ? getAllKeysIn : getAllKeys) : (isFlat ? keysIn : keys) const props = isArr ? undefined : keysFunc(value) arrayEach(props || value, (subValue, key) =&gt; &#123; if (props) &#123; key = subValue subValue = value[key] &#125; // Recursively populate clone (susceptible to call stack limits). // 递归式的 clone assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack)) &#125;) return result&#125;export default baseClone&#125; getTag getTag 方法用来获取元素的类型1234567891011121314151617const toString = Object.prototype.toString/** * Gets the `toStringTag` of `value`. * * @private * @param &#123;*&#125; value The value to query. * @returns &#123;string&#125; Returns the `toStringTag`. */function getTag(value) &#123; if (value == null) &#123; return value === undefined ? '[object Undefined]' : '[object Null]' &#125; return toString.call(value)&#125;export default getTag initCloneObject initCloneObject 用来初始化克隆对象：123456789// object 用来初始化克隆的对象function initCloneObject(object) &#123; // 当 object 为非原型对象的时候，返回一个对象，这个对象的继承 obj 的原型 return (typeof object.constructor === 'function' &amp;&amp; !isPrototype(object)) ? Object.create(Object.getPrototypeOf(object)) : &#123;&#125;&#125;export default initCloneObject isPrototype 判断 value 是否为原型，如果是，返回 true对于 原型 对象上面包含有 constructor 属性123456789101112131415const objectProto = Object.prototype/** * Checks if `value` is likely a prototype object. * * @private * @param &#123;*&#125; value The value to check. * @returns &#123;boolean&#125; Returns `true` if `value` is a prototype, else `false`. */function isPrototype(value) &#123; const Ctor = value &amp;&amp; value.constructor const proto = (typeof Ctor === 'function' &amp;&amp; Ctor.prototype) || objectProto return value === proto&#125; 对于边界条件的处理：如果仅仅按照下面的代码进行判断是有问题的： 12345function isPrototype(vlaue) &#123; const Ctor = value &amp;&amp; value.constructor const proto = (typeof Ctor === 'function' &amp;&amp; Ctor.prototype) return value === proto&#125; 如果我们传入一个 false, isPrototype 返回的结果为 true, 与结果不符合，因此设置 一个 objectProto 来防止这种情况]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 中的数据存储]]></title>
    <url>%2F2021%2F03%2F08%2Fgit%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }版本控制系统 代码版本控制系统大致可以分为三代：本地版本控制系统 代码存储在本地，无法实现多人协作的需求集中化的版本控制系统 解决了多人协作的问题，但是因为代码都是统一存储在服务器上，当无法连接服务器上的时候，无法查看日志和提交比较代码分布式的版本控制系统 这种控制系统的特点是，任何人都可以复制一份和服务上相同的代码，当无法连接服务器的时候，仍然可以提交代码，创建分支Git 中文件夹 .git 当我们使用 git init 初始化git 仓库的时候，当前文件夹下出生成一个 .git 的隐藏文件夹，这个文件夹内存储着我们进行 git 操作的一些数据： 存储当前的分支（HEAD） 存储当前所有的分支信息（config） 存储提交的文件快照数据（objects） .... 三种基本文件 当我们输入一些git命令的时候，git 根据的输入的命令会生成一些文件，有的文件用来存储当前提交的文件内容，有的文件用来存储我们当前提交的信息，这些文件都被存储在 objects 这个文件夹之内，有三种基本文件在我们使用 git 进行数据存储时是息息相关的： blob 文件 tree 文件 commit 文件 blob 文件 blob 文件用来存储我们提交代码的文件快照，这种文件存储的是压缩后的文件内容代码实践下 blob 文件是如何生成的： git 初始化： 初始化的 git 仓库内创建两个文件: 1.txt 与 2.txt, 内容分别是 1 和 2 执行 git add： 查看出现的 d8 和 56 这两个文件夹 ​ 如图，发现是乱码的形式，这是因为 Git 将信息压缩成了二进制，对于这种文件，使用 git cat-file [-t][-p] 来查看文件类型或者 文件内容 ​ 可以看到，使用 git add 命令生成的 56 和 d8 文件都是 blob 类型文件，并且存储的是文件的内容tree 文件 继续上面的操作，这次执行 git commit 命令： 查看 objects 文件： 相比之前多出了两个文件夹：3c 和 96 查看 3c 文件夹​ ​ 可以看到， 3c 文件夹下的文件存储的内容为我们这次 commit 修改的两个文件 1.txt 和 2.txt ，除了文件名之外，还保存有此次修改的blob文件的文件名以及文件类型3c文件夹下的文件类型为 tree, 这种文件存储的信息是当前提交的文件目录commit 文件 查看生成的 96 文件夹，我们可以看到如下内容： 96 文件夹下的文件类型为 commit 文件， 存储的内容是本次 commit 的信息: 提交人，提交信息（git test）等，其中还存储了 tree 文件的文件名，除了这些信息之外， 还存储有上一次提交的 commit 文件（父点），因为我们这里是初次提交，没有上一次提交，因此没有父节点三种文件之间的关系 综上所述，三种类型的文件的主要作用是：blob：存储提交文件的快照 tree：存储提交文件的文件目录以及文件名，blob 文件地址等信息 commit： 存储提交信息，提交生成的 tree 文件用一张图可以说明三种类型文件之间的关系： 总结 使用 git add . 命令时，将变动内容的文件保存生成 blob 文件 使用 git commit 命令时， 生成 tree 文件与 commit 文件 当前分支的指针指向新的 commit 节点，节点中存在 parent 字段，表明上一次提交 commit 文件，逐级向上，一直到第一次提交，这些 commit 连接成为提交记录（git log）]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 中的合并策略]]></title>
    <url>%2F2021%2F03%2F08%2Fgit%20%E4%B8%AD%E7%9A%84%E5%90%88%E5%B9%B6%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }当我们合并两个分支的时候，Git 会帮我们自动挑选合适的合并策略，常见的 git 合并策略有 Fast-forward、Recursive 、Ours、Theirs 几种，不同的合并策略适用于不同的合并场景，如果想要强制指定一种合并策略，使用 git merge -s &lt;策略名字&gt; 命令Fast-forward: 这种合并策略是最简单的一种，适用的场景是：合并两个没有分叉的分支，入下图所示，这个时候只是将 master 分支移动到最新的节点就好 Recursive： 使用 recursive 进行合并的场景是合并两个有分叉的分支，这是经常使用到的一种合并策略 如上图所示，使用 Recursive 的合并过程是：合并中间两个节点 A， B 的时候，先找到它们两个节点的共同祖先节点，最左边的 A，然后这三个节点进行三向合并，最终得到最右边的节点 B‘Recursive 合并策略的合并算法可以总结为：递归寻找路径最短的唯一共同祖先节点，然后以其为 base 节点进行递归三向合并so，什么是三向合并就是我们了解这个合并策略最需要知道的内容三向合并 假如我们在两个分支上，分别修改了同一个文件，如下图所示， 当对于这两个分支进行合并的时候，那么能否合并成功呢？ 很显然是不能的，因为 git 无法判断合并之后的文件是采用哪一个文件的代码为了判断合并之后的文件采用哪一个分支修改的代码，我们除了上面的两个文件之外，还需要一个 base 节点的文件，这个节点的作用是作为对比分别和两个文件进行比较：如上图所示，我们通过三个文件进行对比可以得知，在 Yours 分支上的代码修改了文件，因此合并之后的文件中的内容采用这个分支上修改的内容。会不会出现三个文件上相同的文件修改的内容都不相同的情况呢 ？ 会的，这种情况的出现就是我们合并中会遇到的 冲突这个时候就需要我们解决冲突才能进行合并寻找 base 节点 在了解了三向合并的合并策略之后，接下来我们需要关心的是：如何查找 base 节点像recursive 合并算法中描述的： 递归寻找路径最短的的唯一共同祖先节点如下图： 下面的 Git 流程图中每一个圆圈表示一次提交，圆圈里面的文字表这次提交的文件内容，如果两个圆圈内文件的内容一致，则表示两次提交文件的内容没有被修改 我们想要合并中间的两个节点 A 和 B，找到它们共同的祖先节点 A， 以它为base节点进行三向合并得到最右边的 B 节点 实际情况可能比较复杂，如下图所示情况： 我们想要合并两个节点， B 和 C，查找到 B， C 的节点发现有两个共同的祖先节点： A 和 B，这种情况下我们应该以谁作为祖先节点呢 ？在这种情况下， git 会继续递归查找，寻找 A 和 B 的共同祖先节点，将这个共同的祖先节点为base节点和 A，B进行合并， 如上图所示，首先找到了一个合并之后的节点 4/B, 在根据这个节点作为 base 节点，和 节点 B C 进行三向合并Ours &amp; Theirs 使用 Ours 和 Theirs 这两种合并策略的目的是： 我们希望保留两个分支的历史记录，但是忽略掉一方的代码变更使用 Ours 和 Theirs 应用的场景相似，假如有两个分支，在这两个分支上对于同一功能进行了不同的代码实现，如果我们想要采用其中一种，但是希望另外一种代码实现也能出现在提交记录中的时候，可以执行 git merge -s ours/theirs 命令来实现 如上图所示，最终只会保留 master 分支上的代码]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[协商缓存和强缓存]]></title>
    <url>%2F2020%2F09%2F26%2F%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E5%92%8C%E5%BC%BA%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }缓存是指代理服务器或者客户端本地磁盘内保存的资源副本。使用缓存可以减少对于源服务器的访问，从而节省通信流量和通信时间。在服务器与客户端的通信过程中，对于数据的缓存方式可以分为 强缓存 和 协商缓存 两种，通过http请求头中的 Cache-Control 可以决定是否采用上面两种方式缓存涉及到的相关字段有：Cache-Control Expires Last-Modified If-Modified-Since Etag If-None-Match强缓存 强缓存就是当客户端发起请求之前，首先检查浏览器缓存中是否有要请求的内容，并且根据结果的缓存规则来判断是否实际向服务器发起请求客户端发起请求时，会有下面三种结果： 没有缓存结果，那么需要向服务器请求内容 存在缓存结果，并且缓存规则未失效，那么直接使用缓存的内容 存在缓存结果，但缓存规则已经失效，那么也需要重新向服务器请求内容，效果同 1 使用请求返回头中的：Cache-Control 字段来配置缓存的行为： public: 可以向任意方提供响应的缓存，发送请求的客户端或者代理服务器都可以缓存数据 private: 只有浏览器才能缓存内容 no-cache: 强制所有缓存了该响应的用户，在使用已经缓存的数据前，发送带有验证的请求到服务器，需要等待服务器确认之后，才能使用浏览器缓存 no-store: 不进行缓存，每次请求都需要向服务器重新请求数据 max-age: 指定资源的缓存时间，在客户端请求头中添加时，表示如果缓存资源的缓存时间数值比设置的 max-age 的数值小的话，那么客户端就接收缓存的资源当服务器响应头中添加时，表示当前返回的资源内容在浏览器中的最大缓存时间，在没有禁用缓存并且没有超过有效时间的情况下，再次访问这个资源就命中了缓存，不会向服务器请求资源而是直接从浏览器缓存中取。 协商缓存 协商缓存就是当强制缓存失效后，客户端和服务器根据请求头或者响应头的相关字段来判断是否采用浏览器缓存的资源，因为有可能客户端请求的资源过了有效期，但是此时资源内容和服务器上的资源没有差别，仍然可以使用浏览器缓存资源来避免再次请求服务器资源协商缓存是由服务器来决定是否使用缓存的因此关键是：如何判断服务器上的资源和浏览器上缓存的资源是不是相同的，下面的两种方式分别是根据文件修改时间和文件唯一标识来判断的，两种方式： Last-modified/If-Modified-Since这两个字段是一种时间戳的形式字符串服务器响应头中带有： Last-modified 表示资源最后被修改的时间，当客户端再次请求相同资源时，在请求头中添加 If-Modified-Since 字段为上次请求资源时服务器返回的资源最后修改时间，服务器收到请求之后，会将 If-Modified-Since 的时间与 Last-modified 进行对比，如果不一致，则重新请求资源，如果一致，那么使用浏览器缓存的资源（304） Etag/If-None-Match这两个值都是请求当前资源文件的唯一标识，这个标识是由服务器生成的类似于上面的过程，Etag 由服务器返回，If-None-Match 是再次请求资源时添加在请求头中的字段，值是上次请求时返回头中返回的 Etag 字段的值，在服务器中，根据 If-None-Match的字段值与该资源在服务器的Etag值做对比，如果不一致，重新请求资源，如果一致，同样使用浏览器缓存资源（304） 在 http 中，状态码 304 （Not Modified）返回的内容为空，因为这个时候表示当前请求的资源和服务器上的资源一致，可以直接使用浏览器缓存的内容 总结 概括来说：强缓存是直接使用浏览器内缓存的内容，使用到的字段有：Expires 或者 Cache-Control: max-age=3600 (表示资源的缓存时间是 3600 s)协商缓存是需要服务器参与确认是否使用浏览器缓存的内容的机制，应用在强缓存失效之后这个过程可以用下面的示意图来说明：]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios + vue 实现页面销毁时请求取消]]></title>
    <url>%2F2020%2F09%2F22%2Faxios%20%2B%20vue%20%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E9%94%80%E6%AF%81%E6%97%B6%E8%AF%B7%E6%B1%82%E5%8F%96%E6%B6%88%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }在日常的开发中，会遇到这样的需求：我们想要当离开当前页面的时候， 这个页面上的请求的接口不会继续请求使用 vue + axios 来实现手动取消请求的功能：代码如下：cancelRequest.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196import axios from 'axios'class Collector &#123; constructor(axiosIns, cancelList) &#123; this.axiosIns = axiosIns this.cancelList = cancelList || [] const handlersCount = this.getAllHandlers().length this.handlerIndex = handlersCount ? handlersCount - 1 : 0 this.insertInterceptors = &#123;&#125; &#125; getCancelKeys() &#123; return this.cancelList.map((&#123; key &#125;) =&gt; key) &#125; hasKey(key) &#123; return this.getCancelKeys().includes(key) &#125; get(cancelKey) &#123; return this.cancelList.find((&#123; key &#125;) =&gt; cancelKey === key) &#125; getAllHandlers() &#123; return this.cancelList.reduce((allHandlers, &#123; handlerList &#125;) =&gt; &#123; allHandlers = [...allHandlers, ...handlerList] return allHandlers &#125;, []) &#125; getHandlers(cancelKey) &#123; if (!this.hasKey(cancelKey)) &#123; return [] &#125; return this.get(cancelKey).handlerList &#125; removeInsertInterceptors() &#123; const interceptors = this.axiosIns.interceptors Object.entries(this.insertInterceptors).forEach(([type, incpts]) =&gt; &#123; const handlers = interceptors[type].handlers incpts.forEach(interceptor =&gt; &#123; const incptIndex = handlers.indexOf(interceptor) if (incptIndex !== -1) &#123; interceptors[type].handlers.splice(incptIndex, 1) &#125; &#125;) &#125;) this.insertInterceptors = &#123;&#125; &#125; removeHandler(removeKey, handlerIndex) &#123; const handlerList = this.getHandlers(removeKey) handlerList.length &amp;&amp; handlerList.splice(handlerIndex, 1) if (!handlerList.length) &#123; this.remove(removeKey) &#125; &#125; remove(key) &#123; if (!this.hasKey(key)) return const keyIndex = this.getCancelKeys().indexOf(key) this.cancelList.splice(keyIndex, 1) &#125; cancel(key) &#123; if (key !== undefined) &#123; let handlerList = this.getHandlers(key) for (let i = 0; i &lt; handlerList.length; i++) &#123; handlerList[i]() &#125; this.remove(key) &#125; else &#123; const handlerList = this.getAllHandlers() handlerList.forEach(handler =&gt; handler()) this.cancelList = [] &#125; &#125; add(cancelObj) &#123; const &#123; key, handler &#125; = cancelObj this.handlerIndex++ if (!this.hasKey(key)) &#123; this.cancelList.push(&#123; key, handlerList: [handler] &#125;) &#125; else &#123; const existHandlers = this.getHandlers(key) this.get(key).handlerList = [...existHandlers, handler] &#125; &#125;&#125;class CancelRequest &#123; constructor(config) &#123; const defaultConfig = &#123; vm: null, includes: [] &#125; this.config = Object.assign(&#123;&#125;, defaultConfig, config) this.cancelReqCollectorList = [] if (this.config.vm) &#123; this._vmDestroyedCancel() &#125; else &#123; console.warn('config vm is null, request will not be canceld when component destroyed') &#125; &#125; getAllAxiosInstance() &#123; return this.cancelReqCollectorList.map((&#123; axiosIns &#125;) =&gt; axiosIns) &#125; getCollector(instance) &#123; let existCollector = this.cancelReqCollectorList.find((&#123; axiosIns &#125;) =&gt; axiosIns === instance) if (!existCollector) &#123; existCollector = new Collector(instance) this.cancelReqCollectorList.push(existCollector) &#125; return existCollector &#125; // 拦截 vue 中的 _isDestroyed 属性， 当组件销毁时，取消请求 _vmDestroyedCancel() &#123; let isDestroyed = this.config.vm._isDestroyed Object.defineProperty(this.config.vm, '_isDestroyed', &#123; set: val =&gt; &#123; isDestroyed = val if (val) this.cancel(true) &#125;, get() &#123; return isDestroyed &#125; &#125;) &#125; getTokenKey(config) &#123; const &#123; baseURL, url &#125; = config if (url.startsWith('http')) &#123; return url &#125; return `$&#123;baseURL&#125;$&#123;url&#125;` &#125; getSource() &#123; const cancelToken = axios.CancelToken let source = cancelToken.source() return source &#125; insertInterceptor(interceptors, collector) &#123; const &#123; request, response &#125; = interceptors const requestInt = &#123; fulfilled: config =&gt; &#123; const setKey = this.getTokenKey(config) const source = this.getSource() const isValidIncludes = Array.isArray(this.config.includes) &amp;&amp; this.config.includes.length const isMatch = isValidIncludes &amp;&amp; this.config.includes.some(includeKey =&gt; setKey.includes(includeKey)) if (!isValidIncludes || isMatch) &#123; config.cancelToken = source.token collector.add(&#123; key: setKey, handler: source.cancel &#125;) config.cancelHandlerIndex = collector.handlerIndex &#125; return config &#125;, rejected: null &#125; const successRespInt = &#123; fulfilled: resp =&gt; &#123; const handlerIndex = resp.config.cancelHandlerIndex const removeKey = this.getTokenKey(resp.config) collector.remove(removeKey, handlerIndex) return resp &#125;, rejected: null &#125; const errorRespInt = &#123; fulfilled: null, rejected: error =&gt; &#123; const isCancel = axios.isCancel(error) if (!isCancel) &#123; const handlerIndex = error.config.cancelHandlerIndex collector.remove(this.getTokenKey(error.config), handlerIndex) &#125; return Promise.reject(error) &#125; &#125; collector.insertInterceptors = &#123; request: [requestInt], response: [successRespInt, errorRespInt] &#125; request.handlers.unshift(requestInt) response.handlers.unshift(successRespInt, errorRespInt) &#125; // 向 axios 实例中注入token insertToken(axiosInstance) &#123; const collector = this.getCollector(axiosInstance) const interceptors = axiosInstance.interceptors this.insertInterceptor(interceptors, collector) return collector &#125; cancel(isDestroyed) &#123; this.cancelReqCollectorList.forEach(collector =&gt; &#123; collector.cancel() if (isDestroyed) &#123; collector.removeInsertInterceptors() &#125; &#125;) if (isDestroyed) &#123; this.cancelReqCollectorList = [] &#125; &#125;&#125;export default CancelRequest 使用方法如下：在组件中1234567891011let http = axios.create()// this 为当前组件对象// 在使用 http 来请求时，调用下面的方法const cancelRes = new CancelRequest(&#123; vm: this &#125;)const cancelCollector = cancelRes.insertToken(http)// 当需要取消请求时：// 使用 cancel 方法来取消使用 http axios 实例来发起的请求cancelCollector.cancel() // 或者传入配置 vm: this 时// 当当前页面销毁时，会自动将当前页面正在发起的请求 cancel 掉]]></content>
      <categories>
        <category>代码</category>
      </categories>
      <tags>
        <tag>cancel request</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法（一）（选择，插入，冒泡，归并，快速）]]></title>
    <url>%2F2020%2F09%2F20%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%88%E9%80%89%E6%8B%A9%EF%BC%8C%E6%8F%92%E5%85%A5%EF%BC%8C%E5%86%92%E6%B3%A1%EF%BC%8C%E5%BD%92%E5%B9%B6%EF%BC%8C%E5%BF%AB%E9%80%9F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }下面是选择排序，插入排序，冒泡排序，归并排序，快速排序五种算法的原理以及具体的代码实现选择排序 从数组中选取一个元素 item，初次为第一个元素 在 item 剩余的元素中找到最小的元素 将这个最小的元素与 item 交换位置 重复 1，2， 3的过程，一直到数组结束 示意图如下代码如下：123456789101112131415function selectSort(arr) &#123; for (let i = 0; i &lt; arr.length; i ++) &#123; let minIdx = i; let temp = arr[i]; // 从剩余的元素中查找到最小的元素 for (let j = i + 1; j &lt; arr.length; j ++) &#123; if (arr[j] &lt; arr[minIdx]) &#123; minIdx = j; &#125; &#125; arr[i] = arr[minIdx]; arr[minIdx] = temp &#125; return arr;&#125; 插入排序 从数组中的第二个元素开始抽取元素 item 将 item 与 item 左边第一个元素进行比较，如果左边的元素大于item，那么继续与左边第二个元素继续比较，直到遇到不大于item 的元素，然后将这个元素插入到 item 的右边 继续选取第 3， 4， 5 个元素， 重复 2 过程， 直到数组结束 示意图如下代码如下：123456789101112131415161718192021function insertSort(arr) &#123; for (let i = 1; i &lt; arr.length; i ++) &#123; let k = i; let item = arr[i] while (k &gt;= 0) &#123; k --; // 当找到比当前要插入的元素小的元素时 // 将插入元素插入到小元素的右边 // 或者 k &lt; 0 时，这个时候表示找到最左边 // 都没有找到比 arr[i] 还要小的元素 if (item &gt; arr[k] || k &lt; 0) &#123; arr[k + 1] = item; break &#125; else &#123; // 整体向右边移 arr[k + 1] = arr[k] &#125; &#125; &#125; return arr;&#125; 冒泡排序 将第一个元素与第二个元素进行比较，如果第一个元素比第二个大，那么交换他们的位置，接着继续比较第二个元素和第三个元素 经过一轮比较之后，现在最右边的元素是数组里面最大的元素 除去最右边已经筛选后的元素之后，再对剩余的元素执行 1 过程 示意图如下代码如下：1234567891011121314function bubbleSort(arr, sortedIndex = arr.length - 1) &#123; let i = 0; while (i &lt; arr.length - 1) &#123; let nextIdx = i + 1; if (arr[i] &gt; arr[nextIdx]) &#123; let temp = arr[i] arr[i] = arr[nextIdx] arr[nextIdx] = temp &#125; i ++ &#125; sortedIndex -- return sortedIndex === 0 ? arr : bubbleSort(arr, sortedIndex)&#125; 归并排序 将大数组拆分为小数组，再拆分小数组，一直拆分到数组内只有一个元素 对于小数组内的元素进行排序操作，然后将小数组进行组合 最后组合的大数组为已经排好序的数组 示意图如下：代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041function merge(arr, left, mid, right) &#123; let a = new Array(right - left + 1) let i = left; let j = mid + 1; let k = 0; // 将两个数组进行组合 // 这两个数组分别为 arr[left, ... mid] 以及 arr[mid + 1, ... right] while(i &lt;= mid &amp;&amp; j &lt;= right) &#123; if (arr[i] &lt; arr[j]) &#123; a[k++] = arr[i++] &#125; else &#123; a[k++] = arr[j++] &#125; &#125; // 当还有剩余的 i 数组元素时 // 压入数组中 while(i &lt;= mid) &#123; a[k++] = a[i++] &#125; // 当还有剩余的 j 数组元素时 // 同样压入数组中 while(j &lt;= right) &#123; a[k++] = a[j++] &#125; // 将排好序的 a 数组复制到 arr 中 // 这里的数组 a 已经排好序了 for(i = 0; i &lt; k; i ++) &#123; arr[left ++] = a[i] &#125;&#125;function mergeSort(arr, left, right) &#123; if (left !== right) &#123; let mid = Math.floor((right + left) / 2) // 对于左边的元素进行排序 arr = mergeSort(arr, left, mid) // 对于右边的元素进行排序 arr = mergeSort(arr, mid + 1, right) merge(arr, left, mid, right) &#125;&#125; 快速排序 选取数组中的一个元素为中轴元素，将数组中所有小于中轴元素的元素放在左边，所有大于或者等于中轴元素的元素放在右边 进行完过程 1 之后，这时候中轴元素的位置已经确定了，这个元素左边都是比它小的元素，右边都是比它大的元素 对于中轴元素左右两边的元素再分别进行 1 过程，直到所有的元素作为中轴元素位置都确定了为止 示意图如下：代码如下：12345678910111213141516171819202122232425262728293031function partition(arr, left, right) &#123; let pivot = arr[left] let i = left + 1; let j = right; while (true) &#123; while(i &lt;= j &amp;&amp; arr[i] &lt;= pivot) &#123; i ++; &#125; while(i &lt;= j &amp;&amp; arr[j] &gt;= pivot) &#123; j --; &#125; if (i &gt;= j) &#123; break &#125; let temp = arr[i] arr[i] = arr[j] arr[j] = temp &#125; arr[left] = arr[j] arr[j] = pivot return j&#125;function quickSort(arr, left, right) &#123; if (left &lt; right) &#123; let mid = partition(arr, left, right) arr = quickSort(arr, left, mid - 1) arr = quickSort(arr, mid + 1, right) &#125; return arr&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node中的 events 模块]]></title>
    <url>%2F2020%2F09%2F14%2Fnode%E4%B8%AD%E7%9A%84%20events%20%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }了解 Node 中的 Events 模块node 中的 events 模块是 node 中使用较多的模块，比如在 node 中的流（stream），其内部使用 events 模块作为父类： 作为一个使用广泛的基础模块，其代码中是有些东西值得我们学习和借鉴的。发布/订阅模式 发布/订阅模式定义了一种一对多的依赖关系，观察者同时监听某一个对象相应的状态变化， 当状态变化时通知到所有观察者， 这种设计模式解决了主体对象和观察者之间的耦合问题。图示如下： 上图中左边为观察者模式， 右边为 发布/订阅 模式， 可以看出它们之间的区别是发布/订阅模式通过事件调度中心（Event Channel）来对于事件进行统一管理观察上图可知，发布/订阅这种设计模式的组成特点： 整体结构有三部分组成， 订阅者（Subscriber）, 发布者（Publisher）以及 事件调度器（Event Channel） 订阅者在事件调度器中订阅（Subscribe）事件， 发布者发布事件时，订阅该事件的订阅者将会收到消息通知（事件触发的形式） 在 Node 中的 Events 模块中， 采用了这种设计模式，模块内部维护了一个事件列表（_events）,提供了基础的 api 来进行发布和订阅（emit, on）在 Events 中，订阅事件时需要传入两个参数： 事件名（eventName）以及 事件触发时的回调方法（listener），订阅之后按照下面的结构存储在 _events 中：1234_events = &#123; eventName: listener, wrapFn &#123; fired: false/true, listener &#125; eventName: [listener1, listener2 ....]&#125; 当调用 this.emit(eventName) 来发布特定事件时，将会依次调用_events 中的事件（listener）Events 模块代码实现 on / addListener(eventName, listener)这个方法的作用是订阅eventName 事件, 当事件被发布时， listener 方法被执行具体代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 订阅事件// target: EventEmitter 实例// type: 事件类型// listener: 事件触发后的回调方法// prepend: 是否将回调方法前置（首先触发）,默认为 false, 将会被放到回调方法的最后function _addListener(target, type, listener, prepend) &#123; var m; var events; var existing; // 判断是否为有效的函数 checkListener(listener); events = target._events; if (events === undefined) &#123; events = target._events = Object.create(null); target._eventsCount = 0; &#125; else &#123; // To avoid recursion in the case that type === "newListener"! Before // adding it to the listeners, first emit "newListener". if (events.newListener !== undefined) &#123; target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the // this._events to be assigned to a new object events = target._events; &#125; existing = events[type]; &#125; if (existing === undefined) &#123; // Optimize the case of one listener. Don't need the extra array object. // 只有一个 listener 的情况， 存储的直接是这个函数 existing = events[type] = listener; ++target._eventsCount; &#125; else &#123; if (typeof existing === 'function') &#123; // Adding the second element, need to change to array. existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append. &#125; else if (prepend) &#123; existing.unshift(listener); &#125; else &#123; existing.push(listener); &#125; // Check for listener leak // 获取到一个事件最多的 listener 数量 m = _getMaxListeners(target); if (m &gt; 0 &amp;&amp; existing.length &gt; m &amp;&amp; !existing.warned) &#123; existing.warned = true; // No error code for this since it is a Warning // eslint-disable-next-line no-restricted-syntax var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit'); w.name = 'MaxListenersExceededWarning'; w.emitter = target; w.type = type; w.count = existing.length; ProcessEmitWarning(w); &#125; &#125; return target;&#125;EventEmitter.prototype.addListener = function addListener(type, listener) &#123; return _addListener(this, type, listener, false);&#125;;EventEmitter.prototype.on = EventEmitter.prototype.addListener emit(eventName[, ...args])作用：发布 eventName 事件， 传入的 args 将会作为该事件下 listener 的参数代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 这里包含了 type 为 "error" 或者其他需要 emit 的触发EventEmitter.prototype.emit = function emit(type) &#123; var args = []; for (var i = 1; i &lt; arguments.length; i++) args.push(arguments[i]); var doError = (type === 'error'); var events = this._events; // 当 events 存在的时候 if (events !== undefined) // 当 events 中不存在 error 事件时还 emit 了 error 事件 doError = (doError &amp;&amp; events.error === undefined); // 当 events 不存在， 并且 type 为非 error时， 直接返回 false else if (!doError) return false; // If there is no 'error' event listener then throw. // events 中没有 error 的时候 if (doError) &#123; var er; if (args.length &gt; 0) er = args[0]; if (er instanceof Error) &#123; // Note: The comments on the `throw` lines are intentional, they show // up in Node's output if this results in an unhandled exception. throw er; // Unhandled 'error' event &#125; // At least give some kind of context to the user var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : '')); err.context = er; throw err; // Unhandled 'error' event &#125; var handler = events[type]; if (handler === undefined) return false; if (typeof handler === 'function') &#123; ReflectApply(handler, this, args); &#125; else &#123; var len = handler.length; var listeners = arrayClone(handler, len); for (var i = 0; i &lt; len; ++i) ReflectApply(listeners[i], this, args); &#125; return true;&#125;; off / removeListener(eventName, listener) 作用： 从事件名为 eventName 的事件下移除特定的回调方法（listener） 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// Emits a 'removeListener' event if and only if the listener was removed.// 移除特定事件的 listener &amp;&amp; // EventEmitter.on('removeListener'， handler) 触发// type: 特定事件名称// listener: 移除的函数EventEmitter.prototype.removeListener = function removeListener(type, listener) &#123; var list, events, position, i, originalListener; checkListener(listener); events = this._events; if (events === undefined) return this; list = events[type]; if (list === undefined) return this; // 这里判断是否 list 中只有一个 listener 或者 list 是 wrap fn 的情况 if (list === listener || list.listener === listener) &#123; if (--this._eventsCount === 0) this._events = Object.create(null); else &#123; delete events[type]; if (events.removeListener) this.emit('removeListener', type, list.listener || listener); &#125; // 当 list 不是一个函数的时候，这个时候这个 list 是一个数组 &#125; else if (typeof list !== 'function') &#123; position = -1; for (i = list.length - 1; i &gt;= 0; i--) &#123; if (list[i] === listener || list[i].listener === listener) &#123; originalListener = list[i].listener; position = i; break; &#125; &#125; // 找不到listener if (position &lt; 0) return this; // 第一个是要找到的 listener if (position === 0) list.shift(); else &#123; // 如果要进行删除的元素在 list 数组之中 // splice spliceOne(list, position); &#125; // 当 list 删除完成之后只有一个 listener 时， 直接将这个 listener 作为 events[type] 的值 if (list.length === 1) events[type] = list[0]; if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener); &#125; return this; &#125;;EventEmitter.prototype.off = EventEmitter.prototype.removeListener; 特别：spliceOne 方法, 而非使用splice 方法12345678// 这里是删除数组的方法// 用的方法是找到一个数组的位置， 然后往前挪// 这种方法性能提升比较大function spliceOne(list, index) &#123; for (; index + 1 &lt; list.length; index++) list[index] = list[index + 1]; list.pop();&#125; once(eventName, listener) 作用：添加只能调用一次的 listener 方法代码：12345678910111213141516171819202122232425262728293031function onceWrapper() &#123; // 这里的 fired 或许是为了更方便的暴露给外部使用 if (!this.fired) &#123; // 移除之后这里的闭包将会被回收了 this.target.removeListener(this.type, this.wrapFn); this.fired = true; if (arguments.length === 0) return this.listener.call(this.target); return this.listener.apply(this.target, arguments); &#125;&#125;// 通过 onceWrap 维持了一个 state 状态 用来保存是否被触发过的状态function _onceWrap(target, type, listener) &#123; var state = &#123; fired: false, wrapFn: undefined, target: target, type: type, listener: listener &#125;; // 这里是注入里一些状态字段 // 这里保存一些状态字段， 比如： fired 用来表示这个函数有没有被触发过 var wrapped = onceWrapper.bind(state); wrapped.listener = listener; state.wrapFn = wrapped; return wrapped;&#125;// 这里的 _oncewrap 方法执行之后是一个方法， 方法上的 listener 属性才是传入 once 方法的// listener 参数// 这里的 _onceWrap 方法的包装解释了代码中存在的 listener.listener || listener 的判断EventEmitter.prototype.once = function once(type, listener) &#123; checkListener(listener); this.on(type, _onceWrap(this, type, listener)); return this;&#125;; prependListener(eventName, listener)作用：添加 listener 到事件 eventName 回调数组中的第一个， 当事件被发布时， 添加的 listener 第一个执行代码：1234EventEmitter.prototype.prependListener = function prependListener(type, listener) &#123; return _addListener(this, type, listener, true); &#125;; prependOnceListener(eventName, listener)作用： 添加一次性的 listener 到事件回调函数队列头部代码：就是 prependListener 和 _onceWrap 方法的结合123456EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) &#123; checkListener(listener); this.prependListener(type, _onceWrap(this, type, listener)); return this; &#125;; removeAllListeners([eventName])作用： 移除 eventName 事件的全部 listener代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) &#123; var listeners, events, i; events = this._events; if (events === undefined) return this; // not listening for removeListener, no need to emit // 为了保证 removeListener 方法在删除完之后最后触发， // 需要判断是否存在这个 removeListener 方法是否存在 if (events.removeListener === undefined) &#123; if (arguments.length === 0) &#123; this._events = Object.create(null); this._eventsCount = 0; &#125; else if (events[type] !== undefined) &#123; if (--this._eventsCount === 0) this._events = Object.create(null); else delete events[type]; &#125; return this; &#125; // emit removeListener for all listeners on all events // _events 中存在 removeListener 方法 if (arguments.length === 0) &#123; var keys = Object.keys(events); var key; for (i = 0; i &lt; keys.length; ++i) &#123; key = keys[i]; if (key === 'removeListener') continue; this.removeAllListeners(key); &#125; // 保证之前移除listener 时能够触发 removeListener 回调 this.removeAllListeners('removeListener'); this._events = Object.create(null); this._eventsCount = 0; return this; &#125; // 删除单个事件 listeners = events[type]; // 兼容 listeners 中单个 listener 或者 多个 listener 的问题 if (typeof listeners === 'function') &#123; this.removeListener(type, listeners); &#125; else if (listeners !== undefined) &#123; // LIFO order for (i = listeners.length - 1; i &gt;= 0; i--) &#123; this.removeListener(type, listeners[i]); &#125; &#125; return this; &#125;; rawListeners(eventName) 作用： 获取到 eventName 事件的全部 listeners, 包括是通过 once 方法创建的包裹 listener代码：12345678910111213141516171819202122232425262728293031// 这个方法用来获取到所有的 listener 无论是原生的还是放在 wrapper 上面的function unwrapListeners(arr) &#123; var ret = new Array(arr.length); for (var i = 0; i &lt; ret.length; ++i) &#123; ret[i] = arr[i].listener || arr[i]; &#125; return ret;&#125;// 获取到全部的 _listeners // type event 名称// unwrap 是否是获取 非once 方法创建的 wrapper listenerfunction _listeners(target, type, unwrap) &#123; var events = target._events; if (events === undefined) return []; var evlistener = events[type]; if (evlistener === undefined) return []; if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener]; return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);&#125;EventEmitter.prototype.rawListeners = function rawListeners(type) &#123; return _listeners(this, type, false);&#125;;]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 browserify 处理virtual-dom模块的一个例子]]></title>
    <url>%2F2020%2F09%2F13%2F%E4%BD%BF%E7%94%A8%20browserify%20%E5%A4%84%E7%90%86virtual-dom%E6%A8%A1%E5%9D%97%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }使用 browserify 来实现程序在node环境和浏览器环境的适配： 适配不同的模块加载方式有的时候js文件需要在 node 和 浏览器环境下都能执行，除了兼容性问题之外，还有一点是 node 和 浏览器平台引入文件时的模块机制是不同的 ：Node 中使用 Commonjs 的模块加载机制，Commonjs 模块加载机制如下：使用：使用 require 加载模块， 使用 module.exports 向外部暴露模块特定： 模块同时加载，这种特点在 node 环境下是不存在问题的， 因为 node 环境下模块都是在本地磁盘，加载比较快， 但是在浏览器环境下时会出现阻塞渲染的问题为了解决异步加载模块的问题，AMD(https://github.com/amdjs/amdjs-api/wiki) 和 CMD 通过不同的方式实现异步加载模块：AMD : 相关库： requireJs写法：1234define("module", ["dep1", "dep2"], function(d1, d2) &#123; return someExportedValue;&#125;);require(["module", "../file"], function(module, file) &#123; /* ... */ &#125;); CMD: 相关库： seaJs123456define(function(require, exports, module) &#123; var add = require('math').add; exports.increment = function(val) &#123; return add(val, 1); &#125;;&#125;); 除了 AMD 和 CMD 两个规范之外，使用es6 的模块加载是浏览器的另一种模块加载机制，也是未来的主流使用 es6 模块加载实现动态加载的方法： import(module)123// 导入 dayJs 模块// import(...) 返回 promiseconst dayJs = await import(&apos;dayjs&apos;); 使用 browserify 是如何实现的适配各种模块加载的呢 ？具体代码如下：按照 virtual-dom 这个包为例：这个包的作用是生成虚拟dom对象执行 package.json 中的命令：1"dist": "browserify virtual-dom index.js &gt; dist/virtual-dom.js", 打包时，使用 browserify 来处理， 最终打包完成后的文件输出到 dist/virtual-dom.js 中， 在打包后的代码中，我们可以看到如下的代码结构：处理之后的代码中：将原来文件中 require(...) 这样的文件引用替换为具体的执行函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// 自执行方法 f 为下面的 函数1(function (f) &#123; // 这里根据不同的模块加载方式来导出 virtual-dom 这个包的代码 // 如果是 CommonJs 规范，比如在 node 中使用 // 这里当执行 f() 之后，执行路径是： // 函数1 作为参数 f 传入， 执行 f 函数1 执行 ==&gt; // 函数1 执行 ==&gt; 返回函数 e （为自执行函数） if (typeof exports === "object" &amp;&amp; typeof module !== "undefined") &#123; module.exports = f() &#125; else if (typeof define === "function" &amp;&amp; define.amd) &#123; define([], f) &#125; else &#123; var g; if (typeof window !== "undefined") &#123; g = window &#125; else if (typeof global !== "undefined") &#123; g = global &#125; else if (typeof self !== "undefined") &#123; g = self &#125; else &#123; g = this &#125; // 在不同环境下，给不同全局变量挂载 virtualDom 变量值为 f 函数执行后的结果 g.virtualDom = f() &#125;&#125;)( // 函数1 作为参数 f 传入上面的参数 function () &#123; var define, module, exports; // 函数 e 也是一个自执行函数，接受三个参数： // 这里参数的各个部分 // t: 表示下面的对象1 // n: 表示下面的对象2 // r: 表示下面的对象3 // 这里返回的结构为 (function e(t, n, r) &#123;&#125;)(对象1,对象2,对象3)(4) // 函数e为自执行函数，执行后返回函数 s， s 接受 4 作为参数，最终这里 return // 的结果为 s(4) 之后的返回值 return (function e(t, n, r) &#123; function s(o, u) &#123; if (!n[o]) &#123; if (!t[o]) &#123; var a = typeof require == "function" &amp;&amp; require; if (!u &amp;&amp; a) return a(o, !0); if (i) return i(o, !0); var f = new Error("Cannot find module '" + o + "'"); throw f.code = "MODULE_NOT_FOUND", f &#125; var l = n[o] = &#123; exports: &#123;&#125; &#125;; // 这里的 t[o]0 表示每个模块的方法 // 这里的 t[o]1 表示文件对象，文件对象的键名为引用的文件地址，建值为该文件在对象1中的key // 这里使用 call 会立即执行 t[o]0 这个方法 t[o][0].call(l.exports, function (e) &#123; // 这里的 function (e) &#123;&#125;, l, l.exports // 分别表示 function (require, module, exports) 中的 require, module, // exports 这三个参数 // 所以当调用 module.exports 的时候， 实际上 module.exports === l.exports var n = t[o][1][e]; // 获取到文件地址对象对应的值 return s(n ? n : e) &#125;, l, l.exports, e, t, n, r) &#125; // 这里是 s 方法的返回值 return n[o].exports &#125; var i = typeof require == "function" &amp;&amp; require; for (var o = 0; o &lt; r.length; o++) s(r[o]); return s &#125;)( // 对象1 &#123; ===== 从之前的代码中抽取出来的一些代码 ===== 这个对象中的元素的结构都是一样的： 对象的键key为数字，表示当前文件的标识 对象的值是一个数组， 这个数组中有两个元素，一个元素是 `function(require, module, exports) &#123;&#125;` 方法包裹的文件内的方法，另外一个元素是上面文件中使用 require 引用的文件路径和文件标识对象 ... // 为什么这里要先进行处理呢 ？ 因为可以认为这里是程序的主入口 // 分析程序先从这里进入开始分析 4: [function (require, module, exports) &#123; var diff = require("./diff.js") var patch = require("./patch.js") var h = require("./h.js") var create = require("./create-element.js") var VNode = require('./vnode/vnode.js') var VText = require('./vnode/vtext.js') module.exports = &#123; diff: diff, patch: patch, h: h, create: create, VNode: VNode, VText: VText &#125; &#125;, &#123; "./create-element.js": 1, "./diff.js": 2, "./h.js": 3, "./patch.js": 13, "./vnode/vnode.js": 31, "./vnode/vtext.js": 33 &#125;], ... &#125;, // 对象2 &#123;&#125;, // 对象3 [4] // 这里的参数 （4） 实际上是 上面函数 s 接受的参数 )(4) &#125;);]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>js-module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-Worker]]></title>
    <url>%2F2019%2F10%2F27%2Fjs-Worker%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }What is the worker 浏览器是多线程的， 在浏览器中，存在下面几个线程： 浏览器事件触发线程 UI 渲染线程 JS 引擎线程 定时触发器线程 http 请求线程 js 语言的一个重要特征是单线程，因为在js 中会设计到一些页面交互的逻辑， 比如操作 dom 树， css 样式树等， 单线程的设计避免了复杂的同步问题。因为在 js 中我们是可以进行 dom 操作的， 因此 UI 渲染线程和 js 引擎线程是互斥的，如果我们在页面上要进行一些耗时较大的 js 逻辑计算的时候， 页面可能会出现卡顿现象。为了利用多核 CPU 的计算能力，在 HTML5 中引入的工作线程使得浏览器端的 JavaScript 引擎可以并发地执行 JavaScript 代码，但是引入的工作线程并没有改变 js 单线程的本质， 因为子线程完全受主线程控制， 并且不能操作dom。工作线程的一些特点： 工作线程内不能操作 dom，或者使用 window 对象下的一些属性和方法 工作线程和主线程之间通过消息传递系统实现，消息之间传递的数据是复制而不是共享一个存储空间（深复制和浅复制） both sides send their messages using the postMessage() method, and respond to messages via the onmessage event handler (the message is contained within the Message event&#39;s data property). The data is copied rather than shared. How to create worker 一个 Worker 的创建是通过js 中的构造函数： Worker() 来实现的：1var myWorker = new Worker(aURL, options); 具体看 worker当我们创建一个 worker 的时候， 我们需要手动创建一个 js 文件，这种方式过于死板， 我们希望我们能直接指定在 worker 中运行的代码，而不需要创建多余的文件， 那有没有可能我们直接传入一个方法呢？比如如下代码，我们对于函数代码进行了四次转换，从而实现将一个普通函数转换为 webWroker:123456789101112131415161718192021222324252627function createWorker(workerFn) &#123; const url = URL.createObjectURL(new Blob([`($&#123;workerFn.toString ()&#125;)()`])); const worker = new Worker(url); let promiseResolve; worker.onmessage = (msg) =&gt; &#123; promiseResolve(msg); &#125; return (message) =&gt; &#123; return new Promise(resolve =&gt; &#123; promiseResolve = resolve; worker.postMessage(message); &#125;); &#125;&#125;const fn = () =&gt; &#123; onmessage = (msg) =&gt; &#123; console.log(`resceive message`, msg.data); postMessage('hello'); &#125;&#125;const worker = createWorker(fn);worker('send message').then(msg =&gt; &#123; console.log('msg', msg.data);&#125;); 上面代码实现了在不额外创建文件的情况下，实现创建 worker 代码的过程如下是上面代码普通函数到 worker 的四种转换过程： 在上面的代码中，我们需要理解的是：1URL.createObjectURL(new Blob([`($&#123;workerFn.toString ()&#125;)()`])); Function.toString() 方法可以将函数转换为代码字符串,例如上面的代码中， 执行完成toString 方法之后： 1234567// workerFn.toString ()() =&gt; &#123; onmessage = (msg) =&gt; &#123; console.log(`resceive message`, msg.data); postMessage(&apos;hello&apos;); &#125;&#125; The toString() method returns a string representing the source code of the function. URL.createObjectURL()createObjectURL 可以创建指向 blob 对象的 URL， 需要注意的是， 使用这种方法创建的是一个链接，这个链接指向数据对象， 这个数据对象可以是 File, Blob or MediaSource 对象，真正的数据存放在 上面三种数据对象中。在上面的代码中， URL.createObjectURL 创建的链接， 指向的是保存有 (${workerFn.toString ()})() 的 blob 对象中关于 createObjectURL Worker-loader worker-loader 是用来在 webpack 中实现 worker 的，核心代码如下：12345678910111213141516171819202122232425262728293031323334353637var URL = window.URL || window.webkitURL;module.exports = function (content, url) &#123; try &#123; try &#123; var blob; try &#123; // BlobBuilder = Deprecated, but widely implemented var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder; blob = new BlobBuilder(); blob.append(content); blob = blob.getBlob(); &#125; catch (e) &#123; // The proposed API blob = new Blob([content]); &#125; return new Worker(URL.createObjectURL(blob)); &#125; catch (e) &#123; // 这里对于 js 数据进行编码 return new Worker('data:application/javascript,' + encodeURIComponent(content)); &#125; &#125; catch (e) &#123; if (!url) &#123; throw Error('Inline worker is not supported'); &#125; return new Worker(url); &#125;&#125;; 使用多种不同的 api 主要是为了不同浏览器的兼容性问题，参考链接 how-to-create-a-web-worker-from-a-string]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>Worker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promisify callback-style function]]></title>
    <url>%2F2019%2F10%2F03%2FPromisifyCallback%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }将一个回调函数转换为 promise 类函数，在 promisify 化的函数的 then 方法里面执行回调函数， 避免回调地狱。这样相当于我们日常代码开发中，对于某个函数返回一个 promise, 以期在函数的 then 方法里面处理数据的方法的一个封装。123456789101112function process() &#123; return new Promise((resolve, reject) =&gt; &#123; // some data process code... try () &#123; resolve(data); &#125; catch (err) &#123; reject(err); &#125; &#125;);&#125;process().then(data =&gt; &#123;...&#125;); 在 node.js 中， 存在一个工具方法为 utils.promisfy 的工具方法， 这个方法将回调转换为 promise 类方法：1234567891011121314151617181920212223242526// error-first 类型回调// 回调cb 的第一个参数为 error， 如果没有传 falsefunction fn(cb) &#123; return cb(false, 'hello');&#125;const utils = require('util');const promiseFn = utils.promisify(fn);promiseFn().then((data) =&gt; &#123; console.log(data);&#125;);// 使用这个方法， 可以将 node 中的一些异步的回调// 比如： readFile 等const fs = require('fs');const promiseReadFile = utils.promisify(fs.readFile);promiseReadFile('./.gitignore', 'utf-8').then(data =&gt; &#123; console.log(data);&#125;);// 等同于fs.readFile('./.gitignore', 'utf-8', function (err, data) &#123; console.log(data);&#125;); 在 promisify 出现之前，使用 pify 实现相同的功能pify 模块的核心代码不多, 下面是全部的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// 核心处理方法// fn：将要被 promise 化的函数// options: 相关配置选项// args: 传入函数的相关参数// 实际执行的时候， 执行这个方法返回的方法， 其中 args 为传入的参数// 这里 args 是一个数组， 通过 push 回调的方法const processFn = (fn, options) =&gt; function (...args) &#123; const P = options.promiseModule; return new P((resolve, reject) =&gt; &#123; // multiArgs： 是否传入多个参数 if (options.multiArgs) &#123; // push 一个方法函数， 这个函数就是我们在原函数中手动 // 调用的回调函数 cb， 参数是我们手动写入回调函数中的参数 args.push((...result) =&gt; &#123; // errorFirst: 是否包含错误， 适配 node 如 fs.exists() 类的方法 if (options.errorFirst) &#123; if (result[0]) &#123; reject(result); &#125; else &#123; result.shift(); resolve(result); &#125; &#125; else &#123; resolve(result); &#125; &#125;); &#125; else if (options.errorFirst) &#123; args.push((error, result) =&gt; &#123; if (error) &#123; reject(error); &#125; else &#123; resolve(result); &#125; &#125;); &#125; else &#123; args.push(resolve); &#125; // 这个时候， args 中传入了相关的回调方法 fn.apply(this, args); &#125;);&#125;;module.exports = (input, options) =&gt; &#123; options = Object.assign(&#123; exclude: [/.+(Sync|Stream)$/], // errorFirst: 回调函数中是否第一个参数为 error errorFirst: true, promiseModule: Promise &#125;, options); const objType = typeof input; if (!(input !== null &amp;&amp; (objType === 'object' || objType === 'function'))) &#123; throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`$&#123;input === null ? 'null' : objType&#125;\``); &#125; const filter = key =&gt; &#123; const match = pattern =&gt; typeof pattern === 'string' ? key === pattern : pattern.test(key); // options 中的 include 和 exclude 属性分别表示 // 模块中可以被序列化的方法 return options.include ? options.include.some(match) : !options.exclude.some(match); &#125;; let ret; // 当传入的 input 为函数的时候 if (objType === 'function') &#123; ret = function (...args) &#123; // excludeMain：是否对于一些 module 内部方法 做 promise 化 return options.excludeMain ? input(...args) : processFn(input, options).apply(this, args); &#125;; // 否则 ret 为包含有 input 上面的属性的对象 &#125; else &#123; ret = Object.create(Object.getPrototypeOf(input)); &#125; // 对于 input 参数对象或者函数上面的每一个方法都做 promise 化 for (const key in input) &#123; // eslint-disable-line guard-for-in const property = input[key]; ret[key] = typeof property === 'function' &amp;&amp; filter(key) ? processFn(property, options) : property; &#125; return ret;&#125;; utils.promisify 方法promisify 方法是 node 内置的 promise 化回调函数的工具方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const promisify = function promisify(original) &#123; var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined; if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function'); // 在 original 方法上面存在有 `kCustomPromisifyedSymbol 这个属性 // 这个属性上面存储的是被 promise 化的方法 if (kCustomPromisifiedSymbol &amp;&amp; original[kCustomPromisifiedSymbol]) &#123; var fn = original[kCustomPromisifiedSymbol]; if (typeof fn !== 'function') &#123; throw new TypeError('The "util.promisify.custom" argument must be of type Function'); &#125; Object.defineProperty(fn, kCustomPromisifiedSymbol, &#123; value: fn, enumerable: false, writable: false, configurable: true &#125;); return fn; &#125; function fn() &#123; var promiseResolve, promiseReject; var promise = new Promise(function (resolve, reject) &#123; promiseResolve = resolve; promiseReject = reject; &#125;); var args = []; for (var i = 0; i &lt; arguments.length; i++) &#123; args.push(arguments[i]); &#125; args.push(function (err, value) &#123; if (err) &#123; promiseReject(err); &#125; else &#123; promiseResolve(value); &#125; &#125;); try &#123; original.apply(this, args); &#125; catch (err) &#123; promiseReject(err); &#125; return promise; &#125; // 将 fn 上的原型设置为 original 上的原型 Object.setPrototypeOf(fn, Object.getPrototypeOf(original)); if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, &#123; value: fn, enumerable: false, writable: false, configurable: true &#125;); // 设置 fn 上的属性为 original 方法上面的属性 return Object.defineProperties( fn, getOwnPropertyDescriptors(original) );&#125;]]></content>
      <categories>
        <category>promsie</category>
      </categories>
      <tags>
        <tag>promisify</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构：树]]></title>
    <url>%2F2019%2F10%2F03%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }树 树是这样的一种结构： 对于树的定义如下： 树是 n (n &gt;= 0) 个结点的有限集，n = 0 时称为空树，在任意一棵非空树中， 有且仅用一个特定的称为 根（root）的节点 当 n &gt; 1 时，其余结点可分为 m（m &gt; 0）个互不相交的有限集 T1, T2, ...Tn, 其中每一个集合本身也是一棵树， 并且称为 根的子树， 对于树的存储方式， 可以使用三种表示法来存储树之间结点之间的相互关系：双亲表示法， 孩子表示法， 孩子兄弟表示法双亲表示法：以一段连续的空间存储树的结点， 在每一个结点中，存储当前结点其双亲结点的存储位置： data为数据域， 存储当前结点的相关数据， parent 为指针域， 存储当前节点的双亲结点在数组中的下标比如下面的树使用双亲表示法表示： 根结点的双亲位置为 -1；上面的表示法表示的树用于查找结点的双亲元素比较方便， 但是，如果这个结点下面包含有多个的子结点， 我们可以需要设置多个的指针域， 比如， 长子域， 右兄弟域等等。孩子表示法：孩子表示法的方式是：将每个结点的孩子结点排列起来，以单链表作为存储结构，则 n 个结点有 n 个孩子链表，如果是叶子结点， 那么这个单链表为空，然后 n 个头指针又组成一个线性表，存放在一个一维数组中。使用孩子表示法表示上面的树形结构： 在上面的孩子表示法中，设计有两种结构： 孩子链表 child 为数据域， 用来存储当前的子结点在表头数组中的下标， next 为指针域，存放的是下一个孩子的这个结构指针地址。 表头结点 表头结点存储每个结点， 用于树形结点的遍历使用，另外， 存储长子结点的指针域； 孩子兄弟表示法：孩子兄弟表示法的数据结构如下： data 为数据域firstchild 为该结点第一个孩子结点的指针域rightsib 为该结点的兄弟结点指针域使用 孩子兄弟表示法组织后的数据结构如下： 上面的重新组织后的结构将一棵树转换为了一棵二叉树二叉树 二叉树的定义 二叉树是 n 个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的，分别称为 根结点的左子树和右子树的二叉树组成 二叉树的特点： 每个结点最多有两棵子树 左子树和右子树是有顺序的， 并且不能颠倒 即使树中某结点只有一棵子树，也要区分顺序 如下图， 是一棵二叉树的示意图： 根据二叉树的结构显示， 可以将二叉树分为：满二叉树， 斜树 和 完全二叉树；如下， 是满二叉树的图示： 树的每个结点都有左右两个结点， 故称为满二叉树。二叉树的存储 顺序存储 按照顺序存储二叉树， 主要是使用一维数组来顺序存储树中的各个结点，比如， 存储如下树结构： 使用顺序存储如下： 对于不存在的结点， 我们将不存在的结点设为 ^ 即可。使用顺序存储存在的问题在于， 我们需要对于不存在的结点分配存储空间，比如，对于下面这个右斜树而言： 这样造成了存储空间的浪费。链式存储 对于二叉树结点的存储， 我们使用一种被称为 “二叉链表” 的链式存储结构来存储，二叉链表是下面的这种结构： 这个结构中包含有一个数据域和两个指针域， 数据域表明当前结点的数据，指针域分别为二叉树左右两个结点的地址指针。使用链式存储后的最终的存储链表结构如下： 二叉树的遍历 二叉树的遍历是指从根结点出发， 依次访问到二叉树中的每一个结点，使得每个结点被访问到并且仅被访问到一次。二叉树的遍历方法， 按照访问次序的不同， 可以分为 前序遍历， 中序遍历 以及 后序遍历前序遍历 前序遍历的遍历顺序是先访问二叉树的左子树， 然后访问二叉树的右子树 如， 上图， 二叉树的访问顺序是：ABDGHCEIF中序遍历 中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树 如上图， 那么 二叉树的访问顺序是：GDHBAEICF后序遍历 判断二叉树是否为空， 如果是空， 那么空操作返回，否则的话， 从左到 右通过先叶子后结点的方式遍历访问左右子树 使用后序遍历的方法来访问二叉树的顺序是：GHDBIEFCA二叉树的创建 二叉树的创建可以像二叉树创建方法中传入一串树来实现，通过一定的二叉树的遍历顺序来依次创建结点， 对于空结点， 二叉树中的字符串可以为 ‘#’按照前序遍历创建的二叉树的方法如下:123456789101112131415161718192021222324252627// 创建二叉树// treeStr: 树的字符串， 空结点 ‘#’function createTree(treeStr) &#123; let tree = &#123;&#125;; // 创建树节点 let treeStack = treeStr.split(''); function createNode(node) &#123; let nodeData = treeStack.shift(); if (!nodeData) return; if (nodeData !== '#') &#123; node.data = nodeData; &#125; else &#123; return true; &#125; // 当父节点没有左结点的时候， 创建左结点 if (!node.lChild || !node.lChild.hasOwnProperty('data')) &#123; if (treeStack.length &gt;= 1) node.lChild = &#123;&#125;; if (createNode(node.lChild)) delete node.lChild; &#125; if (!node.rChild || !node.rChild.hasOwnProperty('data')) &#123; if (treeStack.length &gt;= 1) node.rChild = &#123;&#125;; if (createNode(node.rChild)) delete node.rChild; &#125; return; &#125; createNode(tree);&#125; 对于树的创建和访问一样， 也是进行依次遍历， 使用递归进行遍历访问， 需要注意的是：要存在相应的条件， 使得能够跳出递归。对于递归而言， 注意递归循环的跳出是比较重要的。同样，也可以按照中序遍历和后序遍历的次序来创建树， 只是递归的顺序不同而已。另外， 判断对象中某个属性是否存在， 最好不要用直接访问属性的方式进行判断， 因为不知道这个属性的值可能是 undefined, 或者 0 等导致属性访问后为 false 的值。可以使用 hasOwnProperty 的方式来判断属性是否在对象上面:1Object.hasOwnPropery(prop); 注意： 这个方法只能够获取到该对象上面的自身属性， 不能获取到该对象原型上面的属性（for in 是可以获取到继承的属性的， 并且继承的属性是可枚举的）为了防止对象上面有 hasOwnProperty 属性覆盖掉从对象上面继承的， 我们需要通过 Object 来调用：1Object.hasOwnProperty.call(obj, &apos;property&apos;);]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构：栈和队列]]></title>
    <url>%2F2019%2F09%2F28%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }栈 栈是一种特殊的线性表，这种线性表仅允许在表尾（栈顶）进行插入和删除工作：将可以被插入和删除元素的位置称为栈顶， 将另一端称为 栈底， 如果栈没有任何的元素， 这个栈被称为 空栈；栈的数据元素的进出遵循后进先出的原则，简称为 LIFO (Last In First Out) 结构；栈的插入被称为入栈， 栈的删除被称为出栈， 在程序中我们可以将其称为 push 和 pop;在 js 中， 我们使用数组的 push 和 pop 方法模拟栈的入栈和出栈操作；栈的应用 递归 我们将调用函数自身或者间接调用自身的函数称为 递归 在每一层递归的过程中， 我们需要存储当前调用函数的局部变量， 参数值等数据信息存储到栈中，当递归返回之后， 再将这些数据从栈中弹出数据使用栈实现四则运算表达式 如下面程序， 实现将一串运算表达式进行计算的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 对于逆波兰法表示的后缀表达式计算求值function RPNcompute(mathStrStack) &#123; let stack = []; for (let num of mathStrStack) &#123; if (Number.isNaN(+num)) &#123; const num1 = stack.pop(); const num2 = stack.pop(); const total = num2 + num + num1; stack.push(eval(total)); &#125; else &#123; stack.push(num); &#125; &#125; return stack.pop();&#125;// 将中缀表达式转为后缀表达式function toPostFixExpression(expression) &#123; let expressionArr = expression.split(' '); let stack = []; let outputStr = ''; // 处理符号入栈与出栈 function pushStack(s) &#123; let result = ''; if (!stack.length) &#123; stack.push(s); return ''; &#125;; while (stack.length) &#123; let stackTopData = stack.pop(); if (s === ')') &#123; if (stackTopData === '(') break; result += stackTopData + ' '; &#125; else if (['+', '-', '*', '/'].includes(s))&#123; const isLower = ['+', '-'].includes(s); // 当栈顶元素优先级大于等于当前入栈元素时， 栈顶元素依次出栈 if (['/', '*'].concat(isLower ? ['+', '-'] : []).includes(stackTopData)) &#123; result += stackTopData + ' '; if (!stack.length) &#123; stack.push(s); break; &#125;; &#125; else &#123; stack.push(stackTopData); stack.push(s); break; &#125; &#125; else &#123; stack.push(stackTopData); stack.push(s); break; &#125; &#125; return result; &#125; for (let num of expressionArr) &#123; if (Number.isNaN(+num)) &#123; outputStr += pushStack(num); &#125; else &#123; outputStr += `$&#123;num&#125; `; &#125; &#125; return outputStr + stack.reverse().join(' ');&#125;function compute(mathStr) &#123; let stackArr = toPostFixExpression(mathStr).split(' '); return RPNcompute(stackArr);&#125;// 示例：compute('9 + ( 3 - 1 ) * 3 + 10 / 2');// 20compute('9 + 3 * ( 2 + 2 / 2 ) - 10 / 5');// 16 关于 中缀表达式转后缀表达式（逆波兰）法规则如下:从左到右遍历中缀表达式的每个数字和符号，如果是数字那么就输出，成为后缀表达式的一部分，如果是符号， 那么判断该符号与栈顶符号的优先级，是右括号或者优先级低于等于栈顶符号， 那么栈顶符号依次出栈并输出，并将当前符号进栈， 一直到最终输出后缀表达式为止。运算符号优先级： 乘除 &gt; 加减对于后缀表达式的计算规则如下：从左到右遍历后缀表达式的每个数字和符号，如果遇到数字那么就入栈，遇到是符号， 那么就将处于栈顶的两个数字出栈， 进行运算，并将运算结果入栈， 一直到最终获得到结果。队列 队列是只允许在一端进行插入操作， 而在另一端进行删除操作的线性表 队列遵循的是先进先出的线性表， 在程序设计中的应用， 比如我们在显示器上记事本上文字的输出。在日常生活中， 比如我们购买火车票时的排队。队列的线式存储结构 在 js 中， 我们使用数组的 push 和 shift(表头弹出) 这两个 api 实现队列的模拟。顺序存储 使用顺序存储时，我们将队列数据元素按照顺序存储到数组中， 当我们想要对于队列进行出列操作时， 因为出列操作是在表头出列， 因此，出列数据元素后面的每一个数据都会向前移动一个元素位置， 这样会造成程序性能的损耗。 这个时候的时间复杂度为 O(n)为了解决这个移动队列数据元素的问题， 我们可以引入两个指针： front: 指向队头元素， rear: 指向队尾元素的下一个位置当我们对于队列进行添加和删除元素的时候， 只要改变 front 和 rear 指针的位置就可以了， 不需要移动每个队列元素:12345678910111213141516function queue(queueLen) &#123; const queueArr = new Array(queueLen); let front = 0; let rear = 0; this.out = function () &#123; queueArr[front] = undefined; front ++; return queueArr; &#125;; this.add = function (data) &#123; queueArr[rear] = data; rear ++; return queueArr; &#125; return this;&#125; 对于上面的代码， 存在一个问题是， 如果我们当删除数据时， 队列不往前移动， 那么当我们新增队列数据元素的时候， 可以会增加到规定的队列长度之外的元素：比如：12345678const queueList = queue(2);queueList.add(1);queueList.add(2);queueList.out();console.log(queueList.add(3));// [ undefined, 2, 3 ]// 队列长度超出了我们规定的 2 的长度的队列长度 这个时候， 队列数据填充情况如下图所示： 这个时候虽然添加的数据位置超出了队列的长度， 但是删除的队列的第 0 位 和 第 1 位元素却是空的， 我们的溢出是“假溢出”。我们思考， 如何能够利用删除之后的空间， 防止假溢出？循环队列 循环队列相比上面的存储方法而言， 有一些不同， 主要是体现在 rear 指针的指向，rear 指针在队列初始化的时候指向下标 为 0 的位置, 当到达队列列尾的时候， rear 指针移动到队列列头12345678910111213141516171819202122232425262728293031function queue(queueSize) &#123; const queueArr = new Array(queueSize); let front = 0; let rear = 0; this.out = function () &#123; if (front === rear) &#123; console.log('empty'); return; &#125;; queueArr[front] = undefined; // 使用 %（取模）操作来进行归 0 操作 front = (front + 1) % queueSize; return queueArr; &#125;; this.add = function (data) &#123; if (isFull()) &#123; console.log('full'); return; &#125;; queueArr[rear] = data; rear = (rear + 1) % queueSize; return queueArr; &#125; this.queueLength = function () &#123; return (rear - front + queueSize) % queueSize; &#125; function isFull() &#123; return (rear + 1) % queueSize === front; &#125; return this;&#125; 链式存储结构 队列的链式存储结构其实就是单链表。与普通的单链表不同的是， 只能操作链表的头部和尾部节点，队列的链式存储结构被称为 链队列；总结 当已知队列空间大小的情况下， 可以使用 循环队列， 否则， 如果不知道队列的长度， 使用 链对列]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈 和 队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise中的错误捕获]]></title>
    <url>%2F2019%2F09%2F27%2Fpromise%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E6%8D%95%E8%8E%B7%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }在代码中， 我们对于不能预知的代码通常会使用 try catch 来捕获代码错误，当代码内部发生错误时， 对于错误进行捕获， 可以防止代码的错误阻塞后续代码的执行，并且我们可以对于代码的错误进行后续处理；在 promise 中， 对于错误的处理或许稍有不同， 需要注意下面几点： 使用 try catch 只能捕获同步代码， 不能捕获异步代码， 在 async 函数内， 使用 await 可以捕获异步代码，这里实际上是异步代码变成了同步代码 promise 内部代码的错误会沿着 promise 代码链传递， 直到被 promise 的 catch 方法或者上一层 async 函数内的 try catch 方法捕获到, 如果没有使用 catch 方法指定错误处理的回调函数， Promise 对象抛出的错误不会传递到外层的 promise；这个时候会报： UnhandledPromiseRejectionWarning: try catch 处理async 函数内异步 使用 try catch 只能处理同步的代码， 对于异步代码中的代码错误， 使用 try catch 是无法捕获到的：12345678910111213141516function promise() &#123; return new Promise(() =&gt; &#123; throw new Error('error'); &#125;);&#125;function tryError() &#123; try &#123; promise(); &#125; catch (error) &#123; console.log('error'); &#125;&#125;tryError();// UnhandledPromiseRejectionWarning: Error: error 在 async 函数内部使用 try catch可以捕获到异步错误：123456789async function tryError() &#123; try &#123; await promise(); &#125; catch (error) &#123; console.log('error'); &#125;&#125;tryError();// error promise.catch 错误捕获 使用 promise.catch 方法可以对于当前 promise 链上的代码进行错误捕获，当 promise 内部发生错误的时候， 错误会沿着 promise 链向后传递， 直到被 promise 后面的 catch 方法捕获到：123456789101112function apromise() &#123; return new Promise(() =&gt; &#123; console.log(b); &#125;)&#125;apromise().then(() =&gt; &#123; throw new Error('error');&#125;).catch(err =&gt; &#123; console.log('error', err);&#125;);// error: b is not defined 当在 promise 链中没有 catch 方法的时候， promise 中发生的错误不会被上层的 promise 中的catch 捕获, 即使我们使用了 throw new Error 的方式对错误进行抛出也是如此；因为 async 函数返回一个 promise 对象， 我们在 async 函数内部定义一个 Error1234567891011function promise() &#123; return new Promise(async () =&gt; &#123; throw new Error('error'); &#125;).catch(err =&gt; &#123; console.log('error'); &#125;);&#125;promise();// UnhandledPromiseRejectionWarning: Error: error// 这里 async 函数内部抛出的错误不会被外部的 catch 方法捕获到， 因为错误不能传递到外层// 的 `promise` 总结 防止出现 unhandledRejection 问题的解决方法是： 在 async 函数内部使用 try catch 捕获异步错误 promise 内部使用 .catch 方法来捕获 promise 内部代码错误]]></content>
      <categories>
        <category>promise</category>
      </categories>
      <tags>
        <tag>promise catch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构（一）：线性表]]></title>
    <url>%2F2019%2F09%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }数据结构简介 数据结构是相互之间存在一种或者多种特定关系的数据元素的集合 数据结构分为逻辑结构和物理结构；数据对象中数据元素之间的关系称为逻辑结构， 在数据结构中， 存在下面四种逻辑结构： 集合结构集合结构中的元素除了同属于同一集合之外。 没有其他的任何关系， 如同所示： 线性结构： 线性结构中的元素是一对一的关系： 树形结构：树形结构中的元素关系是一对多的层次关系, 比如： 二叉树 图形结构： 图形结构中的元素之间的关系是一对多的关系 物理结构： 是指数据的逻辑结构在计算机中的存储方式；物理结构包括顺序存储结构和链式存储结构；顺序存储结构的数据逻辑关系和物理关系是一致的， 即是数据存放在地址连续的存储单元里面；链式存储结构数据间的存储地址并不连续，数据之间的存储关系并不表示他们之间的逻辑关系，这些数据的地址信息存放在数据的指针中。通过数据的指针来表明数据之间的存储关系。数据结构之线性表 线性表是零个或者多个数据元素的有限序列 线性表是一种序列， 这表明线性表中数据的关系之间都是一对一的关系，如果元素存在多个， 那么第一个元素没有前元素， 最后一个元素没有后元素， 其他元素有且只有一个前元素和后元素，线性表的顺序存储结构 顺序存储结构是物理结构和逻辑结构一致的一种结构， 比如， 我们使用一个一维数组来存储数据，实现顺序存储结构；1let list = [1, 2, 3, 4]; 在顺序存储结构中， 地址和数据之间的关系是一致的，比如， 我们想要获取 第 i 个元素， 我们可以通过 list[i - 1] 来获取数据。删除和插入元素 当我们需要删除或者插入元素的时候， 对于顺序存储结构需要移动比较多的元素， 当我们需要删除一个元素， 需要将该数据项后面的数据都需要向前提前一位：1234567891011121314151617// 从线性表中删除某个数据function deleteData(list, i) &#123; if (list.length === 0) return list; if (i &lt; 1 || i &gt; list.length) return list; if (i &lt; list.length) &#123; for (let index = i; index &lt; list.length; index ++) &#123; list[index -1] = list[index]; &#125; &#125; list.length --; return list;&#125;let list = [1, 2, 3, 4];console.log(deleteData(list, 2));// [1, 3, 4] 对于线性表的插入和删除数据操作，其时间复杂度为 O(n);优缺点 对于线性表的顺序存储结构， 其优点是： 可以快速的存取表中任意位置的元素 无须为表中的逻辑关系增加额外的存储空间 缺点：对于线性表中插入和删除元素操作需要移动大量的元素线性表的链式存储结构 顺序存储结构对于插入和删除元素需要移动大量元素的原因是数据之间的逻辑关系和存储关系一致且相互之间按照次序排列，需要移动大量的元素来保持相互之间的存储关系和逻辑关系的一致。这种问题可以通过使用链式存储结构来解决，链式存储结果的特点是逻辑关系和存储关系分离， 当逻辑关系改变时， 不会引起存储关系的变化线性表的链式结构由一个个的节点（Node）构成， 每个节点中包含有一个数据域和一个或者多个指针域， 顾名思义， 数据域用于存储当前节点的数据， 指针域用来存储下一个节点的位置信息， 根据节点中指针域的数量不同， 将链表分为单链表和双链表；单链表 单链表示意图如下： 在上图中我们可以看到， 在链表中相邻的数据的存储位置并不连续，数据之间的关系通过节点中的指针域中的地址来表明。一些要点： 链表中的最后一个节点的指针为空， 我们常常将其置为 null 为了更方便的对于链表进行操作， 我们在第一个节点之前设置一个头节点，这个节点的指针指向第一个节点， 节点中的数据可以包含有链表的长度等信息。 头指针不为空，是链表的必要元素 链表中节点之间的逻辑关系如图所示： 单链表的读取 链表中数据的关系是通过指针来表示的，想要读取单链表的数据，我们需要通过指针来操作， 比如读取程序如下:1234567891011121314151617181920212223242526272829303132333435363738394041// 创建一个新的链表function linkList() &#123; let list = &#123; data: &#123; length: 0 &#125;, next: null &#125;; const headNodeData = list.data; const headNode = list; // 链表新增节点 this.add = function (value) &#123; let node = &#123; data: value, next: null &#125;; let next = list.next; let currentNode = list; while (next) &#123; currentNode = next; next = next.next; &#125; currentNode.next = node; headNodeData.length ++; return list; &#125; // 获取链表中的某个节点 this.get = function (i) &#123; if (i &lt; 1 || i &gt; headNodeData.length) return null; let next = list.next; let nodeIndex = 0; while (next) &#123; nodeIndex ++; if (i === nodeIndex) break; next = next.next; &#125; return next; &#125; return this;&#125;let linkedList = linkList();linkedList.add(1)；// &#123; data: &#123; length: 1 &#125;, next: &#123; data: 1, next: null &#125; &#125;linkedList.get(1)；// &#123; data: 1, next: null &#125; 单链表的查找数据的核心思想是工作指针后移；单链表的插入和删除 代码如下：1234567891011121314151617// 在第 i 个数据后插入元素, 元素值为 valuethis.append = function (i, value) &#123; const node = this.get(i); if (!node) &#123; console.log('node not exist'); return; &#125; const newNode = &#123; data: value, next: null &#125;; newNode.next = node.next; node.next = newNode; return list;&#125;let linkedList = linkList();linkedList.add(1);linkedList.append(1, 2);// &#123; data: &#123; length: 1 &#125;,// next: &#123; data: 1, next: &#123; data: 2, next: null &#125; &#125; &#125; 对于单链表的插入数据项， 我们要做的仅仅是改变相应节点的指针的指向，原理如图所示： 我们想要在p 节点之后插入节点 s, 我们要做的是将 p 节点的指针 next 指向要插入的节点， 同时将要插入的节点的指针指向插入前的下一个节点。注意： 这里的顺序是：12s.next --&gt; p.next;p.next --&gt; s; 顺序不可以更换；插入成功之后的效果如下图所示： 单链表的删除：实现单链表的删除功能也是通过指针来完成的，实现原理如下图所示： 代码如下：1234567891011121314151617// 删除第 i 个节点的元素this.delete = function (i) &#123; let nodeNext = ((i - 1 === 0) ? headNode : this.get(i - 1)); if (!nodeNext || !nodeNext.next) return false; const deleteNode = nodeNext.next; nodeNext.next = nodeNext.next.next; headNodeData.length --; deleteNode = null; return true;&#125;let linkedList = linkList();linkedList.add(1);linkedList.add(2);linkedList.delete(1);// &#123; data: &#123; length: 1 &#125;, next: &#123; data: 2, next: null &#125; &#125;linkedList.delete(1);// &#123; data: &#123; length: 0 &#125;, next: null &#125; 单链表的整表删除 1234567891011121314151617this.deleteAll = function () &#123; let deleteNode = headNode let freeNode; while (deleteNode &amp;&amp; deleteNode.next) &#123; freeNode = deleteNode.next; deleteNode.next = null; deleteNode = freeNode; headNodeData.length --; &#125; return true;&#125;let linkedList = linkList();linkedList.add(1);linkedList.add(2);linkedList.deleteAll();console.log('list', linkedList.list);// &#123; data: &#123; length: 0 &#125;, next: null &#125; 循环链表 在单链表中终端节点的指针端由空指针指向头节点，就使得整个单链表形成一个环，这种头尾相接的链表称为循环链表 循环链表如下图所示： 循环链表相比于单链表不同的地方在于终端节点的指针指向不同的，使用循环链表的作用是可以从一个节点出发，查找到列表中的所有节点。双向链表 双向链表和单链表的区别在于： 实现双向链表的节点中存在两个指针域，在单链表的基础上，创建另外一个指针指向上一个节点，如下图所示： 相比于单链表而言， 使用双向链表可以实现在前后两个方向上面的节点查找， 比单链表相比，双向链表可以实现在前后两个方向上面的数据节点查找， 当然缺点是会多出一个指针域来指向上一个节点。对比 如果线性表需要频繁的查找， 很少进行插入和删除工作时， 适合采用顺序存储结构；如果涉及到频繁的插入和删除数据工作， 那么适合采用链式存储结构]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[decode & encode]]></title>
    <url>%2F2019%2F09%2F15%2Fencode%20%26%20decode%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }js-base64 是用来对于字符编码和解码操作的一个包， 可以用这个包实现原始字符与 base64 编码后字符之间的转换；核心代码：获取base64 对应字符在字符表中十进制值：123456var b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';var b64tab = function(bin) &#123; var t = &#123;&#125;; for (var i = 0, l = bin.length; i &lt; l; i++) t[bin.charAt(i)] = i; return t;&#125;(b64chars); 字符解码：1234567891011121314151617181920212223242526272829303132var cb_decode = function(cccc) &#123; var len = cccc.length, padlen = len % 4, // 这里通过 &lt;&lt; 移位操作，可以直接操作二进制值 // n : 将各个字符解码之后的二进制值对应的十进制 n = (len &gt; 0 ? b64tab[cccc.charAt(0)] &lt;&lt; 18 : 0) | (len &gt; 1 ? b64tab[cccc.charAt(1)] &lt;&lt; 12 : 0) | (len &gt; 2 ? b64tab[cccc.charAt(2)] &lt;&lt; 6 : 0) | (len &gt; 3 ? b64tab[cccc.charAt(3)] : 0), // 从二进制字符串中按照 8 位依次获取二进制的值 // chars 即为解码之后的字符串原始值 chars = [ fromCharCode( n &gt;&gt;&gt; 16), fromCharCode((n &gt;&gt;&gt; 8) &amp; 0xff), fromCharCode( n &amp; 0xff) ]; chars.length -= [0, 0, 2, 1][padlen]; return chars.join('');&#125;;var _atob = global.atob ? function(a) &#123; return global.atob(a);&#125; : function(a)&#123; // 将base64 字符串按照 4 个字符长度剪切 return a.replace(/\S&#123;1,4&#125;/g, cb_decode);&#125;;// 定义在 atob 上的方法用于字符解码var atob = function(a) &#123; // replace 方法将不属于 base64 字符集内的字符清空 // 比如 base64 编码字符串中最后一位可能为 =， 这个符号不代表任何含义 // base64 字符集正则范围 A-Za-z0-9\+\/ return _atob(String(a).replace(/[^A-Za-z0-9\+\/]/g, ''));&#125;; 要点 String.replace 方法 使用 String.replace 方法可以对于字符串中某些字符作替换操作：123456String.replace(searchStr | Regexp, replacedStr | replaceFn);// searchStr: 匹配的字符// Regexp: 正则表达式， 被正则表达式匹配到的都会被替换掉// replacedStr: 用于替换的字符串// replaceFn: 用于替换过程中的字符串// return: 被替换掉的字符串 例如上面的：12// 将非base64 的字符串清除String(a).replace(/[^A-Za-z0-9\+\/]/g, '') 12// 替换正则表达式匹配的字符串， 在替换过程中应用 cb_decode 方法a.replace(/\S&#123;1,4&#125;/g, cb_decode); 正则表达式相关 在正则中使用限定符 {} 可以限定字符的长度范围\S{1,4}： 匹配字符长度为 1 - 4 的字符串12345// 截取字符串按长度为 4 分段截取let strArr = [];str.replace(/\S&#123;1,4&#125;/g, (mStr) =&gt;&#123; strArr.push(mStr);&#125;); replace 方法接受函数参数如下图： 正则中的描述符 [] 中使用 ^ 表示不匹配12// 正则表示不匹配base64 字符的字符String(a).replace(/[^A-Za-z0-9\+\/]/g, '') 按位操作符相关 在 js 中， 包含下面几种操作符号， 它们用来在js 中操作二进制数据的位数各种操作符号的作用如下图： 示例：对于十进制数 10 和 20:123456789let s1 = 10;let s2 = 20;s1 &amp; s2; // 十进制 0 二进制 0s1 | s2; // 30 11110s1 ^ s2; // 30 11110~s1; // -11 -1011s1 &lt;&lt; 2 // 40 101000s1 &gt;&gt; 2; // 2 10s1 &gt;&gt;&gt; 2; // 2 10 位操作符在上面 base64 转换中的使用： 使用 |来增加二进制字符串使用 | 可以用来存储信息，比如我们对于一组数据定义其存放位置， 将这组二进制数存入到一段二进制值中：12345let s1 = 10;let s2 = 20;let s3 = 30;let str = s1 | s2 &lt;&lt; 8 | s3 &lt;&lt; 16;// s1: 1010, s2: 10100, s3: 11110 str: 111100001010000001010 使用 &amp; 来保留相应位数如：我们想要保留8位二进制的高四位：let str = s &amp; 0xf0 0xf0: 1111000012345let s5 = 0xf0;let s2 = 20;let s4 = s2 &amp; s5;console.log(s5.toString(2), s2.toString(2), s4.toString(2));// 11110000 10100 10000 进制间的转换 在 js 中进制之间的相互转化方法如下：十进制转二进制：numObj.toString(radix)12let num = 2;num.toString(2); // '10' 二进制十进制：parseInt(string, radix) The parseInt() function parses a string argument and returns an integer of the specified radix (the base in mathematical numeral systems). 1parseInt(&apos;10&apos;, 2);]]></content>
      <categories>
        <category>Base64</category>
      </categories>
      <tags>
        <tag>Base64</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数式编程（一）]]></title>
    <url>%2F2019%2F09%2F14%2F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }函数式编程是一种编程范式， 与之相对应的是面向对象编程和指令式编程等。函数式编程（FP）要更加偏向于声明式而不是命令式； 声明式关注于程序做什么， 命令式关注于程序怎样做 在FP 中， 有下面几个关键词： 纯函数 函数组合 避免状态共享 避免状态的变化 避免副作用 纯函数纯函数给定特定的输入值，将总会返回同样的输出值，且没有副作用， 纯函数具有引用透明性的特点，这使得我们更易追踪数据的变化， 减少问题的发生 函数组合函数组合可以根据我们传入的多个函数返回多个函数组合的新函数，或者根据传入的多个函数进行计算 避免状态共享状态共享的问题在于你需要了解某一个函数的功能时， 你需要知道函数中使用到的共享变量的调用历史记录， 另外， 使用共享的状态时， 调用函数的顺序不同会导致最终共享状态数据的不同 状态不变性当函数中的数据被创建之后将不会被更改，如果创建的数据在被创建之后可以被调用的函数更改，那么将会导致程序中的数据流混乱 避免副作用副作用指的是调用函数之后， 改变了函数之外的状态， 或者导致其他的可以被观测到的行为比如以下副作用： 改变外部对象或者变量属性 写文件 错发任何外部的程序 调用其他含有副作用的函数 避免上面的副作用可以使得我们易于扩展， 重构， debug 代码 函数式编程中的一些其他应用：高阶函数 高阶函数可以接受函数作为参数， 返回一种新的函数，高阶函数经常被用作： 抽象或者隔离动作， 行为， 例如回调函数或者 promises 创造作用于范围广范的数据类型的工具方法 实现函数组合或者函数重用，通过将函数作为参数传递或者创建柯里化的函数 接口函数列表， 返回这些输入方法的组合]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>FP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Base64 基础知识]]></title>
    <url>%2F2019%2F09%2F13%2Fbase64%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }Base64 作为一种编码方式， 可以将对于一些数据使用Base64 编码， 那么， 为什么使用 Base64 编码， 使用 Base64 编码的原理是什么以及 Base64 编码在前端的应用，下面的文章将会涉及这些内容：what is Base64? 在计算机中， 一个字节通常有8位字符， 这些字符使用二进制表示共有 256 种组合， 这些组合形成了 ascii（American Standard Code for Information Interchange，美国信息交换标准代码） 码：一种字节组合和字符的对应表, 基础的 ascii 码共有 128 种组合， 因为不同国家语言字符的需要， 现在很多是扩展的 ascii码，但不同的 扩展ascii 码的前 127 位是基本相同的， 这一部分称为基础 ascii 码： 假如我们不通过 Base64 编码， 而是直接向不同设备传输二进制数据，因为一些老旧设备或者软件对于某些二进制值字符的处理方式可能不同， 因就有可能被错误处理，为了解决这种问题， 我们使用Base64 编码将数据统一编码为可见字符，而可见字符在大多设备上的表现行为是一致的，这样就使得数据在不同设备之间的处理出错的可能被降低了。Base64 码共用 64 种对应字符， 对应字符如下: Base64 码由下面这些字符组成： 0 - 25 为大写英文字符 A - Z 26 - 51 为小写英文字符 a - z 52 - 61 为数字 0 -9 另外两个字符 + 和 / Base64编码原理 Base64 本质上是将二进制数据转为文本的形式， 当遇到十进制数据的时候， 需要将十进制转为二进制， 对于二进制数据以连续 6 比特计算其十进制值， 在根据这个值查找上图 Base64表中的字符， 最终我们得到的这段文本即是我们编码后的数据：比如我们对于 myname 进行Base64 编码： 原始字符 m y n a m e ASCII码十进制 109 121 110 97 109 101 二进制 01101101 01111001 01101110 01100001 01101101 01100101 Base64码二进制 011011 010111 100101 101110 011000 010110 110101 100101 Base64码十进制 27 23 37 46 24 22 53 37 对应 Base64 b X l u Y W 1 l 最终使用 Base64 编码之后的字符串为 bXluYW1l在上面的编码过程中， 我们将六个字符的字符串编码为八个字符的字符串， 编码长度前后对比为 4 ：3， 也即是说， 当原始字符长度为 3 的倍数时， 编码之后长度为 4 的相应倍数， 如果， 原始字符长度不能被 3 整除怎么办？ 这时候， 我们需要对原始字符的二进制进行补零操作：例如， 我们对于 my 进行编码： 原始字符 m y ASCII码十进制 109 121 二进制 01101101 01111001 00000000 Base64码二进制 011011 010111 100100 000000 Base64码十进制 27 23 36 0 对应 Base64 b X k A 因为原始字符中补充的 0 没有任何意义， 因此编码后的 A 不带有任何的意义，标准的 ascii 码中将 A 替换为 =my 的编码字符串为 bXk=;对于解码过程， 首先观察编码字符串长度， 如果字符串长度不能被 4 整除，那么，需要给编码字符串补充 = 来使得字符串长度可以被 4 整除， 然后在进行解码操作。解码过程是编码过程的逆向操作，将编码字符串的 = 转为 A, 然后转为十进制的 Base64 码， 后转为二进制的6位比特值，将字符串末尾的相应 A 的二进制比特0值丢弃，因为他们不携带任何的信息。最后将8位二进制转为原始字符.前端应用 Base64 Base64 在前端应用比较常见的是将图片的二进制数据转为 Base64， 嵌套入 html 中。现代浏览器对于图片的 src 属性支持一种 dataUrl 的特性，格式为：url(data:文件类型;编码方式,编码后的文件内容)例如百度搜索的dataURL： 使用这种方式的优点是可以减少外部资源请求， 加快页面加载时间， 缺点是对于色彩丰富的图片， 二进制数据编码之后的 Base64 字符串会比较大， 会影响页面的加载速度其他：Data URLs Data URLs 是以 data: 协议为前缀的一种 url，使用 data url 实现了可以将一些小的文件嵌入到文档中的一种方法data url 的组成结构如下： data:[&lt;mediatype&gt;][;base64],&lt;data&gt; data url 由下面三种结构组成: mediatype 表示当前文件的 MIME type, 例如： image/jpeg, text/plain 等当数据 data 为非文本的格式的时候， 使用一个 base64 标志表示当前的数据为使用 base64 编码之后的数据，对于文字格式， 也是可以使用 base64 进行编码操作data: 数据本身我们经常会遇到的是经过 base64 编码过后的图片，除了图片之外， 我们还可以对于文字进行转为 data url 的形式：data:,Hello%2C%20World!data:text/plain;base64,SGVsbG8sIFdvcmxkIQ%3D%3D // 经过 base64 编码过的上面的文本： Hello World!data:text/html,%3Ch1%3EHello%2C%20World!%3C%2Fh1%3E // html 文本： &lt;h1&gt;Hello World!&lt;h1&gt;注意：在 data url 中数据本身是 data,当我们需要对于数据进行操作的时候， 我们需要获取到 data urls 中的数据：123456// 在 node 中下载 data urls 形式的图片const fs = require('fs');function downloadImage(dataUrl) &#123; dataUrl = dataUrl.replace(/^data:image\/png;base64,/, ""); fs.writeSync('image.jpg', dataUrl, &#123; encoding: 'base64' &#125;);&#125; 参考链接：data urls]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Base64</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node 中的 events 模块学习]]></title>
    <url>%2F2019%2F09%2F08%2Fevent%20Emitter%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }events 模块模仿 events 模块的一些代码， 基本实现原 events 模块的一些功能：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218function cloneArray(list, n, fn) &#123; let clonedArr = new Array(n); for (let index = 0; index &lt; n; index++) &#123; clonedArr[index] = fn ? fn(list[index]) : list[index]; &#125; return clonedArr;&#125;function clonelisteners(list, hasWrap) &#123; return cloneArray(list, list.length, (listener) =&gt; &#123; return hasWrap ? listener : (listener.listener || listener); &#125;);&#125;function getListeners(target, type, hasWrap) &#123; const listenerList = target.events[type]; if (typeof listenerList === 'function') &#123; return hasWrap ? [listenerList] : [listenerList.listener || listenerList]; &#125; else &#123; return clonelisteners(listenerList, hasWrap); &#125;&#125;class EventEmitter &#123; constructor() &#123; this.maxListeners; this.defaultMaxlisteners = 10; this.events = undefined; this.eventsCount = 0; this.init(); &#125; init() &#123; this.maxListeners = this.maxListeners || this.defaultMaxlisteners; this.events = Object.create(null); &#125; checkListener(listener) &#123; if (typeof listener !== 'function') throw new Error('listener is not function type'); &#125; listenerCount(emitter, type) &#123; if (typeof emitter.listenerCount === 'function') return emitter.listenerCount(type); function listenerCount(type) &#123; const events = this.events; if (events === undefined) return 0; const eventList = this.events[type]; if (typeof eventList === 'function') return 1; if (eventList) &#123; return eventList.length; &#125; else return 0; &#125;; listenerCount.call(emitter, type); &#125; prependListener(type, listener) &#123; this.addListeners(type, listener, true); &#125; prependOnceListener(type, listener) &#123; this.once(type, listener, true); &#125; addListeners(type, listener, prepend) &#123; this.checkListener(listener); if (this.events) &#123; if (this.events.newListener) this.emit('newListener', listener.listener || listener); &#125; const existlistener = this.events[type]; if (typeof existlistener === 'function') &#123; this.events[type] = prepend ? [listener, existlistener] : [existlistener, listener]; &#125; else if (typeof existlistener === 'undefined') &#123; this.events[type] = listener; this.eventsCount ++; &#125; else if (prepend) &#123; this.events[type].unshift(listener); &#125; else &#123; this.events[type].push(listener); &#125; let maxlistenerLength = this.getMaxlisteners(); if (this.events[type].length &gt; maxlistenerLength) &#123; let w = new Error('memory leak'); process.emitWarning(w); &#125; return this; &#125; on() &#123; this.addListeners(...arguments); &#125; off() &#123; this.removeListener(...arguments); &#125; once(type, listener, prepend) &#123; this.checkListener(listener); function wrapFn () &#123; if (!this.fired) &#123; this.fired = true; this.emitter.removeListener(type, this.wraplistenerFn); this.listener.apply(this.emitter, arguments); &#125; &#125; const listenerWrapStates = &#123; fired: false, listener, wraplistenerFn: undefined, emitter: this &#125;; const wrapedlistener = wrapFn.bind(listenerWrapStates); wrapedlistener.listener = listener; listenerWrapStates.wraplistenerFn = wrapedlistener; this.on(type, wrapedlistener, prepend); &#125; emit(type, ...args) &#123; const existlistener = this.events[type]; if (existlistener === undefined) return false; if (typeof existlistener !== 'function') &#123; const existList = cloneArray(existlistener, existlistener.length); existList.forEach(listener =&gt; &#123; listener.apply(this, args); &#125;); &#125; else &#123; existlistener.apply(this, args); &#125; &#125; removeAlllisteners(type) &#123; const listenerList = this.events[type]; const isRemoveAllEvens = arguments.length === 0; if (this.events === undefined) return this; // 移除全部的 listernr if (this.events.removeListener === undefined) &#123; if (isRemoveAllEvens) &#123; this.events = Object.create(null); this.eventsCount = 0; &#125; else &#123; if (listenerList) &#123; delete this.events[type]; this.eventsCount --; if (this.eventsCount === 0) this.events = Object.create(null); &#125; &#125; return this; &#125; else &#123; if (isRemoveAllEvens) &#123; for (const key of this.events) &#123; if (key === 'removeListener') continue; this.removeAlllisteners(key); &#125; this.removeAlllisteners('removeListener'); this.eventsCount = 0; this.events = Object.create(null); return this; &#125; &#125; if (typeof listenerList === 'function') &#123; this.removeListener(type, listenerList); &#125; else if (listenerList) &#123; listenerList.forEach(listener =&gt; &#123; this.removeListener(type, listener); &#125;); &#125; return this; &#125; setMaxlisteners(num) &#123; if (typeof num !== 'number' || num &lt; 0 || Number.isNaN(num)) throw new Error('listernrs length is a number'); this.maxListeners = num; return this; &#125; getMaxlisteners() &#123; return this.maxListeners; &#125; eventNames() &#123; if (this.events === undefined || this.eventsCount === 0) return []; return Object.keys(this.events); &#125; rawListeners(type) &#123; const eventList = this.events[type]; if (eventList === undefined) return []; return getListeners(this, type, true); &#125; listeners(type) &#123; const eventList = this.events[type]; if (eventList === undefined) return []; return getListeners(this, type, false); &#125; removeListener(type, listener) &#123; this.checkListener(listener); const eventListeners = this.events[type]; if (eventListeners === undefined) return this; if (typeof eventListeners === 'function') &#123; if (eventListeners === listener || eventListeners.listener === listener) &#123; this.eventsCount --; if (this.eventsCount === 0) &#123; this.events = Object.create(null); &#125; else &#123; delete this.events[type]; if (this.events.removeListener) &#123; this.emit('removeListener', type, eventListeners || eventListeners.listener); &#125; &#125; &#125; // 当存放的事件是一个数组的时候 &#125; else &#123; let handlerIndex = -1; let originlistener; for (let i = 0; i &lt; eventListeners.length; i ++) &#123; if (eventListeners[i] === listener || eventListeners[i].listener === listener) &#123; handlerIndex = i; originlistener = eventListeners[i].listener; break; &#125; &#125; if (handlerIndex &lt; 0) return this; if (handlerIndex === 0) &#123; eventListeners.shift(); &#125; else &#123; const spliceOne = function (list, index) &#123; list.splice(index, 1); &#125;; spliceOne(eventListeners, handlerIndex); &#125; if (eventListeners.length === 1) this.events[type] = eventListeners[0]; if (this.events.removeListener) this.emit(this.removeListener, type, originlistener || listener); &#125; &#125;&#125;module.exports = EventEmitter;]]></content>
      <categories>
        <category>node module</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[prop in vue.js（prop 的初始化）]]></title>
    <url>%2F2019%2F05%2F25%2Fprop%20in%20vue%EF%BC%88prop%20%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%89%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }Prop 在 vue.js 中, 使用 prop 可以实现父组件向子组件传递值，在子组件中的 props 中的数据将会和父组件中传递的相应的 prop 保持一致，在传递 prop 的时候，可以传递一个数组, 例如：1props: ['data1', 'data2', 'data3' ...] 或者可以传递一个对象，对象的键是要传递的 prop 名称， 对象的值可以是一个对象， 这个对象中 可以定义传递值的type 以及 default 属性：123456props: &#123; data1: &#123; type: Boolean, // 传递值的类型， 可以是一个数组 [Boolean, String] default: true // 当父组件没有传递的时候， 子组件中使用的默认值 &#125;&#125; 当父组件中传递值的类型不符合子组件 props 中相应值的 type 的时候， vue 会在控制台进行报错。在源码中， 在初始化 prop 的时候， 会对prop 进行校验。初始化 props 在 initState 中：当当前组件中存在 props 的时候， 对于 props 执行 initProps 进行初始化：123456789101112131415function initState (vm) &#123; vm._watchers = []; var opts = vm.$options; if (opts.props) &#123; initProps(vm, opts.props); &#125; if (opts.methods) &#123; initMethods(vm, opts.methods); &#125; if (opts.data) &#123; initData(vm); &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */); &#125; if (opts.computed) &#123; initComputed(vm, opts.computed); &#125; if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch); &#125; &#125; 在 initProps 中接受两个参数： vm 当前 vue 的实例， propsOptions 在当前组件中规范化后的 props 对象 在执行 initProps 方法之前， 在 vm.$options 属性中的 props 属性中已经对于传递的 props 进行了规范化处理为下面的这种形式：12345&gt;test: &#123;&gt; type: sometype,&gt; default: // 默认值， 如果没有传， 那么就没有&gt;&#125;&gt; initProps:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 用于初始化 props 对象 function initProps (vm, propsOptions) &#123; // vm.$options.propsData: 父组件中传递的 props 对象 var propsData = vm.$options.propsData || &#123;&#125;; var props = vm._props = &#123;&#125;; // cache prop keys so that future props updates can iterate using Array // instead of dynamic object key enumeration. var keys = vm.$options._propKeys = []; var isRoot = !vm.$parent; // root instance props should be converted if (!isRoot) &#123; toggleObserving(false); &#125; var loop = function ( key ) &#123; keys.push(key); var value = validateProp(key, propsOptions, propsData, vm); /* istanbul ignore else */ &#123; var hyphenatedKey = hyphenate(key); if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) &#123; warn( ("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop."), vm ); &#125; defineReactive(props, key, value, function () &#123; if (!isRoot &amp;&amp; !isUpdatingChildComponent) &#123; warn( "Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm ); &#125; &#125;); &#125; // static props are already proxied on the component's prototype // during Vue.extend(). We only need to proxy props defined at // instantiation here. if (!(key in vm)) &#123; proxy(vm, "_props", key); &#125; &#125;; for (var key in propsOptions) loop( key ); toggleObserving(true); &#125; 在上面的函数中。我们传入了 vue 实例和 当前组件中传入的 props 中的数据， 在这个函数中， 我们定义了四个变量：123456var propsData = vm.$options.propsData || &#123;&#125;; // 获取到父组件传递到子组件中的值var props = vm._props = &#123;&#125;; // 在实例上的 _props 属性上定义空对象 &#123;&#125;// cache prop keys so that future props updates can iterate using Array// instead of dynamic object key enumeration.var keys = vm.$options._propKeys = []; // 在 实例的 $options 属性上定义 _propKeys 属性， 并初始化为数组var isRoot = !vm.$parent; // 判断是否为根元素， 因为对于根元素， 其实例上没有 `$parent` 属性， 这个时候 `isRoot` 为true 上面的 toggleObserving 方法用来切换是否对与数据进行监听的开关函数：12345678910/** * In some cases we may want to disable observation inside a component's * update computation. */var shouldObserve = true;// 根据传递的 vue 属性来切换 `shouleObserve` 的值function toggleObserving (value) &#123; shouldObserve = value;&#125; 通过调用这个方法， 改变的是全局变量 shouldObserve 的值， 这个值的作用我们后面在说， 现在， 我们先看下在 initProps 中的 for in 中的 loop 方法：1for (var key in propsOptions) loop(key); 在上面的代码中， 对于当前组件内 prop 中的每一个 prop 值， 都执行 loop 方法：loop 方法：1234567891011121314151617181920212223242526272829303132333435// key prop 值var loop = function ( key ) &#123; // 将当前组件内所有的 prop 值存入到 keys 中 keys.push(key); // 根据定义的 prop 规则判断传入的 prop 值是否有效 var value = validateProp(key, propsOptions, propsData, vm); /* istanbul ignore else */ &#123; var hyphenatedKey = hyphenate(key); if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) &#123; warn( ("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop."), vm ); &#125; defineReactive(props, key, value, function () &#123; if (!isRoot &amp;&amp; !isUpdatingChildComponent) &#123; warn( "Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm ); &#125; &#125;); &#125; // static props are already proxied on the component's prototype // during Vue.extend(). We only need to proxy props defined at // instantiation here. if (!(key in vm)) &#123; proxy(vm, "_props", key); &#125;&#125;; 在上面的 loop 方法中， 当传入 key 之后， 执行了 validateProp 方法， 这个方法定义如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * * @param &#123;key&#125; 在 props 中定义的 prop 值 * @param &#123;propOptions&#125; propOptions : 所有的 prop 值 * @param &#123;propsData&#125; propsData 从上层组件传入的值 * @param &#123;vm&#125; vue 实例 */function validateProp ( key, propOptions, propsData, vm) &#123; // 获取当前 prop 值的规则 var prop = propOptions[key]; // 判断这个 prop 值有没有被传入到 var absent = !hasOwn(propsData, key); var value = propsData[key]; // boolean casting var booleanIndex = getTypeIndex(Boolean, prop.type); if (booleanIndex &gt; -1) &#123; if (absent &amp;&amp; !hasOwn(prop, 'default')) &#123; value = false; &#125; else if (value === '' || value === hyphenate(key)) &#123; // only cast empty string / same name to boolean if // boolean has higher priority var stringIndex = getTypeIndex(String, prop.type); if (stringIndex &lt; 0 || booleanIndex &lt; stringIndex) &#123; value = true; &#125; &#125; &#125; // check default value if (value === undefined) &#123; value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy, // make sure to observe it. var prevShouldObserve = shouldObserve; toggleObserving(true); observe(value); toggleObserving(prevShouldObserve); &#125; &#123; assertProp(prop, key, value, vm, absent); &#125; return value&#125; 在这个方法内部 定义了四个变量：prop: 当前传入 prop 值的对象absent: 布尔值， 当前 prop 有没有被父组件传入value: 父组件传入的 prop 的值， 如果没有传入，为 undefinedbooleanIndex: 是通过 getTypeIndex 方法返回的， 这个方法的作用是：当 prop 中声明的 type 中包含有布尔值的时候， 如果 type 为 String， 返回 0， 如果 type 为数组， 返回这个 Boolean 值在 type 数组中的顺序 index， 如果不包含布尔值， 那么返回 -1getTypeIndex:12345678910111213// expectedTypes： prop 中声明的 type// type: 相应的 type 类型， 例如： Boolean, Stringfunction getTypeIndex (type, expectedTypes) &#123; if (!Array.isArray(expectedTypes)) &#123; return isSameType(expectedTypes, type) ? 0 : -1 &#125; for (var i = 0, len = expectedTypes.length; i &lt; len; i++) &#123; if (isSameType(expectedTypes[i], type)) &#123; return i &#125; &#125; return -1&#125; 这里， 使用了 isSameType 方法来进行比较者两个 type 是否相等：12345678910111213/** * Use function string name to check built-in types, * because a simple equality check will fail when running * across different vms / iframes. */ function getType (fn) &#123; var match = fn &amp;&amp; fn.toString().match(/^\s*function (\w+)/); return match ? match[1] : '' &#125; function isSameType (a, b) &#123; return getType(a) === getType(b) &#125; 在上面的 getType 中， 调用 fn.toString() 方法， 再通过正则表达式获取到 (\w+) 内的内容，例如： 因为， 在 js 中例如 Boolean, String 之类的类型， 都是代表着一个个的函数方法， 对于这个函数， 可以调用 toString 1234Boolean// ƒ Boolean() &#123; [native code] &#125;Boolean.toString()//"function Boolean() &#123; [native code] &#125;" 接来下， 对于数据进行初始化：针对需要校验的 type 中包含有 Boolean 字段的时候12345678910111213141516// 当 prop 的type中包含有 “Boolean” 的时候 if (booleanIndex &gt; -1) &#123; // 当没有传入的 prop 的时候， 并且没有 default 属性的时候 if (absent &amp;&amp; !hasOwn(prop, 'default')) &#123; // 将 prop 值置为 false value = false; &#125; else if (value === '' || value === hyphenate(key)) &#123; // 当 boolean 有更高优先级的时候， 将空字符串或者和 prop 中名字相同的值转化为 布尔值 // only cast empty string / same name to boolean if // boolean has higher priority var stringIndex = getTypeIndex(String, prop.type); if (stringIndex &lt; 0 || booleanIndex &lt; stringIndex) &#123; value = true; &#125; &#125; &#125; 例如：有以下子组件： child.vue12345678export default &#123; props: &#123; propData: &#123; type: [Boolean, String], default: &apos;&apos; &#125; &#125;&#125; 在父组件中如下定义：1&lt;child prop-data=&quot;&quot;&gt;&lt;/child&gt; 那么在子组件中， 获得到的 propData 值为 true;或者， 当在父组件中如下定义的时候：1&lt;child prop-data=&quot;propData&quot;&gt;&lt;/child&gt; 和上面相同， 也是为 true,总之：当定义的 prop 接受值的类型，Boolean 值类型优先级要高于 String 的时候（在 type 中 Boolean 在 String 前面 [Boolean, String]）: 当传递的值为空字符串的时候， 接受到的prop 值变为 true 当传递的值为字符串并且和驼峰后的 prop 名相同的时候， 接受的值也将转为 true 另外， 当在父组件中没有传入 prop 值， 并且， 没有声明 default 属性， 当校验 type 中包含有Boolean 的时候， 这个时候， 获取这个 prop 的值将为 falsechild.vue 组件中：1234567export default &#123; props: &#123; propData: &#123; type: [Boolean, String] &#125; &#125;&#125; 父组件中：1&lt;child&gt;&lt;/child&gt; 在 child.vue 组件中获取到 propData 的值为 false;]]></content>
      <categories>
        <category>vue 源码阅读</category>
      </categories>
      <tags>
        <tag>vue 源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[watch in vue.js]]></title>
    <url>%2F2019%2F05%2F13%2Fwatch%20in%20vue%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }watch 方法 vue 的 watch 方法用来监听 vue 中 data 的变动, 可以接受一个函数， 对象， 字符串， 或者数组。watch 方法接受两个参数： deep &amp; immediate, immediate 表明是否立即进行函数调用， deep 表示是否监听更深一级的对象；例如在vue 组件中：12345678910111213141516new Vue(&#123; el: '#app', data() &#123; return &#123; data: 1 &#125; &#125;, watch: &#123; data: function () &#123; // some code... &#125; &#125;, mounted() &#123; this.data = 2; &#125; &#125; 当 this.data 发生重新赋值的时候， 就会调用 watch 中 data 后面跟的匿名函数：在 vue.js 中， 调用流程如下：首先， 因为在 vue watch 中的名称是先写在 data 中的，在初始化 watch 方法之前， 首先对于 data 中的数据进行了初始化，调用了 defineReactive 方法， 将其数据设为响应式的数据 初始化 watch 方法： 123456789101112131415161718// 初始化状态// vm： vue 实例function initState (vm) &#123; vm._watchers = []; var opts = vm.$options; if (opts.props) &#123; initProps(vm, opts.props); &#125; if (opts.methods) &#123; initMethods(vm, opts.methods); &#125; if (opts.data) &#123; initData(vm); &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */); &#125; if (opts.computed) &#123; initComputed(vm, opts.computed); &#125; if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; // 初始化 watch initWatch(vm, opts.watch); &#125;&#125; initWatch 为如下方法：1234567891011121314// 对于 vue watch 方法中的每一个键都创建一个 watcher function initWatch (vm, watch) &#123; for (var key in watch) &#123; var handler = watch[key]; // 当watch 键后面跟着一个数组的时候， 对于数组里面的每一个函数， 都调用 createWatcher 方法 if (Array.isArray(handler)) &#123; for (var i = 0; i &lt; handler.length; i++) &#123; createWatcher(vm, key, handler[i]); &#125; &#125; else &#123; createWatcher(vm, key, handler); &#125; &#125; &#125; createWatcher 方法： 用于在 watch 中某个键的相关字段进行解析：12345678910111213141516171819202122// vm: vue 实例// expOrFn: 创建 watcher 的一些数据名称// hander 回调函数function createWatcher ( vm, expOrFn, handler, options ) &#123; // 当执行函数是一个对象的时候， 这个时候是将 handler 的 handler调用给执行函数 // 这里的 options 是 watch 函数的配置信息 if (isPlainObject(handler)) &#123; options = handler; handler = handler.handler; &#125; // 当 handler 是一个字符串的时候， 会调用 vm 中相应的方法 if (typeof handler === 'string') &#123; handler = vm[handler]; &#125; //调用在 vue 实例 vm 上面的 $watch 方法 return vm.$watch(expOrFn, handler, options) &#125; 调用 vue 实例上面的 $watch 方法， 这个方法会对于当前的方法创建一个观察者 watcher 12345678910111213141516171819202122232425262728 Vue.prototype.$watch = function ( expOrFn, cb, options ) &#123; var vm = this; if (isPlainObject(cb)) &#123; return createWatcher(vm, expOrFn, cb, options) &#125; options = options || &#123;&#125;; options.user = true; // 创建一个新的观察者 var watcher = new Watcher(vm, expOrFn, cb, options); // 当可选项中包含有 immediate 属性的时候 if (options.immediate) &#123; try &#123; // 立即执行当前 watch 函数 cb.call(vm, watcher.value); &#125; catch (error) &#123; handleError(error, vm, ("callback for immediate watcher \"" + (watcher.expression) + "\"")); &#125; &#125; // 返回一个取消 watch 的函数 return function unwatchFn () &#123; watcher.teardown(); &#125; &#125;;&#125; 当 调用 watch 方法的时候， 将当前 watch 内 data 的回调函数作为依赖进行收集。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283var Watcher = function Watcher ( vm, expOrFn, cb, options, isRenderWatcher ) &#123; this.vm = vm; if (isRenderWatcher) &#123; vm._watcher = this; &#125; vm._watchers.push(this); // options if (options) &#123; this.deep = !!options.deep; this.user = !!options.user; this.lazy = !!options.lazy; this.sync = !!options.sync; this.before = options.before; &#125; else &#123; this.deep = this.user = this.lazy = this.sync = false; &#125; // 回调函数被绑定到 Watcher 观察者上面的 cb 属性上面 this.cb = cb; this.id = ++uid$1; // uid for batching this.active = true; this.dirty = this.lazy; // for lazy watchers this.deps = []; this.newDeps = []; this.depIds = new _Set(); this.newDepIds = new _Set(); this.expression = expOrFn.toString(); // parse expression for getter if (typeof expOrFn === 'function') &#123; this.getter = expOrFn; &#125; else &#123; // 这里对于监听的变量值进行解析 this.getter = parsePath(expOrFn); console.log('this.getter', this.getter); if (!this.getter) &#123; this.getter = noop; warn( "Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm ); &#125; &#125; this.value = this.lazy ? undefined : this.get(); &#125;; /** * Evaluate the getter, and re-collect dependencies. */ Watcher.prototype.get = function get () &#123; // 将当前的 Watcher 赋值给 Dep.target pushTarget(this); var value; var vm = this.vm; try &#123; // 调用 getter 方法， 触发响应式数据的 get 属性， 进行依赖搜集 value = this.getter.call(vm, vm); console.log('this.value', value); &#125; catch (e) &#123; if (this.user) &#123; handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\"")); &#125; else &#123; throw e &#125; &#125; finally &#123; // "touch" every property so they are all tracked as // dependencies for deep watching if (this.deep) &#123; traverse(value); &#125; popTarget(); this.cleanupDeps(); &#125; return value &#125;; parsePath 方法用于监听的字段进行解析：1234567891011121314151617var bailRE = new RegExp(("[^" + (unicodeRegExp.source) + ".$_\\d]"));function parsePath (path) &#123; if (bailRE.test(path)) &#123; return &#125; // 按照 . 号进行分割为数组， 适用于我们想要监听一个对象下面的某一个属性的时候 var segments = path.split('.'); // 返回的函数作为 上面代码中的 this.getter // 当调用 this.getter 函数的时候， 会触发在当前数据上面的响应式数据的 get 方法， 搜集依赖 return function (obj) &#123; for (var i = 0; i &lt; segments.length; i++) &#123; if (!obj) &#123; return &#125; obj = obj[segments[i]]; &#125; return obj &#125;&#125; 当触发响应式数据的 getter 属性的时候，在 defineReactive 中, 会进行依赖收集 当调用dep.depend() 的时候， 调用了 Dep 类的depend 方法：12345Dep.prototype.depend = function depend () &#123; if (Dep.target) &#123; Dep.target.addDep(this); &#125;&#125;; 这里的Dep.target 是我们之前将watcher 赋值的那一个， 当调用 Watcher 上面的 addDep 方法的时候， 是将当前的dep 传入 watcher 实例中的 newDeps 属性， 并且， 当前dep 实例上面的 addSub 方法将会将 Watcher 存放到 这个实例的 subs 属性上面。12345678910Watcher.prototype.addDep = function addDep (dep) &#123; var id = dep.id; if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id); this.newDeps.push(dep); if (!this.depIds.has(id)) &#123; dep.addSub(this); &#125; &#125;&#125;; 当依赖收集完毕之后， 当监听的值发生变化的时候，通知依赖发生变化： 当监听的数据发生变化的时候， 会调用这个数据的 set 属性：1234567891011121314151617181920212223set: function reactiveSetter (newVal) &#123; // 获取到原来的值 var value = getter ? getter.call(obj) : val; /* eslint-disable no-self-compare */ // 当要监听的数据没有发生变化的时候， 返回 if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; /* eslint-enable no-self-compare */ if (customSetter) &#123; customSetter(); &#125; // #7981: for accessor properties without setter if (getter &amp;&amp; !setter) &#123; return &#125; if (setter) &#123; setter.call(obj, newVal); &#125; else &#123; val = newVal; &#125; childOb = !shallow &amp;&amp; observe(newVal); // 通知依赖发生变化 dep.notify();&#125; dep.notify() 是用来通知依赖发生变化的, 调用了 dep 实例上面的 notify 方法：1234567891011121314Dep.prototype.notify = function notify () &#123; // stabilize the subscriber list first var subs = this.subs.slice(); if (!config.async) &#123; // subs aren't sorted in scheduler if not running async // we need to sort them now to make sure they fire in correct // order subs.sort(function (a, b) &#123; return a.id - b.id; &#125;); &#125; // subs 中存放的是 watcher ， 调用了 watcher 实例的 update 方法。 for (var i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update(); &#125;&#125;; 1234567891011Watcher.prototype.update = function update () &#123; /* istanbul ignore else */ if (this.lazy) &#123; this.dirty = true; &#125; else if (this.sync) &#123; this.run(); &#125; else &#123; // 调用 queueWatcher queueWatcher(this); &#125;&#125;; 在 queueWatcher 方法中， 将当前变动的所有 watcher 存放数组 queue 中：123456789101112131415161718192021222324252627282930313233/** * Push a watcher into the watcher queue. * Jobs with duplicate IDs will be skipped unless it's * pushed when the queue is being flushed. */ function queueWatcher (watcher) &#123; var id = watcher.id; if (has[id] == null) &#123; has[id] = true; if (!flushing) &#123; // 将 watcher 存入 queue.push(watcher); &#125; else &#123; // if already flushing, splice the watcher based on its id // if already past its id, it will be run next immediately. var i = queue.length - 1; while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123; i--; &#125; queue.splice(i + 1, 0, watcher); &#125; // queue the flush if (!waiting) &#123; waiting = true; if (!config.async) &#123; flushSchedulerQueue(); return &#125; nextTick(flushSchedulerQueue); &#125; &#125; &#125; 执行 watch 中数据变动之后的函数回调：调用。flushSchedulerQueue 123456789101112131415161718192021222324252627282930313233343536373839404142function flushSchedulerQueue () &#123; currentFlushTimestamp = getNow(); flushing = true; var watcher, id; // Sort queue before flush. // This ensures that: // 1. Components are updated from parent to child. (because parent is always // created before the child) // 2. A component's user watchers are run before its render watcher (because // user watchers are created before the render watcher) // 3. If a component is destroyed during a parent component's watcher run, // its watchers can be skipped. queue.sort(function (a, b) &#123; return a.id - b.id; &#125;); // do not cache length because more watchers might be pushed // as we run existing watchers for (index = 0; index &lt; queue.length; index++) &#123; watcher = queue[index]; if (watcher.before) &#123; watcher.before(); &#125; id = watcher.id; has[id] = null; // 调用 watcher 实例上面的 run 方法 watcher.run(); // in dev build, check and stop circular updates. if (has[id] != null) &#123; circular[id] = (circular[id] || 0) + 1; if (circular[id] &gt; MAX_UPDATE_COUNT) &#123; warn( 'You may have an infinite update loop ' + ( watcher.user ? ("in watcher with expression \"" + (watcher.expression) + "\"") : "in a component render function." ), watcher.vm ); break &#125; &#125; &#125; 调用 watcher.run 方法之后， 如下：123456789101112131415161718192021222324252627Watcher.prototype.run = function run () &#123; if (this.active) &#123; var value = this.get(); if ( value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even // when the value is the same, because the value may // have mutated. isObject(value) || this.deep ) &#123; // set new value var oldValue = this.value; this.value = value; if (this.user) &#123; try &#123; this.cb.call(this.vm, value, oldValue); &#125; catch (e) &#123; handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\"")); &#125; &#125; else &#123; // 调用 watch 之后的函数方法， 传入的两个值， 当前变动的值和之前的值 this.cb.call(this.vm, value, oldValue); &#125; &#125; &#125; &#125;; 最终， 调用this.cb.call(this.vm, value, oldValue);执行当监听的数据发生变化时候的回调函数， 调用的时候传入两个参数： value &amp;&amp; oldValue, 表示当前的值和变化之前的值。 补充： deep 方法是如何起作用的：当我们设定 deep 为 true 的时候， 这个时候， 当对象中的某个属性发生变化的时候， 也会被监听到变动， 关于 deep 为 true 的代码在下面：12345678910111213141516171819202122232425Watcher.prototype.get = function get () &#123; pushTarget(this); var value; var vm = this.vm; try &#123; // 调用 getter, 搜集依赖 value = this.getter.call(vm, vm); // console.log('this.value', value); &#125; catch (e) &#123; if (this.user) &#123; handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\"")); &#125; else &#123; throw e &#125; &#125; finally &#123; // "touch" every property so they are all tracked as // dependencies for deep watching if (this.deep) &#123; traverse(value); &#125; popTarget(); this.cleanupDeps(); &#125; return value &#125;; 正如上面注释写明的一样， 当 deep 为 true 的时候， 调用 traverse 方法， 这个方法的作用是出发对象中每一个属性的 get 方法， 从而让他们的依赖得以收集：traverse. 方法：1234567891011121314151617181920212223242526272829// 递归调用对象中的属性， 通过 val[i] 或者 val[key[i]] 触发 get 方法 function traverse (val) &#123; _traverse(val, seenObjects); seenObjects.clear(); &#125; function _traverse (val, seen) &#123; var i, keys; var isA = Array.isArray(val); if ((!isA &amp;&amp; !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) &#123; return &#125; if (val.__ob__) &#123; var depId = val.__ob__.dep.id; if (seen.has(depId)) &#123; return &#125; seen.add(depId); &#125; if (isA) &#123; i = val.length; while (i--) &#123; _traverse(val[i], seen); &#125; &#125; else &#123; keys = Object.keys(val); i = keys.length; // val[key[i]] 这里是关键 while (i--) &#123; _traverse(val[keys[i]], seen); &#125; &#125; &#125;]]></content>
      <categories>
        <category>vue 源码阅读</category>
      </categories>
      <tags>
        <tag>vue 源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nextTick in vue.js]]></title>
    <url>%2F2019%2F05%2F09%2FnextTick%20in%20vue%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }nextTick 方法 nextTick 方法是挂载到 vue 实例上面， 我们可以通过使用 this.$nextTick 来使用这个方法。这个方法的作用是： 将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。 首先， 当我们在页面上面调用这个方法的时候， 在 vue 内部， 函数执行的路径是什么样的：定义 nextTick:12345mounted() &#123; this.$nextTick(() =&gt; &#123; console.log('nextTick'); &#125;);&#125; 查看调用栈： 查看上面的调用栈得知， 当调用 nextTick 的时候，直到执行函数依次经历：nextTick timeFunc flushCallbacks那么 nextTick 方法在 vue 中是如何起作用的？nextTick 方法定义：12345678910111213141516171819202122232425262728293031// cb: 回调函数// ctx 上下文对象function nextTick (cb, ctx) &#123; var _resolve; // callbacks 中用来存放所有 nextTick 中的 cb 函数 callbacks.push(function () &#123; if (cb) &#123; try &#123; // 当 cb 存在的时候， 执行回调函数 cb.call(ctx); &#125; catch (e) &#123; handleError(e, ctx, 'nextTick'); &#125; // 否则， 返回一个 promise &#125; else if (_resolve) &#123; _resolve(ctx); &#125; &#125;); // 这里保证不会执行 两次 timeFunc if (!pending) &#123; pending = true; timerFunc(); &#125; // $flow-disable-line // 当没有回调函数的时候， 返回一个 promise if (!cb &amp;&amp; typeof Promise !== 'undefined') &#123; return new Promise(function (resolve) &#123; _resolve = resolve; &#125;) &#125; &#125; 当我们调用 nextTick 的时候， 会将回调函数存入 callbacks 数组中， 这个数组用来存放当前组件中使用 nextTick 方法时的回调函数。timeFunc 函数： 这个函数用来在合适的时机调用 nextTick 中推入 callback 列表中的所有函数， 所有代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// Here we have async deferring wrappers using microtasks.// In 2.5 we used (macro) tasks (in combination with microtasks).// However, it has subtle problems when state is changed right before repaint// (e.g. #6813, out-in transitions).// Also, using (macro) tasks in event handler would cause some weird behaviors// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).// So we now use microtasks everywhere, again.// A major drawback of this tradeoff is that there are some scenarios// where microtasks have too high a priority and fire in between supposedly// sequential events (e.g. #4521, #6690, which have workarounds)// or even between bubbling of the same event (#6566).let timerFunc// The nextTick behavior leverages the microtask queue, which can be accessed// via either native Promise.then or MutationObserver.// MutationObserver has wider support, however it is seriously bugged in// UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It// completely stops working after triggering a few times... so, if native// Promise is available, we will use it:/* istanbul ignore next, $flow-disable-line */if (typeof Promise !== 'undefined' &amp;&amp; isNative(Promise)) &#123; const p = Promise.resolve() timerFunc = () =&gt; &#123; p.then(flushCallbacks) // In problematic UIWebViews, Promise.then doesn't completely break, but // it can get stuck in a weird state where callbacks are pushed into the // microtask queue but the queue isn't being flushed, until the browser // needs to do some other work, e.g. handle a timer. Therefore we can // "force" the microtask queue to be flushed by adding an empty timer. if (isIOS) setTimeout(noop) &#125; isUsingMicroTask = true&#125; else if (!isIE &amp;&amp; typeof MutationObserver !== 'undefined' &amp;&amp; ( isNative(MutationObserver) || // PhantomJS and iOS 7.x MutationObserver.toString() === '[object MutationObserverConstructor]')) &#123; // Use MutationObserver where native Promise is not available, // e.g. PhantomJS, iOS7, Android 4.4 // (#6466 MutationObserver is unreliable in IE11) let counter = 1 const observer = new MutationObserver(flushCallbacks) const textNode = document.createTextNode(String(counter)) observer.observe(textNode, &#123; characterData: true &#125;) timerFunc = () =&gt; &#123; counter = (counter + 1) % 2 textNode.data = String(counter) &#125; isUsingMicroTask = true&#125; else if (typeof setImmediate !== 'undefined' &amp;&amp; isNative(setImmediate)) &#123; // Fallback to setImmediate. // Techinically it leverages the (macro) task queue, // but it is still a better choice than setTimeout. timerFunc = () =&gt; &#123; setImmediate(flushCallbacks) &#125;&#125; else &#123; // Fallback to setTimeout. timerFunc = () =&gt; &#123; setTimeout(flushCallbacks, 0) &#125;&#125; 上面的代码表明， nextTick 中的回调函数的执行时机优先在microTask 执行的时候执行， 否则， 在 宏任务的时候执行代码。flushCallbacks 函数用来执行 callbacks 中存放的函数列表：123456789function flushCallbacks () &#123; // 在执行前， 将 pending 置为 false pending = false const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) &#123; copies[i]() &#125;&#125;]]></content>
      <categories>
        <category>vue 源码阅读</category>
      </categories>
      <tags>
        <tag>vue 源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式：单例模式]]></title>
    <url>%2F2019%2F04%2F17%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }单例模式（The Singleton Pattern） 单例模式的特征是限制创建的类的实例为一个单独的对象， 比较典型的例子是： 如果实例不存在， 那么通过方法创建类的实例， 否则， 返回这个实例， 单例模式的实例仅有一个， 因此被称作单例模式；例如下面的代码：1234567891011121314151617let singleton = (function () &#123; let instance; function init() &#123; return &#123; publicName: name, &#125; &#125; return &#123; getInstance: function() &#123; if (instance === undefined) &#123; instance = init(); &#125; return instance; &#125; &#125;&#125;)(); 当我们引用上面的实例时， 我们始终引用到的是一个实例：1singleton.getInstance() === singleton.getInstance() // true 使用单例模式有什么好处呢？ 当当前页面需要一个公共的对象或者全局缓存的时候， 我们需要使用单例模式， 实现例如全局变量存储，线程池之类的功能， 使用单例可以让多个引用的实例状态保持一致， 因此这些多次引用只是引用的同一个实例 划分命名空间， 避免全局变量污染 在使用的时候实例化对象， 可以防止如果引入大的资源的时候出现较大的内存占用， 特别当创建实例的 cost 较大的时候 我们可以使用单例模式的情况： There must be exactly one instance of a class, and it must be accessible to clients from a well-known access point. When the sole instance should be extensible by subclassing, and clients should be able to use an extended instance without modifying their code. 对于一个类而言， 必须有只有一个确定的实例， 而且对于使用者来说， 这个实例可以通过一个很明确的地方获取到, 比如上面的 getInstance 方法 通过添加子类， 这个唯一的实例应该能够是可扩展的， 使用者应该在不改变原来代码的情况下是使用扩展的实例， 例如：1234567891011getInstance: function() &#123; if (instance === undefined) &#123; // 通过 if 的方式切换应用的类 if (useClassA) &#123; instance = new classA(); &#125; else &#123; instance = init(); &#125; &#125; return instance;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式：观察者模式]]></title>
    <url>%2F2019%2F04%2F14%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }观察者模式 使用观察者模式的一个常见的场景是： 一个观察对象需要通知一组相互独立的观察者发生变化， 并且这个观察对象和观察者之间是松耦合的关系。观察者模式是由观察者和观察对象组成的， 观察对象维护一组观察者，这组观察者依赖观察对象， 当观察对象的状态发生变化的时候， 会自动通知这组观察者发生动作。一个观察对象由属于自己的一组观察者， 观察对象的作用是注册， 删除观察者， 以及在合适的时机触发观察者。在其他书籍中对于观察者模式的一些定义如下： &quot;One or more observers are interested in the state of a subject and register their interest with the subject by attaching themselves. When something changes in our subject that the observer may be interested in, a notify message is sent which calls the update method in each observer. When the observer is no longer interested in the subject&#39;s state, they can simply detach themselves.&quot; 在观察者模式中， 存在下面四种组成部分： 观察对象：维护一组观察者， 可以新增 / 删除观察者， 通知观察者发生变化的逻辑 观察者： 提供一个当观察者对象状态发生变化的时候进行状态变化的一个接口 观察对象实例： 当相关状态发生变化的时候通知观察者, 观察者实例： 具体化一个数据改变的接口， 这个观察者实例是和观察对象相关联的 下面是一个观察者模式的模型：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 一组观察者， 扩展了一些删除， 添加观察者的一些方法class ObserverList &#123; constructor () &#123; this.observers = []; &#125; append(ob) &#123; this.observers.push(ob); &#125; delete(obIndex) &#123; this.observers.splice(obIndex, 1); &#125; get(obIndex) &#123; return this.observers[obIndex]; &#125; clear() &#123; this.observers = []; &#125; count() &#123; return this.observers.length; &#125; getList() &#123; return this.observers; &#125;&#125;// 观察者， 提供了一个 update 接口class Observer &#123; constructor (cb) &#123; this.cb = cb; &#125; update() &#123; this.cb(); &#125;&#125;// 观察者对象class Subject &#123; constructor() &#123; // 维护一组观察者 this.observerList = new ObserverList(); &#125; add(ob) &#123; this.observerList.append(ob); &#125; notify() &#123; for (let ob of this.observerList.getList()) &#123; ob.update(); &#125; &#125; remove(obIndex) &#123; this.observerList.delete(obIndex); &#125;&#125;const subject = new Subject();const observer = new Observer(action);const action = () =&gt; &#123; console.log('hello world');&#125;;// 注册观察者subject.add(observer);// 通知与之依赖的观察者动作subject.notify(); 上面的观察者模式， 其实可以使用下面的图进行说明： 在上面的代码中， 我们可以发现， 观察者和观察者对象之间是松耦合的， 观察者对象维护者一组观察者， 观察者对象需要做的是通知相关观察者进行更新。和发布/订阅模式的区别 上面的代码使用发布/订阅模式实现如下：123456789101112131415161718192021class EventMananger &#123; constructor() &#123; this.events = &#123;&#125;; &#125; publish(event) &#123; if (!this.events[event]) return false; let eventCount = this.events[event].length; while (eventCount--) &#123; this.events[event][eventCount](); &#125; &#125; subscribe(event, fn) &#123; (this.events[event] || (this.events[event] = [])).push(fn); &#125;&#125;const mananger = new EventMananger();mananger.subscribe('action', action);mananger.publish('action'); 两者区别： 对于观察者模式， 其订阅和发布消息是在同一个对象上面进行的（subject）， 对于发布订阅模式， 其角色有三种， 订阅者， 发布者 以及 中间存放方法的事件列表。发布者向事件列表中推送消息， 订阅者从事件列表中订阅消息， 并且当发布者推送消息的时候来触发订阅的事件。 发布订阅模式发布者和订阅者之间不存在耦合关系， 对于观察者模式， 观察者依赖观察对象， 这两者之间是松耦合关系 发布订阅模式应用于跨应用的情况下， 当多个应用之间进行通信的时候， 可以使用这种模式是实现通信， 对于 观察者模式， 主要应用于单个应用的情况。 一些缺点：使用观察者模式存在着一些缺点： 观察对象不知晓观察者的状态， 当某个观察者中包含有一些自增代码的时候， 调用 观察对象的 update 方法，可能会造成观察者状态的重复更新。 两种方式在 vue 中的应用： 在 vue 源码中的 $emit $on 方法中使用了发布/订阅模式：vm._events 作为事件通道， 存放函数列表。$on订阅者123456789101112131415161718Vue.prototype.$on = function (event, fn) &#123; var vm = this; if (Array.isArray(event)) &#123; for (var i = 0, l = event.length; i &lt; l; i++) &#123; vm.$on(event[i], fn); &#125; &#125; else &#123; // 将相关函数存入到 vm._events 中 // vm._events 作为事件列表方法事件 (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration // instead of a hash lookup if (hookRE.test(event)) &#123; vm._hasHookEvent = true; &#125; &#125; return vm&#125;; $emit发布者 1234567891011121314151617181920212223242526Vue.prototype.$emit = function (event) &#123; var vm = this; &#123; var lowerCaseEvent = event.toLowerCase(); if (lowerCaseEvent !== event &amp;&amp; vm._events[lowerCaseEvent]) &#123; tip( "Event \"" + lowerCaseEvent + "\" is emitted in component " + (formatComponentName(vm)) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + (hyphenate(event)) + "\" instead of \"" + event + "\"." ); &#125; &#125; var cbs = vm._events[event]; if (cbs) &#123; cbs = cbs.length &gt; 1 ? toArray(cbs) : cbs; var args = toArray(arguments, 1); var info = "event handler for \"" + event + "\""; // 触发相应的函数方法 for (var i = 0, l = cbs.length; i &lt; l; i++) &#123; invokeWithErrorHandling(cbs[i], vm, args, vm, info); &#125; &#125; return vm&#125;; 在 vue 的依赖收集过程中， 使用了观察者模式： 在 vue 源码中， 初始化data 的时候， vue 会通过一个 defineReactive 函数， 这个函数是实现当数据更新时相关依赖进行更新的关键， 这个函数里面对于数据的 getter 和 setter 函数内进行了一些处理， 当触发 getter 函数（读取）的时候会进行依赖收集， 当 触发 setter 函数（设置）的时候会通知相关依赖进行更新。具体代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859function defineReactive (obj, key, val, customSetter, shallow) &#123; // 这里的 new Dep() 是维护了一组观察者 // Dep 是观察者对象， 维护者一组观察者 var dep = new Dep(); var property = Object.getOwnPropertyDescriptor(obj, key); if (property &amp;&amp; property.configurable === false) &#123; return &#125; // cater for pre-defined getter/setters var getter = property &amp;&amp; property.get; var setter = property &amp;&amp; property.set; if ((!getter || setter) &amp;&amp; arguments.length === 2) &#123; val = obj[key]; &#125; var childOb = !shallow &amp;&amp; observe(val); // 使用 defineProperty 对于对象进行拦截处理 Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; var value = getter ? getter.call(obj) : val; // 收集依赖 // traget 全局变量 if (Dep.target) &#123; dep.depend(); if (childOb) &#123; childOb.dep.depend(); if (Array.isArray(value)) &#123; dependArray(value); &#125; &#125; &#125; return value &#125;, set: function reactiveSetter (newVal) &#123; var value = getter ? getter.call(obj) : val; /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; /* eslint-enable no-self-compare */ if (customSetter) &#123; customSetter(); &#125; // #7981: for accessor properties without setter if (getter &amp;&amp; !setter) &#123; return &#125; if (setter) &#123; setter.call(obj, newVal); &#125; else &#123; val = newVal; &#125; childOb = !shallow &amp;&amp; observe(newVal); // 通知依赖发生变化 dep.notify(); &#125; &#125;);&#125; 这里 dep 是 用来维护者一组的观察者， 通过 dep.depend 方法收集到依赖， 然后通过 dep.notify() 来通知变动。具体到 Dep 的类：1234567891011121314151617181920212223242526272829303132333435363738394041export default class Dep &#123; static target: ?Watcher; id: number; subs: Array&lt;Watcher&gt;; constructor () &#123; this.id = uid++ // 维护一组观察者 subs 内部存放了 Watcher 类的实例 this.subs = [] &#125; // 新增观察者 addSub (sub: Watcher) &#123; this.subs.push(sub) &#125; // 移除观察者 removeSub (sub: Watcher) &#123; remove(this.subs, sub) &#125; // Dep.target 是一个 watcher 实例, 这里调用的 addDep 方法是调用在 watcher 上面的方法 // 在 watcher 方法上面的 addDep 方法也是调用了 addSub 方法 depend () &#123; if (Dep.target) &#123; Dep.target.addDep(this) &#125; &#125; // 用来通知这组观察者进行更新， 调用观察者中的 update 方法来更新 notify () &#123; // stabilize the subscriber list first const subs = this.subs.slice() if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) &#123; // subs aren't sorted in scheduler if not running async // we need to sort them now to make sure they fire in correct // order subs.sort((a, b) =&gt; a.id - b.id) &#125; // 对于改观察者对象下面的每一个观察者都进行数据的更新处理 for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125;&#125; 注： depend 方法中的 addDep 方法引用的是 Watcher 实例上面的方法：12345678910111213/** * Add a dependency to this directive. */addDep (dep: Dep) &#123; const id = dep.id if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) &#123; dep.addSub(this) &#125; &#125;&#125; 这些观察者是 Watcher 的实例， Watcher 位于源码中的 Watcher.js 文件中， 一些更新观察者信息的方法作为实例方法。在 Watcher 的类中， 上面定义了update 的方法：12345678910111213141516171819202122232425262728293031323334353637383940414243update () &#123; /* istanbul ignore else */ if (this.lazy) &#123; this.dirty = true &#125; else if (this.sync) &#123; // 执行run 函数 this.run() &#125; else &#123; queueWatcher(this) &#125;&#125;/** * Scheduler job interface. * Will be called by the scheduler. */run () &#123; if (this.active) &#123; const value = this.get() if ( value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even // when the value is the same, because the value may // have mutated. isObject(value) || this.deep ) &#123; // set new value const oldValue = this.value this.value = value if (this.user) &#123; try &#123; // 执行 this.cb 回调 this.cb.call(this.vm, value, oldValue) &#125; catch (e) &#123; handleError(e, this.vm, `callback for watcher "$&#123;this.expression&#125;"`) &#125; &#125; else &#123; this.cb.call(this.vm, value, oldValue) &#125; &#125; &#125;&#125; tips 可以在数组中查找到对象， 或者说， js 的数组中存放的是对象的引用：1234let a = &#123;&#125;;let arr = [&#123;&#125;, a];arr.indexOf(a);// 1]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue源码：utils 函数]]></title>
    <url>%2F2019%2F04%2F05%2Fvue%20%E6%BA%90%E7%A0%81%EF%BC%9Autils%20%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }utils 函数 在 vue 的 utils.js 文件中提供了一些使用的公共方法， 下面是在阅读这部分代码的时候的一些笔记：判断值的类型 1234// 使用 Object.toString 得到的是 [object type]// 可以获取到 type 值来获取到要进行判断的类型const _toString = Object.prototype.toStringfunction toRowType = value =&gt; _toString.call(value).slice(8, -1) 如下： 判断值为纯对象：1function isPlainObject = obj =&gt; toRowType(obj) === '[object Object]'; 判断为正则1function isRegExp = val =&gt; toRowType(val) === '[object RegExp]'; 判断一个值为 promise 123456function isPromise(val) &#123; return val !== undefind &amp;&amp; val !== null &amp;&amp; typeof val.then === 'function' &amp;&amp; typeof val.catch === 'function'&#125; 也可以使用 instanceof 方法进行判断：123function isPromise(val) &#123; return val instanceof Promise;&#125; 上面的那种方法更多的是为了一些浏览器不能兼容 promise 的原因通过函数的方法判断字符串中是否含有字符串 123456789function makeMap(str) &#123; // 使用 Object.create 用来创建一个 “干净”的对象 const map = Object.create(null); const list = str.split(','); for (let i = 0; i &lt; list.length; i ++) &#123; map[list[i]] = true &#125; return val =&gt; map[val];&#125; 在 vue 中，使用上面的方法用来判断一串使用逗号分割的字符串中是否包含有某个字符串：目前， 使用 es6 的 includes 可以实现这种效果。上面的 Object.create 方法， 可以创建自继承自传入值的对象， 例如上面的 Object.create(null) 代码就是创建了一个空对象， 与 {} 对象不同的是， 通过 create 创建的空对象， 没有继承 Object.prototype 上面的方法。例如： 在上面中 使用 create 创建的空对象， 原型上面没有任何的属性使用 Object.create 创建空对象的好处如下： 创建的对象比较“干净”, 我们可以实现自定义的比如 toString 方法 使用 for in 的时候无需使用 hasOwnProperty 方法判断属性是不是继承的来的属性， 并且必用遍历继承的属性而提高了性能。 校验相等， 对于对象， 判断是否 “看起来” 一样： 在代码中使用 looseEqual 这个函数， 如下：12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Check if two values are loosely equal - that is, * if they are plain objects, do they have the same shape?*/export function looseEqual (a, b)&#123; if (a === b) return true const isObjectA = isObject(a) const isObjectB = isObject(b) // 当都为对象的时候 if (isObjectA &amp;&amp; isObjectB) &#123; try &#123; const isArrayA = Array.isArray(a) const isArrayB = Array.isArray(b) // 当都为数组的时候 // 这里判断数组相等， 可以先判断数组长度是否相等 if (isArrayA &amp;&amp; isArrayB) &#123; return a.length === b.length &amp;&amp; a.every((e, i) =&gt; &#123; return looseEqual(e, b[i]) &#125;) // 对于时间判断的时候， 通过 getTime() 来判断 &#125; else if (a instanceof Date &amp;&amp; b instanceof Date) &#123; return a.getTime() === b.getTime() &#125; else if (!isArrayA &amp;&amp; !isArrayB) &#123; const keysA = Object.keys(a) const keysB = Object.keys(b) // 判断都为对象的时候 return keysA.length === keysB.length &amp;&amp; keysA.every(key =&gt; &#123; return looseEqual(a[key], b[key]) &#125;) &#125; else &#123; /* istanbul ignore next */ return false &#125; &#125; catch (e) &#123; /* istanbul ignore next */ return false &#125; &#125; else if (!isObjectA &amp;&amp; !isObjectB) &#123; return String(a) === String(b) &#125; else &#123; return false &#125;&#125; once 函数方法 12345678910// 确保 fn 只会调用一次function once(fn) &#123; let called = false; return function () &#123; if (!called) &#123; called = true; fn.apply(this, arguments); &#125; &#125;&#125; 正则相关 代码中， 使用正则中的 replace 方法实现了对于变量命名由驼峰式转变为为连字符式：1234function hyhenate(str) &#123; return str.replace(/\B([A-Z])/g, '-$1').toLowerCase()&#125;hyhenate('myComponent'); // my-component 相关 replace 的一些特性， 在博客文章 正则表达式（二）：基础方法 中已经说明， 需要注意的一些地方： 正则表达式中需要添加标识符 g 用来进行全局匹配捕获 正则中使用括号包裹的表示一个捕获组进行捕获到的数据 使用 \B 表示匹配单词内部 使用正则将连字符单词转换为驼峰式的单词：1234function camelize(str) &#123; return str.replace(/-(\w)/g, (_, c) =&gt; c ? c.toUpperCase() : '')&#125;camelize('my-component'); // myComponent 注意： 关于 replace 的第二个参数, 可以阅读 正则表达式（二）：基础方法 中关于replace的相关知识。]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>vue 源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现machine函数]]></title>
    <url>%2F2019%2F04%2F01%2F%E5%AE%9E%E7%8E%B0machine%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }机器可以按照一定的顺序对于零件进行加工， 在程序中， 我们也可以实现一个机器函数， 这个函数可以按照我们调用函数的顺序进行执行。 实现一个类似于 machine 的函数：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * * @param &#123;String&#125; machineName 机器名称 * @description 机器函数 */function machine(machineName) &#123; let fnList = []; fnList.push(() =&gt; &#123; console.log(`start $&#123;machineName&#125;`); &#125;); const doFnMap = &#123; do(doName) &#123; console.log(`do $&#123;doName&#125;`); &#125;, // 执行机器函数 execute() &#123; const handleFn = () =&gt; &#123; if (fnList.length &gt; 0) &#123; const fnNow = fnList.shift(); const fnVal = fnNow(); if (fnVal instanceof Promise) &#123; fnVal.then(() =&gt; &#123; handleFn(); &#125;); &#125; else &#123; handleFn(); &#125; &#125; else &#123; console.log(`end $&#123;machineName&#125;`); &#125; &#125;; handleFn(); &#125;, // 执行机器前等待时间 waitFirst(time) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(`wait first $&#123;time&#125;s`); resolve(); &#125;, time * 1000); &#125;); &#125;, waitEnd(time) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(`wait end $&#123;time&#125;s`); resolve(); &#125;, time * 1000); &#125;); &#125;, // 执行过程中等待时间 wait: (time) =&gt; &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(`wait $&#123;time&#125;s`); resolve(); &#125;, time * 1000) &#125;) &#125; &#125;; let proxy; // proxy 代理拦截 // 获取到需要执行的函数名之后，将其放入执行函数队列数组 proxy = new Proxy(doFnMap, &#123; get: function (target, property) &#123; return (...args) =&gt; &#123; if (property !== 'execute') &#123; if (property === 'waitFirst') &#123; fnList.unshift(() =&gt; &#123; return target.waitFirst(args); &#125;); &#125; else &#123; fnList.push(() =&gt; &#123; return target[property](args); &#125;); &#125; return proxy; &#125; else &#123; return doFnMap.execute(); &#125; &#125;; &#125; &#125;); return proxy;&#125; 执行效果如下：1machine('machine').waitFirst(3).do('eat').do('run').wait(5).do('sleep').execute() 执行结果： 上面代码的主要思路是， 通过使用 proxy 获取到每一次的动作， 将每一次的函数存放到一个函数list 数组中， 当执行 execute 的时候， 依次执行数组中的函数， 在执行过程中进行判断， 当判断为 wait或者 waitFirst 函数的时候， 等待 wait 或者 waitFirst 函数执行完毕之后执行：12345678// 对于 wait 或者 waitFirst 函数执行完毕之后返回了一个 promiseif (fnVal instanceof Promise) &#123; fnVal.then(() =&gt; &#123; handleFn(); &#125;);&#125; else &#123; handleFn();&#125; 在执行过程中， 当调用执行方法的时候， 在代码中通过使用 proxy 进行拦截处理：1234567891011121314151617181920proxy = new Proxy(doFnMap, &#123; get: function (target, property) &#123; return (...args) =&gt; &#123; if (property !== 'execute') &#123; if (property === 'waitFirst') &#123; fnList.unshift(() =&gt; &#123; return target.waitFirst(args); &#125;); &#125; else &#123; fnList.push(() =&gt; &#123; return target[property](args); &#125;); &#125; return proxy; &#125; else &#123; return doFnMap.execute(); &#125; &#125;; &#125; &#125;); 使用 Proxy 方法用于对一个对象的属性访问和获取进行拦截， 在上面的代码中， 使用 proxy 中的 get 方法，设置了当调用 doFnMap 中的方法的时候， 调用get 方法，在 get 方法中， 可以用来将将要执行的函数方法推入到函数数组列表中以及调整函数的执行顺序。]]></content>
      <categories>
        <category>代码集</category>
      </categories>
      <tags>
        <tag>machine 函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式（五）：括号与正则符号优先级]]></title>
    <url>%2F2019%2F02%2F05%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }括号 作用 提供分组和分支结构 分组和分支结构是括号中的基础使用， 作用是提供一个子表达式分组 使用括号进行分组， 用来表明括号内的所有字符是一个组合， 从而对于括号内的字符组合进行范围限定， 可以对于整个括号添加量词， 表明匹配括号内的元素进行整体量词限定：123let str = 'abababc ab';let regex = /(ab)+/g;str.match(regex); // Array(2) ["ababab", "ab"] 分支结构 我们在正则中使用 | 表明匹配 | 符号左边或者右边的正则， 使用括号包裹| 用来限定 | 的作用范围， 例如：12345let str = 'ab ac';let regex = /a(b|c)/g;// 如果不加上括号 regex = /ab | c/g 那么匹配的是 ab 或者 c// 加上括号表明分支结构只有 b 和 cstr.match(regex); // ['ab', 'ac'] 在使用 match 的时候，添加全局标识符 g 加不加是不同的：上面的代码如果不用添加 g 标识符， 那么返回结果如下：不会进行全局匹配， 只会匹配到 ab 就会返回。12345&gt; let str = 'ab ac';&gt; let regex = /a(b|c)/;&gt; str.match(regex);&gt; // ['ab', 'b']&gt; 分组引用 在正则中使用括号进行包裹正则表达式时， 正则引擎会对于正则表达式进行分组，正则引擎会在匹配过程中， 给每一个分组都开辟一个内存空间， 用来存储每一个分组匹配到的数据。例如， 我们想要对于日期进行匹配：123let date = &apos;2019-02-05&apos;;let regex = /(\d&#123;4&#125;-(\d&#123;2&#125;)-(\d&#123;2&#125;))/;date.match(regex); // [&quot;2018-02-02&quot;, &quot;2018&quot;, &quot;02&quot;, &quot;02&quot;] 这里使用 match 进行匹配的正则表达式中没有包含有标识符 g， 因此使用 match 与使用 exec 的返回结果是一样的。 符号的优先级 在正则表达式中， 使用操作符进行操作的时候， 需要规定操作符的优先级， 用来表示操作符是谁先操作， 谁后操作， 在正则表达式中， 各种操作符的优先级如下：从上到下： 描述符 操作符 转义符 \ 括号与方括号 (...) (?:...) (?=...) (?!...) [...] 量词限定符 {m} {m, n} {m, } ? * + 位置和序列 ^ $ \元字符 一般字符 管道符 ` 上面的操作符从上到下， 优先级从高到低；示例： /ab?(c|de*)+|fg/上面的操作过程如下：因为在正则中存在管道符 | 用于分割为 ab?(c|de*)+ 和 fg 两个部分， 先执行这两个部分：执行 ab?(c|de*)+: 在这个过程中，先执行括号内的正则， 然后执行字符 a, b ? 以及 +, 在括号内c|de* 的执行顺序中， 先执行 c, de*, 其中 * 是和 e 在一起的， 因此 * 限定的量词是 e;如下： 匹配一个字符串， 字符串中的字符为 a , b, c 中的一个， 并且， 字符串的长度为 3 的倍数；1let regexp = /([abc]&#123;3&#125;)+/; 这里是将量词 3 使用括号进行包裹如下： 匹配一个 ipv4 的地址：IP4 的地址的结构为这种形式：3位数.3位数.3位数.3位数其中 3 位数的数字范围为 0 - 255， 因此， 对于一位数而言， 可以这样写：1/0&#123;0,2&#125;\d+/ // 匹配 000 - 009 对于两位数而言， 进行匹配：1/0?\d&#123;2&#125;/ 对于三位数而言， 需要进行匹配：1/1\d&#123;2&#125;/ // 匹配 100 - 199 1/2[0-4]\d/ // 匹配 200 - 249 1/25[0-5]/ // 匹配 250 -255 上面的这几种匹配结构为或的关系， 因此， 上面几种结构使用管道符 | 进行连接：1(0&#123;0,2&#125;\d|0?\d&#123;2&#125;|1\d&#123;2&#125;|2[0-4]\d|25[0-5]) 匹配. 号：1/^((0&#123;0,2&#125;\d|0?\d&#123;2&#125;|1\d&#123;2&#125;|2[0-4]\d|25[0-5])\.)(0&#123;0,2&#125;\d|0?\d&#123;2&#125;|1\d&#123;2&#125;|2[0-4]\d|25[0-5])$/ 上面的也可以第二部分可以使用 \2 进行代替：1/^((0&#123;0,2&#125;\d|0?\d&#123;2&#125;|1\d&#123;2&#125;|2[0-4]\d|25[0-5])\.)\2$/]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式（四）：匹配]]></title>
    <url>%2F2019%2F02%2F04%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6%EF%BC%8C-%E5%8C%B9%E9%85%8D%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }正则表达式中的位置匹配：正则表达式是匹配模式， 要么匹配字符， 要么匹配位置对于位置匹配， 这里的位置是字符之间的间隙， 进行位置匹配时， 使用正则表达式中存在下面几个‘锚’：^ $ \b \B (?=p) (?!p) 字符 匹配含义 ^ 匹配字符串的开头 $ 匹配字符串的结尾 \b 单词边界， 具体就是 \w 与 \W 之间的位置, 以及字符串的开始位置和结尾位置 \B 是 /b 之外的位置 (?=P) p 是一个模式， 这个正则表达式匹配的是P 之前的位置， 或者当前位置之后的字符要匹配正则表达式 P (?!P) 这个与 (?=P) 意思相反， 是除了 (?=P) 之外的位置 ^ 以及 $ 用于匹配字符串开头或者字符串结尾的位置：如下例子：将字符的开头和结尾添加特定的字符：1234let str = &apos;hello&apos;;let regex = /^|$/g;let res = str.replace(regex, &apos;*&apos;);console.log(res); // &apos;*hello*&apos; 例如下面， 使用 replace 代替 trim 方法：1234let str = ' hell o ';let regex = /^\s+|\s+$/g;let res = str.replace(regex, '');// hell o \b 以及 \B 使用 \b 的作用是匹配单词边界之间的位置， 具体而言是 \w 以及 \W 之间的位置：\w: 匹配单词字符， 字符包括字母， 汉字， 下划线以及数字示例如下：1234let str = 'hel lo';let regex = /\b/g;let res = str.replace(regex, '#');// #hel# #lo# 使用 \B 则和 \b 相反， 匹配的位置是单词字符内的位置：123regex = /\B/g;res = str.replace(regex, '#');// h#e#l l#o; (?=P) 以及 (?!P) 使用 (?=P) 用来匹配特定字符前的位置, P 是一个正则表达式；如下： 给单词中的 l 字符前面添加字符 #:1234regex = /(?=l)/g;str = 'hello';let res = str.replace(regex, '#');// he#l#lo 给每一个单词字符前面添加一个字符 *1234regex = /(?=\w)/g;str = &apos;hello&apos;;let res = str.replace(regex, &apos;*&apos;);// *h*e*l *l*o 使用 (?!P) 用来匹配除了匹配到的正则表达式 P 之前位置之外的其他位置：例如上面的例子， 我们使用 (?!P) 来代替 (?=P):1234567regex = /(?!l)/;str = 'hello';let res = str.replace(regex, '*');// *h*ell*o*// 当我们仅仅想匹配到单词内部的时候regex = /(?!l)(?!^)(?!$)/;// h*ell*o 这里的 (?!^)(?!$) 是匹配除了单词开头和结尾的位置， 这里可以使用 /B 来进行代替; regex = /(?!l)(\B)/ 如下， 给一个数字添加千位分隔符 &#39;,&#39; 123let str = "12345678";let regex = /(?!^)(?=(\d&#123;3&#125;)+$))/g;let res = str.replace(regex, ','); // 12,345,678 分析：给一个数字添加一个千位字符的时候， 我们需要在字符尾部向前查找三位字符， 在三位字符前面的位置处添加分隔符 &#39; ,&#39;; 1(\d&#123;3&#125;)+$ // 匹配结尾处向前 3 个或者多个 3 字符倍数的字符 1(?=(\d&#123;3&#125;)+$) // 匹配 3 个字符或者 3 个字符倍数的字符前面的位置 1(?!^) // 匹配非开头的位置 如下， 给钱数添加人民币符号 ¥1234let number = '1234';let regex = /(?=^)/;let res = number.replace(regex, '¥ ');// ¥ 1234 如下： 判断一段字符中必须包含有数字：12345let str = 'str123';let regex = /(?=.*[0-9])^/g;// 这里的 ^ 表示开头， 这个正则表达式表示开头的位置， 也就是开头之后的字符需要匹配 .*[0-9]// .*[0-9] 表示任意字符长度后面都需要一个数字， 也就是需要匹配到的字符串必须包含有数字let res = regex.test(str); // true 如下： 判断字符中不能全部为数字, 可以使用 ?!P 进行判断判断字符中不能全部为数字的反义为全部为数字：那么判断全部为数字的正则表达式为：12// 判断6位字符串中全部为数字let regex = /(?=[0-9]&#123;6&#125;)/ 因为 ?! 和 ?= 互为反义， 因此， 判断不能全部为数字的正则如下：12345let regex = /(?![0-9]&#123;6&#125;)/let str = '123456';regex.test(str); // falsestr = 'a23456';regex.test(str); // true]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式（三）：一些例子]]></title>
    <url>%2F2019%2F01%2F27%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%B8%80%E4%BA%9B%E4%BE%8B%E5%AD%90%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }下面是使用正则表达式的一些示例： 实现密码输入以英文字母开头， 密码长度为 8 到 16 位， 密码限为字符， 数字和下划线。1let pattern = /^[a-zA-a]\w&#123;7, 15&#125;/; 验证是否含有^%&amp;&#39;&#39;,;=?$&quot;等字符12let pattern = /[\^%&amp;$&quot;.&apos;=?]/;// &quot;\&quot; 用于转义 `^` 整数正则 1let pattern = /^-?\d+$/; 匹配数字， 小数点后最大两位小数1let pattern = /^\d+/.?\d&#123;0, 2&#125;$/; 手机号码的匹配1let pattern = /^1[34578]\d&#123;9&#125;$/; 匹配16进制颜色值1234// 比如匹配如下的颜色// #ffbbad #Fc01DF #FFF #ffElet pattern = /[0-9a-fA-F]&#123;6&#125; | [0-9a-fA-F]&#123;3&#125;/;// 使用 | 用来表示正则表达式中分支结构 匹配 24 小时时间123// 例如匹配 23:59 和 02:12// 使用 () 对于正则表达式进行分组使用， 在 （） 内使用 | 只会作用到括号内的正则内容let pattern = /^([01][0-9] | [2][0-4]):[0-5][0-9]/; 匹配日期例如： 我们想要匹配 “YYYY-mm-dd” 的日期格式：1let pattern = /^[0-9]&#123;4&#125;-([0][0-9] | [1][0-2])-(0[1-9] | [12][0-9] | [3][01])/; 匹配 innerHTML 中的类名 如果我们想要进行匹配这样一个innterHtml 中的类名： 1234567let innerHtml = '&lt;div class="content"&gt;&lt;div class="body"&gt;&lt;/div&gt;&lt;/div&gt;';pattern = /class=".*?"/i;test = innerHtml.match(pattern)[0];// class="content"// 使用 ？进行的是贪婪匹配， 会 匹配尽量少的字符 对于字符串中的 trim 方法：使用正则表达式清除字符串两边的空格：123let str = ' hello ';let regex = /^\s+|\s+$/g;let res = str.replace(regex, ''); // hello 验证 URL 为绝对路径12345678/*A URL is considered absolute if it begins with "&lt;scheme&gt;://" or "//" (protocol-relative URL).RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed by any combination of letters, digits, plus, period, or hyphen.*/// ? 非贪婪匹配 表明前面匹配的 () 内字符的数量可能为 0 次 匹配 // 的情况function isAbsoluteURL(url) &#123; return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式：基础方法]]></title>
    <url>%2F2019%2F01%2F20%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }下面是一些正则表达式的一些常用方法：正则表达式中的属性和方法 创建了正则表达式之后， 返回的是一个正则表达式的实例，返回的实例中包含有正则的一些属性方法。我们可以在 控制台中打印正则实例， 可以看到其继承的所有的属性和方法如下：例如：1234let pattern = /.at/g;let str = &apos;bat, cat&apos;;let matches = pattern.exec(str);console.log(&apos;lastIndex&apos;, pattern.lastIndex); // 3 一些属性 属性 含义 示例 lastIndex 下一次匹配在字符串中的起始位置, 当前匹配到字符串的下一个字符的位置 ， 注意， 当前缺少修饰符 g 的时候， 这个值始终是 0 上面的例子中， 匹配完了 bat 之后， 后面将要进行匹配的是 , 位置为 3 flags(es6) 获取当前正则的修饰符 g global 布尔值， 表示是否设置了 g 标志 pattern.global: true ignoreCase 布尔值， 表示是否设置了 i 标志 multiline 表示是否设置了 m sticky 表示是否这种了 y 标志 dotall es2018 表示是否含有 s 修饰符 source 表示当前的匹配字符串 &quot;.at&quot; Tips: 使用 lastIndex 是可以改变的， 使用 lastIndex 可以决定需要进行开始匹配的位置 1234567let pattern = new RegExp('.at', 'g');let str = "cat, bat";pattern.lastIndex = 4;let matches = pattern.exec(str);// matches// [ 'bat', index: 5, input: 'cat, bat', groups: undefined ] 一些方法 RegExp.prototype.test 使用 test 方法用于判断在一个字符串中是含有能够匹配的到字符：示例：123let pattern = /test/g;let str = 'test string';pattern.test(str); // true 123let pattern = /[cb]at/g;let str = "cat, bat";pattern.test(str); // true RegExp.prototype.exec 使用 exec 方法用于获取到匹配到的数组：1234567let pattern = /.at/;let str = &quot;cat, bat&quot;;let matches = pattern.exec(str);// [ &apos;cat&apos;, index: 0, input: &apos;cat, bat&apos;, groups: undefined ]// 当前匹配到 字符串是 cat， 匹配的字符串在原字符串中的开始位置为 0， input： 当前被匹配的字符串为 // &apos;cat, bat&apos; 如果有匹配到值的话， 返回一个数组， 如果没有匹配到值， 返回 null;使用 exec 方法返回的是一个数组，这个数组包含被匹配到的字符串，（在存在捕获组的情况下， 获取到的被匹配的字符串不止一个） 比如上面的代码中， 匹配到了 cat 但是这个数组实例上面还定义了一些属性, 例如上面的数组中包含了 index, input 以及 groups ， 这些属性表示的是被匹配到的字符串的相关信息， 这些属性的含义如下： index: index 表明匹配数组中第一个值在字符串中的位置。 input：input 表明当前匹配的字符串 groups: groups 是 es2018 中提出的一个新的方法 注意： 当正则表达式中包含有全局匹配 g 的时候，每次调用 exec 都会在上一次匹配的位置之后继续进行匹配, 当没有设置全局匹配 g 的时候， 多次调用 exec 只会调用第一次匹配到的信息。 1234567891011let pattern = new RegExp('.at', 'g');let str = "cat, bat, dat";let matches = pattern.exec(str);while(matches) &#123; console.log(pattern.lastIndex, matches[0]); matches = pattern.exec(str);&#125;// 3 'cat'// 8 'bat'// 13 'dat' 应用正则表达式的一些方法： String.prototype.match str.match(regexp)接收一个正则表达式， 如果有匹配到的字符串， 将会返回一个数组， 数组的第一项是进行匹配的字符串， 后面几项是获取到的捕获组的结果， 如果没有匹配到的字符串， 那么将会返回 null。 注意， 在使用 match 方法的时候加不加标识符 g 是有区别的， 当正则中不含有 g 标识符的时候， 返回的结果是标准的匹配格式： 数组的第一个元素是整体匹配的内容，其他元素是分组捕获的内容， 如果加上了 g 符号， 那么返回的是包含有所有匹配的字符串内容：例如下面这个例子：123456789&gt; var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/g;&gt; var string = &quot;2017-06-12&quot;;&gt; console.log( string.match(regex) );&gt; // [&quot;2017-06-12&quot;] 没有获得到捕获组 括号内的匹配项&gt; // 当正则表达式中不含有 g 标识符的时候&gt; regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;&gt; // [&quot;2017-06-12&quot;, &quot;2017&quot;, &quot;06&quot;, &quot;12&quot;]`String.prototype.search`&gt; // 返回内容为整体匹配以及分组匹配的内容. l;` &gt; String.prototype.search str.search(regexp)接收一个正则表达式， 返回在字符串中第一次被匹配到的位置， 如果没有匹配到， 返回 -112let str = &apos;hello world&apos;;str.search(/world/); // 6 使用 indexOf 方法也可以用来查找到字符串中的某一个字符， 相比 indexOf 方法， 个人认为 search 方法的优点在于可以借助于正则表达式中的一些功能， 比如， 我们可以不区分大小写的进行查找字符串中的某一个单词：12let str = "search Word";str.search(/word/i); // 6 注意：当我们使用 search 方法的时候， 当向 search中传入字符串的参数的时候， 字符串参数会被转换为正则表达式如下： 123let str = "2019.02.05";str.search('.'); // 0// 因为上面的方法中转换为了 str.search(/./); 相当于匹配任意的字符， 从而匹配到第一个字符， 匹配到的位置为 0 String.prototype.replace str.replace(regexp, replaceStr)使用 replace 方法可以实现对于匹配到的字符串进行替换, 匹配过程中不会改变原来的进行匹配的字符串，返回值为进行匹配完成的字符串。注意： 使用 replace 方法的时候 replaceStr 中使用 $1, $2 以及 $3 可以表示 RegExp.$1, RegExp.$2RegExp.$3 如下， 转换日期的格式问题：123let str = &apos;2018-02-02&apos;;let regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;str.replace(regex, &apos;$3/$2/$1&apos;); // 02/02/2018 如下， 隐藏手机号码中间四位的数字：1234let str = &apos;15656568620&apos;;let regex = /(\d&#123;3&#125;)(\d&#123;4&#125;)(\d&#123;4&#125;)/;str.replace(regex, &apos;$1****$3&apos;);// 156****8620 使用 replace 可以实现更为强大的功能， 因为第二个参数的 replaceStr 可以有多个具有特殊含义的字符： 属性 描述符 $1 $2 ... $99 匹配地 $1 , $2 ... $99 分组捕获的文本 $&amp; 匹配到的子串文本 $` 匹配到的子串的左边文本 $&#39; 匹配到的子串的 $$ 表示美元符号 其他符号 符号本身 如下， 我们想要将一段金钱文字都添加上一个 $ 符号：1234let str = '100, 200, 300';let regex = /(\d+)/g;str.replace(regex, '$$ $&amp;');// $100, $200, $300 使用 replace 我们不仅仅可以实现对于一串字符串中某个字符的替换， 更强大的作用在于， 使用 replace 可以实现对于匹配到的字符串进行统一处理， 这样， 我们就无需手动查找字符串中的某个值，然后逐个替换了。 replace 第二个参数除了接受一个字符串之外， 还可以接受一个函数如下：123456789function replaceStr (matchChar, captureChar, charIndex, matchStr) &#123; console.table([&#123; matchChar, captureChar, charIndex, matchStr &#125;]); return captureChar ? captureChar.toUpperCase() : '';&#125;// 将连字符相连的单词转换为驼峰式的写法function camelize(str) &#123; return str.replace(/-(\w)/g, replaceStr)&#125;camelize("my-component"); 最终打印结果如下： 上面各个参数如下： matchChar(第一个参数) captureChar(第二个参数) charIndex(第三个参数) matchStr(第四个参数) 正则匹配匹配到的字符串 捕获组捕获到的字符 matchChar 在整个字符串中的起始位置 被匹配的字符串 注意： 当匹配正则中没有 () 也就是没有捕获组的时候， 参数总体向前挪动， 最后一个参数为 undefined例如上面的代码中：修改为如下：123456789function replaceStr (matchChar, captureChar, charIndex, matchStr) &#123; console.table([&#123; matchChar, captureChar, charIndex, matchStr &#125;]); // return captureChar ? captureChar.toUpperCase() : '';&#125;function camelize(str) &#123; return str.replace(/-\w/g, replaceStr)&#125;camelize("my-component"); 最终打印结果如下： 上面可以看到， 当正则中没有捕获组了之后， 捕获组参数 captureChar 消失掉了， charIndex 以及 matchStr 参数向前挪动了一位， 从而导致最后一位为 undefined其他 使用 $1 $2 .. 可以获取到被匹配到的捕获组中的数据， $1 获取到第一个捕获组数据， $2 获取到第二个捕获组数据， 依次类推例如：123456str = '2018-02-02';regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;regex.test(str);RegExp.$1 // 2018RegExp.$2 // 02RegExp.$3 // 02 可以在正则中使用 \1 或者 \2 之类的表示引用分组 $1 $2 ....， 例如： 我们想要匹配如下的日期格式：2019-02-052019.02.052019/02/05我们注意到， 对于 - 或 . 或 / 是重复使用的， 因此， 我们可以在正则表达式中引用这个分组：123let regex = /\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;(-|\/|\.)\d&#123;2&#125;/;let str = &apos;2019-02-05&apos;;regex.test(str); // true 但是上面的正则也可以匹配到 2019-02.05 这样的格式；当匹配的字符串中出现重复匹配的内容， 并且匹配规则相同的时候， 我们可以使用分组引用：1let regex = /\d&#123;4&#125;(-|/\|\.)\d&#123;2&#125;\1\d&#123;2&#125;/; 如下： 匹配 html 中的匹配标签：12345678let html = "&lt;p&gt;我是一段文字&lt;/p&gt;";let regex = /&lt;([^&gt;]+)&gt;[\d\D]*&lt;\/\1&gt;/;regex.test(html); // true// 注： 这里的 [\d\D] 表示匹配 \d 或 \D, 也就是匹配任意的字符// 匹配含有 class 的元素属性html = "&lt;p class="content"&gt;我是一段文字&lt;/p&gt;";regex = /&lt;([^&gt;]+).*&gt;[\d\D]*&lt;\/\1&gt;/;regex.test(html) // true]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈 window.location 对象]]></title>
    <url>%2F2019%2F01%2F20%2F%E8%B0%88%E8%B0%88-window-location-%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }谈谈 window.location 对象 window.location 是一个只读属性， 用于获取到页面文档的位置信息， 如果我们在浏览器控制台中打印， 那么打印出来的结果如下：以我们在 页面 https://developer.mozilla.org/zh-CN/docs/Web/API/Window/location 下获取 window.location 为例：1234567891011121314151617ancestorOrigins: DOMStringList &#123;length: 0&#125;assign: ƒ ()hash: &quot;&quot;host: &quot;developer.mozilla.org&quot;hostname: &quot;developer.mozilla.org&quot;href: &quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Window/location&quot;origin: &quot;https://developer.mozilla.org&quot;pathname: &quot;/zh-CN/docs/Web/API/Window/location&quot;port: &quot;&quot;protocol: &quot;https:&quot;reload: ƒ reload()replace: ƒ ()search: &quot;&quot;toString: ƒ toString()valueOf: ƒ valueOf()Symbol(Symbol.toPrimitive): undefined__proto__: Location 上面的这些值表明了在 window.location 中的一些属性和方法： 属性名 含义 示例 href 当前页面的url https://example.com:8080/page/childpage?pageId=1#identify host host 包含端口名 example.com:8080 hostname 不包含端口名 example.com pathname 路径名 /page/childpage origin 源网址 https://example.com:8080 是 网址在第一个 &#39;/&#39; 之前的部分 port 端口号 8080 protocol 协议名 https search 截取到的链接的 ？ 之后的字符串, 不包含标识符 # 之后的内容 ?pageId=1 hash 标识符 #identify 除了上面几种属性之外， 还包括一些方法：123window.location.reload() // 对于当前页面进行重载操作window.location.replace(rul) // 对于当前页面进行替换window.location.assign(url) // 会触发页面重载并且跳转到指定的 url tips： 使用 replace 和 assign 不同的区别在于： 使用 replace 替换的当前页面不会保存到页面浏览会话历史中，因此当跳转完成之后， 点击浏览器的后退按钮， 是不会进入到使用 replace 的那个页面资源的。而使用 assign 会回到之前跳转的页面。]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>window.location</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blob 对象]]></title>
    <url>%2F2019%2F01%2F12%2FBlob%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }js 中的 blob 数据类型：Blob 什么是 blob ？ blob 代表了一个存放文d件数据的字节包， 使用 blob 可以代替 file， 我们可以在使用 file 的地方使用 blob 作为代替。同样， blob也有和 文件 file 类似的 size 和 MIME 属性。在 blob 中可以存放二进制数据， 同时我们可以使用 arrayBuffer 进行读取数据。创建 blob： 123new Blob(array, [,options]);// array is an Array of ArrayBuffer, ArrayBufferView, Blob, DOMString objects, or a mix // of any of such objects, that will be put inside the Blob. DOMStrings are encoded as // UTF-8.// options 是可选的额外参数， 比如， 可以传递一个 type， 表示放入 blob 中的数据的 MIME 类型 如下， 将字符串保存到 blob 中， type 为 “text／plain”1const blob = new Blob([&quot;hello world&quot;], &#123; type: &apos;text/plain&apos; &#125;); 读取blob 如果我们直接打印出 blob 是不能打印出来的1Blob(11) &#123;size: 11, type: "text/plain"&#125; 我们可以通过使用 FileReader 读取 blob 中的数据： FileReader 是 web 用来异步读取电脑上的文件或者blob数据的对象， 其对于从web端操作文件提供了一系列的方法， 具体内容查看 FileReader 123456const reader = new FileReader();reader.readAsText(blob);rader.onloadend = () =&gt; &#123; console.log("result", reader.result);&#125;;// result "hello world" 我们可以使用 blob来做什么？ blob 提供了用于操作二进制数据的一些接口， 一些可以用来操作二进制数据的api 比如 file 对象， 都是建立在blob的对象基础之上的， 继承了blob 的一些属性和方法。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>blob</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端路由的实现]]></title>
    <url>%2F2019%2F01%2F12%2F%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }前端路由的两种实现方式 路由是什么？ 路由一种根据请求的内容来匹配相应执行代码的一种机制， 在前端应用上面来说， 就是通过不同的路径来请求不同的资源。对于前端应用， 路由可以分为前端路由以及后端路由两种类型。后端路由： 在spa单页面应用出来之前， 最常用的一种渲染方式是服务端渲染（SSR）， 主要的方式是通过服务器返回页面上需要呈现的内容， 因此， 需要页面呈现什么的内容， 如何根据请求的不同路径返回不同的资源是由服务器端进行配置的，使用服务器端进行渲染有如下几个优缺点：优点： 有利于 SEO 优化。 首屏加载速度快。 缺点： 每次请求都是渲染一个新的页面，页面重新进行刷新， 旧的页面会被丢失， 从而造成性能上的影响。 前端路由： 前端路由是单页面应用中页面切换时的资源请求方式， 前端路由会通过url的改变匹配获取到请求参数，根据请求参数的不同 在一个页面中加载不同的资源， 通过这种方式，可以跳转到不同的页面并且不会刷新页面。优点： 除了首屏之外的页面能够快速响应， 因为每次切换页面都只需要加载少量数据。 组件的复用度高， 提高页面加载性能。 前后端分离开发。 当页面进行切换的时候的 transiton 或者 animation 动画更容易被应用。 缺点： 首屏资源加载速度慢， 因为对于单页面应用， 页面渲染相关的逻辑位于js文件中，js 文件会在浏览器解析 html 之后加载， 因此会造成首屏加载时的白屏问题。 SEO 性能差。 首次加载比较慢， 因为整个网站的资源需要在首次加载页面的时候全部加载。 前端路由的实现方式： 更新视图但不重新请求页面时前端路由的核心之一。实现前端路由主要有两种模式， hash 以及 history 模式。hash： hash 又被称作锚点， 本来用于放在 url 中指定网页中的位置， hash 指的是url 中 # 符号之后的字符， 这个值可以通过 window.localtion.hash 获取到值。hash 值时用于浏览器端的， 对于服务器端没有作用， 不会包含在 http 请求中， 改变 hash 值不会重新加载页面。可以通过使用监听 hashchange 监听 hash 值的改变：1window.addEventListener('hashchange', func, false); 这样我们就可以在 hash 值发生变化的时候触发 func 函数， 从而更新视图。history： history 模式主要是通过使用 window.history 只读属性从而对于浏览器历史记录栈进行读取信息和操作。 window.history 是指向浏览器历史记录栈的只读对象， 提供了操作浏览器历史记录栈的接口 window.history 提供了一些方法用于操作浏览器的页面行为：window.history.back(); : url 回退， 类似于点击浏览器上方的回退按钮。window.history.forward(); url 前进， 类似于点击浏览器上方的前进按钮。window.history.go(1): 前进到下一个页面。与 forward 相同。window.history.go(-1): 回退到上一个页面， 和 back 相同。 在 HTML5 中， 新增了两个新的 API： pushState 和 replaceState.12window.history.pushState(state, title, url);window.history.replaceState(state, title, url); 使用这两种方法修改浏览器历史记录栈之后， 虽然改变了当前的 url， 但是浏览器不会立即发送这个 url， 这就实现了更新视图但是不会请求页面的作用。这两个 api 都有三个参数： 状态对象（state object）：一个JavaScript对象，与用pushState()方法创建的新历史记录条目关联。无论何时用户导航到新创建的状态，popstate事件都会被触发，并且事件对象的state属性都包含历史记录条目的状态对象的拷贝。 标题（title）：FireFox浏览器目前会忽略该参数，虽然以后可能会用上。考虑到未来可能会对该方法进行修改，传一个空字符串会比较安全。或者，你也可以传入一个简短的标题，标明将要进入的状态。 地址（URL）： 新的历史记录条目的地址。浏览器不会在调用pushState()方法后加载该地址，但之后，可能会试图加载，例如用户重启浏览器。新的URL不一定是绝对路径；如果是相对路径，它将以当前URL为基准；传入的URL与当前URL应该是同源的，否则，pushState()会抛出异常。该参数是可选的；不指定的话则为文档当前URL。 使用 pushState 用于增加一条新的历史记录， 使用 replaceState 将会替换掉当前的历史记录。当活动历史记录中的条目更改的时候， 将会触发 popstate 事件， 例如点击浏览器的回退按钮， 当事件被触发的时候, 事件的 state 属性为使用 pushState 或者 replaceState 中传入的参数 state12345const state = &#123; bar: 'foo' &#125;;window.history.pushState(state, '', 'route');window.addEventListener('popstate', function (e) &#123; console.log('state', e.state); // &#123; bar: 'foo' &#125;&#125;); 两种路由实现方式的区别： 使用 history 模式可以设置任意和当前 url 同源的 url ，但是使用 hash 只能设置 # 号之后的数值。 使用 history 的 pushState 可以设置相同的 url ，这个新的 url 也会被存放在记录中， 而 hash 值只有和之前的 url 不同才会被记录到 url 中。 在 pushState 中通过传入的 state 值可以添加任何类型的数据， 而 hash 值只可以添加短字符。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>route</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式（一）：理论基础部分]]></title>
    <url>%2F2018%2F12%2F15%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }在 js 中，利用正则表达式进行验证是我们经常会遇到的功能需求， 今天就讲解一些正则表达式的理论基础；正则表达式是用来判断一段字符串是否匹配某一个规则， 通过正则表达式我们可以匹配到我们想要匹配的字符， 判断匹配字符是否存在， 一段字符串是否符合我们的匹配规则等等。创建正则表达式的两种方式： 创建两种正则表达式有两种方法： let reg = new RegExp(pattern[, flags]) let reg = /pattern/flags 上面两种方法创建正则除了包含有一个表达式 pattern 之外， 还包括一个可选的 flags 字段， 这个字段包含有几种字段： g： 全局匹配正则表达式 i： 表示不区分大小写， 匹配的时候忽略大小写的匹配。 m: 表示多行匹配， 即到达某一行文本结束的时候还会继续查找下一行中是否包含有与模式匹配的值 通过上面两种方法创建的正则表达式返回的都是一个正则对象， 这个正则对象中包含有正则表达式中的一些方法例如： exec, match test 等方法。元字符 正则表达式中的元字符是用来匹配一个位置或者字符集合中的一个字符， 元字符可以分为两种类型， 匹配位置的元字符和匹配字符的元字符；匹配位置的元字符： 元字符 含义 ^ 匹配行的开始位置 $ 匹配行的结束位置 \b 可以用来匹配单词的开始或者结尾位置， 也就是单词的分界处 匹配字符的元字符： 元字符 含义 . 匹配除换行符之外的任意字符 \w 匹配单词字符（包括字母， 数字，下划线和汉字） \W 匹配任意的非单词字符（和 \w） 相反 \s 匹配任意的空白字符， 比如空格符， 制表符或者换行符 \S 匹配任意的非空白符 \d 用于匹配任意的数字 \D 用于匹配任意的非数字字符 字符类 字符类是一个字符集合， 使用方括号 [] 定义， 表示匹配到方括号中的任意一个：注意： 除了 - 以及 ^ (只能用在开头， 表示否定) 这两个特殊字符之外， 其他的的特殊字符没有任何特殊的含义例如：1/&lt;H[123456]&gt;/ 表示匹配 H1 H2 ... H6 中的任意一个标签在方括号中可以使用 - 用作连接符表示字符的范围：[0-9] 表示匹配 0 到 9 范围类的数字[a-z] 表示匹配 a 到 z 范围内的小写字母[a-zA-Z] 表示匹配 a到 z 或者 A 到 Z 范围内的英文字母在方括号中当 ^ 符号位于开头的时候， 表示对于当前字符集表示否定， 匹配的是排除在当前字符集中的字符：1/[^0-8]/.test(9); // true 要匹配上面的两个特殊符号， 那么需要我们使用反引号进行转义：12/[a\-c]/.test('-');// true 限定符 使用字符类方括号 [] 或者 元字符只能表示匹配单个字符， 如果我们想要匹配多个字符的时候， 我们可以使用限定符进行范围的限定：限定符紧跟在单个字符后面，表示这个字符或者字符集重复的次数。 对于限定符有下面几种情况 ：对于限定符也可分为贪婪匹配以及懒惰匹配， 下面的六种限定符为贪婪匹配， 懒惰匹配为在贪婪匹配后面添加 ? 表示懒惰匹配； 字符或者表达式 说明 {n} 重复 n 次 {n, } 表示至少重复 n 次 {n, m} 重复至少n 次， 至多 m 次 * 重复至少0次， 等同于 {0, } + 重复至少 1 次， 等同于 {1, } ? 重复 0 次 或者 1 例如：12345const reg = /a.*b/;"aabab".match(reg); // aababconst reg = /a.&#123;0,1&#125;b/;"aabab".match(reg); // aab 使用贪婪匹配与懒惰匹配的区别在于， 使用贪婪匹配会尽可能多的匹配字符， 使用懒惰匹配则是查找到满足匹配条件的字符串中字符较少的字符。例如：12345678const reg1 = /a.+b/;const reg2 = /a.+?b/;const str = "avbaab";// 贪婪匹配str.match(reg1); // avbaab// 懒惰匹配str.match(reg2); // avb 替换 在正则表达式中 | 用于表示当字符串匹配了 | 左边或者右边的规则的时候， 表示这个字符串匹配了当前的正则表达式，类似于 js 中的 || 操作符， 当 | 左边的正则不匹配， 那么进行右边的正则匹配。1let reg1 = \d&#123;5&#125; - \d&#123;3&#125; | d&#123;5&#125;; // 同时可以匹配 12345-678 或者 12345 注意： 使用 | 进行匹配的时候， 如果当左边的元素被匹配到的时候， 右边的元素将不会进行匹配。12345&gt; let str = 'goodbye';&gt; // | 两边不能有空格&gt; let regex = /goodbye|good/g;&gt; str.match(regex); // ['goodbye']&gt; 分组 使用 () 包裹起来的表达式在正则表达式中表示一个整体， 我们可以对这个整体进行限定符限制， 重复匹配例如：12// 匹配一个 ip 地址let reg = /(\d&#123;1,3&#125;\.)&#123;3&#125;/d&#123;1,3&#125;/; 总结 在正则中使用 [] 以及 | 都有 “或者” 的意思， 这两者可以根据不同的请求可以选择使用， 具体的对比如下： 描述符 优点 缺点 [] 适合单个字符之间的匹配， 需要转义的特殊字符比较少（^ 和 -） 不能匹配多个字符结合的字符串，相对表达意思比较少， 只能表示匹配或者不匹配（使用^） 两种逻辑 竖直 可以匹配多个字符的字符串 当匹配正则中的特殊字符的时候需要进行转义]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 文件上传与下载]]></title>
    <url>%2F2018%2F10%2F31%2Fjs-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }前端实现的文件上传与下载操作：上传 在上传文件的操作中， 可以使用 formData 或者 fileReader 进行上传操作， 使用 fileReader 可以在本地将上传的文件转为二进制的数据格式； formData 是在 XMLHttpRequest 中的接口，可以用来实现模拟的表单提交， 当前端通过 ajax 向后端传递文件的时候， 使用 ajax 提交 formData 可以实现异步上传二进制文件1&lt;input type=&quot;file&quot; onClick=&#123; this.uploadFile.bind(this) &#125; /&gt; 对于上传文件，可以通过两种方式进行上传，通过 filereader 或者通过 formData 都可以实现上传文件FileReader: 12345678uploadFile(fileInput) &#123; const file = fileInput.target.files[0]; // 获取到文件对象 const reader = new FileReader(); // 创建 fileReader 的实例 reader.readAsArrayBuffer(file); // 将file 读取为 ArrayBuffer reader.onload = function () &#123; // 当文件加载成功的时候调用 console.log(&quot;result&quot;, reader.result); &#125;&#125; 在 MDN 上面， 对于 FileReader 的描述如下:123FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。其中File对象可以是来自用户在一个&lt;input&gt;元素上选择文件后返回的FileList对象,也可以来自拖放操作生成的 DataTransfer对象,还可以是来自在一个HTMLCanvasElement上执行mozGetAsFile()方法后返回结果。 使用 fileReader 接受的参数可以是一个 File 对象或者 Blob 对象， 使用上传文件的时候， 接收的是一个 fileList 对象。构造函数 1const reader = new FileReader(); // 创建一个新的 filereader 实例 相关方法 reader.readAsArrayBuffer(file) : 将文件读取为 ArrayBuffer 的数据对象ArrayBuffer 是一种二进制数组，通过 ArrayBuffer 中的一些语法可以实现使用数组的语法处理二进制数据reader.readAsText(file, [encode]) : 读取文件内的内容作为字符串的形式输出，这个方法读取的是文件内的内容，其中的 encode 用于将 file 对象进行转换的编码格式;reader.readAsDataURL(file): 将文件读取为 DataUrl相关属性 reader.error: 表示在读取文件的时候发生的错误；reader.readyState: 表示当前上传文件的状态：0: 表示当前文件尚未加载1: 表示当前文件正在加载中2: 表示当前文件已经完成加载reader.result : 上传文件的内容，只有上传成功之后这个属性才有值事件处理 事件名 描述 Onabort 当读取操作中断的时候触发 Onerror 当操作发生错误的时候触发 Onload 当读取操作完成的时候触发 Onloadstart 当开始进行读取的时候触发 Onloadend 当读取操作结束的时候触发 Onprogress 当读取的时候触发 FormData: 12345678910uploadFile(fileInput) &#123; const file = fileInput.target.file[0]; const formData = new FormData(); formData.append(&quot;file&quot;, formData); axios(&#123; method: &quot;post&quot;, url: &apos;...&apos;, data: formData &#125;);&#125; 下载 常用的下载操作是创建一个 a 标签， 通过 a 标签的 href 指向下载的文件链接，通过使用 download 属性来说明下载的文件名称:1&lt;a href="" download="文件.txt"&gt;下载文件&lt;/a&gt; // download 表明下载的文件名, href 指向下载的文件的地址 在后端传递的文件进行下载的时候， 因为后端传递的是一个二进制的数据格式文件， 前端这边需要将二进制数据转为 a 标签的链接进行下载操作， 通过使用 window.URL.createObjectURL 转为链接。window.URL.createObjectURL:接受参数为一个 file 对象或者一个 blob 对象， 最后生成一个 url, 这个url指向参数中给定的对象。这个 URL 的生命周期和创建它的窗口中的 document 绑定，当不需要使用 URL 对象的时候， 可以通过 URL.revokeObjectURL 进行释放， 已获得最佳性能和内存使用情况。在实际的开发中， 通常使用js 来创建下载标签， 代码如下:123456789101112// name: 下载的文件名// blob 下载的文件的blob 二进制数据格式的文件function downloadFile (name, blob) &#123; var downloadElement = document.createElement('a'); var href = window.URL.createObjectURL(blob); //创建下载的链接 downloadElement.href = href; downloadElement.download = `$&#123;name&#125;.xlsx`; //下载后文件名 document.body.appendChild(downloadElement); downloadElement.click(); //点击下载 document.body.removeChild(downloadElement); //下载完成移除元素 window.URL.revokeObjectURL(href); //释放掉 URL 对象 &#125; 当接受到文件数据不为 blob 对象的时候, 可以通过使用 new Blob([data]) 转换为 blob 对象。Blob blob 是 js 中的对象，可以存储大量的二进制编码格式的数据， 使用 blob, 当 input 标签 type 设为 file 的时候提交的 fileList 中的每一个 file 对象就是基于 blob 对象的；构造函数 new Blob(array, [,options]):array 中的值可能是 ArrayBuffer, ArrayBufferView, Blob, DOMString 对象， 或者这些对象的混合。options 字段是可选的字段， 包含下面两种值： type: 表明将要放入 blob 中的数组内容的 MIME 类型 endings: 决定第一个参数的数据格式，可以取值为 &quot;transparent&quot; 或者 &quot;native&quot;（transparent的话不变，是默认值，native 的话按操作系统转换 方法 Blob.slice([start[, end[, contentType]]])用于对 Blob 进行&quot;切割&quot;， 返回一个新的 Blob 对象， 包含特定字节范围内的数据属性 Blob.size: 在 Blob 数据对象中的字节大小。Blob.type: Blob 数据对象中的 MIME 类型。使用 Blob 存储的数据对象读取的唯一方式是通过使用 FileReader 进行读取， 通过使用 FileReader 中的 readAsDataURL 或者 readAsArrayBuffer 将 Blob 中的数据类型读取为 ArrayBuffer 或者 dataurl 的格式。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>fileReader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css modules: 前端模块化]]></title>
    <url>%2F2018%2F09%2F09%2Fcss-modules-%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }在 css 模块化的解决方案中， 存在两种解决方案， 一种是放弃使用 css, 使用 js 或者 json 的形式来重写 css, 这样写的好处在于方便利用 js 的模块化管理，缺点在于缺少 css 预处理器例如 less sass 等的支持，例如 react-style 属于这种解决方案。另外一种是依旧采用 css 的原生态写法， 但是通过 js 来进行管理依赖， 下面我们介绍的 css-modules 属于这种的写法。css 模块化中的一些问题 在 css 的模块化的过程中， 下面几种问题是需要解决的：全局污染 在 css 中， 样式 style 是属于全局范围内的， 因此当我们在全局范围内w为某一元素标签添加样式的时候， 这一样式会被应用到全局的所有的该标签下的元素上面，为了减少掉全局变量的污染，我们会采用提高元素优先级的方法进行样式覆盖， 例如添加 !important ，获取通过复杂选择器增大元素的权重值以及行内样式，这种通过提高元素优先级的方法实现的元素样式覆盖导致了无法重写元素样式， 丧失了l灵活性。命名混乱 混乱的命名方式会导致开发过程中的样式冲突， 样式混乱， 为后续开发带来了困难， 在这个问题上面， 有一种解决方式， 就是采用 BEM 的命名方式；依赖管理不彻底 在引入组件的时候， 组件应该相互独立， css 文件应该随着组件的引入按需加载，而不是引入所有的样式， 这样造成了模块的浪费。实现变量共享 在复杂的组件中, 可能需要通过 js 或者 css 同时进行操作样式，这种情况下可能会造成样式的冗余，现在的预处理器都不能实现变量在 css 与 js 之间的变量共享。CSS modules css modules 是一种模块化的解决方案，通过使用 js 文件引入管理， 同时， 在 css modules 中的 css 文件中的样式名被默认为局部样式，从而避免了局部样式的污染， 结合 webpack, 使用 css modules 应用的类名会被编译为一串字符， 从而避免 class 命名的重复。下面是一些基本的语法:基本语法 引入与导出 在需要使用 css 的组件中通过使用 import 的方法进行导入：index.css:1.btn &#123; /* btn 的相关样式 */ &#125; index.js:123456import style from "./index.css";...render () &#123; return &lt;button className=&#123; style.btn &#125;&gt;&lt;/button&gt;&#125;... 最终生成：1&lt;button class=&quot;btn&quot;&gt;&lt;/button&gt; 通过使用 js 引入的方式还可以实现常量的共享功能： 对于常量， 需要使用 :export关键字将 css 中的常量输出到 js 中:12345@color: "red";:export &#123; color: @color;&#125; 123import style from "./index.css";style.color // "red" 全局与局部样式 通过使用 :global 和 :local 样式可以将当前的样式声明为全局和局部样式：index.css:1234567891011121314151617.btn &#123; color: blue;&#125;// 等同于下面的 local:local(.btn) &#123; color: blue;&#125;// 声明为全局样式// 文件中所有类名为 `btn` 的元素都将应用这个样式:global &#123; .btn &#123; color: blue; &#125;&#125; 代码复用与样式组合 在 css-modules 中使用 composes 来实现多个类名的组合， 例如， 当我们定义组件 Button 的时候， 我们需要定义基础配置， 大小以及类型样式， 可以这么写12345678910111213141516171819.btn &#123; // 定义基础样式&#125;.btn-small &#123; // small 大小相关样式&#125;.btn-text &#123; // text btn 相关样式&#125;&lt;!-- 组合样式 --&gt;.btn-small-text &#123; compose: btn btn-small btn-text;&#125;// 或者当 btn 为全局样式 global-btn 的时候， 可以进行组合.btn-small-text &#123; composes: global-btn btn-small btn-text;&#125; 注意：使用 composes进行样式组合的时候， 需保证组合的样式名在composes之前已经存在了， 并且是单独的样式名， 没有嵌套关系使用技巧 减少 class 嵌套, 使用单独 class 来定义样式，减少 class 层叠 使用 composes 类名组合来组合样式 不使用选择器， 仅仅使用 class 来定义样式 CSS modules 使用 项目中使用 less 作为 css 预处理器，在 webpack 中 css-loader 支持 css modules, 相关配置如下:1234567891011121314151617181920test: /\.less$/,use: [ &#123; loader: 'style-loader' &#125;, &#123; loader: 'css-loader', options: &#123; // 启用 css modules modules: true, // 定义最终编译之后的样式名称 // local: 应用的 class 名称 // hash: 编译时随机生成的 hash 值， 避免 class 名称重复 localIdentName: '[local]--[hash:base64:5]' &#125; &#125;, &#123; loader: 'less-loader' &#125;]]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css modules</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grid 布局（一）]]></title>
    <url>%2F2018%2F08%2F18%2Fgrid-%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }grid 布局是一种方便的用于创建网格布局的强大工具， 使用grid 布局可以很方便的构建网页结构， 本篇文章主要介绍grid 布局的基础知识。基本属性 使用 grid 布局实现一个九宫格:123456&lt;div class="content"&gt; &lt;div class="item1"&gt;&lt;/div&gt; &lt;div class="item2"&gt;&lt;/div&gt; ... &lt;div class="item9"&gt;&lt;/div&gt;&lt;/div&gt; 1234567.content &#123; display: grid; width: 300px; height: 300px; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px;&#125; 实现的九宫格如下所示:display: grid 使用 display: grid 的目的是用于声明当前元素使用 grid 布局构建;常用值: grid: 生成一个块状网格 inline-grid: 生成一个内联网格 subgrid: 表示当前的网格容器继承自父级元素的网格容器 grid-template-columns, grid-template-rows 这两个属性用于在声明 grid 的当前元素内部划分网格内容。后面的数值表明网格内容的长度大小， 数值之间的空格表示划分网格的网格线。grid-template-columns : 用于在网格元素划分列， 后面的值表示划分列的宽度， 比如上面的九宫格代码中， 表示将当前的元素划分为 3 列， 且三列的宽度均是 100px;grid-template-row: 使用效果类似于 grid-template-columns, 是对于 grid 元素行的划分。比如上面的代码中表示将 grid 元素划分为三行， 并且三行的高度均为 100px;常用值: &lt;track-name&gt;&lt;track-size&gt;&lt;track-name&gt;&lt;track-size&gt;... track-size: 表示网格内容的宽度，可取值: percentage 数值 auto: 网格宽度的剩余空间 fr: 表示等份网格容器中的可用空间 track-name: 表示网格之间网格线的名称式例:123.content &#123; grid-template-columns: [line-start] 50px [line1-start] 20% [line2-start] 1fr [line-end];&#125; 效果如下:当 auto 和 fr 同时存在的时候， 优先级： auto &gt; fr, 这个时候 , 声明 auto 的那一列宽度为 0grid-template-areas 使用 grid-template-areas 用来定义网络模板；常用值: grid-area-name : 由网格项的 grid-area 指定的网格区域名称 . 表示一个空的网格单元 none 表示不定义网格区域 例如下面实现的一个网页布局:123456&lt;div class="content"&gt; &lt;div class="header"&gt;&lt;/div&gt; &lt;div class="menu"&gt;&lt;/div&gt; &lt;div class="body"&gt;&lt;/div&gt; &lt;div class="footer"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728.content &#123; width: 400px; height: 300px; display: grid; grid-template-columns: repeat(1fr); grid-template-rows: repeat(1fr); // 这里的 h, m , b, f是和下面声明的 `grid-area` 是一一对应的 grid-template-areas: "h h h h" "m . b b" "f f f f";&#125;.header &#123; grid-area: h; background-color: lightcoral;&#125;.menu &#123; grid-area: m; background-color: lightblue&#125;.body &#123; grid-area: b; background-color: lightslategray&#125;.footer &#123; grid-area: f; background-color: lightseagreen;&#125; 效果如下:]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>grid 布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解js中的线程，进程, eventLoop]]></title>
    <url>%2F2018%2F06%2F21%2F%E8%AF%A6%E8%A7%A3js%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }存在下面一段代码：1234567891011setTimeout(function() &#123; console.log(1) &#125;, 0);new Promise(function(resolve)&#123; console.log(2); for(var i = 0; i &lt; 10000; i++) &#123; i === 9999 &amp;&amp; resolve() &#125; console.log(3);&#125;).then(function () &#123; console.log(4);&#125;);console.log(5); 上面的代码的执行顺序， 依次输出内容分别是什么？ 正确的答案是： 2， 3， 5 ，4， 1； 在上面的代码中， 执行的代码顺序如下： 执行 promise 实例内部的代码， 输出 2; 顺序执行后面的代码 console.log(3), 输出 3; 执行 console.log(5)， 代码输出 5; 执行 resolve 函数， 执行 resolve 函数中的代码 console.log(4), 输出 4; 最后执行 setTimeout 中的代码， 代码执行 console.log(1) ， 输出 1; 为什么会按照上面的顺序执行代码， 下面将要进行详细的讲解： js 中的线程 在 js 中的线程和浏览器中的线程是不同的， 在 js 中是单线程， 在浏览器是多线程的。js 的单线程是指所有的 js 代码都是在 js 引擎上面的一个主线程上面运行的，js 同时只能执行一个任务， 其他的任务则会排队进行等待执行。这些任务被放在一个任务队列中等待执行。在浏览器中， 包括下面这些线程： js 引擎线程（例如 v8 引擎） UI 渲染线程 浏览器事件触发线程 定时触发器线程 http 请求线程 这些线程的作用分别是这样的： UI渲染线程用于渲染页面、解析 HTMl CSS， 创建 DOM 树。当页面元素发生重构或者回流的时候， 这个线程就会执行， 重新渲染页面。 js引擎用于执行 js 脚本代码，等待任务队列中的任务到来， 并且加以处理 浏览器事件触发线程用于控制用户， 响应交互，当 js 引擎执行代码遇到相关事件的时候， 会将对应的任务添加到事件线程中， 当任务符合触发条件被触发的时候， 触发的任务会被添加到任务队列的队尾， 等待 js 引擎执行完成主线程上面的任务之后执行。 定时触发器线程用于对于 setTimeout 或者 setInterval 进行计数, 因为 js引擎是单线程的， 所以自然计数的任务就不能有 js 引擎来完成， 而是由浏览器单独开出一个定时触发器线程用于计数， 当计数完毕之后， 会将计数完成之后的函数添加到任务队列尾部， 等待 js引擎执行完成主线程上面的任务之后执行。 这里也就是说有个常见的问题： setTimeout(() =&gt; {}, 0);回调是立即执行的吗？并不是， 因为， 需要js 引擎执行完主线程上面的任务之后， 才会执行 任务列表中的任务。 http 请求线程， ajax 是委托给浏览器新开一个 http 线程 在上面的这些线程中， js 引擎的线程和UI渲染的线程是互斥的， 因此， 当js执行代码的时候会出现阻塞页面渲染的情况， 这也就是许多前端性能优化中都有提到的将js代码在html代码尾部加载的原因， 同时， 在 js 中操作dom会引发页面的重构或者回流， 这个时候UI渲染线程就会开始工作， 重新渲染页面， js 引擎的主线程就会被挂起，暂停代码执行， 从而影响页面性能， 这也是前端性能优化的一种方式：尽量减少js中直接对于dom的操作。setTimeout setTimeout 在 js 中的作用是用来延迟代码执行， 规定代码在延迟多少时间之后执行回调函数代码，在上面关于线程的讲解中， 我们知道浏览器的定时触发器线程会在延迟时间达到之后将回调事件添加到js引擎中的任务队列中， 而在 js 引擎中， 引擎会在执行完成主线程上面的任务之后执行任务队列中的事件， 因此，当代码中存在 setTimeout 的时候， 内部的回调函数会在其他代码执行完毕之后才执行， 尽管我们将延迟时间设为0的情况也是如此：有如下代码：12setTimeout(function () &#123; console.log(2) &#125;, 0);console.log(1); 执行结果： 1， 2上面 setTimeout 中的函数会等到 console.log(1) 执行完成之后执行结果。js 中的事件运行机制 我们知道js是单线程运行的， 那么具体的运行机制是如何的？我们需要知道下面这些概念： js 中分为同步任务和异步任务 同步任务都是在主线程上面执行， 形成一个执行栈 在主线程之外， 事件触发线程管理着一个任务队列， 当异步任务有了运行结果时， 就在任务队列中添加一个事件 当执行栈中的所有的同步任务执行完毕之后， 任务队列中的任务将会添加到执行栈中， 开始执行 事件运行机制的详细图解如下：js 中的 macrotask 与 microtask 在 js 中， 存在两种任务类型： macrotask(宏任务) 和 microtash (微任务)， 这两种任务类型的区别在于执行任务的时机是不同的。 macrotask: 宏任务可以理解为执行栈中执行的任务， 在执行任务期间不会中断任务， 浏览器为了能够使 js 内部task与 dom 能够有序的执行， 在执行完成任务之后会进行渲染，1task ---&gt; 渲染 ---&gt; task microtask微任务会在宏任务执行完毕之后， 进行渲染之前执行 macrotask 与 microtask 中分别包含的几种任务类型： macrotask : 代码块， setTimeout, setInterval 等 microtask: Promise 参考链接 从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理JavaScript 运行机制详解：再谈Event Loop]]></content>
      <categories>
        <category>js理论基础</category>
      </categories>
      <tags>
        <tag>js运行机制，线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 中的函数式编程（译）]]></title>
    <url>%2F2018%2F06%2F16%2FJavaScript-%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%88%E8%AF%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }在这篇文章中，我们将会学习到声明式， 纯函数， 不变性以及副作用。什么是函数式编程？ 在计算机科学中，函数是编程是一种编程范例或者模式（一种构建计算机程序结构和元素的样式） 函数式编程将计算机运算视为数学概念中函数的计算。 函数式编程避免改变状态以及使用可变的数据。 上面的这些定义来自于维基百科， 在这篇文章中，我们尝试理解FP(函数式编程)的价值和意义。其他主要的编程规范或模式： 过程式编程 面向对象的编程 元编程 命令式编程 声明式编程 过程式编程 基于程序调用的概念，简单包括计算机将要执行的一系列的计算过程， 在程序执行期间的任何时候，任何被设定的程序都有可能被调用，包括被其他的程序被调用或者自身调用，主要的过程式编程语言有COBOL, BASIC, C, ADA 和 GO面向对象编程 基于对象的概念，对象中包含数据（属性）和程序（方法），这种模式更接近于函数式编程，一些重要的面向对象的语言包括：C++, Java, PHP, C#, Python, Ruby, Swift 等等。元编程 具备将程序视为数据的能力，这意味着程序能够被设计成能够阅读，复制， 分析或者转换为其他程序，甚至在运行的时候修改自身。命令模式 vs 声明模式 命令模式关心描述程序如何运行, 由计算机执行的命令组成 声明模式关心程序能够做什么而无需确定程序应该如何完成。 函数式编程遵循声明模式。 123456789101112131415var books = [ &#123;name:'JavaScript', pages:450&#125;, &#123;name:'Angular', pages:902&#125;, &#123;name:'Node', pages:732&#125;];/* Imperative Pattern */for (var i = 0; i &lt; books.length; i++) &#123; books[i].lastRead = new Date();&#125;/* Declarative Pattern */books.map((book)=&gt; &#123; book.lastReadBy = 'me'; return book;&#125;);console.log(books); 在上面的这一段代码中， 我们对于书籍数组中的每一本书添加了一个新的属性，这个过程通过两种不同的方法执行。 第一段中借用 for 循环，依据数组的长度进行迭代,接着将数组的指针计数器和数组的长度进行核对并且在每一次迭代中增加指针计数器，因此， 这更像程序/代码正在关心为了得到想要的输出结果如何进行运行操作。 第二段中的代码借助于原生Js数组中的 map 这个 map 方法将函数作为参数，这个函数获取到每一个元素，因此在这种情况下代码不是在描述程序如何运行，而是讨论需要达成什么 ，在这种情况后的 map 方法 关心实际的程序执行。 数学意义上的函数或者纯函数 在数学中，函数是一系列输入值和合法的输出值之间的关系，这种特性反映了每一个输入组合都关联着一个确定的输出。这函数式编程中，这种函数被称作纯函数，函数的输出结果仅仅取决于函数接收到的输入数据， 除了返回值之外， 函数不会改变输入的数据。Math.random() 不是纯函数，因为每次调用的时候总会返回一个新的值。Math.min(1, 2) 是纯函数的一个例子，对于相同的一组输入值总会返回新的值。为什么要使用函数式编程 函数式编程中的纯函数确保了不会改变在其范围之外的数据。 其减少了复杂程度， 我们不需要关心程序如何怎样做， 而只需要关心程序做了什么。 易于测试，因为其不会取决于应用的状态，对于结果的验证也将会变得简单。 让代码更具有易读性。 函数式编程让代码更易于理解。 函数式编程的例子 数组函数在上面的代码中， 我们试图过滤出只有活跃的 meet-ups, 我们可以看到这个功能可以使用两种不同的方法实现，在这里， 第二种方法是函数式编程，其中的 filter() 方法关心&quot;程序如何运行&quot;，程序只关心输入也就是 meetups数组以及输出activeMeetupsFP 但是在第一种方法中程序也关心 for 循环如何运行代码。相似的，下面的这些数组方法有助于实现函数式编程，减少代码的复杂度。 find reduce map some every 函数链 函数链是用于调用多种方法的机制， 每一个方法返回一个对象， 允许在一个声明中调用链接在一起而无需变量来储存中间结果。在上面的代码片段中， 我们想要打印出所有的活跃的 meetup 用户的总人数， 考虑到可能有10%的用户重复。支持 FP 的库 下面这些库中提供了一些让代码看起来更加声明式的有用函数。 RamadaJS UnderscoreJS lodash 副作用 函数或者表达式除了返回一个值之外，在下面的几种情况下被认为产生了副作用： 如果其改变了其自身范围之外的程序状态， 或者与其调用的函数或者外部的程序有一个可以观察到的交互。123456789101112131415let meetup = &#123;name:'JS',isActive:true,members:49&#125;;const scheduleMeetup = (date, place) =&gt; &#123; meetup.date = date; meetup.place = place; if (meetup.members &lt; 50) meetup.isActive = false;&#125;const publishMeetup = () =&gt; &#123; if (meetup.isActive) &#123; meetup.publish = true; &#125;&#125;scheduleMeetup('today','Bnagalore');publishMeetup();console.log(meetup); 上面的这段代码产生了副作用，因为函数 scheduleMeetup 的本来的作用是给 meetup 添加 date 和 place, 但是这个函数改变了 isActive 的值， 而这个 isActive 正是函数 publishMeetup 所依赖的。具有副作用的 publishMeetup 函数将不会得到理想的输出， 因为其输入的值在这个过程中被改变了。 在大型的程序中（真实的程序情况下）， 很难去 debug 副作用。副作用不总是产生坏的影响，但是如果其产生的时候我们应该小心对待。不变性 在函数运行之后，不变性是十分重要的对于确保一个函数确实没有改变原来的数据而不是返回数据的新的副本。例如， 如果数组以及对象在经历过多个函数之后， 如果我们不能保持不变性， 那么函数可能不会得到数组或者对象的原始值。在可变的对象和数组的情况下，如果发生了一些错误对于我们来说是非常困难排除bug的。支持不变性的库 JavaScript默认没有对于使得对象或者数组不变提供任何的工具， 下面是一些可能帮助我们实现不变性的库: Seamless-immutable Immutable JS 总结 函数式编程中主要的方面是纯函数和更小的功能， 函数不变性以及更少的副作用。本文翻译至Functional Programming in JavaScript，实际上翻译之后才发现这里只是一些函数式编程基础知识，对于其他的函数式编程的更多特性并没有涉及，本文仅仅作为函数式编程的基本入门知识， 如果能帮到读者，那就再好不过了。]]></content>
      <categories>
        <category>翻译文集</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取数组中特定值的数组]]></title>
    <url>%2F2018%2F06%2F11%2F%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E4%B8%AD%E7%89%B9%E5%AE%9A%E5%80%BC%E7%9A%84%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }有如下题目：根据指定元素，在数组里面找出类数组。比如数组 [2, 3, 5, 7] ，指定元素 5，则类数组是 [2,, 3] 和 [5]，因为上面两个数组的元素之和相加为5。自己想了一下， 实现方法如下：1234567891011121314151617181920212223242526/**** description 得到** arr 传入的数组** value 得到的类数组的值** maxLen 类数组的最大长度**/function compile(arr, value, maxLen = arr.length) &#123; if (!arr.length || !value) return; let result = []; let tempArr = []; const len = arr.length; let nowIndex = 0; while (nowIndex &lt; len) &#123; if (tempArr.length &gt; 0) &#123; let temp = []; for (let item of tempArr) &#123; temp.push([...item, arr[nowIndex]]); &#125; tempArr = [...tempArr, ...temp]; &#125; tempArr.push([arr[nowIndex]]); nowIndex++; &#125; result = tempArr.filter(arr =&gt; (arr.reduce((pev, now) =&gt; (pev = pev + now) &amp;&amp; pev, 0) === value) &amp;&amp; (arr.length &lt;= maxLen) ); return result;&#125; 实现的效果如下：1compile([1, 2, 3], 5) // [2, 3]]]></content>
      <categories>
        <category>代码集</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阅读函数式编程（二）]]></title>
    <url>%2F2018%2F05%2F23%2F%E9%98%85%E8%AF%BB%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }在上一篇文章中，我们了解了关于纯函数的概念， 纯函数的好处体现了函数式编程的一大优点： 没有副作用， 那么什么是函数式编程， 与命令式编程有什么不同， 函数式编程有什么优点，这篇文章想要深入了解下函数式编程的基本概念以及特点；基本概念 在 Wikipedia 上面， 这样解释函数式编程： In computer science, functional programming is a programming paradigm or pattern (a style of building the structure and elements of computer programs) Functional Programming treats computation as the evaluation of mathematical functions. Functional Programming avoids changing-state and mutable data. ​ 在计算机中， 函数式编程是是一种编程范例或者模式（一种构建计算机程序的结构和元素的类型）。 函数式编程将计算视作数学上函数的评估。 函数编程中避免改变状态以及变化的数据。 函数式编程与命令式编程最大的区别在于：函数式编程关心数据的映射， 命令式编程关心解决问题的步骤。 这里的函数式编程之所以被称作函数，实际上类似于数学上函数的概念； 函数的定义：设A，B是非空的数集，如果按照某种确定的对应关系f，使对于集合A中的任意一个数x，在集合B中都有唯一确定的数 y 和 x 对应，那么变称映射 f: A ===&gt; B 称为从集合 A 到 B 的一个映射 同样在函数式编程中， 函数式编程中的函数中， 每一个输入值都有一个唯一确定的输出值和输出值对应， 但是不同的输入值可以得到相同的输出值， 这种关系是一种映射关系。当然，对于函数编程而言，它不仅仅可以实现数据的映射， 还可以实现函数之间的映射。例如：如果我们想要对于数组中的每一个数加1:12345const arr = [1, 2, 3];for (let index in arr) &#123; arr[index] += 1;&#125;console.log("arr", arr); // [2, 3, 4] 或者使用 forEach, map 中数组中定义的方法：1234// forEacharr.forEach(item =&gt; item += 1);// mapconst newArr = arr.map(item =&gt; item += 1); 注意：使用 map 以及 forEach 的方法都是对于一个数组进行遍历，接收的参数也是相同的， 但是， 这两个方法之间还是存在着一些区别的，使用 map 不会改变原数组，但是会返回经过函数运算之后的新数组。对于使用 forEach 而言， 使用 forEach 不会改变原来的数组，返回值为 undefined。从函数式编程的角度而言，使用 map 更能体现函数式编程的特点： 不会产生副作用； 在上面实现数组中每项加一的操作中， 使用两种代码实现的， 第一个代码中我们将想要计算机运行的步骤通过命令的方式写了下来，告诉计算机， 通过 for 循环循环这个数组，然后数组中的每一项进行加一操作， 而在第二种代码中， 我们通过类似于函数式编程的方式实现，我们不用关心这个过程是怎么实现的， 我们只要将这个数据转换的关系告诉函数就可以了，换句话说， 我们这里关心的是数据之间的映射。几大特性 对于函数式编程而言，存在下面几种特性： 高阶函数 没有副作用 函数柯里化 闭包 高阶函数 高阶函数是这样一种函数： 函数被作为参数传入或者被作为返回值被返回的一类函数被称作高阶函数；例如下面一段 polifill es6 中 promise 的代码中， 对于promise 返回成功状态或者失败状态的调用函数中是下面这样调用的：123456789101112131415function Promise (executor) &#123; let that = this; that.status = PENDDING; that.value = void 0; that.handlerQueue = []; // 执行函数， 传递进入 value // executor(成功函数， 失败函数); executor(function (value) &#123; // 成功函数执行，传递进入 transition 状态: FULFILLED that.transition(FULFILLED, value); &#125;, function (value) &#123; // 失败函数执行， 传递进入 transition 状态: REJECTED that.transition(REJECTED, value); &#125;)&#125; 在上面的代码中， 这个 executor 函数是被作为参数传入到 Promise 函数中的， 同时这个 executor 也是接受两个函数作为参数， 一个是作为函数返回值为成功状态的函数， 另一个是作为函数返回值为失败状态的函数。例如计算下面代码：12345678910111213141516function getSum(a, b, sum = 0) &#123; if (a &lt; b - 1) &#123; return getSum(a + 1, b, sum + a + 1); &#125; else &#123; return sum; &#125;&#125;function getSquare(a, b, sum = 0) &#123; if (a &lt; b - 1) &#123; return getSquare(a + 1, b, sum + Math.pow(a + 1, 2)); &#125; else &#123; return sum; &#125;&#125;const sums = getSum(1, 4);const squareSums = getSquare(1, 4); 上面两段代码分别是求两个数之间的整数和以及平方和;（不包括这两个数）实际上， 上面的两种方法都是进行函数求和的运算， 只是求和的过程是不一样的，上面的代码我们可以重写如下：123456789function sumFn(a, b, cb, sum = 0) &#123; if (a &lt; b -1) &#123; return sumFn(a + 1, b, cb, cb(sum, a)); &#125; else &#123; return sum; &#125;&#125;const addSum = sumFn(1, 4, (sum, a) =&gt; sum + 1 + a);const squareSum = sumFn(1, 4, (sum, a) =&gt; sum + Math.pow(a + 1, 2)); 在上面的代码中， 我们抽取出了求和的函数， 通过向求和函数中的参数 cb 中传入一个函数进行求取。我们可以看到， 在 sumFn 这个函数中， 函数的逻辑取决于传入的参数cb的逻辑， 通过传入函数为参数的这种形式， 将程序的粒度控制在函数的层面上面。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊js中的类]]></title>
    <url>%2F2018%2F05%2F15%2F%E8%81%8A%E8%81%8Ajs%E4%B8%AD%E7%9A%84%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }对于js 中类的使用，自己平常工作的时候也有用到， 但是只是一些浅显的知识，实际上， 在 js 中如何使用类， 对于类的更深一步的理解，还是有很多的东西需要进行了解, 纸上得来终觉浅， 绝知此事要躬行，作为一名程序员更重要的还是要多写， 多练， 在练习中不断成长。实现类的机制在 js 中有两种方法： prototype 以及 es6 中class 关键字， 下面分别就这两种探讨一下 js 中类的形成：使用 prototype 实现类 什么是 prototype 在 js 中创建对象的时候，对象中默认存在一个 prototype（在 Chrome, Safari, Firefox 中的对象上这个属性被称作 _proto_） 属性，这个属性是一个 指针，指向一个对象， 这个对象被称作原型对象， 原型对象上的属性是可以通过对象访问到的：123let obj = &#123;&#125;;obj._proto_ = &#123; name: "张宁宁" &#125;;obj.name // 张宁宁 想要了解这个过程，我们需要知道当我们在使用 . 或者 [] 查找元素属性的时候，元素属性是如何被查找到的。当在对象中查找某一个元素属性的时候， 会首先在对象本身上进行属性查找， 如果对象本身上没有查找到对象属性， 那么就会在对象的原型上进行查找。如果在对象本身上已经查找到了， 那么返回这个属性的值上面的例子中， 虽然我们没有在 obj 上面定义一个 name 属性，但是我们在 obj 对象的原型上定义了一个 name 属性，因此还是可以查找到的。同样， 对于定义在 prototype 上的属性，使用 for in 操作符也是可以访问到的。1234for (let key in obj) &#123; console.log(key);&#125;// name* 使用hasOwnProperty 方法可以判断定义的属性是在对象本身上面还是在原型上面。注意： 使用 Object.keys 是不能获得到定义在对象原型上面的属性的。1Object.keys(obj); // [] 了解原型链 原型链的实现方式 在 javascript 中，原型链是被用来实现继承的主要方法， 基本的原理如下： 使用原型链实现在 js 中继承的方式是让一个构造函数的原型对象等于另外一个构造函数的实例 我们知道，对于一个构造函数而言，存在一个原型对象， 该构造函数形成的实例包含一个指向原型对象的指针， 如果我们将这个原型对象变为另外一个构造函数的实例，那个同样在这个原型对象中包含一个指向另外一个构造函数的原型对象的指针，这样层层递进，从而形成了一条原型链。代码实现：12345678910111213function func1 () &#123; this.value = true;&#125;function func2 () &#123;&#125;func2.prototype.getValue = function () &#123; return this.value;&#125;func1.prototype = new func2()const instance = new func1();// 或者 const instance = Object.create(func1.prototype);// 使用 Object.create(obj) 会创建一个新对象， 并且对象内部的 prototype 指向 objinstance.getValue(); // true 上面的这个过程其实也可以说是我们重写了构造函数的原型;原型链的终点 对于一个原型链而言，是否原型链存在终点呢？实际上， 原型链的终点是存在的。我们知道在 javascript 中， 存在下面几种基本类型：undefined, null , Boolean , Number, String 这五种基本类型和一种复杂的数据类型： Object.实际上， 例如我们创建一个新的对象的时候， 创建的这个新的对象实际上是 Object 的实例。1let newObj = new Object(); 这个时候， 这个对象的原型指向的是对象的原型； 例如我们在对象上经常使用的一些对象方法例如： Object.keys, Object.values 这些方法实际上是定义在对象的原型上面的。12let obj = &#123;&#125;;obj._proto_ // Object.prototype 而对于 Object.prototype 上面，实际上也是存在一个 prototype 属性， 只不过这个属性指向的是 null;new 操作符 我们使用 new 操作符用来创造一个构造函数， 或者可以说， 我们通过使用 new 标识符号将一个普通函数转变为一个构造函数:使用 new 操作符创造构造函数的实例的时候发生的过程如下： 创建一个新对象。 将这个新对象的原型对象指向构造函数的原型 返回这个新对象。 在 高级程序设计 这本书中有这样一句话： 这两个对象( person 的实例)都有一个constructor(构造函数)属性，这个属性指向 person. 上面这句话第一次读的时候不好理解，看起来感觉像是 constructor 属性是定义在实例上面的，实际上， 这里在实例上能够获得 constructor 属性，其实这里是继承来自于构造函数的原型上面的，因为构造函数的原型上面有个 constructor 属性，这个属性指向构造函数。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>js 类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tooltip 的实现]]></title>
    <url>%2F2018%2F05%2F09%2Ftooltip-%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }在业务上实现了一个类似于 el-tooltip 的方法，类似于下面这种情况：业务需求是对于弹窗的文字标签字段， 如果文字标签说明太长的时候， 而这个时候文字标签说明又有宽度限制， 这个时候需要实现一个类似于 el-tooltip 的实现方法，但是对于每一个标签上都添加上 el-tooltip 是不现实的，因此想要通过使用指令的方法，对于表单中的标签字段进行动态添加，实现这个指令的 toolTip.js 的具体代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176// 对于出现dialog 的情况， 都是在 el-dialog__wrapper 上进行滚动的import Util from "./util";const getScrollRoot = () =&gt; &#123; return document.documentElement.querySelector(".el-dialog__wrapper");&#125;;let instancePool = [];// 定义 tip instance 方法const instanceAction = () =&gt; &#123; const push = (instance) =&gt; &#123; instancePool.push(instance); &#125;; return &#123; pushInstance: push &#125;;&#125;;// 获取到绑定元素在当前页面上距离左边的距离const getElementViewLeft = (element) =&gt; &#123; let actualLeft = element.offsetLeft; let current = element.offsetParent; while (current !== null) &#123; actualLeft += current.offsetLeft; current = current.offsetParent; &#125; return actualLeft;&#125;;// 获取到绑定元素在当前页面上位置高度const getElementViewTop = (element) =&gt; &#123; let actualTop = element.offsetTop; let current = element.offsetParent; while (current !== null) &#123; actualTop += current.offsetTop; current = current.offsetParent; &#125; return actualTop;&#125;;function tooltip(el, opt) &#123; const items = el.querySelectorAll(".el-form-item"); for (const item of items) &#123; const target = item.firstChild; // 如果定义了一个 label 为空的时候的 form-item， label 部分为 before 元素， 但是还是可以这个时候 className 为 null if (target.className) &#123; // 将每一个需要显示标签的实例信息压入 instanceAction().pushInstance(&#123; tip: null, target, message: target.innerText, offset: 0, class: "vk-tooltip" &#125;); &#125; &#125; this.scrollListener = null; this.mouseenterListener = null; this.mouseleaveListener = null; this.init(); // target：传入的DOM // this.target = el; // tip：用来放初始化创建的tip元素 // this.tip = null; // this.message = (opt &amp;&amp; opt.msg) || this.target.innerText; // this.offset = (opt &amp;&amp; +opt.offset) || 0; // this.class = "vk-tooltip"; // instanceAction.push(); // this.init();&#125;tooltip.prototype = &#123; // 初始化tip，添加事件监听 init: function () &#123; const me = this; const root = getScrollRoot(); // 鼠标进入才创建标签 for (let instance of instancePool) &#123; const &#123; target, tip, message, offset &#125; = instance; // 滚动监听事件 // 鼠标移入监听事件 // 鼠标移除监听事件 if (message.length &lt; 6) continue; this.mouseenterListener = Util.listener(target, "mouseenter", () =&gt; &#123; instance = me.createTip(instance); instance.tip.style.opacity = 1; this.scrollListener = Util.listener(root, "scroll", () =&gt; &#123; me.setTipPlace(instance.tip, instance.target, instance.offset); instance.tip.style.opacity = 0; &#125;); this.scrollListener.listen(); &#125;); this.mouseenterListener.listen(); this.mouseleaveListener = Util.listener(target, "mouseleave", () =&gt; &#123; instance.tip.style.opacity = 0; this.scrollListener.remove(); &#125;); this.mouseleaveListener.listen(); &#125; &#125;, createTip(instance) &#123; const me = this; const poppup = "&lt;div class='triangle-down'&gt;&lt;/div&gt;"; const cache = document.getElementsByClassName(instance.class); // 如果存在一个tip标签则使用该标签 instance.tip = cache.length ? cache[0] : document.createElement("div"); instance.tip.className = instance.class; instance.tip.innerHTML = `$&#123;instance.message&#125;$&#123;poppup&#125;`; document.body.appendChild(instance.tip); if (!me.tip) &#123; me.tip = instance.tip; &#125; me.setTipPlace(instance.tip, instance.target, instance.offset); return instance; &#125;, // 设置tip显示的位置 setTipPlace: function (tip, target, offset) &#123; const root = getScrollRoot(); const distance = (tip.clientWidth - target.clientWidth) / 2; const pageX = `$&#123;getElementViewLeft(target) - root.scrollLeft - distance + offset&#125;px`; const pageY = `$&#123;getElementViewTop(target) - target.clientHeight - root.scrollTop&#125;px`; tip.style.left = pageX; tip.style.top = pageY; &#125;, clear: function () &#123; instancePool = []; if (this.tip) &#123; this.tip.parentNode.removeChild(this.tip); &#125; this.mouseenterListener.remove(); this.mouseleaveListener.remove(); this.mouseenterListener = null; this.mouseleaveListener = null; this.scrollListener = null; &#125;&#125;;export default tooltip;// /**// * @description 因为el的tooltip展示需要用到组件，这里用指令进行tooltip展示// * @example &lt;div v-tips&gt;此处为被缩略的文本内容&lt;/div&gt;// * @param opt v-tips="opt" 可以传入配置对象, msg 展示信息, offset X轴偏移量// * 在元素插入DOM时，创建tooltip实例。// */// Vue.directive("tips", &#123;// bind: (el) =&gt; &#123;// console.log(el);// &#125;,// // 当绑定元素插入到 DOM 中。// inserted: (el, &#123; value &#125;) =&gt; &#123;// // 暂时针对el-form的label标签，所以指定firsChild// this.instance = new VkTooltip(el.firstChild, value);// &#125;,// // 解除绑定的时候清除实例以及标签,清除事件监听// unbind: (el) =&gt; &#123;// this.instance.clear();// &#125;// &#125;);// Util listen 函数Util.listen = (target, eventType, callback) =&gt; &#123; if (target.addEventListener) &#123; return &#123; listen: &#123; target.addEventListener(eventType, callback, false); &#125;, remove: &#123; target.removeEventListener(eventType, callback, false); &#125; &#125; &#125; else if (target.attachEvent) &#123; listen: &#123; target.attachEvent('on' + eventType, callback); &#125;, remove: &#123; target.detachEvent('on' + eventType, callback); &#125; &#125;&#125; 使用的时候， 这个函数被作为指令在 main.js 中引入：1234567891011import VKTooltip from "@/assets/js/tooltip";Vue.directive("tips", &#123; bind: (el) =&gt; &#123; &#125;, inserted: (el, &#123; value &#125;) =&gt; &#123; this.instance = new VKTooltip(el, value); &#125;, unbind: (el) =&gt; &#123; this. instance.clear(); &#125;&#125;); 关于在 vue.js 中自定义指令的使用， 可以查看vue.js 官网， 自定义指令需要注意的知识点： 对于页面元素各个位置的理解 js 基础一定要熟悉]]></content>
      <categories>
        <category>代码集</category>
      </categories>
      <tags>
        <tag>toolTip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件监听代码]]></title>
    <url>%2F2018%2F05%2F06%2F%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }简单的事件监听函数，从 N3-components 组件代码中发现的：123456789101112131415161718192021const EventListener = &#123; listen (listen, eventType, callback) &#123; // 如果存在 addEventListener if (target.addEventListener) &#123; target.addEventListener(eventType, callback, false); return &#123; remove () &#123; target.removeEventListener(eventType, callback, false); &#125; &#125; // 如果存在 attachEvent 事件 &#125; else if (target.attachEvent) &#123; target.attachEvent('on' + eventType); return &#123; remove () &#123; target.detachEvent('on' + eventType, callback); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>代码集</category>
      </categories>
      <tags>
        <tag>事件监听</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 知识总结]]></title>
    <url>%2F2018%2F04%2F29%2Fvue%20%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }在项目开发中，发现对于 vue 的使用还有一些新的认识，在这段时间中使用到的知识点做一个总结：计算属性和侦听器 在 vue.js 中，通过使用 watch 以及 computed 这两个方法来进行侦听数据的变化，但是这两种方式对于数据侦听的处理是不同的，应用的场景也是不同的， 之前应用的时候总是习惯性的时候用 watch, 但是在一些情况下，使用 comnputed 要更好一些，这里先简单的介绍这两种方法的使用， 具体可见 vue.js 官方文档：计算属性和侦听器 watch:watch侦听器相对于 computed 而言更为通用，使用 watch 用来监听数据的变化， 定义在数据变化之后的行为，基本使用用法如下：123456789101112// 监听某一个数据watch: &#123; value: function (newVal, oldVal) &#123; // some action &#125;&#125;// 监听对象中的某一个属性watch: &#123; "object.value"： function (newVal, oldVal) &#123; // some action &#125;&#125; 注意： 使用 watch 不能监听到对象的变化， 如果想要对于对象进行监听， 可以使用 deep: true:12345678watch: &#123; object: &#123; handler: function (newVal, oldVal) &#123; // somn action &#125;, deep: true &#125;&#125; 如果想要回调在监听之后立即被调用， 可以设置 immediate:true ：12345678910watch: &#123; object: &#123; // 回调函数立即被调用不管监听对象有没有被调用 handler: function (newVal, oldVal) &#123; // some action &#125;, deep: true, immediate: true &#125;&#125; computed:在有些地方， 我们使用 computed 要比单纯的监听数据的变化要方便很多， 比如下面这种情况：1234567891011121314data() &#123; person: &#123; name: "", age: "", sex: "" &#125;&#125;,computed: &#123; personMsg: function () &#123; // 这里可以监听到对象的变化 const &#123; name, age, sex &#125; = this.person; return `$&#123;name&#125; is a $&#123;age&#125; $&#123;sex&#125;`; &#125;&#125; 当上面代码中的 this.person 中的数据发生变化的时候， personMsg 就会实时的发生变化：对于 computed 的使用， 注意下面两点： 对于上面代码中的计算属性： personMsg 的取值决定于 this.person 的值， 这里计算函数实际上拦截了计算属性的 getter 函数， 计算属性可以在模版中像其他 data 中的数据一样被使用1&lt;div&gt;&#123;&#123; personMsg &#125;&#125;&lt;div&gt; 使用函数调用可以实现类似于计算属性相同的作用：不同的是计算属性可以进行缓存数据，之后只有当计算属性的依赖选项发生变化的时候， 计算属性才会求值， 如果依赖项没有发生变化，那么计算属性就不会发生再次求职。12345methods: &#123; personMsg () &#123; return this.msg; &#125;&#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue 知识总结（一）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由目录搜索想到的多叉树向二叉树的转换]]></title>
    <url>%2F2018%2F04%2F21%2F%E7%94%B1%E7%9B%AE%E5%BD%95%E6%90%9C%E7%B4%A2%E6%83%B3%E5%88%B0%E7%9A%84%E5%A4%9A%E5%8F%89%E6%A0%91%E5%90%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }目录搜索 在上个星期一轮迭代之后， 自己手上暂时还没有工作要做，在上一期迭代中， 需求表示目录太长了，用户不好操作，虽然这个问题通过添加滚动条解决了，但是我想着加一个搜索框实现对于目录的搜索， 效果如下： your browser does not support the video tag 如上面所示我们想要进行一个对于目录的搜索，其中目录部分的结构如下：123456789&#123; children: [ children: [...], title: ..., ... ], title: ..., ...&#125; 这里 title 表示目录的名字， children 表示当前目录下的子目录，如果当前目录没有子目录， 那么 children 属性就不会存在。html 部分：1&lt;el-input v-model="searchContent"&gt;&lt;/el-input&gt; vue 部分12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152export default &#123; data () &#123; searchContent: "", originMenus: "" &#125;, watch： &#123; "route": function () &#123; // 这里用来保存原始数组 this.originMenus = Util.clone(this.menus); &#125;, "searchContent": function (val) &#123; if (val.trim().length === 0) &#123; this.menus = this.originMenus; &#125; else &#123; this.filterMenus(val, this.orginMenus); &#125; &#125;, methods: &#123; filterMenus(val, menus) &#123; const filterVal = val; // 深拷贝对象 const filterMenus = Util.clone(menus); const filterFn = theMenus =&gt; &#123; if (theMenus.children) &#123; let spliceIndex = 0; // 当我们想要对于一个数组进行条件判断并且删除数组中的元素的时候， 可以使用 Array.splice 进行操作 while (spliceIndex &lt; theMenus.children.length) &#123; if (Array.isArray(theMenus.children[spliceIndex].children) &amp;&amp;theMenus.children[spliceIndex].children.length !== 0) &#123; // 这里使用递归， 因为对于children 下的各个目录， 判断条件也是基本上一样的 filterFn(theMenus.children[spliceIndex]); // 如果当前目录下存在符合条件的， spliceIndex ++ 使用 continue 跳过当前的 while 循环 if (theMenus.children[spliceIndex].children.length !== 0) &#123; spliceIndex++; continue; &#125; &#125; // 这一部分， 如何实现有选择性的删除的？ // 使用 splice 用于数组的删除，如果满足某一个条件， splice 跳过条件删除 if (theMenus.children[spliceIndex] &amp;&amp; theMenus.children[spliceIndex].title &amp;&amp; theMenus.children[spliceIndex].title.indexOf(val) &gt; -1) &#123; spliceIndex++; &#125; else &#123; theMenus.children.splice(spliceIndex, 1); &#125; &#125; &#125; &#125;; filterFn(filterMenus); return filterMenus; &#125; &#125; &#125;&#125; 在上面的代码中， 使用到了 while 循环以及一些递归的东西。由多叉树向二叉树的转换 在上面的目录搜索中，其实自己想要将目录搜索转化为二叉树进行搜索的， 只不过后面发现没有必要，但是自己也是做了一个多叉树转化二叉树的函数。二叉树 二叉树是这样的一种树： 二叉树是 n ( n &gt;=0 ) 个结点的有限集合， 该集合或者为空集( 空二叉树 ), 或者有一个根节点和两棵互不相交的， 分别称为根节点和左子树和右子树的二叉树组成。 二叉树的特点 每一个节点最多有两棵子树， 二叉树中每一个节点都是一个对象， 对于一个完整的二叉树而言， 每一个二叉树节点存在三个指针， 分别指向父母， 左孩子以及右孩子的指针， 每一个节点都是通过指针相互连接的， 连接指针的关系都是父子关系。二叉树节点的代码定义：12345678910111213141516node &#123; value: "", // 左孩子 left: &#123; left : &#123; ... &#125;, right ： &#123; ... &#125; &#125;, // 右孩子 right: &#123; ... &#125;&#125; 二叉树的遍历 对于二叉树而言， 存在三种遍历方式： 前序遍历： 首先访问根节点， 然后遍历左子树， 最后遍历右子树。 中序遍历：首先遍历左子树， 然后访问根节点，最后遍历右子树。 后序遍历：首先遍历左子树， 然后遍历右子树， 最后访问根节点。 下面是三种遍历的示意图：前序遍历：​ 代码实现：1234567function preOrder (node) &#123; if (node !== null) &#123; getNode(node); preOrder(node.left); preOrder(node.right); &#125;&#125; 中序遍历：代码实现：12345678910function inOrder (node) &#123; if (node !== null) &#123; // 先访问左子树 inOrder(node.left); // 访问根节点 getNode(node); // 访问右子树 inOrder(node.right); &#125;&#125; 后序遍历：代码实现：123456789function postOrder (node) &#123; if (node !== null) &#123; // 先访问左节点 postOrder(node.left); // 再访问右节点 postOrder(node.right); getNode(node); &#125;&#125; 使用二叉树的目的 上面说了这么多， 那么我们为什么构建二叉树呢？二叉树相对于其它的数据结构而言具有什么优点呢？ 对于数组而言， 实现数组的搜索比较方便， 可以直接使用下标访问到， 但是如果对于数组进行删除和插入就比较麻烦了， 而对于链表而言， 插入和删除比较简单， 但是访问却相对来说慢了一些。 对于有序数组而言， 对于有序数组在查找的时候有较高的效率。而无序链表在插入的时候具有较高的灵敏性。而对于二叉树而言， 二叉树综合了上面两种数据结构的优点。 二叉查找树 二叉查找数用来寻找到一组数组中的值的大小是非常有用的，因为二叉查找树在定义的时候定义到节点的左节点的值要小于右节点的值。如下使用数组建立一个二叉查找树：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 构建左节点function setLeftNode(array, node) &#123; const len = array.length; if (len % 2 !== 0) &#123; if (array[(len - 1) / 2]) &#123; node.left = &#123; value: array[(len - 1) / 2] &#125;; &#125; return; &#125; if (array[len / 2]) &#123; node.left = &#123; value: array[len / 2] &#125;; &#125;&#125;// 构建右节点function setRightNode(array, node) &#123; const len = array.length; if (len % 2 !== 0) &#123; if (array[(len - 1) / 2]) &#123; node.right = &#123; value: array[(len - 1) / 2] &#125;; &#125; return; &#125; if (array[len / 2]) &#123; node.right = &#123; value: array[len / 2] &#125;; &#125;&#125;// 将数组转化为二叉树function arrayToTree(array, node) &#123; const len = array.length; array.sort(); node.value = (len % 2) !== 0 ? array[(len - 1) / 2] : array[len / 2]; const leftArr = array.slice(0, (len % 2) !== 0 ? (len - 1) / 2 : len / 2); const rightArr = array.slice(((len) % 2) !== 0 ? (len + 1) / 2 : ((len / 2) + 1), array.length); setLeftNode(leftArr, node); setRightNode(rightArr, node); (leftArr.length !== 0) &amp;&amp; arrayToTree(leftArr, node.left); (rightArr.length !== 0) &amp;&amp; arrayToTree(rightArr, node.right); return node;&#125; 123const arr = [1, 9, 2, 6, 3, 4, 7, 8];let tree = &#123;&#125;;console.log(arrayToTree(arr, tree)); 最终结果如下：多叉树 如果一个节点下面有多个节点， 那么可以称这样的数据结构为多叉树,这里可以类比二叉树中的两个子节点：例如上面中的目录部分就是一个多叉树，根目录下面有多个子目录， 子目录下面还有可能有别的目录，如果将这样的多叉树转换为二叉树呢？只要记住一个转换原则就可以了： 多叉树向二叉树转换的原则是： 左孩子，右兄弟。也就是说，一颗转换完成的二叉树的任意一个节点的左节点都是在转换之前的多叉树中的子节点， 任意一个节点的右节点都是当前节点在转换之前的多叉树中的兄弟节点。 转化示意图如下：转化代码：123456789101112131415const treeRight = (tree, fatherChild) =&gt; &#123; if (fatherChild &amp;&amp; fatherChild.length !== 0) &#123; fatherChild.splice(0, 1); tree.right = fatherChild[0]; treeLeft(tree.right, fatherChild); treeRight(tree.right, fatherChild); &#125;&#125;;const treeLeft = (tree) =&gt; &#123; if (tree &amp;&amp; tree.children) &#123; tree.left = tree.children[0]; treeLeft(tree.left); treeRight(tree.left, tree.children); &#125;&#125;;]]></content>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vertical-align && line-height]]></title>
    <url>%2F2018%2F03%2F26%2Fvertical-align%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }vertical-align 关于 vertical-align 的字面意思是垂直居中的意思， 其中 vertical-align 有下面几种支持的属性： 值 含义 baseline(初始值) 一个元素的基线和父元素的基线对齐 sub 将元素作为一个下标，该元素的基线会相当于父元素的基线降低 super 将元素作为一个上标， 该元素的基线会相当于父元素的基线升高 top 把对齐的子元素的顶端与父元素顶端对齐。 text-top 类似于使用 text-bottom ， 将元素行内文本的顶端与父元素的顶端对齐 middle 居中对齐，常用于图像的垂直居中 bottom 将元素行内框的低端与父元素的低端对齐 text-bottom 行内文本的底端与行框的低端对齐 百分数 将元素的基线相对于父元素的基线升高或者降低指定的量， 这里的百分数是指相对于该元素的 line-height 的百分数。 length 使用 length 用于将元素升高或者降低指定的距离 inherit 从父元素下继承属性 注意：这里的 vertical-align 影响的是行内元素， 行内块元素，以及表单元格的对齐，对于 块状元素不受 vertical-align 的影响。vertical-align 作用效果在图像垂直居中的时候的作用：123&lt;div class="wrap"&gt; &lt;img class="img" alt="这是一张图片"&gt;&lt;/div&gt; 我们知道对于行内元素的垂直居中我们可以使用 line-height = height 的方法实现垂直居中的效果， 但是对于图像而言使用这种方法是失效的，例如下面的代码：12345678910.wrap &#123; width: 200px; height: 300px; line-height: 300px; background-color: blue;&#125;.img &#123; width: 50px; height: 50px;&#125; 结果如下：如上图所示， 使用 line-height = height 并不能实现对于图片的垂直居中效果，为了实现图片的垂直居中， 在 img 元素上添加 vertical-align:middle 效果， 最终效果如下：123.img &#123; vertical-align: middle;&#125; ​ 注意： 这里的 vertical-align 主要参照的是父元素的行高， 因此在设置 vertical-align: middle 的时候，需要将父元素的 line-height 设置为 父元素的 height 高度。vertical-align:middle vertical-align: middle 经常用于图像的居中， 我们要注意的一点就是，当元素设置 vertical-align: middle 的时候，这个属性会将行内元素框的中点与父元素的基线上方 0.5ex 处的一个点进行对齐， 这里的 1ex 是相对于父元素的 font-size 进行定义的，例如下面这个例子：123&lt;span class="allDemo"&gt; &lt;span class="demo1"&gt;我是一段文字&lt;/span&gt;&lt;span class="demo2"&gt;我是第二段文字&lt;/span&gt;&lt;/span&gt; 对于 demo1 进行 vertical-align: middle: 123456789101112.allDemo &#123; display: inline-block; background-color: lightslategray;&#125;.demo2 &#123; line-height: 100px; background-color: lightgreen;&#125;.demo1&#123; background-color: lightcoral; vertical-align: middle;&#125; 如上图所示， class = &quot;demo2&quot; 这段文字， vertical-align 默认是 baseline,其元素框底端是与行框的基线对齐的，demo1 相比于 demo2 元素而言， 元素下移， 这是 vertical-align: middle 之后的结果， 图示如下:如果我们将父元素的 font-size 置为0， 我们将会看到下面的情况：代码如下：123.allDemo &#123; font-size: 0px &#125;;.demo1 &#123; font-size: 16px &#125;;.demo2 &#123; font-size: 16px &#125;; vertical-align 各属性作用位置如下：line-height line-height 与 line box 之间的关系 line-height 从字面意义上来讲， 是 行高 的意思，在页面上表现出来的就是一行文字的高度， 在介绍 line-height 之前，我们先来认识一下 line boxes 和 inline boxes 这两个东西。line boxes 与 inline boxes inline boxes : 可以认为是包裹在 inline 元素外面的的一层外层， 例如 span 元素， img 图片元素等 inline 形式的元素，对于 inline 水平的元素，都会形成一层的 inline boxes 进行包裹。line boxex : 对于 line boxes 你可以认为 line boxes 用于包裹一行元素， 也就是说，对于一行 inline 水平的元素而言， 在外面有一个 line boxes 进行包裹， 如果一行有多个 inline 水平的元素，那么，这一行的 line boxes 就会包含有多个的 inline boxex。 对于 line boxes 的元素的高度， 他的高度是获取该 box 下面的所有的 inline boxes 元素的高度 ， 比较获取他们中最大的高度， 最后这个最大的高度被认为是 line boxes 的最大高度。这里 inline boxes 的高度是什么呢？ 就是今天我们要说的 line-height. 行高具体来讲就是两行文字之间基线之间的距离：如下图所示： 上面的图中红线就是表示所谓的基线， 关于我们另外一个css 的属性 vertical-align 改变的就是基线的高低大小。 使用 line-height 实现的垂直居中实现 我们经常使用 line-height = height 实现行内元素的垂直居中效果， 这里的 height ， 更为确切的说是 我们将要居中 line boxes 的高度进行居中， 因为对于行高而言具有一个垂直居中的性质。使用 line-height = height 在图片中垂直居中效果的失效。 html:123&lt;div class="demo"&gt; &lt;img src="./picture.png" alt="垂直居中的图片" class="img"&gt;&lt;/div&gt; CSS:123456789.demo &#123; display: inline-block; line-height: 150px; height: 150px; background-color: lightblue;&#125;.img &#123; height: 50px;&#125; 最终结果如下：并没有居中！对于图片元素而言， 使用 line-height = height 并不能实现元素的垂直居中，要想实现这种效果， 就需要 vertcial-align: middle 出马了。但是使用 vertical-align:middle 就能保证万无一失了吗？font-size: 0px 在图片居中时的应用 在讲解 vertical-align:middle 的时候， 我们使用 vertical-align: middle 实现了图片的垂直居中， 但是这个垂直居中只是近似的， 并不是真正的垂直居中。123&lt;div class="imgWrap"&gt; &lt;img src="img.png" class="img"&gt;&lt;/div&gt; 123456789.imgWrap &#123; line-height: 40px; background-color: lightblue;&#125;.img &#123; width: 50px; height: 30px; vertical-align: middle;&#125; 我们看到，这个时候使用 vertical-align:middle 并没有实现真正的垂直居中， 原因是什么呢？因为就如同我们刚才说的那样： 当元素设置 vertical-align: middle 的时候，这个属性会将行内元素框的中点与父元素的基线上方 0.5ex 处的一个点进行对齐 我们想要的结果是将行内元素框的中点和父元素的中点进行对齐，而使用 vertical-align 的时候并不是这样， 为了解决这个问题， 我们使用了font-size: 0这个属性。代码如下：123.imgWrap &#123; font-size: 0;&#125; 居中成功！font-size: 0px 起的作用是： 基线和中线之间的距离是根据字母 x 的高度进行计算的， 通过设置 font-size 为0， 使得 基线和中线在同一水平线上，从而使得图片元素框的中线和父元素的中线重合， 实现垂直对齐效果。 使用 vertical-align:middle 对齐的不是父元素的基线， 而是基线上面 0.5ex 这样一个高度的点， 但是这个高度是由父元素的 font-size 来决定的， 这样就将这个高度置为 0 ， 从而使得图片中线和父元素基线对齐。 参考链接 张鑫旭：css行高line-height的一些深入理解及应用]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>vertical-align &amp;&amp; line-height</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阅读函数式编程（一）]]></title>
    <url>%2F2018%2F03%2F20%2F%E9%98%85%E8%AF%BB%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }函数式编程的定义 在 javascript 中， 函数被作为一等公民， 属于内置对象, 函数是对象中的一个子类型， 因此， 函数可以当作参数传递， 可以放到数组之中，本质上和普通的对象是一样的， 只不过相对于普通的对象而言， 函数可以被调用， 因此可以被称作可调用的对象。 在 js 中， 存在下面几种内置对象： String Number Boolean Object Function Array Date Regexp Error 这几种内置对象相当于语言中的类，可以通过使用 new 操作符进行调用。 使用函数式编程的目的在于： 我们希望去践行每一部分都能完美接合的理论，希望能以一种通用的、可组合的组 件来表示我们的特定问题，然后利用这些组件的特性来解决这些问题。 使用纯函数 什么是纯函数， 在介绍纯函数之前， 我们先看下关于纯函数的概念： 纯函数是这样一种函数，即相同的输入， 永远只能得到相同的输出，而且没有任何可以观察到的副作用。 对于有些函数而言，在函数执行的过程中发生了一些可能会影响外部状态的副作用， 包括下面几种： 外部状态发生了改变 读取文件 console.log 数据 发送请求 总而言之， 在函数执行的过程中， 函数与外部环境发生了交互的过程，代表这个函数存在副作用， 存在副作用的不纯函数容易产生 bug, 数据状态难以追踪， 并且增加我们的认知负荷， 因此， 在函数编写的过程中要尽量较少函数执行的时候对于外部环境的影响。 这里对于纯函数而言， 相同的输入总会得到相同的输出， 这里类似于数学中的函数的概念， 在数学中的函数的概念中， 存在一个映射的改变： 函数只是两种数值之间的关系， 尽管相同的输入只能得到相同的输出， 但是不同的输入也可以得到相同的输出 因为在纯函数中，相同的输入只能得到相同的输出， 因此对于输入值是一定的情况下，对于输出的值则是一定的， 这样的情况下， 我们所要关心的只是这个函数做了什么，而不同尽力了解函数实现的具体细节， 这样能够增强我们调试代码的便利性。使用纯函数的好处 可缓存性简单的一段代码如下：12345678910111213let squareNumber = memorize(function (x) return &#123; x*x &#125;);squareNumber(4) =&gt; 16;squareNumber(4) =&gt; 16; // 从缓存中获取到的值// memorize 函数如下function memorize(f) &#123; let cacheData = &#123;&#125;; return function() &#123; let arg = JSON.stringify(arguments); cacheData[arg] = cacheData[arg] || f.apply(f, arguments); return cacheData[arg]; &#125;&#125; 上面的这种纯函数的可缓存性类似于在 js 中的闭包的效果， 可以将值保存在函数内部。 依赖明确， 易于调试对于纯函数而言， 函数的依赖都是写在函数参数之中的， 更便于我们理解与调试， 对于纯函数而言， 与外部函数发生作用的仅仅是定义中传入的参数，函数内部则不会涉及到关于外部环境的变量。 引用透明性 如果一段代码可以替换成它执行之后得到的结果， 而且是在不改变整个程序行为的情况下被替换的， 那么， 我们说这段函数具有引用透明性。 例如对于类似下面这类的代码：12345678910111213141516function isNewUser() &#123; // 判断是否是新用户&#125;function loginIn(user) &#123; // 用户登录&#125;function register(user) &#123; // 注册新用户&#125;function start(user) &#123; if (isNewUser(user)) &#123; register(user); return; &#125; loginIn(user);&#125; 在上面的代码中， 三个行为， 判断是否是新用户， 登录， 注册， 三个部分的逻辑封装在三个函数中， 从而更容易理解。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器渲染过程]]></title>
    <url>%2F2018%2F03%2F13%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }浏览器渲染过程以及原理 浏览器渲染的过程 对于浏览器而言， 浏览器请求， 加载， 渲染一个页面的时候，所要花费的时间主要在下面几个过程中: DNS 查询（DNS 根据服务器地址查找到IP地址） TCP 连接（用于连接客户端与服务器， 包含三次握手，四次挥手的过程） HTTP 请求以及响应（请求响应数据） 服务器响应（后端响应数据） 客户端渲染 对于第五个部分客户端渲染的过程中， 这一部分过程主要是渲染树的构建，布局，以及绘制， 具体而言， 主要是下面几个过程： 处理 HTML 标记并且构建 DOM 树。 处理 CSS 标记并且构建 CSSOM 树。 将 DOM 以及 CSSOM 合并为一个渲染树。 根据渲染树进行布局,以计算每个节点的几何信息。 将各个节点绘制到屏幕上去。 在上面的过程中，如果DOM或者CSSOM被修改,那个这个过程需要重复执行，重新在屏幕上进行渲染。阻塞渲染 在一个网页中， CSS被视为阻塞性的资源， 当 CSSOM 被构建的时候， 其他的内容将不会被处理， 因此， 只有当 CSSOM 构建完毕之后其他内容才可能被加载。对于 javascript 也是类似的效果， 当浏览器遇到一个 script 标记的时候，DOM 构建将会暂停，知道脚本完成执行。使用 javascript 可以改变 DOM 以及 CSSOM， 而当 DOM 或者 CSSOM 被改变的时候， 这两个树均会重新进行绘制， 对于 CSSOM 因为是阻塞性资源, 在构建的时候， JavaScript 将会延迟执行， 直到CSSOM 构建完毕。在实际使用的时候应该遵循下面两个原则： CSS资源要优于JavaScript 资源进行加载。 尽量避免使用 JavaScript 进行DOM 的操作。 解决渲染阻塞的几种方法 CSS 对于 CSS 而言， 浏览器解析 CSS 用于创建 CSSOM 树， 因此在 CSS 编写的过程中要注意对于 CSS 解析速度的影响： 提高CSS页面的加载速度提高页面的加载速度主要是通过将样式尽量写在单独的文件里面， 将 CSS样式作为单独的文件进行引入， 这样做的目的不仅仅是减少页面体积， 并且可以利用 CSS 文件的缓存以及重用， 提高文件的加载速度。少用 @import 用于引入 CSS 文件, 使用 @import 会影响 CSS 文件的加载速度。 加快解析速度， 提高解析性能。减少css 样式的嵌套层数， 对于 CSS 的嵌套层数尽量不要超过三层, 过多的嵌套层数会影响到CSS的解析速度。]]></content>
      <tags>
        <tag>浏览器渲染</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this.nextTick in vue.js]]></title>
    <url>%2F2018%2F01%2F21%2Fthis-nextTick-in-vue-js%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }this.nextTick 的作用 在 Vue.js 的官方文档中是这样描述 this.nextTick 的: 为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用. 在 vue.js 中, 使用 this.nextTick 的作用是更新 dom , 在 涉及关于在 vue.js 中 Dom 的操作中, 当我们想要操作被更新后的 DOM的时候，可以使用 this.nextTick 进行操作。为什么采用 this.nextTick Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。 使用 this.nextTick 的两种情况: 在 created 阶段的时候， 这个时候 DOM 元素尚未挂载, 在这个钩子函数内操作 DOM 是无法找到 DOM 元素的， 这个时候使用 this.nextTick 类似于使用 mounted 的钩子函数， 这个时候所有的 DOM 元素挂载和渲染均已经完成，这个时候可以执行对于 DOM 元素的操作。 当我们想要对于数据发生变化之后的 DOM 元素之后执行一些操作的时候， 我们可以使用 this.nextTick(callback) 那么 callback 回调函数就会当 DOM 元素被更新之后被触发。 ​ 上图是 vue 实例的生命周期图。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>this.nextTick</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 中数据结构的实现]]></title>
    <url>%2F2018%2F01%2F13%2Fjs-%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }对于线性表而言， 使用链式的存储结构可以提高相对于使用线性表添加和删除节点的操作效率。 对于链表中的每一个元素，除了需要存储其本身的信息之外，还需要存储一个显示后面元素位置的信息。单链表的实现 实现单向链式列表的代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140function LinkedList() &#123; // 对于链表中的元素包含有 element 以及 next // element 表示数据 // next 表示指向下一个的指针 let Node = function (element) &#123; this.element = element; this.next = null; &#125;; let length = 0, head = null; // append 添加元素 this.append = function (element) &#123; let node = new Node(element), current; if (!head) &#123; head = node; &#125; else &#123; current = node; // 使用 while 进行循环操作 // 一直进行循环, current = current.next; while (current.next) &#123; current = current.next; &#125; current.next = node; &#125; length++; return current; &#125;; // this.insert 用于插入节点 this.insert = function (position, element) &#123; if (position &gt; 0 &amp;&amp; position &lt;= length) &#123; let node = new Node(element), currrent = head, previous, index = 0; if (position === 0) &#123; node.next = current; head = node; &#125; else &#123; while (index++ &lt; position) &#123; previous = current; current = current.next; &#125; node.next = current; previous.next = node; &#125;; length++; return true; &#125; else &#123; return null; &#125; &#125;; // 删除某一个位置处的元素 this.removeAt = function (position) &#123; if (position &gt; -1 &amp;&amp; position &lt; length) &#123; let current = head, previous, index = 0; if (position === 0) &#123; head = currrent.next; &#125; else &#123; while (index++ &lt; position) &#123; previous = current; current = current.next; &#125; // 在删除了某一个元素之后 // previous.next 指向 current.next previous.next = current.next; &#125;; length--; return current.element; &#125; else &#123; return null; &#125; &#125;; // 移除某一个节点 this.remove = function (element) &#123; let current = head, previous; if (element === current.element) &#123; head = current.next; length--; return true; &#125; previous = current; current = current.next; while(currrent) &#123; if (element === current.element) &#123; previous.next = current.next; length--; return true; &#125; else &#123; // 继续轮询下一个元素 previous = current; current = current.next; &#125; &#125; return false; &#125;; // this.remove 用于删除最后一个节点 this.remove = function () &#123; if (length &lt; 1) &#123; return false; &#125; let current = head, previous; if (length === 1) &#123; head = null; length--; return current.length; &#125; while(current.next !== null) &#123; previous = current; current.current.next; &#125; previous.next = null; length--; return current.element; &#125;; // indexOf 获取到索引值 this.indexOf = function (element) &#123; let current = head, index = 0; while(current) &#123; if (element === current.element) &#123; return index; &#125; index++; current = current.next; &#125; return false; &#125;; this.isEmpty = function () &#123; return length === 0; &#125;; this.size = function () &#123; return length; &#125;; this.toString = function () &#123; let current = head, str = ''; while(current) &#123; str+= current.element; currrent = current.next; &#125; return str; &#125; this.getHead = function () &#123; return head; &#125;&#125; 对于线性表的链式存储结构而言，链表中每一个节点包含数据域与指针域，相对于使用线性表的顺序存储结构而言， 在链表中数据的存储是没有特定的顺序的，在链表中， 节点之间的关系是通过其本身存储的指针来进行体现的。 指针表示的是线性表中的数据元素与数据元素之间的关系。 对于链表而言，我们想要获取到第 i 个元素的值比较麻烦的， 因为对于第 i 个元素 a i 的存储地址放在了链表中上一个节点中的指针域中，同理， 这个节点的存储地址有被放在了上上一个节点中的指针域中.....，如果要查找到这个元素，要使用下面的算法: 声明节点指向链表的第一个节点， 初始化 j 从 1 开始。 当 j &lt; i 的时候，遍历链表， 使 p 的指针向后移动， 不断指向下一个节点， j 累加 1; 如果链表末尾为空， 那么说明第 i 个元素不存在。 如果查找成功的话，返回查找到的数据。 对于上面的单链表程序而言， 我们可以添加一个获得相关位置的元素的方法:123456789101112131415this.getEle = function (elementIndex) &#123; let current = head, index = 0; if (elementIndex &gt; 0 &amp;&amp; elementIndex &lt;= length) &#123; // while 内嵌 current = current.next 方法， 从头开始查询 while(current) &#123; if (index === elementIndex) &#123; return current.element; &#125; index++; current = current.next; &#125; &#125; else &#123; return null; &#125;&#125; 链表的使用相对于使用线表而言, 对于链表之间的数据关系是通过使用指针进行体现的 实现一个对象链表的实现；12345678910111213141516171819202122function linkTable(array) &#123; let linkArray = []; const getLinks = (now, index, arr) =&gt; &#123; const len = arr.length; let pre = 0; let next = 0; pre = index - 1; next = index + 1; if (index === 0) &#123; pre = len - 1; &#125; if (index === len - 1) &#123; next = 0; &#125; linkArray.push(&#123; pre: arr[pre], current: now, next: arr[next] &#125;); &#125;; array.forEach((now, index, arr) =&gt; getLinks(now, index, arr));&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>js 链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js Timers]]></title>
    <url>%2F2017%2F12%2F19%2Fnode-js-Timers%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }Timers APIS setImmediate(callback, args) callback : 在 node.js 事件循环之后被调用的函数。 args: 当 callback 函数被调用的时候传递的参数。 在 I / O 事件回调时间之后立即执行 callback 回调函数的执行。如果 callback 不是一个 function , 会抛出一个 TypeError 错误。123456setImmediate(function () &#123; console.log('事件稍后被执行');&#125;);console.log('事件立即被执行');// 事件立即被执行// 事件稍后被执行 setInterval(callback, delay, args) 使用 setInterval 类似于使用 setInterval 方法, 在一定的时间间隔 delay 之后执行 callback 函数。 在官方给的例子中存在使用 util.promisly() 的一个变体。123456const util = require('util');const setTimeoutPromise = util.promisify(setTimeout);setTimeoutPromise(4000, 'foobar').then((value) =&gt; &#123; console.log(value);&#125;);// after delay print 'foobar' canceling Timers 使用 setImmediate setInterval 以及 setTimeout 每一个方法都会返回一个代表排列事件的对象, 这些能够用来取消 timer 防止被触发的操作。 clearImmediate, clearInterval, clearTimeout 用来清除通过使用 setImmedidate setInterval 以及 setTimeout 创建的定时器。12345678910let immidate = setImmediate(function () &#123; console.log('事件之后被调用');&#125;);clearImmediate(immidate);// 清除事件， 事件之后不会调用clearInterval();// 清除间隔时间后的调用clearTimeout();// 清除一段时间之后的调用]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>Timers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js EventEmitter]]></title>
    <url>%2F2017%2F12%2F17%2Fnode-js-EventEmitter%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }EventEmitter 基本构建 许多的 node.js 核心的 API 是围绕事件异步模型进行构建的，特定种类的事件对象会周期性的触发命名的函数对象，从而导致函数对象被触发。 这些函数对象被称作 listeners;所有的触发事件的对象属于 EventEmitter 类， 这些对象暴露有 emit 以及 on 方法。12345678let eventEmitter = require('events');let myEmitter = new eventEmitter();// listenersmyEmitter.on('event', () =&gt; &#123; console.log('event');&#125;);// emittersmyEmitter.emit('event'); // event 向 lisitens 传递 arguments 以及 this 值 1234567myEmitter.on('event', function (msg) &#123; console.log(`my name is $&#123;msg&#125;`); console.log('被传递的值', this);&#125;);myEmitter.emit('event', '张宁宁');// my name is 张宁宁// this 值指向的值是 eventEmitter 对象 handle event only once 使用 once 函数的时候, 当使用 emit 的时候只会被触发一次123456myEmitter.once(&apos;event&apos;, () =&gt; &#123; console.log(&apos;事件被触发一次&apos;);&#125;);myEmitter.emit(&apos;event&apos;);// &apos;事件触发一次&apos;myEmitter.emit(&apos;event&apos;); some API Event: newListener 在监听器被加入到监听器队列之前，EventEmitter 实例会触发自己的 newListener 事件。123456789101112131415const myEmitter = new EventEmitter();myEmitter.once('newListener', (event, listener) =&gt; &#123; if (event === 'event') &#123; myEmitter.on('event', () =&gt; &#123; console.log('B'); &#125;); &#125;&#125;);myEmitter.on('event', () =&gt; &#123; console.log('A');&#125;);myEmitter.emit('event');// B// A// 在触发 'event' 事件的时候先要触发事件 B 在触发事件 A EventEmitter.listenerCount(emitter, eventName) 用来获得在 emitter 上面注册的 eventName 的次数。1234let myEmitter = new EventEmitter();myEmitter.on('event', () =&gt; &#123;&#125;);myEmitter.on('event', () =&gt; &#123;&#125;);console.log(EventEmitter.listenerCount(myEmitter, 'event')); // 2 emitter.eventNames() 用来获得 emitter 上面注册的 listeners 的事件列表。 1234let myEmitter = new EventEmitter();myEmitter.on('a', () =&gt; &#123;&#125;);myEmitter.on('b', () =&gt; &#123;&#125;);console.log(myEmitter.eventNames); // ['a', 'b'] emitter.listenerCount(eventName) eventName : the name of the event being listened for作用和 EventEmitter.listenerCount(emitter, eventName) 是相同的。 emitter.listeners(eventName) 用于获得 emitter 上 eventName 事件的注册函数。1234567let myEmitter = new EventEmitter();myEmitter.on('event', () =&gt; &#123;&#125;);myEmitter.on('event', () =&gt; &#123;&#125;);// 使用 emitter.listeners(eventName)// 用于获得 emitter 上面的 eventName 上注册的函数console.log(myEmitter.listeners('event'));// [[Function], [Function]] emitter.on(eventName, listener) 向一个被称作 eventName 的事件listener 的列表之中添加事件， 添加的事件被添加到 listener 列表的末尾。 注意，在添加事件的时候， 添加的事件只会按照顺序添加到时间列表数组的末尾，在这个过程中，不会进行判断事件是否已经添加了。emitter.prependListener(eventName, listener) 将 listener function 添加到事件队列的开头1234567891011121314myEmitter.on('otherEvent', () =&gt; &#123; console.log('第一次');&#125;);myEmitter.prependListener('otherEvent', () =&gt; &#123; console.log('第三次');&#125;);myEmitter.on('otherEvent', () =&gt; &#123; console.log('第二次');&#125;);myEmitter.emit('otherEvent');// 第三次// 第一次// 第二次 emitter.prependOnceListener(eventName, listener) 仅仅添加一次运行的函数到事件队列开始，第二次调用的时候会被移除emitter.removeAllListeners([eventName]) 移除 eventName 事件上的所有函数。 emitter.removeListener(eventName, listener) removes the specified listener from the listener array for the event named eventName 使用 removeListener 的时候将会移除事件队列中至多一个instance (实例), 如果一个 单独的监听器被多次添加，那么使用 removeListener 需要多次调用才能被多次删除。 从被称作 eventName 的事件队列中移除掉特定的事件函数。注意: 一旦时间被触发的时候, 在触发的时刻所有与之相关联的 listeners 将会被调用， 这表明， 在 listeners 被 emit 之后，在 listeners 中的最后一个函数被执行之前， 使用 removeListenr() 或者 removeAllListeners 都不会起作用 也就是说， 使用使用移除事件的时候是不会在 listeners 函数执行的过程中被调用的。 例子如下:12345678910111213141516const callBackA = () =&gt; &#123; console.log('A'); myEmitter.removeListener('callback', callBackB);&#125;;const callBackB = () =&gt; &#123; console.log('B');&#125;;myEmitter.on('callback', callBackA);myEmitter.on('callback', callBackB);myEmitter.emit('callback'); // 这一次调用的时候是不会移除掉 B 的myEmitter.emit('callback');// 这一次调用的时候移除掉了 B// A B AmyEmitter.listeners() // [[Function: callbackA]] 因为对于 listeners 而言, 是通过使用内部的数组进行管理的, 当其中的 listener 被移除之后，会改变每一个注册的 listern 位置， 但是不会影响 listener 被调用的顺序， 但是通过使用 emitter.listeners() 返回的调用函数数组队列将会发生变化。]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>EventEmitter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js 源码分析(十六)]]></title>
    <url>%2F2017%2F12%2F16%2Funderscore-js-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E5%85%AD%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }underscore.js 源码分析(十六) isEmpty isEmpty(object) isElement ``如果 object 是一个空对象， 或者 object 是一个字符串或者数组, 并且字符串或者数组的 length 为 0; 返回 true,否则, 返回 false.示例 12_.isEmpty(&#123;&#125;); // true_.isEmpty(&#123; name: '张宁宁' &#125;); // false 源码分析 123456789/** @description isEmpty 用来判断 Obj 是否为空*/function isEmpty (obj) &#123; if (obj == null) return true; if (isArray(obj) || isString(obj) || isArguments(obj)) return obj.length === 0; for (let key in obj) if (has(obj, key)) return false; return true;&#125; isElement isElement(obj)如果 obj 是一个 dom 元素, 返回为 true;对于 dom 元素 nodeType === 112345function isElement(obj) &#123; // 如果 obj 以及 obj.nodeType === 1 // 表示 obj 是一个节点对象 return !!(obj &amp;&amp; obj.nodeType === 1);&#125;; 判断函数 使用判断函数用于判断函数的类型, 例如: isArray isObject isArguments isFunction isString isNumber ....实现上面这几种方法的判断是使用 Array.prototype.toString.call 的方法进行判断的:源码分析 123456_.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function (name) &#123; _.['is' + name] = function (obj) &#123; // 通过使用 toString.call 来决定判断是属于哪一种类型 return toString.call(obj) === `[object $&#123;name&#125;]`; &#125;&#125;) 对于其他几个的判断:isObject 1234_.isObject = function (obj) &#123; let type = typeof obj; return type === 'function' || type === 'object' &amp;&amp; !!obj;&#125;; isFinite 用来判断给定的对象是否属于一个无限的数。 123_.isFinite = function () &#123; return isFinite(obj) &amp;&amp; !isNaN(parseFloat(obj));&#125; isNaN 用来判断给定的值是否是 NaN 值, NaN is the only number which does not equal itself (NaN 是唯一一个和他自身不等的值) 12345_.isNaN = function(obj) &#123; // NaN !== NaN // NaN 是一个数字 return _.isNumber(obj) &amp;&amp; obj !== +obj;&#125; isBoolean 用于判断是否是一个布尔值;123_.isBoolean = function(obj) &#123; return obj === true || obj === false || toString.call(obj) === '[object, Boolean]';&#125; isNull 123_.isNull = function (obj) &#123; return obj === null;&#125; isUndefined 1234_.isUndefine = function (obj) &#123; // 这里通过使用 void 0 来代替 undefined 值 return obj === void 0;&#125;]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js 源码分析(十五)]]></title>
    <url>%2F2017%2F12%2F14%2Funderscore-js-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E4%BA%94%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }underscore.js 源码解析( 十五 ) clone tap has matcher property propertyOf isEqualclone _.clone(object) 创建一个浅拷贝的 object 使用 _.clone 的源码如下:12345_.clone = function (obj) &#123; if (!.isObject(obj)) return obj; // 对于 obj 是对象的, 分为数组和对象两种形式 return isArray(obj) ? obj.slice() : _.extend(&#123;&#125;, obj);&#125; tap _.tap(object, interceptor) interceptor 拦截器 使用 interceptor 的作用是用于对于传入的对象 object 进行 interceptor 操作, 并且操作完成之后返回 object 本身。用于链式调用: 123456_.tap = function (obj, interceptor) &#123; // 对于对象应用 interceptor 函数作用 interceptor(obj); // 返回这个对象 return obj;&#125; has _.has(object, key)用于判断对象是否包含有特定的属性 key , 在源码中有这样一句话, 等同于object.hasOwnProperty(key)，但是使用hasOwnProperty 函数的一个安全引用，以防意外覆盖。什么是意外覆盖? 源码分析如下:123_.has = function(obj, key) &#123; return obj != null &amp;&amp; hasOwnProperty.call(obj, key);&#125;; matcher matcher(attrs)使用 matcher 函数是一个断言函数, 返回一个 true or false 来判断给定的对象中是否含有 attrs 中指定的键值对儿示例:12345let list = &#123; selected: true&#125;let hasSelected = _.matcher(&#123;selected: true&#125;);hasSelected(list); // true 源码分析 源码如下:123456_.matcher = _.matches = function(attrs) &#123; attrs = _.extendOwn(&#123;&#125;, attrs); return function (obj) &#123; return _.isMatch(obj, attrs); &#125;&#125; 其中 _.isMatch 源码如下:12345678910111213_.isMatch = function (object, attrs) &#123; let keys = _.keys(attrs), length = keys.length; if (object === null) return !length; let obj = Object(object); for (let i = 0; i &lt; length; i++) &#123; let key = keys[i]; //如果 attrs 中的值和 obj 中的值不相等， 或者 key 不属于 obj 中 // 返回 false if (attrs[key] !== obj[key] || !(key in obj)) return false; &#125; // 返回 true return true;&#125; property property(key) 该方法返回一个函数，返回传入该函数的任何对象的 key 属性。 源码 12345let property = function (key) &#123; return function (obj) &#123; return obj === null ? void 0 : obj[key]; &#125;&#125; propertyOf 使用 propertyOf 与使用 property 相反。 propertyOf(object) 传入一个对象， 返回一个函数，这个函数接收一个属性，返回对象对应属性的值。使用 propertyOf 12345_.propertyOf = function (obj) &#123; return obj == null ? function () &#123;&#125; : function (key) &#123; return obj[key]; &#125;&#125; isEqual isEqual(object, other) 使用 isEqual 用来判断两个对象是否相等。 因为不同的对象被放在了不同的内存空间中, 因此， 即使是属性和值均相等的对象也是不相同的, 如果对象的属性和值都是相同的，使用 isEqual 返回的是 true12&#123;&#125; == &#123;&#125; // false_.isEqual(&#123;&#125;, &#123;&#125;); // true 在源码中使用 equal 进行判断:123_.equal = function (a, b) &#123; return eq(a, b);&#125; 使用 eq 进行判断的源码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293var eq = function(a, b, aStack, bStack) &#123; // Identical objects are equal. `0 === -0`, but they aren't identical. // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal). if (a === b) return a !== 0 || 1 / a === 1 / b; // A strict comparison is necessary because `null == undefined`. // 如果 a 或者 b === undefined 返回 a === b if (a == null || b == null) return a === b; // Unwrap any wrapped objects. if (a instanceof _) a = a._wrapped; if (b instanceof _) b = b._wrapped; // Compare `[[Class]]` names. var className = toString.call(a); // 如果 a 的对象的类型不同于 b 的对象的类型， 返回的是 false if (className !== toString.call(b)) return false; switch (className) &#123; // Strings, numbers, regular expressions, dates, and booleans are compared by value. case '[object RegExp]': // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i') case '[object String]': // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is // equivalent to `new String("5")`. return '' + a === '' + b; case '[object Number]': // `NaN`s are equivalent, but non-reflexive. // Object(NaN) is equivalent to NaN // 当 a 是 NaN 的时候, 如果 b 也是 NaN 那么 !b !== b // false if (+a !== +a) return +b !== +b; // An `egal` comparison is performed for other numeric values. // 判断 +a === 0 ? return +a === 0 ? 1 / +a === 1 / b : +a === +b; case '[object Date]': case '[object Boolean]': // Coerce dates and booleans to numeric primitive values. Dates are compared by their // millisecond representations. Note that invalid dates with millisecond representations // of `NaN` are not equivalent. return +a === +b; &#125; var areArrays = className === '[object Array]'; // 如果不是一个数组 if (!areArrays) &#123; if (typeof a != 'object' || typeof b != 'object') return false; // Objects with different constructors are not equivalent, but `Object`s or `Array`s // from different frames are. var aCtor = a.constructor, bCtor = b.constructor; if (aCtor !== bCtor &amp;&amp; !(_.isFunction(aCtor) &amp;&amp; aCtor instanceof aCtor &amp;&amp; _.isFunction(bCtor) &amp;&amp; bCtor instanceof bCtor) &amp;&amp; ('constructor' in a &amp;&amp; 'constructor' in b)) &#123; return false; &#125; &#125; // Assume equality for cyclic structures. The algorithm for detecting cyclic // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`. // Initializing stack of traversed objects. // It's done here since we only need them for objects and arrays comparison. aStack = aStack || []; bStack = bStack || []; var length = aStack.length; while (length--) &#123; // Linear search. Performance is inversely proportional to the number of // unique nested structures. if (aStack[length] === a) return bStack[length] === b; &#125; // Add the first object to the stack of traversed objects. aStack.push(a); bStack.push(b); // Recursively compare objects and arrays. if (areArrays) &#123; // Compare array lengths to determine if a deep comparison is necessary. length = a.length; if (length !== b.length) return false; // Deep compare the contents, ignoring non-numeric properties. while (length--) &#123; if (!eq(a[length], b[length], aStack, bStack)) return false; &#125; &#125; else &#123; // Deep compare objects. var keys = _.keys(a), key; length = keys.length; // Ensure that both objects contain the same number of properties before comparing deep equality. if (_.keys(b).length !== length) return false; while (length--) &#123; // Deep compare each member key = keys[length]; if (!(_.has(b, key) &amp;&amp; eq(a[key], b[key], aStack, bStack))) return false; &#125; &#125; // Remove the first object from the stack of traversed objects. aStack.pop(); bStack.pop(); return true; &#125;; eq 函数 使用 eq 函数进行比较的时候，进行比较的值有下面几种情况: 处理传递进比较的数值出现 0 === -0 的情况。这种情况用于单个数值的比较 因为 a === -0 但是他们是不相同的。 123// 当 a !== 0 || 1/a === 1 / b// 因为 1 / a === 1 / b (Infinity === -Infinity) // falseif (a === b) return a !== 0 || 1 / a === 1 / b; 处理 null == undefined 的情况 12// 当 a == null 或者 b == null 的时候， 返回 a === bif (a == null || b == null) return a === b; 使用 Object.toString 进行判断属于 Object 的哪一种类型。123456789101112131415let className = toString.call(a);// 类型不同, 返回 falseif (className !== toString.call(b)) return false;switch (className) &#123; case '[object RegExp]': case '[object String]': return '' + a === '' +b; case '[object Number]': // 使用 NaN 进行比较 if (+a !== +a) return +b !== +b; return +a === 0 ? 1 / +a === 1 / b : +a === +b; case '[object Date]': case '[object Boolean]': return +a === +b;&#125; 对于数组和对象的之间进行比较，需要深度比较当不是数组， 对象的情况:12345678910111213141516171819var areArrays = className === '[object Array]';if (!areArray) &#123; if (typeof a !== 'object' || typeof b !== 'object') return false; var aCtor = a.constructor, bCtor = b.constructor; // 如果 aCtor !== bCtor if (aCtor !== bCtor &amp;&amp; !(_.isFunction(aCtor) &amp;&amp; aCtor instanceof aCtor &amp;&amp; _.isFunction(bCtor) &amp;&amp; bCtor isntanceof bCtor) &amp;&amp; ('constructor' in a &amp;&amp; 'constructor' in b)) &#123; return false; &#125;&#125;let length = aStack.length;while(length--) &#123; if (aStack[length] === a) return bStack[length] === b;&#125;// 将 a 压入到 aStack 数组中// 将 b 压入到 bStack 数组中// aStack bStack 主要用于多重数组的情况aStack.push(a);bStack.push(b); 进行比较对象或者数组:12345678910111213141516171819202122// 比较数组if (areArrays) &#123; length = a.length; if (length !== b.length) return false; while (length--) &#123; if (!eq(a[length], b[length], aStack, bStack)) return false; &#125;&#125; else &#123;// 比较对象 let keys = _.keys(a), key; length = keys.length; // 如果两个对象的属性数目不相同 返回 false 不用进行深度遍历 if (_.keys(b).length !== length) return false; while (length--) &#123; key = keys[length]; if (!(_.has(b, key) &amp;&amp; eq(a[key], b[key], aStack, bStack))) return false; &#125;&#125;// 将存入的元素进行弹出aStack.pop();bStack.pop();return true; ​​]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js源码分析(十四)]]></title>
    <url>%2F2017%2F12%2F12%2Funderscore-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }underscore.js 源码分析(十四) extend extendOwn pick omit defaultextend _.extend(destination, *sources)将多个对象 souces 覆盖到 destination 上面，返回被覆盖掉的 destination 上面。使用 extend 类似于使用 Object.assign 用来将多个对象进行合并。自己写的代码如下:1234567891011function extend(destination) &#123; let sources = Array.prototyep.slice.call(arguments, 1); let len = sources.length; for (let i = 0; i &lt; len; i++) &#123; let currrentSource = sources[i]; let key = _.keys(currentSource); for (let index = 0; index &lt; keys.length; index++) &#123; destination[keys[index]] = currentScource[keys[index]]; &#125; &#125;&#125; 源码分析:1234567891011121314151617181920let createAssigner = function (keysFunc, undefinedOnly) &#123; return function (obj) &#123; let length = arguments.length; // 进行边界处理 // 当传入一个参数的时候或者 obj === null 的时候, 返回 obj if (length &lt; 2 || obj === null) return obj; for (let index = 1; index &lt; length; index++) &#123; // 需要对于额外传入的参数进行循环的时候使用 arguments[index] 进行获得 let source = arguments[index]; keys = keysFunc(source); l = keys.length; for (let i = 0; i &lt; l; i++) &#123; let key = keys[i]; // 这里面使用了 undefinedOnly 如果 undefinedOnly 是 true 的时候 // 接下来判断 obj[key] 是否为 undefined(void 0) if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key]; &#125; &#125; &#125;&#125; extendOwn 使用 extendOwn 实现的效果类似于使用 extends, 实现的效果是只是复制自己的属性到目标对象。_.extendOwn(destination, *source)复制 source 属性的值到 destination 只是复制自身的属性。(不包括继承的属性)这个函数与 _.extend 的不同之处在于不会将 source 对象中继承到的属性复制到 destination 之中。使用 extendOwn 与 extend 的不同在于: 源码不同1234// 使用 _.allKeys 获得到包括自身和继承得到的属性_.extend = createAssigner(_.allKeys);// 使用 extendOwn 获得到仅仅包括自身的属性_.extendOwn = _.assign = createAssigner(_.keys); pick _.pick(object, *keys) 使用这个属性用于返回 object 副本, 过滤出 keys(有效的键组成的数组) 参数指定的属性值，或者接受一个判断函数，指定挑选哪一个 key使用 pick 的源码如下。123456789101112131415161718192021222324252627_.pick = function(object, oiteratee, context) &#123; let result = &#123;&#125;, obj = object, iteratee, keys; if (obj == null) return result; // 如果 oiteratee 是一个函数的话 if (_.isFunction(oiteratee)) &#123; // 使用 _.allKeys 获得到 obj 中的所有键 keys = _.allKeys(obj); iteratee = optiomizeCb(oiteratee, context); &#125; else &#123; // 如果 oiteratee 不是一个函数的时候 // 表示这时候用于筛选出对象 object 中包含 keys 的内容 // 效果是相同于 Array.prototype.slice.call(arguments, 1); 相识 keys = flatten(arguments, false, false, 1); // 返回在 obj 中的 key iteratee = function(value, key, obj) &#123; return key in obj; &#125;; obj = Object(obj); &#125; for (let i = 0; length = keys.length; i &lt; length; i++) &#123; let key = keys[i]; let value = obj[key]; // 这里通过使用不同的函数来实现对于不同情况下的处理条件 // 通过改变 iteratee 函数的不同来实现不同的处理流程 // if (iteratee(value, key, obj)) if (iteratee(value, key, obj)) result[key] = value; &#125; return result;&#125; 上面中有一个 flatten 函数, 使用 flatten 函数的目的是将多层嵌套的数组转化为一维数组。flatten源码:1234567891011121314151617let flatten = function(input, shallow, strict, startIndex) &#123; let output = [], idx = 0; for (let i = startIndex || 0, length = getLength(input); i &lt; length; i++) &#123; let value = input[i]; if (isArrayLike(value) &amp;&amp; (_.isArray(value) || _.isArguments(value))) &#123; if (!shallow) value = flatten(value, shallow, strict); let j = 0; len = value.length; output.length += len; while (j &lt; len) &#123; output[idex++] = value[j++]; &#125; &#125; else if (!strict) &#123; output[idx++] = value; &#125; &#125; return output;&#125; 自己写的函数: pick12345678910111213141516171819202122function pick(obj, oiteratee) &#123; // 边界处理 如果 obj === null 或者 typeof obj !== 'object' // 返回一个空对象 if (obj === null || typeof obj !== 'object') &#123; return &#123;&#125;; &#125; let output = &#123;&#125;; let keys = Object.keys(obj); let len = keys.length; let iteratee; let choiceKeys = Array.prototype.slice.call(arguments, 1); if (typeof oiteratee === 'function') &#123; iteratee = oiteratee; &#125; else &#123; iteratee = function (value, key) &#123; retutn choiceKeys.includes(key); &#125;; &#125; for (let i = 0; i &lt; len; i++) &#123; let key = keys[i]; if (iteratee(obj[key], key)) output[key] = obj[key]; &#125; return output;&#125; omit omit(object, *keys)使用 omit 函数的目的是与使用 pick 函数相反，返回一个 object 副本，过滤出除去 keys 中的属性值，或者接收一个判断函数，指定忽略哪一个 key 值。omit 源码如下:1234567891011_.omit = function (obj, iteratee, context) &#123; if (_.isFunction(iteratee)) &#123; iteratee = _.negate(iteratee); &#125; else &#123; let keys = _.map(flatten(arguments, false, false, 1), String); iteratee = function() &#123; return !_.contains(keys, key) &#125;; &#125; return _.pick(obj, iteratee, context);&#125; default _.defaults(object, *defaults)使用 default 的目的是使用 default 对象填充 object 中的 undefined 属性，并且返回这个 object。当 object 中存在 default 中的属性被填充的时候，使用 defaults 方法不会起作用。使用 _.defaults 方法的时候源码如下:1234// 使用 createAssigner(keysFunc, undefinedOnly);// 传递两个参数： keysFunc 表示对于键的处理函数// undefinedOnly 表示是否只是复制目标对象中值为 undefined 的属性_.default = createAssigner(_.allKeys, true); 在 createAssigner 的函数中使用 _.default 方法主要是使用下面的这句函数:12// 当 undefinedOnly 为 true 的时候, 接下来进行判断 obj[key] === void 0 对象的属性是否为 undefinedif (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS: 未知高度内文本居中]]></title>
    <url>%2F2017%2F12%2F11%2FCSS-%E6%9C%AA%E7%9F%A5%E9%AB%98%E5%BA%A6%E5%86%85%E6%96%87%E6%9C%AC%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }在项目中遇到过单行文本出现垂直居中的问题， 对于已知高度使用 line-height = height 可以解决问题，对于未知高度，下面有几种方法。例如下面的 HTML 以及 CSS 如下:1234&lt;div class=&quot;wrapper&quot;&gt; &lt;span class=&quot;first&quot;&gt;我是第一个需要居中的文字&lt;/span&gt; &lt;span class=&quot;second&quot;&gt;我是第二个需要居中的文字&lt;/span&gt;&lt;/div&gt; 1234567891011121314.wrapper &#123; width: 200px; height: 100px;&#125;.wrapper span &#123; width: 100%; display: inline-block;&#125;.first &#123; height: 30%;&#125;.second &#123; height: 70%;&#125; 我们期望得到下面的效果:但是, 因为我们无法使用 line-height = height (你总不能计算高度 * 30% 吧， 愚蠢的做法), 我们得到这样的效果:为了实现居中效果，我们可以采用下面的方式: 暴力 flex 1234.wrapper span &#123; display: flex; align-items: center;&#125; table]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>垂直居中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js 源码分析(十三)]]></title>
    <url>%2F2017%2F12%2F11%2Funderscore-js-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E4%B8%89%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }underscore.js 源码分析(十三) keys values pairs invert functions mapObject findKeykeys(Object) 使用 keys(Object) 用于获得 Object 的所有属性名称。 与 es6 中 Object.keys() 功能相同，不同的是做了兼容性处理。12345678910111213function keys (obj) &#123; // 如果 obj 不存在? if (!obj || typeof obj !== 'object') return []; // 如果支持 Object.keys 方法, 返回 Object.keys(obj) if (Object.keys) return Object.keys(obj); // else 使用 for in 进行属性获取 let keys = []; for (let key in obj) &#123; keys.push(key); &#125; // 返回属性数组 return keys;&#125; values(Object) 使用 values(Object) 用于获得对象的所有的属性名称。 类似于使用 Object.values 获取到对象的属性值。123456789function values (obj) &#123; let keys = _.keys(obj); let length = keys.length; let values = new Array(length); for (let i = 0; i &lt; length; i++) &#123; values[i] = obj[keys[i]]; &#125; return values;&#125; pairs() 使用 pairs() 用于将一个对象转化为键值对的形式。自己写的函数:12345678910function pairs (obj) &#123; let keys = _.keys(obj); let values = _.values(obj); let len = keys.length; let pairs = []; for (let i = 0; i &lt; len; i++) &#123; pairs.push([keys[i], values[i]]); &#125; return pairs;&#125; 源码分析:123456789_.pairs = function(obj) &#123; var keys = _.keys(obj); var length = keys.length; var pairs = Array(length); for (var i = 0; i &lt; length; i++) &#123; pairs[i] = [keys[i], obj[keys[i]]]; &#125; return pairs; &#125;; invert() invert(object)使用 invert 实现的是返回一个 object 的副本，在这个副本中, object 中的键和值互换。源码:12345678function invert(object) &#123; let result = &#123;&#125;; let keys = _.keys(object); for (let i = 0; i &lt; keys.length; i++) &#123; result[object[keys[i]]] = keys[i]; &#125; return result;&#125; functions functions(object)返回一个对象中所有的方法名，并且是已经经过排序的方法。源码分析:1234567_.functions = function (obj) &#123; let names = []; for (let key in obj) &#123; if (_.isFunction(obj[key])) names.push(obj[key]); &#125; return name.sort();&#125; mapObject 类似于使用数组的 map 方法，不同的是这个方法针对的是对象的 map 方法, 使用 mapObject 用来对于对象的属性值进行操作， 实现的源码如下:1234567891011_.mapObject = function(obj, iteratee, context) &#123; iteratee = cb(iteratee, context); let keys = _.keys(obj); length = keys.length; result = &#123;&#125;; currentKey; for (let index = 0; index &lt; length; index++) &#123; currentKey = keys[index]; results[currentKey] = iteratee(obj[currentKey], currentKey, obj); &#125; &#125; findKey _.findKey(obj, predicate, context)使用 findKey 返回的是 obj 中第一个满足 predicate 函数的 key。12345678let numbers = &#123; first: 5, second: 8&#125;;_.findKey(numbers, function (value) &#123; return value &gt; 2;&#125;);// 返回 first 源码分析 findKey 源码:123456789_.findKey = function (obj, predicate, context) &#123; predicate = cb(predicate, context); let keys = _.keys(obj), key; for (let i = 0; length = keys.length; i &lt; length; i++) &#123; key = keys[i]; // 如果条件满足, 返回 key if (predicate(obj[key], key, obj)) return key; &#125;&#125;]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js源码分析(十二)]]></title>
    <url>%2F2017%2F12%2F10%2Funderscore-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }underscore.js 源码分析(十二) wrap negate composewrap 实例 _.wrap(function, wrapper)使用 wrap 的目的在于将函数 function 作为第一个参数传递进入 wrapper 之中, 从而在 wrapper 中在不同的事件，不同的代码，根据不同的条件执行 function 函数。实例:1234567function hello(name) &#123; console.log(`hello my name is $&#123;name&#125;`);&#125;let sayHello = _.wrap(hello, function (func) &#123; func('张宁宁');&#125;);sayHello(); // hello my name is 张宁宁 源码分析 使用 _.partial 函数实现的参数替换:123_.wrap = function (func, wrapper) &#123; return _.partial(wrapper, func);&#125; negate 返回 negate 的否定版本:源码分析 123456// predicate 迭代函数_.negate = function (predicate) &#123; return funciton () &#123; return !predicate.apply(this, arguments); &#125;&#125; compose compose(*functions)compose 用于函数的组合, 将一个函数的返回值作为另外一个函数的参数。实例 12345678function sayHello(word) &#123; console.log(`hello, my name UpperWorlds is $&#123;word&#125;`)&#125;function toUpper(word) &#123; return word.toUpperCase();&#125;let composeFn = _.compose(sayHello, toUpper);composeFn(&apos;zhangningning&apos;); // hello my name UpperWorlds is ZHANGNINGNING; 源码分析 自己写的部分代码:哪个好？？12345678function compose() &#123; let fns = Array.prototype.slice.call(arguments); reurn function (args) &#123; fns.reduceRight((preFn, nextFn) =&gt; &#123; return nextFn(preFn); &#125;, args); &#125;&#125; 源码如下:123456789101112_.compose = function () &#123; let args = argumemts; let start = args.length - 1; return function () &#123; let i = start; // 使用 call 以及 apply 进行参数传递 let result = args[start].apply(this, arguments); // 使用 while 进行递减 while(i--) result = args[i].call(this, result); return result; &#125;&#125;]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js基础.基本服务器构建]]></title>
    <url>%2F2017%2F12%2F10%2Fnode-js%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }node.js 是 javascript 对于后端的应用, 下面是使用node.js 构建的一个基础的图片上传应用:应用地址hello world: 基本组成 这个基本的引用由下面几个部分组成:index.js : 作为各个模块的入口。 server.js 服务器模块。 router.js 用于路由的存放。requireHandler.js 用于路由相关的动作模块分析 server.js server.js 用于创建 http 服务器。一个基础的 http 服务器的构成。12345678910111213let http = require('http');// request 是浏览器向服务器进行请求的相关信息function onRequest(request, response) &#123; // response 用于向对于发送信息的浏览器响应请求 // 规定返回响应的 头部信息 // 返回一个 http 状态码为 200 Content-type 为 text/plain 的 http 信息 response.writeHead(200, &#123;"Content-type": "text/plain"&#125;); // 使用 response.write 向响应的主体中发送内容 response.write(); // 结束响应请求 response.end();&#125;http.createServer(onRequest).listen(8888); 上面的创建的基础的 node.js 服务器用于监听 8888 端口。node.js 是基于事件驱动的, 也就是我们说的 回调， 上面的服务器中， 只要在 8888 端口处监听到事件发生, 则进行回调 onRequest 函数。在这个应用中，这样构建服务器模块:1234567891011121314// 引入 http 模块let http = require('http');// 引入 url 模块let url = require('url');// 创建一个 start 函数用于开启服务器function start(route, handle) &#123; function onRequest(request, response) &#123; let pathname = url.parse(request.url).pathname; route(handle, pathname, response, request); &#125; http.createServer(onRequest).listen(8888);&#125;// 导出 start 模块export.start = start; router.js 在 router.js 存放在对于根据不同的路由切换函数。1234567891011121314function route(handle, pathname, response, request) &#123; if (typeof handle[pathname] === 'function') &#123; // 执行 handle[pathname] 函数 // handle[pathname] 函数接收两个参数 response, request // 这个启动的函数位于 requireHandler.js 中 handle[pathname](response, request); &#125; else &#123; // http 状态 404 not found Content-type 设置 text/plain response.writeHead(404, &#123; 'Content-type': 'text/plain' &#125;); response.write('404 not found'); response.end(); &#125;&#125;export.route = route; index.js 使用 index.js 用于对于各个模块进行集中处理:1234567891011121314151617// 导入 server, router, requestHandlers 模块// server: 服务器模块// router: 路由模块// requestHandlers： 相应路由的处理函数模块let server = require("./server.js");let router = require("./router");let requestHandlers = require("./requireHandlers");let handle = &#123;&#125;;// 对于不同的路由进行不同的函数配置handle['/'] = requestHandlers.start;handle['/start'] = requestHandlers.start;handle['/upload'] = requestHandlers.upload;handle['/show'] = requestHandlers.show;// 启动服务器server.start(router.route, handle); requireHandler.js 这个模块用来个根据不同的路由进行不同的函数处理:对于上传数据的不同处理都是放在了这里面:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162let fs = require('fs');// 使用 formidable 用于处理文件上传的问题let formidable = require('formidable');function start(response, request) &#123; var body = '&lt;html&gt;'+ '&lt;head&gt;'+ '&lt;meta http-equiv="Content-Type" '+ 'content="text/html; charset=UTF-8" /&gt;'+ '&lt;/head&gt;'+ '&lt;body&gt;'+ '&lt;form action="/upload" enctype="multipart/form-data" '+ 'method="post"&gt;'+ '&lt;input type="file" name="upload"&gt;'+ '&lt;input type="submit" value="Upload file" /&gt;'+ '&lt;/form&gt;'+ '&lt;/body&gt;'+ '&lt;/html&gt;'; response.writeHead(200, &#123;"Content-Type": "text/html"&#125;); response.write(body); response.end();&#125;function upload(response, request) &#123; let form = new formidable.IncomingForm(); form.parse(request, function (error, fields, files) &#123; var readStream=fs.createReadStream(files.upload.path); var writeStream=fs.createWriteStream(`./assets/$&#123;files.upload.name&#125;`); imgname = files.upload.name; readStream.pipe(writeStream); readStream.on('end',function()&#123; fs.unlinkSync(files.upload.path); &#125;); response.writeHead(200, &#123;"Content-Type": "text/html"&#125;); response.write('received image: &lt;br/&gt;'); console.log(files.upload.name); // src='/show' 调用 show 函数 response.write("&lt;img src='/show'/&gt;"); response.end(); &#125;);&#125;// show 函数用于文件显示function show(response, postData) &#123; // 读取文件 fs.readFile(`./assets/$&#123;imgname&#125;`, "binary", function (error, file) &#123; // 如果发生错误 if (error) &#123; response.writeHead(500, &#123;"Content-Type": "text/plain"&#125;); response.write(error + "\n"); response.end(); &#125; else &#123; response.writeHead(200, &#123;"Content-Type": "image/png"&#125;); response.write(file, "binary"); response.end(); &#125; &#125;)&#125;exports.start = start;exports.upload = upload;exports.show = show; 其他 关于使用 response.write 的问题:12response.write(chunk, [encoding]);// encoding 表示编码形式]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[while and do]]></title>
    <url>%2F2017%2F12%2F09%2Fwhile-and-do%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }运算符优先级 关于运算符的优先级，存在下面的优先级级别:(因此当我们在表达式中出现下面这些情况的时候, 我们注意符号的优先级) . [ ] ( ) 提取属性与调用函数 （优先级 () &gt; .） delete new typeof + - ! 一元运算符 * / % 乘法， 除法, 求余 + - 加法/ 连接 减法 &gt;= &lt;= &gt; &lt; 不等式运算符 === !== 等式运算符 &amp;&amp; 逻辑与 ` ?: 三元 使用运算符优先级中注意: &amp;&amp; &gt; ||下面是一些使用运算符的一些例子: 对于点号运算符以及加号运算符 123+"2.34567".toFixed(2);// 我们的本意是先想要将字符串 "2.34567" 转化为数字在利用 toFixed(2) 进行保留两位小数// 但是返回错误 uncaught TypeError "2.34567".toFixed(2) is not a function 上面是因为使用上面的表达式的时候 . 号的操作符优先级要高于 + 所以先计算的是字符串的 toFixed() 函数， 当然会出现错误， 解决办法， 添加 () 因为这时候括号的优先级要高于点号: 1(+"2.34567").toFixed(2) 逻辑与的操作符 &amp;&amp; 的操作符优先级要高于 || 的操作符优先级。例如对于下面的这个程序而言:12true || false &amp;&amp; false// 因为这里 &amp;&amp; 操作符的优先级要高于 || 因此这里会返回 true 注意: 这里对于 || 以及 &amp;&amp; 操作符的理解要正确:这两个操作符返回的都是值，而不是 true 或者 `false [] == ![] 上面这个等式是一个很有意思的等式， 理解这个等式有助于我们加深对于于运算符优先级的理解， 并且在上面的这个公式中还有涉及到了隐式转换的一些知识点。 在上面这个过程中， 因为 `!` 的优先级要高于 `==`, 因此先执行 `!` 进行类型转换， 因为这里 `[]` 是真值，(只要不属于假值的都是真值，你别看我这里是一个空数组) &gt;通过使用布尔强制类型转换结果为 `false` 的被称作假值， 假值有下面几种： &gt; &gt;`undefined`, `null`, `false`, `+0, -0 和 NaN`, &quot; &quot; &gt; &gt;ps: 其他的类型不要进来 （`[], {}` : 你们看我干嘛？） 首先执行下面的操作： 1![] ===&gt; false 这个时候等号右边的值变成了 `false`,这个时候使用 `==` 会进行强制类型转换，将布尔值转换为数字 1Number(false) ===&gt; 0 这个时候 `==` 两边分别是 `object` 以及 `number` 类型的值， 这个时候需要将 `obejct` 转为数字： 1Number([].valueOf()) ===&gt; 0 因此， 上面的等式经过转换之后，变成了下面的这种： 10 === 0 // true]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>whileordo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js源码分析(十一)]]></title>
    <url>%2F2017%2F12%2F07%2Funderscore-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E4%B8%80%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }underscore.js 源码分析(十一) throttle debounce once after beforethrottle 函数节流_.throttle(function, wait, [options])使用 throttle 函数用于节流操作, 目的是对于重复执行的函数，最多每隔 wait 毫秒调用一次这个函数。源码分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** @description throttle 用于函数节流* @param func 运行的函数* @param wait 等待的毫秒数* @param options*/// previous 这里的意思的记录下上次记录下上次的时间_.throttle = function(func, wait, options) &#123; var context, args, result; var timeout = null; var previous = 0; if (!options) options = &#123;&#125;; var later = function() &#123; // 这里 previous 的作用 previous = options.leading === false ? 0 : _.now(); timeout = null; result = func.apply(context, args); if (!timeout) context = args = null; &#125;; return function() &#123; var now = _.now(); // 记录下被调用的时刻 if (!previous &amp;&amp; options.leading === false) previous = now; // 当 previous 等于 now 的时候 remaining = wait // 记录下等待的时间和 now - previous 的差值 // 不会执行下面的 if else 函数 var remaining = wait - (now - previous); context = this; args = arguments; // 如果 remaining &lt;= 0 // 第一次函数执行的时候被调用，因为这个时候 now &gt;&gt; wait remaining &lt;= 0 if (remaining &lt;= 0 || remaining &gt; wait) &#123; // 当超出等待时间之后调用的时候 // 返回调用的结果，清除 timeout if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; // 获取到 func 执行之后的结果 result = func.apply(context, args); if (!timeout) context = args = null; // 如果 timeout 为 null // 开启一个新的队列等待 // 如果 options.trailing === false, 表示禁用最后一次执行 &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123; // 如果没有超过等待时间 // remaining 时间之后调用 later函数 // 对于在一段时间内应用同一个函数的时候，只是改变的later 函数 timeout = setTimeout(later, remaining); &#125; return result; &#125;; &#125;; 首先，需要明白一点，函数式编程同样可以首先数据的共享。1234567891011121314function getIndex() &#123; let index = 0; // return 返回的是一个函数 return function () &#123; index++; console.log(index); &#125;&#125;let getIndexFn = getIndex();// 因为在个过程中，通过getIndex 返回的是一个函数// 在 getIndex 中的 index 并没有发生变化， 因为 getIdnex 只是调用了一次getIndexFn(); // 1getIndexFn(); // 2 练习:12345678910111213141516171819202122232425262728293031function throttle (func, wait, options) &#123; let context, args, result; let timeout = null; let previous = 0; if (!options) options = &#123;&#125;; let later = funciton () &#123; previous = options.leading === false ? 0 : now(); timeout = null; result = func.apply(context, args); &#125;; return funcion () &#123; let now = now(); if (!previous &amp;&amp; options.leading === false) previous = now; let remaining = wait - (now - previous); context = this; args = arguments; // 如果第一次执行 if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (timeout) &#123; cleatTimeout(timeout); timeout = null; &#125; previous = now; result = func.apply(context, args); if (!timeout) context = args = null; &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123; timeout = setTimeout(later, remaining); &#125; return result; &#125;&#125; debounce _.debounce(function, wait, [immediate])debounce 函数用于函数防抖: 函数防抖的意思是将延迟函数的执行(真正的执行)在函数最后一次调用的时刻的 wait 毫秒之后进行执行。当函数重复调用的时候，函数执行只是发生在最后一次调用的 wait 毫秒之后进行执行。自己写的:12345678910111213141516171819202122232425262728293031323334function debounce(func, wait, immediate) &#123; // 定义执行上下文, 参数， 结果 let context, args, result; let timeout = null; let previous 0; let remainding = 0; immediate = immediate || false; let later = function () &#123; result = func.apply(context, args); timeout = null; context = args = null; &#125;; return function () &#123; let now = _.now(); remainding = now - previous; context = this; args = arguments; // 保证使用 immediate 的时候立即执行函数 if (immediate &amp;&amp; remainding &gt; wait) &#123; previous = _.now(); result = func.apply(context, args); timeout = null; context = args = null; &#125; else if (!immediate) &#123; // if timeout // clearTimeout 进行清除 timeout if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; timeout = setTimeout(later, wait); &#125; &#125;&#125; 源码解析 12345678910111213141516171819202122232425262728_.debounce = function(func, wait, immediate) &#123; let timeout, args, context, timestamp, result; let later = function () &#123; let last = _.now() - timestamp; if (last &lt; wait &amp;&amp; last &gt;= 0) &#123; timeout = setTimeout(later, wait - last); &#125; else &#123; timeout = null; if (!immediate) &#123; result = func.apply(context, args); if (!timeout) context = args = null; &#125; &#125; &#125;; return function () &#123; context = this; args = arguments; // 这里面继续调用的时候改变的只是这个 timestamp = _.now(); let callNow = imemediate &amp;&amp; !timeout; if (!timeout) timeout = setTimeout(later, wait); if (callNow) &#123; result = func.apply(context, args); context = args = null; &#125; return result; &#125;;&#125; 如下流程图如下: 关于 later 函数如下:123456789101112let later = function () &#123; let last = now() - timestamp; if (last &lt; wait &amp;&amp; last &gt;= 0) &#123; timeout = setTimeout(later, last - wait); &#125; else &#123; timeout = null; if (!immediate) &#123; result = func.apply(context, args); if (!timeout) context = args = null; &#125; &#125;&#125; 这一部分实现的原理是:假如使用 bounce 函数的程序被多次调用的时候，如果在函数被第一次调用之后的 wait 时间之内，函数被调用了第二次，程序会在函数调用第二次的时候记录下时间，这时候 wait 时间之后调用函数的时候，第一次调用的函数不会被触发，程序在 later 函数中继续延迟第二次调用函数距离上一次调用需要的时间，这样，最终，第二次函数也是和第一次函数调用的结果是相同点的，都是在延迟了wait 时间之后被调用。once 创建一个只能调用一次的函数。即使函数被调用一次，也只是返回第一次被调用的结果。使用 once 是当 before 方法中 count 等于2的情况下进行执行的函数;12// 向 befor 函数中传递参数为 2_.once = _.partial(_.before, 2); before _.before(count, function)创建一个函数，调用不超过 count 次, 当count已经被达到的时候，最后一次调用的结果被记住并被返回。自己写的:12345678910111213141516/** @description before 用于返回 调用不超过 count 次数的函数调用* @param &#123;Numbet&#125; count 调用函数的次数* @param &#123;function&#125; func 被调用的函数*/function before(count, func) &#123; let index = 1; let memo; return function () &#123; if (index &lt; count) &#123; memo = func.apply(this, arguments); index++; &#125; return memo; &#125;&#125; 源码分析:123456789101112_.before = function (times, func) &#123; let memo; return function () &#123; // --times if (--times &gt; 0) &#123; memo = func.apply(this, arguments); &#125; // 如果 times &lt;= 1 将 func 重置为 null if (times &lt;= 1) func = null; return memo; &#125;&#125; after _.after(count, function)使用 _.after 的作用是创建一个函数，只有调用 count 次之后才能得到效果。123456789101112/** @description after 用于表示 after 函数* @param &#123;Number&#125; 需要的调用次数* @param &#123;function&#125; func 规定调用次数之后的调用函数*/function after (times, func) &#123; return function () &#123; if (--times &lt; 1) &#123; return func.apply(this, arguments); &#125; &#125;&#125; st=>start: bounce; init=>operation: 初始化context, args, timeout, timeStamp, result, 定义later函数 rt=>operation: 记录当前调用时间 timeStamp = _.now(), callNow = imemediate && !timeout isTimeout=>condition: !timeout iscallNow=>condition: callNow 为 true setTimeout=>operation: setTimeout(later, wait); cond=>condition: Yes or No? replyFn=>operation: 执行函数, result = func.apply(context, args); context = args = null; e=>end: return result st->init->rt->isTimeout->e isTimeout(yes, right)->setTimeout->iscallNow isTimeout(no)->iscallNow iscallNow(yes, right)->replyFn->e iscallNow(no)->e cond(no)->io cond(yes)->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise 原理]]></title>
    <url>%2F2017%2F12%2F05%2Fpromise%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }使用 promise 构建异步请求在 es6-promise 中已经说过了，下面这章想要探究一下使用 promise 的原理。使用 promise 的实例如下:new Promise(function (resolve, reject) {....})对于 promise 的执行过程是这样的: executor 执行器:executor 是一个带有 resolve 和 reject 两个参数的函数, executor 函数 promise 构造函数执行的时候同步执行， 被传递 resolve 以及 reject 函数，executor 函数在 Promise 构造函数返回新建对象前被调用, resolve 和 reject 函数被调用的时候，分别将 promise 的状态改为 fullfilled(完成) 和 rejected(完成) executor 函数内部会执行异步操作，操作完成成功之后将 promise 状态改为 fullfiled 或者将发生错误的时候, 将 状态变为 rejected 对于一个 promise 对象具有下面三种状态:123pending: 初始状态，不是成功就是失败 // pending 英文: 等待，表示处于等待异步处理结果的状态fufilled 等待结果操作成功完成rejected 表示等待操作结果失败 下面是通过使用 promise 进行调用的状态图:promise 代码 构建 Promise 构造函数 es6:12345678910let p = new Promise((resovle, reject) =&gt; &#123; // 异步操作 if () &#123; // resolve(value) resolve(value); &#125; else &#123; // reject(value) reject(value); &#125;&#125;) 实际源码:123456789101112131415function Promise (executor) &#123; let that = this; that.status = PENDDING; that.value = void 0; that.handlerQueue = []; // 执行函数， 传递进入 value // executor(成功函数， 失败函数); executor(function (value) &#123; // 成功函数执行，传递进入 transition 状态: FULFILLED that.transition(FULFILLED, value); &#125;, function (value) &#123; // 失败函数执行， 传递进入 transition 状态: REJECTED that.transition(REJECTED, value); &#125;)&#125; 改变状态函数 es6:123resolve(value);reject(value); 实际源码:123456789Promise.prototpe.transition = function (status, value) &#123; if (this.status === PENDING) &#123; // 当处于 PENDDING 状态的时候执行函数 this.status = status; this.value = value; // 当成功或者失败的时候都会执行 this.process() 函数 this.process(); &#125;&#125; then es6: 123p.then(onFulFilled, onRejected);// onFulFilled 成功之后执行的函数// onRejected 失败之后执行的函数 源码分析:12345678910111213141516Promise.prototype.then = function (onFulfilled, onRejected) &#123; // thenPromise 是一个新的 Promise 对象 let thenPromsie = new Promise(function() &#123;&#125;); // 将执行的函数存入到 handlerQueue 数组之中 this.handlerQueue.push(&#123; // 成功函数 onFulfilled, // 失败函数 onRejected, thenPromise &#125;); // this.process() 执行函数 this.process(); // 返回 thenPromise 一个新的 promise 对象 return thenPromise;&#125; process处理函数 用来执行成功时的回调函数以及失败的回调函数。 es6: 12345p.then(function () &#123; // 成功函数执行&#125;, function () &#123; // 失败函数执行&#125;) 源码如下:12345678910111213141516171819202122232425262728293031// 使用 process 的主要目的是执行保存在 this.handlerQueue 中的函数Promise.prototype.process = function () &#123; let that = this; // 如果状态处于 PENDING 状态 返回 if (that.status === PENDING) &#123; return; &#125; while (that.handlerQueeu.length &gt; 0) &#123; let handler = that.handlerQueue.shift(); (function (handler) &#123; let handlerFn = that.status === FULFILLED ? handler.onFulfilled : handler.onRejected; // 如果 handlerFn 是一个函数 if (isFunction(handlerFn)) &#123; // 使用 callLater 回调函数执行 callLater(function () &#123; try &#123; // 执行 handlerFn 函数 let x = handlerFn(that.value); // 将 handler.thenPromise 以及 handlerFn 计算之后的 x 传入 resolve 函数 resolve(handler.thenPromise, x); &#125; catch (e) &#123; // 如果 catch error handler.thenPromise.transition(REJECTED, e); &#125; &#125;); &#125; else &#123; handler.thenPromise.transition(that.status, that.value); &#125; &#125;)(handler); &#125;&#125; resolve resovle 函数用于函数执行完毕之后改变状态:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function resovle(promise, x) &#123; if (promise === x) &#123; promise.transition(REJECTED, new TypeError()); // 如果 x 是一个 promise &#125; else if (isPromise(x)) &#123; // 调用 x 的 then 方法 x.then(function(value) &#123; promise.transition(FULFILLED, value); &#125;, function(reason) &#123; promise.transition(REJECTED, reason); &#125; ); // 如果函数执行之后的返回值是一个对象或者一个函数 &#125; else if (isObject(x) || isFunction(x)) &#123; try &#123; let then = x.then; // 如果 then 是一个函数 // 参数具有 then 方法的对象 if (isFunction(then)) &#123; let called = false; try &#123; then.call(x, function(y) &#123; if (!called) &#123; resolve(promise, y); called = true; &#125; &#125;, function (r) &#123; if (!called) &#123; promise.transition(REJECTED, r); called = true; &#125; &#125;); &#125; catch (e) &#123; if (!called) &#123; promise.transition(REJECTED, e); &#125; &#125; &#125; else &#123; promise.transition(FULFILLED, x); &#125; &#125; catch (e) &#123; promise.transition(REJECTED, x); &#125; // 如果 x 只是一个数值 &#125; else &#123; promise.transition(FULFILLED, x); &#125;&#125; promsie.resolve 对于 promise.resolve 的状态，存在下面几种情况: 如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。 如果参数是一个具有 then 方法的对象, 使用 promise.resolve 会将这个对象转化为 promise 对象，并且立即执行 thenable 对象的 then 方法。 如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。 如果不带参数, 直接返回一个 resolve 状态的 Promise 对象。 实现代码如下:12345678910111213Promise.resolve = function(value) &#123; // 返回一个 new Promise return new Promise(function(resolve, reject) &#123; if (isThenable(value)) &#123; // 如果 value 是一个 then 对象 // 如果 value 具有 then 方法，执行下面的函数 value.then(resolve, reject); &#125; else &#123; // else 执行 resolve 函数 resolve(value); &#125; &#125;);&#125; promise.reject 12345Promise.reject = function(reason) &#123; return new Promise(function(resolve, reject) &#123; reject(reason); &#125;&#125;&#125; 使用 Promise.reject 接收的参数 reason 会被作为 error 传递 other 123456789101112131415161718192021222324// 定义 promise 的三种状态// PENDING, FULFILLED REJECTEDlet PENDING = 0; FULFILLED = 1; REJECTED = 2;function isFunction(fn) &#123; return fn instanceof Function;&#125;function isObject(obj) &#123; return obj instanceof Object;&#125;function isPromise() &#123; return p instanceof Promise;&#125;// 判断是否含有 then 方法function isThenable(obj) &#123; return obj &amp;&amp; isFunction(obj.then);&#125;// 借用 callLater 实现异步function callLater(fn) &#123; setTimeout(fn, 0);&#125;]]></content>
      <categories>
        <category>代码集</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js源码分析(十)]]></title>
    <url>%2F2017%2F12%2F05%2Funderscore-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }underscore.js 源码分析（十） 使用underscore.js 的 function 部分bind bindall partial memorize delaybind _.bind(func, obj, *arguments)使用 bind使用 bind 的目的是将函数 func 绑定到 obj 上面去，也就是说，这时候 func 中的 this 就指向了 obj, 其中 arguments 被作为传递给 func 的参数被传入到 func 之中。实例如下 123456function greet(home) &#123; console.log(`hi my name is $&#123;this.name&#125;, my home is $&#123;home&#125;`);&#125;// 使用 _.bind 进行函数绑定_.bind(greet, &#123;name: '张宁宁'&#125;, '山东');// hi my name is 张宁宁, my home is 山东 关于使用 bind 的函数:使用 bind 的函数使用 bind 函数接收两个参数，第一个参数表示需要进行绑定的变量，第二个参数表示传递给函数的参数。 源码如下:1234567891011121314151617181920_.bind = function(func, context) &#123; // 首先检查是否支持 es5 的bind 方法, 如果支持， 使用 nativeBind 进行绑定操 // nativeBind.appy // 对于 es5 支持的 bind 方法接收两个参数 // func 以及 参数 if (nativeBind &amp;&amp; func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1)); // 如果 func 不是一个函数的时候 // throw new TypeError('bind must be called on a function'); if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function'); // 使用 slice.call 用于截取 arguments // 通过使用 slice.call 方法截取传入函数的参数 var args = slice.call(arguments, 2); var bound = function () &#123; // 返回一个 executeBpund 函数 // 使用 args 数组的 concat 方法用于连接数组 // 分别传入的值是 func, bound, context, this, args return executeBound(func, bound, context, this, args.concat(slice.call(arguments))); &#125;; return bound; &#125;; 其中 executeBound 函数如下:1234567891011121314// 这里面 boundFunc 是需要进行绑定的函数 var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) &#123; // 如果 boundFunc 不在 callingContext 的原型链上 // 使用 apply 方法进行绑定 // 如果 callingContext 不在 boundFunc 的原型链上 // 这里的 callingContext 是指的 this 值 // 返回将 context 绑定到 sourceFunc 上面 if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args); // 关于 baseCreate 函数 var self = baseCreate(sourceFunc.prototype); var result = sourceFunc.apply(self, args); if (_.isObject(result)) return result; return self; &#125;; 关于 baseCreate 函数如下:123456789101112let Ctor = function () &#123;&#125;;let baseCreate = function(prototype) &#123; // 判断 prototype 是否是一个对象 if (!_.isObjject(prototype)) return &#123;&#125;; // 如果nativeCreate 存在的话, 返回 nativeCreate(prototype) 这个函数 if (nativeCreate) return nativeCreate(protoytpe); Ctor.prototype = prototype; // 创建一个函数的实例，这个函数的原型指向 prototype var result = new Ctor; Ctor.prototype = null; return result;&#125; 上面的 nativeCreate 返回的是这个 Object.create() 使用 Object.create 用来实现继承的关系123456789// 使用 new 操作符的过程let obj = new Constructor();// 创建一个新的对象let obj = &#123;&#125;;// 执行原型链接obj._proto_ = Constructor.prototype;// 将这个构造函数的 this 值指向新创建的这个新对象Constructor.call(obj);// 这样在 obj 中我们就能愉快的使用在 Constructor 中通过 this 值创建的新对象了 partial partial(function, *arguments)局部应用一个函数填充在任意个数的 arguments。实例 123456function add(a, b) &#123; return a + b;&#125;let particalAdd = _.partial(add, 3);particalAdd(5); // 8// 这里的 5 填充了函数的第二个参数 b 自己写的函数:12345678910function partial(fn) &#123; // 获取到传入到 partial 函数中的参数 let partialArgs = Array.prototype.slice.call(arguments, 1); // return 返回一个函数 return function(args) &#123; let fnArgs = Array.prototype.slice.call(arguments, 0); // 将参数传入，执行 fn fn(...partialArgs, ...fnArgs); &#125;&#125; 源码分析 123456789101112131415_.partial = function(func) &#123; let boundArgs = slice.call(arguments, 1); return function bound () &#123; let position = 0; let args = boundArgs.slice(); let length = args.length; for (let i = 0; i &lt; length; i++) &#123; // 在数组中使用 position ++ if (args[i] === _) args[i] = arguments[position++]; &#125; whitle(position &lt; arguments.length) args.push(arguments[position++]); // 这时候的 args 中是包含了所有的参数 return executeBound(func, bound, this, this, args); &#125;&#125; 关于 executeBound 函数上面有解释，这个函数的作用是: Determines whether to execute a function as a constructor, or a normal function with the provided arguments决定是否构建一个函数作为构造函数，或者运行一个给定参数的普通函数。 memoize使用 memorize 用来缓存函数计算的结果。delay使用 delay 用来实现对于函数延迟执行，代码如下:123456789101112function delay(func, wait) &#123; // 通过调用 Array.prototype.slice.call 的方法进行获得传递的参数 let args = Array.prototype.slice.call(arguments, 2); // 返回等待 wait 时间之后的函数 return setTimeout(() =&gt; &#123; // 自己写的 func(args); // 源码写的 // 使用 apply 的方法向函数 func 中传递 args 参数 return func.apply(null, args); &#125;, wait)&#125; deferdefer(function, *arguments)使用 defer 的目的在于延迟调用 function 直到当前的调用栈被清空为止，其中 arguments 会被作为 function 的参数进行传入。类似于使用 setTimeout(function () {}, 0) 的延迟调用效果。实现的源码如下:1_.defer = _.partial(_.delay, _, 1);]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js 源码分析(九)]]></title>
    <url>%2F2017%2F12%2F04%2Funderscore-js-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B9%9D%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }underscore.js 源码分析 sortedIndex findIndex findLastIndex rangesortedIndex sortedIndex(list, value, [iteratee], context)其中 list 是已经被排好序的数组，通过使用 soetedIndex 可以查找到 value 在已经排好序的 list 数组中的顺序。使用 二分法进行查找的。使用二分法进行查找的 value 位置如下:12345678910111213function sortIndex(array, obj, iteratee, context) &#123; iteratee = cb(iteratee, context, 1); // 获取到传入的 obj 的值 let value = iteratee(obj); let low = 0; // 定义 high 是数组的长度 array.length let high = array.length; while(low &lt; high) &#123; let mid = Math.floor((low + high) / 2); // 如果 array[mid] &gt; value value 在 low 和 mid 之间 if (itetatee(array[mid]) &gt; value) &gt; 0) mid = high; else low = mid + 1; &#125;&#125; findIndex findIndex(array, predicate, [context])返回在array 中满足 predicate 函数为真的第一个元素的索引, 如果没有找到，返回 -1;findLastIndex 类似于使用 findIndex 不同的是从数组的从后向前开始检索，返回的是第一个判断为真的值使用 findIndex 以及 findLastIndex 的代码如下:12345678910111213function getIndexFunc(dir) &#123; return function(array, predicate, context) &#123; predicate = cb(predicate, context); let length = array.length; let index = dir &gt; 0 ? 0 : length - 1; for (; index &gt;= 0 &amp;&amp; index &lt; length; index += dir) &#123; if (predicate(array[index], index, array)) return index; &#125; return - 1; &#125;&#125;let findIndex = getIndexFunc(1);let findLastIndex = getIndexFunc(-1); range range([start], stop, [step])使用 range 创建一个整数灵活编号的列表函数，返回一个从 start 到 stop 的整数的一个列表, 通过使用 step 来减少独占。如果省略 start, start 默认从 0 开始，步进为 1;自己写的代码:1234567891011121314151617181920212223242526272829function range(start, stop, step) &#123; let args = arguments; let resultArray = []; let theStep = 1; let theStart = 0; if (args.length === 1) &#123; stop = args[0]; &#125; if (args.length === 2) &#123; theStart = args[0]; stop = args[1]; &#125; if (args.length === 3) &#123; theStart = args[0]; stop = args[1]; theStep = args[2]; &#125; // 太繁琐 if (theStart &lt; stop) &#123; for (let index = theStart; index &lt; stop; index = index + theStep) &#123; resultArray.push(index); &#125; &#125; else &#123; for (let index = theStart; index &gt; stop; index = index + theStep) &#123; resultArray.push(index); &#125; &#125; return resultArray;&#125; 源码:1234567891011121314151617181920/** @description range 返回特定范围的数组* @param start &#123;Number&#125; 数组中开始的数字* @param stop &#123;Number&#125; 数组中结束的数字* @param step &#123;Nunber&#125; 步进*/function range(start, stop, step) &#123; if (arguments.length &lt;= 1) &#123; start = stop || 0; stop = 0; &#125; step = step || 1; let length = Math.max(Math.ceil((start - stop) / step), 0); let result = new Array(length); for (let index = 0; index &lt; length; index++, start += step) &#123; result[index] = start; &#125; return result;&#125;]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js源码分析(八)]]></title>
    <url>%2F2017%2F12%2F01%2Funderscore-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%85%AB%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }underscore.js 源码分析(八) zip unzip object indexOf lastIndexOfzip _.zip(*arrays)使用 zip 的目的是将数组中相应位置的值结合在一起。将分离的数组归并为一个数组。实例 12_.zip(['张宁宁', '张艺苇'], ['男', '女'], ['山东', '河北']);=&gt; [['张宁宁', '男', '山东'] , ['张艺苇', '女', '河北']] 源码分析 自己写的:12345678910111213141516171819/** * @description 用于合成数组 * @param &#123;Object&#125; array 传入的多个数组 * @return &#123;Object&#125; 返回的经过合成之后的数组*/function zip(array) &#123; // 需要添加是否为 null if (array === null) return []; let args = Array.prototype.slice.call(arguments, 0); let result = []; array.map((item, index) =&gt; &#123; let arr = []; args.map((argItem) =&gt; &#123; arr.push(argItem[index]); &#125;) result.push(arr); &#125;); return result;&#125; 需要注意的几点: 对于传入的 array 需要进行判断，是否为 null 对于传入的参数一定要进行类型判断 123456789101112_.zip = function(array) &#123; if (array == null) return []; // 使用 _.max 获取到 arguments 中所有的数组个数 var length = _.max(arguments, 'length').length; // 使用 Array 生成 length 长度的数组 var results = Array(length); while (length-- &gt; 0) &#123; // 使用 pluck 用于萃取获得 arguments 的某种属性值 results[length] = _.pluck(arguments, length); &#125; return results; &#125;; unzip 使用 unzip 的目的是将归并后的数组分解为串联的一系列的新数组。实例 123_.unzip([['张宁宁', '张艺苇'], ['山东', '行唐']]);=&gt; ['张宁宁', '山东'] ['张艺苇', '行唐']// 返回的第一个元素中包含所有输入数组的第一个元素 实现代码如下:1234_.unzip = function(array) &#123; // 返回使用 apply 压入的一个数组 return _.zip.apply(null, array);&#125;; object 使用 object 用于将数组转化为对象的形式。_.object(list, [values])传递一个单独的[key, value] 的列表，或者一个键的列表和一个值的列表。当传入 list 和 values 的时候， list 中的值会被作为返回对象的键, values 中的值会被作为返回对象的值。实例 12_.object(['moe', 'larry', 'curly'], [30, 40, 50]);=&gt; &#123;moe: 30, larry: 40, curly: 50&#125; 源码解析 代码如下:1234567891011121314151617181920/** * @description toObj 将键值数组组合为对象 * @param &#123;Array&#125; list 键数组 * @param &#123;Array&#125; values 值数组 * @return &#123;Object&#125; 组成的对象*/function toObj(list, values) &#123; if (list === null) return &#123;&#125;; let obj = &#123;&#125;; if (typeof values === 'undefined') &#123; list.map((item) =&gt; &#123; obj[item[0]] = item[1]; &#125;); &#125; else &#123; list.map((item, index) =&gt; &#123; obj[item] = values[index]; &#125;); &#125; return obj;&#125; indexOf _.indexOf(array, value, [isSorted])使用 indexOf 用于返回 value 在 array 中的索引值， 当传入第三个值为数字的时候，表示从第几个数字进行索引。实例 12_.indexOf([1, 2, 3 ,4 ,1],1, 1);=&gt; 5 源码分析 1234567891011121314_.indexOf = function (array, item, isSorted) &#123; var i = 0; length = array &amp;&amp; array.length; // 使用判断数组的方法 // length = array &amp;&amp; array.length; if (typeof isSorted === 'number') &#123; i = isSorted &lt; 0 ? Math.max(0, length + isSorted) : isSorted; &#125; else if (isSorted &amp;&amp; length) &#123; // 如果传入的是一个 true, 使用更快的算法 i = _.sortedIndex(array, item); return array[i] === item ? i : -1; &#125; for (; i &lt; length; i++) if (array[i] === item) return i; return -1;&#125; 判断一个数组是否存在:length = array &amp;&amp; array.length 使用 Math.max 的妙用 例如: 123456Math.max(0, num);// 返回 num &gt; 0//相当于num &lt;= 0 ? 0 : num;//因此// 对于数字的判断比较，就不要使用三元运算符了，使用 `Math.max` 或者 `Math.min` 会更好些 例如下面的一个程序，用来获得一组数组中的最大的差值:12345678910function getMaxProfit(arr) &#123; let minProfit = arr[0]; let maxProfit = 0; for (let i = 0; i &lt; arr.length; i ++) &#123; minProfit = Math.min(minProfit, arr[i]); let currentProfit = arr[i] - minProfit; maxProfit = Math.max(maxProfit, currentProfit); &#125; return maxProfit;&#125; lastIndexOf _.lastIndexOf(array, value, [fromIndex])返回 value 在 array 中从最后开始的索引值，传入的 fromIndex 将从给定的索引值进行搜索。源码分析 12345678910_.lastIndexOf = function(array, item, fromIndex) &#123; let index = array ? array.length : 0; if (typeof fromIndex === 'number') &#123; // 使用 Math.min 当 fromIndex + 1 &gt; index 的时候，要取 index index = fromIndex &lt; 0 ? index + fromIndex + 1 : Math.min(index, fromIndex + 1); &#125; // 使用 --index 因为最后一个元素的索引是 array.length - 1 while (--index &gt;= 0) if (array[index] === item) return index; return -1;&#125; sortIndex _.sortIndex(list, value, [iteratee], [context])使用 sortIndex 的目的在于使用二分法查找到 value 在 list 中的位置序号。实例 12_.sortedIndex([10, 20, 30, 40, 50], 35)// 3 源码分析 使用二分法进行比较获得到元素在数组中的位置的。1234567891011_.sortedIndex = function (array, obj, iteratee, context) &#123; iteratee = cb(iteratee, context, 1); let value = iteratee(obj); let low = 0; let high = array.length; while(low &lt; high) &#123; let mid = Math.floor((low + high) / 2); // 判断 value 在相对于 array 在左边还是在右边 if (_.comparator(iteratee(array[mid], value)) &lt; 0) low = mid + 1; else high = mid; &#125; return low;&#125; 使用二分法的原理是将数组中分为两个部分，判断 value 值在哪一个部分之内。]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js源码分析(七)]]></title>
    <url>%2F2017%2F11%2F28%2Funderscore-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%83%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }underscore.js 源码分析（七） flatten without union intersection uniqflatten 实例 使用 flatten 用来将多层嵌套的数组转化为一层，例如:12list = [1, [3, 4]];_.flatten(list) // [1, 3, 4] 源码分析 123_.flatten = function(array, shallow) &#123; return flatten(array, shallow, false); &#125;; 其中 flatten 函数如下:123456789101112131415161718192021222324252627282930/**@description 用于将数组脱离嵌套*@params input 传入的数组*@params shallow &#123;Boolean&#125; 是否需要减少嵌套**/var flatten = function(input, shallow, strict, startIndex) &#123; var output = [], idx = 0, value; for (var i = startIndex || 0, length = input &amp;&amp; input.length; i &lt; length; i++) &#123; value = input[i]; // 这里使用了运算符嵌套表达式 // value存在并且value的length 大于等于0 并且 value 输入数组或者类数组对象 if (value &amp;&amp; value.length &gt;= 0 &amp;&amp; (_.isArray(value) || _.isArguments(value))) &#123; //flatten current level of array or arguments object // use recursion to get the value // use if to decide isRecursion // 这里使用 if 来决定是否需要进行递归 if (!shallow) value = flatten(value, shallow, strict); var j = 0, len = value.length; output.length += len; // 看这种优雅的写法 while (j &lt; len) &#123; // 将取到的值依次填入 output[idx++] = value[j++]; &#125; &#125; else if (!strict) &#123; output[idx++] = value; &#125; &#125; return output; &#125;; without 实例 _.without(array, values)使用 _.without 用来所有 values 值后的 array 副本。使用:12_.without([1, 2, 3], 1)=&gt; [2, 3] 源码分析 自己写的函数:1234567891011function without(array, values) &#123; if (typeof values === 'undefined') return array; if (array &amp;&amp; array.length) &#123; let value = Array.prototype.slice.call(arguments, 1); array.filter((item) =&gt; &#123; return ~values.indexOf(item); &#125;); &#125; else &#123; return []; &#125;&#125; 上面的函数中存在错误: 结果或返回 undefined原因: 使用 filter方法中的 return 只会跳出 filter 循环，不会跳出最终的函数循环。 低级错误12345678910111213function without(array, values) &#123; if (typeof values === 'undefined') return array; if (array &amp;&amp; array.length) &#123; let value = Array.prototype.slice.call(arguments, 1); // 使用 filter 进行的筛选效果选出的是符合效果的值 let newArray = array.filter((item) =&gt; &#123; return value.indexOf(item) === -1; &#125;); return newArray; &#125; else &#123; return []; &#125;&#125; 使用源码分析如下:12345_.without = function(array) &#123; // 向 difference 的函数中传入两个参数， array 以及 slice.call(arguments, 1); // array 是传入的需要进行删除的数组, slice.call() 获取到传入的第二个参数 return _.difference(array, slice.call(arguments, 1)); &#125;; 这里调用了 _.difference 的方法实现。使用 _.difference 实现的函数代码如下:123456789101112_.difference = function(array) &#123; // 获得到的 rest 函数 // 将 arguments 传入到 flatten 函数, 传入的参数是 startIndex: 1 // 表示获取到传入的 arguments 的第二个参数 var rest = flatten(arguments, true, true, 1); // 对于数组使用 filter 的方法 // !_.contains 对于每一个数组进行遍历处理 // 返回 rest 中没有包含 value 的值 return _.filter(array, function(value)&#123; return !_.contains(rest, value); &#125;); &#125;; union 实例 _.union(*arrays)使用 union 用于返回传入的 arrays 的并集。按照顺序返回，可以传入一个或者多个的 arrays 数组。源码分析 123_.union = function() &#123; return _.uniq(flatten(arguments, true, true));&#125; 其中 _.uniq 函数如下:1234567891011121314151617181920212223242526272829303132333435_.uniq = _.unique = function(array, isSorted, iteratee, context) &#123; if (array == null) return []; // 如果 isSorted isBoolean if (!_.isBoolean(isSorted)) &#123; context = iteratee; iteratee = isSorted; isSorted = false; &#125; // 如果 iteratee 不是null if (iteratee != null) iteratee = cb(iteratee, context); var result = []; var seen = []; for (var i = 0, length = array.length; i &lt; length; i++) &#123; var value = array[i], // 获取到返回的结果 computed = iteratee ? iteratee(value, i, array) : value; if (isSorted) &#123; // 如果 i !== 0 或者 seen 不等于 computed 将 value push 进入到 result 中 if (!i || seen !== computed) result.push(value); // 将computed 结果赋给 seen seen = computed; // 如果 iteratee 函数存在的话并且没有被排序 &#125; else if (iteratee) &#123; // 如果seen 中没有包含有 computed 结果 if (!_.contains(seen, computed)) &#123; // 将computed 结果推入到 seen 中 seen.push(computed); result.push(value); &#125; &#125; else if (!_.contains(result, value)) &#123; result.push(value); &#125; &#125; return result; &#125;; intersection _.intersection(arrays)实例 使用 _.intersection 用来返回传入多个数组的并集。1_.intersection([1, 2, 3], [1, 2, 4], [10, 1, 2, 6]) // [1, 2] 返回传入的多个数组的并集。源码分析 1234567891011121314151617_.intersection = function(array) &#123; var result = []; var argsLength = arguments.length; for (var i = 0, length = getLength(array); i &lt; length; i++) &#123; var item = array[i]; // 使用 continue 是结束本次循环 // 用于判断传入的数组中是否有包含的相同的元素 if (_.contains(result, item)) continue; // 使用 break 是结束整个循环 for (var j = 1; j &lt; argsLength; j++) &#123; if (!_.contains(arguments[j], item)) break; &#125; // 当上次循环结束之后 j === argsLength 成立 if (j === argsLength) result.push(item); &#125; return result; &#125;; 基本的思路是对于第一个传入的数组中的值进行遍历，根据第一个数组中的值, 遍历其他的数组，判断其他的数组中是否含有这个值。如果含有这个值的时候，将这个值存入一个result数组，最后将这个 result 数组返回。要点: 两次循环, 使用结束循环的方式是不一样的。 使用 break 的时候， 结束的是整个循环使用 continue 的时候, 结束的是当前的循环 关于 contain 函数使用 contain 用来判断在一个数组中是否包含有某一个元素:在 es6 中使用 Array.includes(item) 来判断 item 是否包含在 Array 之中。 difference 实例 _.difference(array, *others) 使用 difference 获取到来自于 array 但是不存在于 others 中的数组元素。源码分析 自己写的代码:1234567function difference(array, other) &#123; let rest = Array.prototype.slice.call(arguments, 1); let newArr = array.filter((item) =&gt; &#123; return other.indexOf(item) === -1; &#125;); return newArr;&#125; 源码如下:123456_.difference = function(array) &#123; var rest = flatten(arguments, true, true, 1); return _.filter(array, function(value)&#123; return !_.contains(rest, value); &#125;); &#125;;]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js 源码解析(六)]]></title>
    <url>%2F2017%2F11%2F27%2Funderscore-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%85%AD%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }underscore.js 源码解析(六) first initial last rest compactfirst 实例 _.first(array, [n])n 是可选的, 表示选择数组中的前 n 个元素， 当我们没有传递 n 的时候，我们获得的是数组的第一个元素 array[0]。使用 first 用来获取到数组中的第一个元素。12let list = [1, 2, 3, 4];_.first(list) // 1 源码分析 使用 _.first 实现的源码如下:12345678_.first = _.head = _.take = function(array, n, guard) &#123; // 如果 array 为null 返回 undefined if (array == null) return void 0; // 如果没有明确传入的 参数 n 返回数组的第一项 array[0] if (n == null || guard) return array[0]; // 使用 _.initial 用于返回数组的前 n 个元素 return _.initial(array, array.length - n); &#125;; 注意: 如何判断 null? 如果使用 typeof 判断 null 会返回 object , 实现判断是否为 null 的简单方法是进行判断: 123if (obj == null) &#123; // isnull&#125; 这里使用了一个 _.initial 用于获取到数组的相关值:_.initial 使用 _.initial 的目的在于返回数组中前 n 个元素，不包括第 n 个元素源码如下: 123_.initial = function(array, n, guard) &#123; return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));&#125;; _.last 使用 _.last 用于返回数组中的最后一个元素。源码分析 123456_.last = function(array, n, guard) &#123; if (array == null) return void 0; if (n == null || guard) return array[array.length - 1]; // 调用 rest函数， 当 n !== null 的时候 return _.rest(array, Math.max(0, array.length - n)); &#125;; _.rest 使用 _.rest 函数用于返回数组中剩下的元素。源码分析 123_.rest = _.tail = _.drop = function(array, n, guard) &#123; return slice.call(array, n == null || guard ? 1 : n); &#125;; 使用 slice.call 其实是 Array.prototype.slice.call() 的方法Array.slice(start, end) // 用于裁剪数组，裁剪的数组包括 start 不包括 end compact 使用 compact 用于去除所有为 假值 的数组成员 关于假值: false, undefined null 0 以及 &quot;&quot; 被称为假值, 因为强制类型转换会被转换为 false。 源码如下:1234_.compact = function(array) &#123; // 在 filter 的函数中 return _.filter(array, _.identity);&#125;; 因为在上面的代码中，函数 _.filter 中存在一个判断:123if (someFn) &#123; // doSomething&#125; 这里会对位于 if 框内的元素someFn进行强制类型转换。]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js 源码分析(五)]]></title>
    <url>%2F2017%2F11%2F26%2Funderscore-js-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }underscore.js 源码解析（五） sample toArray size partition_.sample _.sample(list, [n])用于产生一个随机样本, 传递的参数 n 表示从 list 中返回 n 个随机元素。源码分析 12345678910_.sample = function(obj, n, guard) &#123; if (n == null || guard) &#123; if (obj.length !== +obj.length) obj = _.values(obj); // 返回使用 _.random 获得的随机数 return obj[_.random(obj.length - 1)]; &#125; // 使用 slice 用来分割数组 // 使用 Math.max() 用来返回最大值 return _.shuffle(obj).slice(0, Math.max(0, n)); &#125;; 通过使用 Math.max() 用来获得一组数中的最大值。1234Math.max(value1, value2, value3, value4...)// 获取到 value1, value2, value3, value4... 等一组数中的最大值Math.min(value1, value2, value3, value4...)// 获取到 value1, value1.. 中的最小值 使用 Array.slice 用来进行分割数组Array.slice(start, end) 分割的数组中包括 start 不包括 end toArray 实例 _.toArray(list)如果 list 是一个可以迭代的对象, 可以将 list 转化为一个数组。源码分析 123456789101112_.toArray = function(obj) &#123; // 如果 obj 不存在, 返回一个空的数组 if (!obj) return []; // 如果 obj 是一个真正的数组, 返回 slice.call(obj), // Object.prototype.slice if (_.isArray(obj)) return slice.call(obj); // 如果 obj 是一个类数组对象 // 类数组对象属于对象，但是有 length if (obj.length === +obj.length) return _.map(obj, _.identity); // 返回 obj 是一个对象 return _.values(obj); &#125;; 当我们判断一个对象是否是数组或者对象的时候我们要分为几种情况:使用 obj.length 进行判断的时候: 对象是数组:使用 Array.isArray 进行判断，当 这个判断不支持的时候，使用 Object.prototype.toString 进行判断。123function isArray(obj) &#123; return Array.isArray(obj) || Object.prototype.toString.call(obj) ==== '[object Array]';&#125; 对象是类数组对象对于类数组对象也有 length 属性，因此当我们判断类数组对象不是数组的时候，接下来进行判断:123if (obj.length === +obj.length) &#123; // 判断得到是类数组对象&#125; 当得到的类型是对象的时候 1234// 对于对象而言: obj.length: undefined// +obj.length: NaNif (obj.length !== +obj.length) &#123;&#125; size _.size(list)用于返回 list 的长度当 list 是数组的时候，返回的是数组的长度，当 list 是对象的时候，返回的是对象的长度。实例 123456let person = &#123; name: '张宁宁', age: 23, sex: 'female'&#125;;_.size(person) // 3 源码分析 使用_.size 进行判断的数组数量的方法十分简单，判断传入的是对象或者是数组，对象的话返回的是键的值，对于数组返回的是数组的长度。1234567function size(list) &#123; if (list == null) return 0; // 判断 list 是否是对象或者数组 // list 是数组，返回 list 的length // list 是对象, 返回的是 Object.keys(list) 的长度 return list.length === +list.length ? list.length : Object.keys(list).length;&#125; partition _.partition(array, predicate)实例 使用 partition 的目的在于拆分一个数组为两个数组，拆分之后的数组中第一个数组是满足 predicate 函数的数组，拆分之后的第二个数组是不满足 predicate 函数的数组。 predicate : 断言，断定，宣布，宣讲，使基于 源码分析 123456789101112_.partition = function(obj, predicate, context) &#123; predicate = cb(predicate, context); // 定义两个数组，分别用来存放成功的数组和失败的数组 var pass = [], fail = []; _.each(obj, function(value, key, object) &#123; // predicate 返回 true : pass.push(obj) // predicate 返回 false : fail.push(obj) (predicate(value, key, object) ? pass : fail).push(obj); &#125;); // 返回一个二维数组 return [[pass], [fail]];&#125;;]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js源码分析(四)]]></title>
    <url>%2F2017%2F11%2F23%2Funderscore-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }underscore.js 源码分析(四) _.min _.sortBy _.groupBy _.indexBy _.countBy_.min _.min(list, [iteratee], [context])类似于使用 _.max 这个函数用于获取到 list 中的最小值, 其中 iteratee 是作为的筛选的依据。源码如下:123456789101112131415161718192021222324_.min = function(obj, iteratee, context) &#123; var result = Infinity, lastComputed = Infinity, value, computed; if (iteratee == null &amp;&amp; obj != null) &#123; obj = obj.length === +obj.length ? obj : _.values(obj); for (var i = 0, length = obj.length; i &lt; length; i++) &#123; value = obj[i]; if (value &lt; result) &#123; // 和使用 _.max 的没有什么不同，不同的是这里筛选的是最小值 result = value; &#125; &#125; &#125; else &#123; iteratee = cb(iteratee, context); _.each(obj, function(value, index, list) &#123; computed = iteratee(value, index, list); if (computed &lt; lastComputed || computed === Infinity &amp;&amp; result === Infinity) &#123; result = value; lastComputed = computed; &#125; &#125;); &#125; return result; &#125;; _.sortBy _.sortBy(list, iteratee, [context])使用 _.sortBy 返回的是一个经过排序之后的数组。排序的依据是根据 iteratee 函数进行判断的。返回的是进行排序之后的数组的副本，原来的数组并没有进行了改变。实例 源码分析 123456789101112_.sortBy = function(obj, iteratee, context) &#123; iteratee = cb(iteratee, context); return _.pluck(_.map(obj, function(value, index, list) &#123; return &#123; value: value, index: index, criteria: iteratee(value, index, list) &#125;; &#125;).sort(function(left, right) &#123; return _.comparator(left.criteria, right.criteria) || left.index - right.index; &#125;), 'value'); &#125;; 在 _.sortBy 函数中存在着多个的函数，下面一一进行分析。_.pluck 函数，这个函数用于获取到对象数组中包含有过相关属性的所有的对象。看来是用 _.map... 这个方法返回的是一个对象数组。1234// _.pluck 函数用于return _.pluck(_.map(obj, function(value, index, list) &#123; // balabala&#125;), 'value') 在 _.map... 中执行了两步操作: 调用了使用的 _.map 方法以及接下来调用 sort 方法。1234567891011121314// _.map 方法 obj 是一个对象数组// 返回的是一个数组，数组中包含有对象// value: 对象的值// index: 对象的键// criteria: 对象运行iteratee 之后返回的值_.map(obj, function(value, index, list) &#123; return &#123; // 对象中返回了三个值 // &#123;value: '', index: '', criteria: ''&#125; value: value, index: index, criteria: iteratee(value, index, list) &#125;&#125;) 对于使用 _.map 方法返回的一个新的数组对象之后， 对于这个新的对象数组执行 sort 方法。关于数组的 sort 方法: 关于使用数组的 sort 方法12Array.sort(sortBy);// sortBy 是一个用来进行排序依据的函数 使用 sort() 方法的时候，如果不传递 sortBy 的时候，使用数组的 sort 方法默认的是按照字符编码的顺序进行排序 例如:123let a = [1, 2, 4, 23];// 在原来的数组上进行的改变，并没有生成一个新的数组a.sort() // [1, 2, 23, 4] sortBy 是用来进行排序的函数:sortBy 接收两个参数，用来对于这两个参数进行比较。 接下来执行的是 sort 函数12345.sort(function(left, right) &#123; // 在使用 comparator 之后进行比较 left.index - right.index // 为什么呢？ return _.comparator(left.criteria, right.criteria) || left.index - right.index;&#125;) 这个函数的作用是对于上面返回的数组对象进行 sort 排序。 返回的是 _.comparator(left.criteria, right.criteria) 或者 left.index - right.index。看来是用进行比较。其中 _.comparator 的方法。1234567891011121314// 传入要进行比较的函数参数 a, b_.comparator = function(a, b) &#123; // 如果 a === b 返回 0 if (a === b) return 0; // 判断 a &gt;= a b &gt;= b // 为什么呢？ var isAComparable = a &gt;= a, isBComparable = b &gt;= b; // 如果其中一个为 true if (isAComparable || isBComparable) &#123; if (isAComparable &amp;&amp; !isBComparable) return -1; if (isBComparable &amp;&amp; !isAComparable) return 1; &#125; return a &gt; b ? 1 : (b &gt; a) ? -1 : 0; &#125;; _.groupBy 实例 _.groupBy(list, iteratee, [context])将一个集合分为多个的集合，通过使用 iteratee 函数进行分组，如果 iteratee 是一个字符串而不是一个函数的时候，将这个 iteratee 作为元素的属性名来进行分组。如下:1234_.groupBy([1, 2, 4], function(num) &#123;return num % 2;&#125;) // &#123; 0: [2, 4], 1: [1] &#125;// 返回一个对象// 对象的属性是函数中返回的值// 相应属性的值是 list 数组中运行函数得到的相应属性的集合 源码解析 123_.groupBy = group(function(result, value, key) &#123; if (_.has(result, key)) result[key].push(value); else result[key] = [value]; &#125;); 在上面的函数中，存在两个函数: group 以及 _.has关于使用 group 函数:1234567891011121314151617// 接收一个 behavior 作为参数var group = function(behavior) &#123; // 返回一个函数，这个函数就是返回的 _.groupBy return function(obj, iteratee, context) &#123; // 定义 result 是一个对象 var result = &#123;&#125;; iteratee = cb(iteratee, context); _.each(obj, function(value, index) &#123; // 对于使用 obj 进行遍历, 获取到 key // 将 list 中的 value, index 传入 var key = iteratee(value, index, obj); // 执行 behavior 函数 behavior(result, value, key); &#125;); return result; &#125;; &#125;; 在上面的函数中 behavior 函数是在 _.groupBy 中的函数是下面的这个:1if (_.has(result, key)) result[key].push(value); else result[key] = [value]; 使用 _.has 方法用来判断对象 result 中是否含有属性 key:_.has 方法如下:1234let _.has = function (obj, key) &#123; // 当obj 不是null 并且 对象 Obj 中包含有属性 key 的时候 返回 true return obj !== null &amp;&amp; Object.prototype.hasOwnProperty.call(obj, key);&#125; _.indexBy _.indexBy(list, iteratee, [context])使用 _.indexBy 用来返回在列表中每一个元素键的 iteratee 函数。 返回一个每一项索引的对象。 使用 _.indexBy 和使用 _.groupBy 的区别在于:使用 _.indexBy 你需要知道键值对是唯一的，比如:12345678&gt;let list = [&#123;name: '张宁宁', age: 20&#125;, &#123;name: '张宁宁', age: 50&#125;];&gt;_.indexBy(list, function(value) &#123; return value.name &#125;);&gt;=&gt;&gt;&#123;张宁宁:&#123;name: "张宁宁", age: 50&#125;&#125;&gt;_.groupBy(list, function(value) &#123; return value.name &#125;);&gt;=&gt;&gt;&#123;张宁宁:[&#123;name: '张宁宁', age: 20&#125;, &#123;name: '张宁宁', age: 50&#125;]&#125;;&gt; 实例 1234567let list = [&#123;name: '张三', age: 12&#125;， &#123;name: '李四', age: 13&#125;];_.indexBy(list, 'age');=&gt; &#123; '12': &#123;name: '张三', age: 12&#125;, '13': &#123;name: '李四', age: 13&#125;&#125; 源码解析 类似于使用 _.groupBy 的源码, 使用 _.indexBy 的源码如下:123_.indexBy = group(function(result, value, key) &#123; result[key] = value;&#125;); _.countBy _.countBy(list, iteratee, [context]) 返回各组中对象的数量的计数。返回在该组中值的数目。实例 1234let list = [&#123;name: '张宁宁', age: 20&#125;, &#123;name: '张宁宁', age: 50&#125;];_.countBy(list, function(value) &#123; return value.age &#125;);=&gt;&#123; 20: 1, 50: 1 &#125; 源码如下 12345let _.countBy = group(function(result, value, key) &#123; // 如果在 result 中存在 key result[key] ++ // 否则 将 result[key] = 1; if (_.has(result, key)) result[key] ++; else result[key] = 1; &#125;) 其中 [group](# group) 函数；shuffle 实例 用来返回一个随机乱序的副本。并没有改变 list 的值。123let list = [1, 2, 3, 4, 5, 6];_.shuffle(list)[2,6,3,1,5,4] 源码分析 使用 _.shuffle 的源码如下:123456789101112131415161718_.shuffle = function(obj) &#123; // 获取到数组的值或者对象的值 var set = obj &amp;&amp; obj.length === +obj.length ? obj : _.values(obj); // var length = set.length var length = set.length; // shuffled 是一个数组 var shuffled = Array(length); for (var index = 0, rand; index &lt; length; index++) &#123; // 通过使用 _.randow获得到rand 随机数 rand = _.random(0, index); if (rand !== index) shuffled[index] = shuffled[rand]; // 将 index 的值赋给这个随机数组 // 将set[index] 传入到 shuffled 中 shuffled[rand] = set[index]; &#125; // 返回生成的随机数组 return shuffled;&#125;; 对于使用 _.random 的函数如下:123456789// 这个函数的目的是用来生成_.random = function (min, max) &#123; if (max == null) &#123; max = min; min = 0; &#125; // 加了一个 1 表示生成的数中可以包括 max return min + Math.floor(Math.random() * (max - min + 1));&#125; Math.floor : 向下取整Math.random 用于生成 0 - 1 之间的随机数; 注意: 使用的是生成 min 和 max 之间的值得时候: min : inclusive 包括 max : exclusive 不包括 12Math.random() * (max - min) + min// 生成 位于 max 与 min 之间的数， 包括 min 但不包括 max 在 shuffle 函数中，使用了一个分牌算法：12345678for (var index = 0, rand; index &lt; length; index++) &#123; // 通过使用 _.randow获得到rand 随机数 rand = _.random(0, index); if (rand !== index) shuffled[index] = shuffled[rand]; // 将 index 的值赋给这个随机数组 // 将set[index] 传入到 shuffled 中 shuffled[rand] = set[index]; &#125; 使用 分牌算法的原理如下:存在两个数组 a 和 b现在想要将 a 中的元素随机生成到 b 中12345a--&gt;b: indexnote left of a: a 中遍历b--&gt;b:根据 a 中的index b[index] = b[rand],\n取到自身的 b[rand] 值b--&gt;a: rand(随机生成的\n位于(0, index) 之间的数值)a--b: 将得到的 rand 随机数\n b[rand] = a[index],填补刚才 b取到的自身的 rand 如上图所示的算法:123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js源码分析(三)]]></title>
    <url>%2F2017%2F11%2F22%2Funderscore-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }underscore.js 源码分析(三) _.some _.contains _.invoke _.pluck _.max_.some 实例 _.some(list, [predicate], [context])遍历 list 中的元素, 只要其中有一个元素通过 predicate , 那么就返回为 true源码分析 12345678910111213_.some = _.any = function(obj, predicate, context) &#123; if (obj == null) return false; predicate = cb(predicate, context); var keys = obj.length !== +obj.length &amp;&amp; _.keys(obj), length = (keys || obj).length, index, currentKey; for (index = 0; index &lt; length; index++) &#123; currentKey = keys ? keys[index] : index; // 如果 obj 中其中的一个元素进行 predicate 检验的结果为 true 返回为true if (predicate(obj[currentKey], currentKey, obj)) return true; &#125; return false;&#125;; _.contains 实例 _.contains(list, value, [fromIndex])如果在 list 中包含有 value 值，那么返回为 true fromIndex 表示开始进行检索的位置。如果 list 是数组, 检查数组中是否包含有对应的 value 值如果 list 是对象, 检查对象中的值是否有存在的 value 值自己写的代码:123456789function contain(obj, value, fromIndex) &#123; if (obj == null) return false; let list = obj; if (obj.length !== +obj.length) &#123; list = obj.values(); &#125; // 为了保证代码的健壮性，添加 typeof fromIndex === 'number' &amp;&amp; fromIndex 的判断 return list.indexOf(value, typeof fromIndex === 'number' &amp;&amp; fromIndex) &gt;= 0;&#125; 源码分析 1234567_.contains = _.includes = _.include = function(obj, target, fromIndex) &#123; if (obj == null) return false; // 使用 _.values 获得到对象的值 if (obj.length !== +obj.length) obj = _.values(obj); // 使用 `_.indexOf` 获取到索引 return _.indexOf(obj, target, typeof fromIndex == 'number' &amp;&amp; fromIndex) &gt;= 0;&#125;; _.invoke 计算机术语中: invoke : [ɪnˈvoʊk] 乞求，借助于 调用【计算机】 实例 _.invoke(list, methodName, *arguments) 在 list 的每一个元素上执行 methodName 方法。 argument 用于将使用 _.invoke 调用 methodName 方法的时候传递的函数。12345678let list = [[1, 4, 3]];_.invoke(list, 'sort') // [1, 3 ,4]// 这个函数的作用是将 执行 list 元素中的数组 [1, 4, 3] 方法 sort// 同样 我们可以使用别的函数,这个时候 argument 会被作为 methodName 函数的参数，// 而 函数 print 中的 this 值指向的是 list 中的元素function print() &#123; console.log(this); // [1, 4, 3]&#125; 源码分析 实现这个功能的源码如下:123456789101112_.invoke = function(obj, method) &#123; // 使用 Array.slice.call 返回一个子数组 // 第二个参数 2 表示截取从传入参数的第二个处进行截取 var args = slice.call(arguments, 2); var isFunc = _.isFunction(method); // 对于 obj 进行遍历 return _.map(obj, function(value) &#123; // 通过使用 apply 方法， 将 value 作为 func 的 this 值， 同时传入截取的参数 // 进行判断是否是函数 method 或者 内置的 method 方法 return (isFunc ? method : value[method]).apply(value, args); &#125;); &#125;; 这是一个用于进行调用绑定的函数。_.pluck pluck 拔掉，摘，拉 _.pluck(list, propertyName) 实例 使用 _.pluck 用于获取到数组对象中的对应属性的所有的值。对于对象中不存在的属性返回 undefined123var stooges = [&#123;name: 'moe', age: 40&#125;, &#123;name: 'larry', age: 50&#125;, &#123;name: 'curly', age: 60&#125;];_.pluck(stooges, 'name');=&gt; ["moe", "larry", "curly"] 自己写的一个 pluck 函数如下：123456789101112function pluck(list, name) &#123; let props = []; list.map((obj) =&gt; &#123; if (Object.keys(obj).indexOf(name) &gt;= 0) &#123; props.push(obj[name]); &#125; else &#123; // 这里使用 void 0 代替 undefined props.push(void 0); &#125; &#125;); return props; &#125; 源码分析 1234_.pluck = function(obj, key) &#123; // 使用 _.map， 对于 obj 中的数组对象成员执行 _.property 方法 return _.map(obj, _.property(key));&#125;; 1234567_.property = function(key) &#123; // 返回一个函数， 参数 obj 接收到的是 _.property()(obj) 这个的值 return function(obj) &#123; // 传入的 obj 是否为 null 是 返回 undefined 否则 返回 obj[key] return obj == null ? void 0 : obj[key]; &#125;; &#125;; _.max _.max(list, [iteratee], [context]) 返回 list 中的最大值。123456789101112131415161718192021222324252627282930313233_.max = function(obj, iteratee, context) &#123; // 将 result 初始化为 -infinity lastComputed 初始化为 infinity var result = -Infinity, lastComputed = -Infinity, value, computed; // 当 interaee 为null 不传参数,采用 obj 中内置的方法名称来做 // 并且 obj 不等于 null 的时候 if (iteratee == null &amp;&amp; obj != null) &#123; // obj 为数组 ? 数组 : 对象的值 obj = obj.length === +obj.length ? obj : _.values(obj); for (var i = 0, length = obj.length; i &lt; length; i++) &#123; // 进行遍历值 value = obj[i]; // 比较大小，将最大的那个值赋给 result 参数 if (value &gt; result) &#123; result = value; &#125; &#125; &#125; else &#123; iteratee = cb(iteratee, context); // 使用 foreach 对于 obj 进行计算 _.each(obj, function(value, index, list) &#123; // 进行计算之后返回计算结果 computed = iteratee(value, index, list); // 如果计算结果大于上一次计算结果， 将最大的值赋给 result // 将最大的结果赋予 lastComputed if (computed &gt; lastComputed || computed === -Infinity &amp;&amp; result === -Infinity) &#123; result = value; lastComputed = computed; &#125; &#125;); &#125; return result; &#125;; 在js 中关于运算符优先级的问题: 逻辑 &amp;&amp; (与) 大于 逻辑 或|| 上面有一段程序如下:if (computed &gt; lastComputed || computed === -Infinity &amp;&amp; result === -Infinity)这段话翻译为中文就是如果满足 computed === -Infinity &amp;&amp; result === -Infinity 或者 computed &gt; lastComputd 的时候，进行动作。]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js源码分析(二)]]></title>
    <url>%2F2017%2F11%2F20%2Funderscore-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }underscore.js 源码分析(二) _.filter _.where _.findWhere _.reject _.every_.filter 实例 _.filter(list, predicate, [context])遍历 list 值, 返回通过 predicate 函数返回为真的值数组。代码如下:12345list = [1, 2, 5, 6];function toFilter(num) &#123; return num % 2 === 0;&#125;console.log('通过过滤的数组', _.filter(list, toFilter)); // [2, 6] 源码分析 使用 _.filter() 的源码如下所示:1234567891011_.filter = _.select = function(obj, predicate, context) &#123; var results = []; // 判断 `obj` 是否为 null 是返回空数组 if (obj == null) return results; predicate = cb(predicate, context); // 使用 `each` 函数对于数组中的每一个列表进行遍历 _.each(obj, function(value, index, list) &#123; if (predicate(value, index, list)) results.push(value); &#125;); return results;&#125;; _.where 实例 _.where(list, propertries)list: 数组propertries : 需要进行检索的键值对(一个对象)遍历 list 中的每一个值， 返回一个数组，这个数组中包含含有 propertries 中属性的所有的键值对。用法:12list = [&#123;name: '张宁宁', age: 18&#125;, &#123;name: '张宁宁', age: 70&#125;];console.log(_.where(list, &#123;name: '张宁宁', age: 18&#125;)); // [&#123;name: '张宁宁', age: 18&#125;] #####源码分析 自己写的代码:123456789101112131415161718192021222324function where(list, sObj) &#123; let results = []; let flag = false; if (list == null) &#123; return results; &#125; for (let obj of list) &#123; for (let key in obj) &#123; if (Object.keys(sObj).includes(key)) &#123; if (sObj[key] === obj[key]) &#123; flag = true; &#125; else &#123; flag = false; &#125; &#125; else &#123; flag = false; &#125; &#125; if (flag) &#123; results.push(obj); &#125; &#125; return results;&#125; _where() 源代码如下所示:123_.where = function(obj, attrs) &#123; return _.filter(obj, _.matches(attrs));&#125;; 使用 _filter 筛选出 obj 对象中适合函数 _.matches 的键值对儿。_.match() 方法的源码如下所示:123456789101112131415161718192021_.matches = function(attrs) &#123; // 获取到对象的键值对儿, 是 [key, value] 的形式 var pairs = _.pairs(attrs), length = pairs.length; // 返回一个函数，接收 obj 参数 return function(obj) &#123; // 如果 obj == null 返回 !length // 为什么不直接返回false ? if (obj == null) return !length; // 创建一个新对象 obj = new Object(obj); for (var i = 0; i &lt; length; i++) &#123; var pair = pairs[i], key = pair[0]; // 两种情况， 不存在键或者键存在，值不相等， 两种情况发生一种情况 // 返回 false if (pair[1] !== obj[key] || !(key in obj)) return false; &#125; // 返回 true return true; &#125;;&#125;; 对于返回一个函数的这种形式:1234567function name() &#123; return function (obj)&#123; // dosomething &#125;&#125;// 调用的时候这样调用name()(); // to dosomething _.findWhere 实例 _findWhere(list, properties)遍历整个 list 返回匹配整个 properties 参数所列出的所有键值对儿的第一个值。源码分析 12345_.findWhere = function(obj, attrs) &#123; // 通过使用 _.matches(attrs) 返回了一个函数 // 通过使用 _.find 方法调用了这个函数 return _.find(obj, _.matches(attrs));&#125;; 通过调用 _.find 函数返回通过第一次获得匹配的对象。_.reject 实例 _.reject(list, predicate, [context])返回 list 列表中没能通过 predicate 检验的数值。12345function reject() &#123; return num%2 === 0;&#125;let list = [1, 3, 5, 6];console.log(_.reject(list, reject)); // [1, 3, 5]; 作用与 filter 相反。源码分析 123_.reject = function(obj, predicate, context) &#123; return _.filter(obj, _.negate(cb(predicate)), context);&#125;; _.negate 函数123456 _.negate = function(predicate) &#123; return function() &#123; // 通过使用 apply 方法将 arguments 方法传入 return !predicate.apply(this, arguments); &#125;;&#125;; _every 实例 _every(list, [predicate], [context])如果 list 中的元素都通过 predicate 的真值检验就返回为 true代码分析 源码如下:1234567891011121314function every(obj, predicate) &#123; if (obj == null) return true; // 通过使用 keys 获得到一个包含对象键的数组 let keys = obj.length == +obj.length &amp;&amp; Object.keys(obj); let currentKey; // length 为数组或者对象的长度 let length = (keys || obj).length; for (let index = 0; index &lt; length; index++) &#123; currentKey = keys ? keys[index] : index; // 如果对于predicate 函数返回为 false, every 函数返回为false if (!predicate(obj[currentKey])) return false; &#125; return true;&#125;]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore.js源码分析(一)]]></title>
    <url>%2F2017%2F11%2F18%2Funderscore-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }underscore.js 源码分析（一） _.each _.map _.refuce _.reduceRight _.find_.each 实例 _.each(list, iteratee, [context])这个方法用于循环遍历, 用于循环 list 对象或者数组， iteratee 是一个遍历函数，接收的参数为遍历之后的结果。 当 list 为数组的时候，传递给 iteratee 函数的参数是 (element, index, list), 当 list 为对象的时候, 传递给 iteratee 函数的参数是 [value, key, list]。对于 context 上下文, 这个决定的是 iteratee 中的 this 的指向值。可选参数， 当 context 忽略的时候 this 指向的是全局变量。_.each 返回值是进行遍历的 list 数组对象。123456789101112131415function print(value, index, list) &#123; console.log(this.name);// 这里 this 指向了后面传递的 context console.log(value, index, list);&#125;let person = &#123; name: &apos;张宁宁&apos;&#125;console.log(_.each([1, 2, 3], print, person)); // [1, 2, 3]// 最终打印张宁宁1 0 (3) [1, 2, 3]张宁宁2 1 (3) [1, 2, 3]张宁宁3 2 (3) [1, 2, 3] 源码分析 在 underscore.js 源码中， _.each() 源码为下:1234567891011121314151617181920212223_.each = _.forEach = function(obj, iteratee, context) &#123; // 如果 obj == null 返回 null if (obj == null) return obj; // 调用 optimiseCb 函数 稍后分析 iteratee = optimizeCb(iteratee, context); var i, length = obj.length; // 这里提供了分别 数组和对象的一种方法 // 如果数组 if (length === +length) &#123; // 数组情况下， 将 [value, index, list] 传入遍历函数 for (i = 0; i &lt; length; i++) &#123; iteratee(obj[i], i, obj); &#125; &#125; else &#123; // 获取到对象所有的 key 值 var keys = _.keys(obj); for (i = 0, length = keys.length; i &lt; length; i++) &#123; iteratee(obj[keys[i]], keys[i], obj); &#125; &#125; // 返回数组或者对象 return obj; &#125;; 分析: 分别数组和对象的方法 我平常的时候使用 Object.prootype.toString.call().slice(8, -1) 这种方法来分别数组和纯对象，这里使用了一种方法。 12345if (length === +length) &#123;// 这是数组&#125; else &#123;// 这是对象&#125; +length 执行的是隐式类型转换，用于将其他的值转换为数字。经过实验，使用 + 进行类型转换的可能性如下: 123456789+null // 0+flase // 0+"" // 0+true // 1+对象 // NaN+非空字符串 // NaN+NaN // NaN+1 // 1+undefined // NaN 因为上面中 对象的 length 为 undefined 因此 length ===+length // false 这里 +length 会被转化为 NaN。 iteratee = optimizeCb(iteratee, context); optimizaCb 函数 使用 optimizaCb 函数用于绑定上下文: 使用 call 以及 apply 的方法实现的改变函数运行的 this 值的改变 接收三个参数: func 运行的函数 context 运行函数需要进行绑定的上下文 argCount 参数的个数 12345678910111213141516171819202122var optimizeCb = function(func, context, argCount) &#123; // 使用 void 0 类似于使用 undefined // 等同于使用 if(context === undefined) if (context === void 0) return func; switch (argCount == null ? 3 : argCount) &#123; case 1: return function(value) &#123; return func.call(context, value); &#125;; case 2: return function(value, other) &#123; return func.call(context, value, other); &#125;; case 3: return function(value, index, collection) &#123; return func.call(context, value, index, collection); &#125;; case 4: return function(accumulator, value, index, collection) &#123; return func.call(context, accumulator, value, index, collection); &#125;; &#125; return function() &#123; return func.apply(context, arguments); &#125;; &#125;; 上面的 _.each 源码中的使用这个函数的目的是将 iteratee 的上下文 this 绑定到 context 对象。 这里有一个 void 0 这里的 void 0 等同于使用 undefined 不同于使用 undefined 的原因在于： 在 javascript 中 undefined 不是一个保留字。代码如下:1234&gt;var undefined = 1;&gt;console.log(undefined); // 1 也是可以的&gt;使用 void 0 作用是这样的&gt; _.map 实例 _.map(list, iteratee, [context])通过 使用变换函数 iteratee 将list 中的值映射到一个新的数组。1234function filter(value) &#123; return value * 2;&#125;_.map([1, 2, 3], filter); // [2, 4, 6] 源码如下:12345678910111213141516_.map = _.collect = function(obj, iteratee, context) &#123; if (obj == null) return []; iteratee = cb(iteratee, context); // 使用 &amp;&amp; 操作符， 只有当第一个为true的时候才执行下一步操作 var keys = obj.length !== +obj.length &amp;&amp; _.keys(obj), // || 操作符 第一个为true的时候不再进行下一步动作 length = (keys || obj).length, // 使用 Array 创建一个 length 长度的数组 results = Array(length), currentKey; for (var index = 0; index &lt; length; index++) &#123; currentKey = keys ? keys[index] : index; results[index] = iteratee(obj[currentKey], currentKey, obj); &#125; return results;&#125;; 源码分析 使用 &amp;&amp; 以及 || 进行计算 这两个符号被称之为 选择器操作符，返回的是两边选择器结果的其中一个。在选择的过程中会被执行强制类型转换。 这里对于类型转换，使用的时候要注意出现假值的情况 使用 &amp;&amp; 以及 || 会首先对于 * 第一个* 操作数进行计算，根据判断结果来决定返回哪一个操作数。 1234a || b// 如果 a 类型转换结果为 true 返回的是 a 否则 返回 ba &amp;&amp; b// 如果 a 类型转换结果为 true 返回的是 b 否则返回 a 上面我们可以看到，我们可以利用这两个操作符做一些事情: a || b 好像备用条件。 如果条件 a 不成立, 执行条件 b, 如果成立，执行条件 a a ? a : b`a &amp;&amp; b` 好像通过条件， 如果 `a` 成立，向下执行，如果不成立，打住，返回 `a` 执行的结果 `a ? b : a` 使用 Array(length) 创建的是一个 length 长度的数组。 _.reduce 实例 _.reduce(list, iteratee, [memo], context)通过迭代将 list 中的元素归结为一个值。 memo 表示初始参数。12345function reduceFn(memo, num) &#123; return memo * num;&#125;let list = [1, 2, 3];_.reduce(list, reduceFn, 1) // 6 源码分析 源码如下:123456789101112131415function reduce(obj, iteratee, memo, context) &#123; if (obj === null) obj = []; iteratee = optimizeCb(iteratee, context, 4); var keys = obj.length !== +obj.length &amp;&amp; Object.keys(), length = (keys || obj).length, index = 0, currentIndex; if (arguments.length &lt; 3) &#123; memo = obj[keys ? keys[index++] : index++]; &#125; for (; index &lt; length; index++) &#123; currentIndex = keys ? keys[index] : index; memo = iteratee(memo, obj[currentIndex], currentIndex, obj); &#125; return memo; &#125; 分析: 在 obj 可能是对象或者数组的情况下，当 obj 是对象的时候，需要产生了一个 使用 keys 来进行数组操作 在迭代的时候， 当没有 memo 初始值的时候， 将数组或者对象的第一个值作为 memo 这里，使用 index++ 来处理的 使用 index++ 的时候，相当于 index = index + 1; 但是直接使用的时候还是原来的 index12345&gt;let currentIndex = 0;&gt;let addIndex = currentIndex++; // 相当于先返回 currentIndex 在进行加一操作&gt;addIndex // 0&gt;currentIndex // 1&gt; ​ 迭代的过程发生在使用循环赋值的过程中123for (; index &lt; length; index++) &#123; memo = iteratee(memo, obj[currrentIndex], currentIndex, obj);&#125; _.reduceRight 实例 _.reduceRight(list, iteratee, [memo], context)类似于使用_.reduce 不过不同于使用 _.reduce 的是，这个是从右边向左进行遍历操作;12345function contact(a, b) &#123; return a.contact(b);&#125;let list = [[1, 2], [3, 4], [5, 6]];_.reduceRight(list, contact) // [5, 6, 3, 4, 1, 2] 源码分析 1234567891011121314151617_.reduceRight = _.foldr = function(obj, iteratee, memo, context) &#123; if (obj == null) obj = []; iteratee = optimizeCb(iteratee, context, 4); var keys = obj.length !== + obj.length &amp;&amp; _.keys(obj), index = (keys || obj).length, currentKey; if (arguments.length &lt; 3) &#123; // 先对于 index 进行 减一操作 memo = obj[keys ? keys[--index] : --index]; &#125; // 在判断完成 index 之后进行减一操作 while (index-- &gt; 0) &#123; currentKey = keys ? keys[index] : index; memo = iteratee(memo, obj[currentKey], currentKey, obj); &#125; return memo; &#125;; 使用 while 循环进行判断 123while (index-- &gt; 0) &#123; // do something&#125; _.find 实例 _.find(list, predicate, [context])遍历 list 值 返回第一个通过 predicate 函数返回真值的数值。12345let list = [1, 2, 3];function getodd(value) &#123; return value % 2 === 0;&#125;_find(list, getodd) // 2 源码分析 123456789101112_.find = _.detect = function(obj, predicate, context) &#123; var key; // 如果是数组 if (obj.length === +obj.length) &#123; // 使用 findIndex 找到数组的值 key = _.findIndex(obj, predicate, context); &#125; else &#123; // 如果是是对象 key = _.findKey(obj, predicate, context); &#125; if (key !== void 0 &amp;&amp; key !== -1) return obj[key]; &#125;;]]></content>
      <categories>
        <category>underscore.js 源码分析</category>
      </categories>
      <tags>
        <tag>underscore.js源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[作用域 与 this 值]]></title>
    <url>%2F2017%2F11%2F12%2F%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }对于作用域而言，可以将作用域分为动态作用域和词法作用域。js 中的作用域属于词法作用域。词法作用域 对于使用词法作用域而言，词法作用域最重要的规则在于词法作用域的定义过程发生在代码的书写阶段。代码如下:123456789function foo() &#123; console.log(a) // 2&#125;function bar() &#123; var a = 3; foo();&#125;var a = 2;bar(); 因为这里面的 foo 函数书写在全局的作用域中，因此会被输出 2动态作用域 动态作用域关心的是函数是在哪里被调用的。上面的函数中使用动态作用域的时候 最终输出应该是 3,因为从 foo 函数被调用的地方寻在变量 a 最后找到了 var a = 3.词法作用域关心的是函数在那里被声明, 动态作用域关心的是函数在哪里被调用。使用js 中的 this 的时候， this 的效果是类似于使用动态作用域的。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[translate3d']]></title>
    <url>%2F2017%2F11%2F05%2Ftranslate3d%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }transform 特性 一个使用 transform 实现的垂直居中的代码如下:1234567891011121314151617181920&lt;div class="fDiv"&gt; &lt;div class="cDiv"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style &gt; .fDiv &#123; width: 300px; height: 300px; position: relative background-color: blue; &#125; .cDiv &#123; position: absolute; background-color: red; top: 50%; left: 50%; width: 50%; height: 50%; transform: translate3d(-50%, -50%, 0); // translate(-50%, -50%) &#125;&lt;/style&gt; transform 这个的 css 元素实际上是可以允许我们对于元素进行旋转, 移动, 缩放, 或者平移常见的 transform 特性如下其中 translate 规定的是元素在 x, y ,z 轴上的位移translate (x, y, z)length / percentage 其中 x, y z 的单位可以是长度或者是百分比, 当以百分比进行比较的时候, 百分比相对的是元素本身的高度或者宽度在上面的完全居中代码中1234567position: absolute;background-color: red;top: 50%;left: 50%;width: 50%;height: 50%;transform: translate3d(-50%, -50%, 0); // translate(-50%, -50%) 在添加 transform之前, 方块是这样被放置的:因为这里是定位, top 以及 left 被放置的时候的宽度以及高度的百分比是按照父元素的宽度和高度进行计算的添加了transform 之后因为这里使用 translate 定义的距离 x , y , z 的距离是根据元素本身的宽度和高度被定义的, 而同时使用 left: 50% 的时候元素被紧靠在父元素的中间垂线上, 使用 translate 的时候向左移动了元素的一半距离, 使得这个元素在水平距离上是居中设置的。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>transform</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象复制]]></title>
    <url>%2F2017%2F11%2F04%2F%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }复制对象 对于变量进行复制的代码如下:123456789101112131415function clone(obj) &#123; if (obj &amp;&amp; typeof obj === 'object') &#123; let cloneObj = Object.prototype.toString.call(obj).slice(8, -1) === 'Array' ? [] : &#123;&#125;; for (let prop in obj) &#123; if (obj[prop] &amp;&amp; typeof obj[prop] === 'object') &#123; cloneObj[prop] = clone(obj[prop]); &#125; else &#123; cloneObj[prop] = obj[prop]; &#125; &#125; return cloneObj; &#125; else &#123; return obj; &#125;&#125; 要点 使用 Object.prototype.toString.call() 来判断数据是属于对象的哪一种子类型1234let a = [];typeof a; // objectObject.prototype.toString.call(a) // &quot;[object, Array]&quot;Object.prototype.toString.call(a).slice(8, -1) // &quot;Array&quot; 在 js 中 null 代表假值, 并且 typeof null 为 object检测类型为不为 null123456if (typeof obj === 'object' &amp;&amp; obj) &#123;&#125;// 对于如果检查到的类型为 null 的时候if (obj === null) &#123;// do something &#125; null 表示类型尚未定义，表示未定义的类型， undefined 表示值没有被声明 获取class 使用原生的方法获取到 class 值的方法如下:123456789101112function getClass(parent, sClass) &#123; let elements = parent.getElementsByTagName('*'); let eleResult = []; // 使用 '\\b' 进行匹配一个单词的边界 let classReg = new RegExp('\\b' + sClass + '\\b', i); for (let i = 0; i &lt; elements.length; i++) &#123; if (classReg.test(elements[i].className)) &#123; eleResult.push(elements[i]); &#125; &#125; return eleResult;&#125;]]></content>
      <categories>
        <category>代码集</category>
      </categories>
      <tags>
        <tag>对象复制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-promise]]></title>
    <url>%2F2017%2F10%2F30%2Fes6-promise%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }resove and reject 使用 es6 回调函数的例子1234567let promise = new Promise(function (resolve, reject) &#123; if (/* 如果异步操作成功 */) &#123; resolve(value); &#125; else &#123; reject(error) &#125;&#125;) 在上面的函数中，调用promise 构造函数创建了一个 promise 对象, 这个构造函数接收一个函数作为参数, 在函数中存在两个参数 resolve 和 reject , 这两个参数是两个函数, 用来执行回调的作用 resolve resove 是作为异步回调成功之后需要执行的函数 reject reject 是作为异步回调失败之后需要进行执行的函数在 promise 的对象中, 可以通过进行判断来选择执行 resolve 或者 reject 函数 使用 promise 进行 ajax 请求的函数如下:123456789101112131415161718192021222324252627282930313233/*** @description promise 的 ajax 请求* @param url &#123;String&#125; ajax 请求的地址* @param method &#123;String&#125; ajax 请求的方法 &apos;get&apos; or &apos;method&apos;* @return promise 新的 promise 请求对象**/let ajax = function (url, method) &#123; let promise = new Promise((resolve, reject) =&gt; &#123; let xhr = new XMLHttpRequest(); xhr.open(method, url); xhr.onreadystatechange = handler; xhr.responseType = &apos;json&apos;; xhr.setRequestHeader(&apos;Accept&apos;, &apos;application/json&apos;); xhr.send(); function handler() &#123; if (this.readystate !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statuText)); &#125; &#125;; &#125;); return promise;&#125;;ajax(url, &apos;get&apos;).then((json) =&gt; &#123; console.log(&apos;请求成功之后返回的数据&apos;, json);&#125;, (error) =&gt; &#123; console.error(&apos;出现的错误&apos; + error);&#125;); promise.then() 在创建完成 promise 实例之后, 可以调用 promise.then() 中指定具体的回调成功或者失败的具体函数 promise.then() 用于接收两个回调函数作为参数, 第一个回调函数是当 Promise 对象状态变为 resolve 的时候执行的函数,表示上面的 resolve 函数, 第二个回调函数是当 Promise 对象状态变为reject 的时候执行的函数, 也就是表示上面的 reject 函数,这两个函数都可以接收 promise 传入的值作为函数参数 12345promise.then(function(value) &#123; // when promise success do something&#125;, function(error) &#123; // when promise failed do something&#125;) promise.all() 使用 promise.all() 方法用于将多个 promise 实例, 包装为一个 promise 实例Promise.all([promise1, promise2, promise3])使用 Promise.all 接收的是一个数组作为参数， 其中 promise1 promise2 promise3 分别是 Promise 的实例关于使用 Promise.all 的状态: 只有 promise1 promise2 promise3 的状态都变成了 fullfilled 的状态, Promise.all 的状态才会变成 fullfilled 并且三个 promise 的返回值组成一个数组, 传递给 Promise.all 的回调函数。 当三个 promise 中存在一个为 reject 的时候, Promise.all 的状态就会变成 reject , 这个时候 , 被 reject 实例 的返回值被传递给Promise.all 的回调函数. 123const firstNamePromise = namePromise.then(getFirstName);const lastNamePromise = namePromise.then(getLastName);Promise.all([firstNamePromise, lastNamePromise]).then(([firstName, lastName]) =&gt; nextAction(firstName, lastName)); 注意: 上面使用到了对于对象的解构赋值操作, 在上面的函数中 firstNamePromise 的返回值被赋给 firstName, lastNamePromise 的返回值被赋给 lastName++++对于对象的解构赋值而言,我们可以这样赋值1234let a = 2;let b = 3;// 这样let [a, b] = [2, 3]; ++++promise .race() 使用 promise.race() 类似于 promise.all 方法, 将多个 promise 实例包装为一个 promise 方法let p = promise.race([p1, p2, p3]) 只要上面的 p1, p2, p3 中有一个的实例率先发生变化, 那么 p 的状态就会发生变化, 率先发生变化的返回值就会传递给 p 函数。其他方法 promise.finally 使用 promise.finally 的方法的作用在于: 不管 promise 的最后的状态是什么, 使用 promise.finally 内的回调函数始终会被执行;例如: 请求之前的指示器打开或者关闭：123456789this.indicator.show();let promise = new Promise();promise.then(// callback success fn).catch(e =&gt; &#123; this.toast(e.message)&#125;).finally(() =&gt; &#123; this.indicator.hide()&#125;)]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2017%2F10%2F12%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() } 补充关于空间复制度和时间复杂度的概念。冒泡排序 使用 冒泡排序最重要的思想是: 将一个数和数组中右边的数依次进行比较，如果找到了有左边的数大于右边的数，进行互换，最终一次循环之后，放在左边的数是右边中的最小值，这样依次进行排列，最后得到的左边的数组是已经被排好序之后的数组。12345678910111213141516function bubbleSort (arr) &#123; let len = arr.length; for (let i = 0; i &lt; len; i++) &#123; // 保证一轮循环之后 arr[i] 是 i 之后数组的最小值 for (let j = i + 1; j &lt; len; j++) &#123; // 比较相邻两个的大小, 将较大的那个排到后面去 // 始终保证 if (arr[j] &lt; arr[i]) &#123; // 使用 es6 结构赋值进行交换 let t = arr[j]; arr[j] = arr[i]; arr[i] = t; &#125; &#125; &#125;&#125; 快速排序 使用快速排序的基本原理是:算法参考某一个值，遍历一个数组，将数组中小于参考值的元素放在左边的数组中，将数组中大于参考值的元素放在右边的数组中，递归左右数组，返回合并之后的数组。合并之后的数组是已经被排好序的数组。123456789101112131415161718192021222324/** @description quickSort 用于进行快速排序* @return &#123;Array&#125; 经过排序之后的数组*/function quicksort(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; let first = arr[0]; let leftArr = []; let rightArr = []; let len = arr.length; for (let i = 0; i &lt; len; i++) &#123; if (arr[i] &lt; first) &#123; leftArr.push(arr[i]); &#125; if (arr[i] &gt; first) &#123; rightArr.push(arr[i]); &#125; &#125; // 一层一层剥开我的心 // 一直一直进行递归~~ return [].concat(quicksort(leftArr), [first], [quicksort(rightArr)]);&#125; 插入排序 使用 插入排序的基本原理是: 想象一个数组分为两部分，对于整个数组进行遍历的时候，被遍历到的数组元素的左边是已经排好序的，实现的过程是，遍历数组元素左边的元素，和遍历到的元素进行对比，最终将这个新的元素插入到左边元素的合适的位置。1234567891011121314151617181920/** @description insertSort 用于进行插入排序* @param &#123;Array&#125; arr 进行排序的数组* @return &#123;Array&#125; arr 返回进过排序之后的数组*/function insertSort(arr) &#123; for (let i = 0; i &lt; arr.length; i++) &#123; let temp = arr[i]; for (let j = i - 1; j &gt;= 0; j--) &#123; if (arr[j] &gt; temp) &#123; // 将大于 temp 的元素向后推一位 // 这些元素是之前已经被排好序的 arr[j + 1] = arr[j]; // 将元素插入到 arr[j] 的位置 arr[j] = temp; &#125; &#125; &#125; return arr;&#125;]]></content>
      <categories>
        <category>代码集</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6: Map & Set]]></title>
    <url>%2F2017%2F09%2F23%2Fes6-Map-and-Set%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }Set 数据结构 基本属性 Set 数据结构类似于数组， 不同于数组的是， Set 数据结构中不允许存在重复的值。123let arr = [1,2,2,3,4];let set = new Set(arr);console.log(arr) // &#123;1,2,3,4&#125; 去除重复数字 在上面的程序中， 使用 new Set构造函数生成的 set 的类型是一个对象，并且通过使用 set 结构进行处理之后的数据中没有重复数据。使用 set 进行数组去重的方法12arr = [...new Set([arr])]// [1,2,3,4]//如上所示，完成了数组的去重操作 Set 实例的属性和方法, 如下图所示let set = new Set([1,2,3,4])set.prototype.constructor : 默认 set 函数set.size 表示 set 数据结构中成员的个数1set.size // 4 对于 set 结构的方法，分为操作方法和遍历方法操作方法:add() 用于向 set 数据机构中添加成员delete() 用于删除数据中的某个值，返回布尔值， 表示是否删除成功has() 表示判断数据结构中是否含有某个值，返回的是布尔值，表示是否含有clear() 表示清除所有的成员，没有返回值1234567set// &#123;1,2,3,4&#125;set.add(5)// &#123;1,2,3,4,5&#125;set.has(5) // trueset.delete(5) // true 删除成功set.has(5) // falseset.clear()set // &#123;&#125; 一个数组去重操作:1234function removeDeu (Array) &#123; return [...new Set(Array)] // 换成 Array.from(new Set(Array)) 也是可以的&#125;使用 Array.from 也可以将Set 结构转换为数组结构 Set 实例的遍历方法 keys() 返回键名的数组values() 遍历键值entires() 遍历键值对儿因为 Set() 结构只有键值，没有键名，因此使用 values() 和 keys() 的遍历结果是一样的123456let arr = [1,2,3,4];let set = new Set(arr);for (let key of set.keys()) &#123; console.log(key)&#125;// 1,2,3,4,5 对于set 结构可以转换为 数组结构,可以应用数组的 map 等方法1let arr = [...set]; Map 数据结构 基本属性 对于对象而言，对象是有键值对的数据结构组成的，但是对于对象的键，他的格式会被转换为字符串， 即便我们传入了一个数组或者对象1234567let obj = &#123;&#125;;let o = &#123;a: 1&#125;;obj[o] = &apos;content&apos;;for (let key in obj) &#123; console.log(typeOf key)&#125;// string 使用 map 结构可以实现对象的键不再必须是字符串的形式创建 map 结构:1let map = new Map(); map 属性的方法 通过 console 控制台打印数据如下类似于 Set 结构, 存在 set get delete has clear 等几种操作方法set(键， 值) 写入数据get(键) 从数据结构中获得对应键的值 虽然 typeof map // Object 以及 map instanceof Object === true 但是， Map 是一种不同于对象的数据结构，在对象上使用 [ ] 访问属性的方法在 map 数据结构中是不适用的，要获得 Map 数据结构中的值， 我们是通过使用 get 方法，后面我们会说如何将 map 数据结构转换为对象 delete(键) 删除对应键的值clear() 将 map 数据中的所有数据清除has() 返回布尔值, 表示是否含有某条数据使用 map 的数据结构不同于对象的是，通过使用 map 添加的键名可以是变量1234567let map = new Map();let obj = &#123;a: 1&#125;;map.set(obj, &apos;good&apos;);map.get(obj) // &apos;good&apos;for (let key of map) &#123; console.log(typeof key) // object&#125; 可以是数组:123let arr = [1];map.set(arr, &apos;good&apos;);map.get(arr)// &apos;good&apos; 需要注意的一点，通过使用 get() 获取键值的时候，最终是查找到了键值的内存地址 代码如下:12map.set(&#123;a:1&#125;, &apos;good&apos;);map.get(&#123;a:1&#125;)// undefined 在上面的代码中，虽然查找的键值是一样的，但是两个 {a:1} 实际上的内存地址是不一样的。使用下面的代码可以找到对应的键值，因为变量 obj 指向了同一个对象的内存地址。123let obj = &#123;a: 1&#125;;map.set(obj, &apos;good&apos;);map.get(obj) // &apos;good&apos; 关于对象及内存地址:每创建一个对象，总会创建一个内存地址，对于下面对象:let person = { name: &#39;张宁宁&#39; } 我们使用 person.name 来访问到值的，但是，对象的值并没有存放在person 容器内，person 中存放了对象的属性，这个属性相当于指针，指向存放 张宁宁 的内存地址例如:{} === {} // false因为这两个空对象的内存地址是不一样的，所以是不相等的 使用 map 结构可以传入数组，数组中的成员是存在两个元素的数组结构。其中第一个元素会被当作键名，第二个元素会被当作键值12let map = new Map([[&apos;name&apos;, &apos;张宁宁&apos;]]);map.get(&apos;name&apos;) // &apos;张宁宁&apos; map 对象的遍历方法 对于 map 结构的遍历，存在下面几种方法keys() 返回键名的遍历器values() 返回键值的遍历器entires() 返回所有成员的遍历器forEach() 类似于数组中的 forEach() 方法， 实现对于 map 数据结构的遍历使用 keys() values() 以及 entires() 返回的是类数组对象123456let map = new Map();map.set(&apos;h&apos;, &apos;hello&apos;);map.set(&apos;g&apos;, &apos;good&apos;);map.keys() // &#123;&apos;h&apos;, &apos;g&apos;&#125;;map.values() // &#123;&apos;hello&apos;, &apos;good&apos;&#125;;map.entires(); // &#123;&apos;h&apos;: &apos;hello&apos;, &apos;g&apos;: &apos;good&apos;&#125;; 使用扩展运算符可以将类数组对象转化为数组对象，从而对于类数组对象上应用各种方法。1[...map.keys()] // [&apos;h&apos;, &apos;g&apos;] Map 与各种数据结构的相互转化 对象转为 map1234567function toMap (obj) &#123; let map = new Map(); for (let key in obj) &#123; map.set(key, obj[key]); &#125; return map;&#125; map 转化为对象1234567function toObj (map) &#123; let obj = Object.create(null); for (let [k,v] of map) &#123; obj[k] = v; &#125; return obj;&#125; ​]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>Map Set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6: 对象的扩展]]></title>
    <url>%2F2017%2F09%2F17%2Fes6-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }es6 中对象扩展的用法 1.简洁属性名 函数的属性可以是一个变量：12345let foo = &apos;good&apos;;let bar = &#123; foo: foo&#125;;console.log(bar.foo); // &apos;good&apos; es6 中我们可以直接传入一个变量到对象中123456let foo = &apos;good&apos;;let bar = &#123; foo&#125;;console.log(bar.foo); // &apos;good&apos; //传入的变量名会被作为对象的属性名，变量的值会被作为对象属性的值 用在函数中返回一个对象12345function Person(name) &#123; let age = 22; return &#123;name, age&#125;;&#125;person(&apos;张宁宁&apos;)// &#123;name: &apos;张宁宁&apos;, age: 22&#125; 2. Object.is( ) 判断相等 对于比较两个值是否相等，使用 全等 === 运算符进行判断, 因为使用 == 会自动转换数据类型使用 === 有缺点： NAN === NAN flase 以及 +0 === -0 false使用 object.is 可以解决这个缺点1234object.is(1,1) // trueobject.is(1,&apos;1&apos;) // falseobject.is(NaN, NaN) // trueObject.is(+0, -0) // true 使用 == 或者 === 进行相等比较的时候，实际上，是无法进行比较对象的，因为对象是一个指针，指向存储对象数据的内存地址1object.is(&#123;&#125; , &#123;&#125;); // false 3. Object.assign () 合并对象 12345let t = &#123;&#125;;let s1 = &#123; a: 1 &#125;;let s2 = &#123; b: 2 &#125;;Object.assign(t, s1, s2);// &#123;a: 1, b: 2&#125; 上面中将对象 s1, s2, 合并入 t 中；传入值的情况: 如果只有一个参数，使用这种方法会返回这个参数 如果传入的一个参数是 Null 或者 undefined 机会报错 要进行合并的参数是字符串的情况下，会返回该字符串的对象,传入非对象，非字符串的其他值，无效 12Object.assign(&#123;&#125;, &apos;string&apos;);// &#123;0: &quot;s&quot;, 1: &quot;t&quot;, 2: &quot;r&quot;, 3: &quot;i&quot;, 4: &quot;n&quot;, 5: &quot;g&quot;&#125; 使用 Object.assign () 返回的是对象的形式使用 Object.assign() 实现浅拷贝4. Object.keys() Object.values() Object.entires() Object.keys() 使用这种方法得到的是对象中所有可遍历的属性名组成的数组 Object.values() 使用这种方法得到的是对象自身所有可以遍历到的属性的值 Object.entires()使用这种方法得到的数组，数组中包括对象自身所有可遍历得到的属性的键值对儿数组 应用 判断对象内是否是空对象的方法：1const isEmpty = obj =&gt; return Object.keys(obj) === 0; 使用 Object.assign 实现自定义配置覆盖默认配置123function toConfig(defaultConfig, config) &#123; return Object.assign(defaultConfig, config);&#125; ​]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>对象扩展</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS块状格式化上下文(BFC)]]></title>
    <url>%2F2017%2F09%2F17%2FBFC%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }BFC 的概念 bfc 被称作: 块状格式化上下文，通过创建 bfc 可以创建出一块独立的渲染区域，在这个区域内，bfc 仅仅对于 blcok-level 块状水平的 box 起作用，bfc 上下文规定了内部的块状水平 box 如何起作用，并且创建了块状格式化上下文的容器，内部元素的布局方式不会影响到外部的区域，因此，我们可以使用 bfc 的概念实现对于浮动的清除。BFC 的创建 创建块状格式化上下文的方式有以下几种: float 的值不为 none position 的值不为 static 或者 relative display 的值为 table-cell table-caption inline-block flex inline-flex 中的其中一个 overflow 的值不为 visible (通过设置 overflow: hidden) 我的理解： 对于创建了块状格式化上下文的元素，在元素内部相当于定义了一个单独的区域，在这个区域内，内部子元素的布局不会影响到外部的元素BFC 的布局规则 In a block formatting context: boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the &#39;margin&#39; properties. Vertical margins between adjacent block boxes in a block formatting context collapse. each box&#39;s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box&#39;s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats). 在BFC 中: 垂直方向上，内部的 box 元素从包含块的顶部开始一个接一个的布局，两个相邻块之间的垂直距离是有 margin 特性决定的，在相邻的块状元素的垂直 margin 上会出现外边距折叠的问题 每一个块状元素的左边缘会紧紧跟在包含块的左边缘，甚至当有浮动元素存在的情况下也是一样的道理，除非这个块状元素创建了一个新的 BFC BFC 的应用 1. 使用 BFC 用来解决外边距折叠问题 外边距折叠是特定的相邻的外边距会形成一个单独的外边距，collpase margin 发生在下面的这些情况: 元素为空元素 padding 或者 border 为 0 no clearance to seperate them ? 什么意思 更多详细的的内容 : https://www.w3.org/TR/css3-box/#compact-boxes对于外边距坍塌，最终形成的外边距遵循的是 M-N 原则: 如果两个元素的外边距是正值, 最后得到的坍塌之后的外边距是两个边距的最大值 M如果两个元素的外边距是负值，最后得到的坍塌之后的外边距是两个边距中的最小值 N如果外边距是 none , 得到的坍塌之后的外边距是 0存在边距坍塌的几种情况 相邻的块状元素之间出现外边距坍塌 父元素和内部的子元素出现的外边距坍塌 使用块状格式化上下文解决外边距层叠:css 代码如下 :1234567891011121314151617&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;b1&quot;&gt; &lt;/div&gt; &lt;div class=&quot;b2&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt;.container &#123; background: blue;&#125;.b1, .b2 &#123; width: 100px; height: 50px; margin: 10px; background: red;&#125;&lt;/style&gt; 如上图所示, 父元素container 内部的子元素和父元素的边界坍塌，导致子元素与父元素的边界贴合，并且在子元素之间。两个 div margin 都设为 10, 最后出现折叠之后的 margin 也变成了 10 ，出现了元素折叠的现象如何解决： 使用 overflow: hidden 创建 bfc当我们给父元素创建 bfc 之后, 123.container &#123; overflow: hidden&#125; 可以看到:这时候因为父元素创建了 bfc ，因此子元素的 margin 不会出现坍塌现象，因为创建了 bf c 的元素不会和任何其它的元素出现边距折叠现象但是, 我们看到，元素内部的两个字元素还是出现了边距坍塌现象，按照上边的思想，我们可以给单独的一个子元素创建bfc1234567891011121314&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;b1&quot;&gt; &lt;/div&gt; &lt;div class=&quot;b3&quot;&gt; &lt;div class=&quot;b2&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt;.b3 &#123; overflow: hidden&#125;&lt;/style&gt; 上面的代码中, 我们给子元素 b2 上创建了一个父元素，给这个父元素创建bfc 最终结果如下: 最终我们可以看到，因为对于 b3 创建了 bfc ， 因此， 对于 bfc 内部的元素的布局是不会影响到外部的子元素的 2.使用 BFC 进行浮动的清除 使用 BFC 进行浮动清除的原理还是一样的，利用位于块状上下文中的元素是不会影响到外部元素的特性，防止子元素设置浮动之后，父元素高度为 0 的情况123456789101112131415161718192021&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;b1&quot;&gt; 我是浮动元素 &lt;/div&gt; &lt;div class=&quot;b2&quot;&gt; 我是浮动的元素 &lt;/div&gt;&lt;/div&gt;&lt;style&gt;.container &#123; background: blue; overflow: hidden;&#125;.b1, .b2 &#123; float: left; width: 100px; height: 50px; margin: 10px; background: red;&#125;&lt;/style&gt; 结果如下所示: 如上图所示，使用了 bfc 清除了由于使用 float:left 造成的浮动现象 浮动元素的父元素高度依然存在3. 使用 BFC 实现两栏自适应布局 在存在浮动的情况下,前面我们说过，包含块内部的子元素的左边缘会紧紧贴在其父元素的左边缘，即使存在浮动元素的情况下也是一样的，例如：12345678910111213141516171819202122&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;aside&quot;&gt;&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;style type=&quot;text/css&quot;&gt; .container &#123; width: 300px; &#125; .aside &#123; width: 20%; float: left; height: 100px; background-color: red; &#125; .main &#123; width: 80%; height: 200px; background-color: blue; &#125;&lt;/style&gt; 图片如下:即使 aside 浮动，main 还是会贴在左边缘，如果我们想要实现两栏的自适应布局，如何实现？根据上面的布局规则， 我们可以给 main 创建一个块状格式化上下文，这样，main 的布局就不会受到 aside 元素的影响123456.main &#123; width: 80%; height: 200px; background-color: blue; overflow: hidden;&#125; 最终，我们得到了自适应布局: 从而得到了一个两栏布局]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>bfc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 组件之间的传值]]></title>
    <url>%2F2017%2F09%2F10%2FVue-%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }在 vue 中，进行组件通信有下面几种形式:父子组件通信 在 vue 中, 实现父子组件通信的方法主要是 : props down, emit up使用 props 实现父组件向子组件传递信息, 在父组件上的子组件模板上绑定需要进行传递的数据1234567891011121314151617父组件中：&lt;child :propsData = &apos;localData&apos;&gt;&lt;/child&gt;子组件中：&lt;template&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &apos;child&apos;, // 子组件中通过使用 props 声明需要进行接受的数据 props: [&apos;propsData&apos;], data () &#123; return &#123; localData: &apos;&apos; &#125; &#125; &#125;&lt;/script&gt; 对于实现子组件向父组件的传值操作，使用 emit() 操作实现:兄弟组件通信 Vuex 使用 vuex 实现多个组件之间状态的共享上图是使用 vuex 的工作流程，下面是我对于 vuex 的一些个人理解vuex 主要是有三个部分组成: actions : 用来执行提交 mutations 操作 mutations : 用来对于 state 中存储的数据进行改变操作 state : 用来存储一些数据， 这些数据对于各个组件之间是可以共享的 总的来说： 要执行一次进行改变 state 中状态的数据，要进行以下操作state 中保存了要进行改变的数据状态 mutations 中定义了要进行改变数据状态的操作，这是函数我们通过 actions 中的函数对于在mutations 中定义的函数进行提交, 相当于执行函数，从而实现对于state 中保存数据的改变]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>组件通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6:变量的解构赋值]]></title>
    <url>%2F2017%2F09%2F09%2Fes6-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }es6的数值解构赋值 1.es6 允许使用一定的方式从数组或者对象中提取数值，从而对于同样模式的变量进行赋值操作，代码如下: 12345678let [a,b,c] = [1,2,3]a // 1b // 2c // 3类似:let a = 1let b = 2let c = 3 使用数组形式进行解构赋值的时候要注意到，两边其实并不是数组，而只是数组的形式对于等号两边必须是数组的形式，如果是其他的形式，那么就会报错:12345let [a] = &#123;&#125;;let [a] = null;let [a] = undefined;let [a] = NaN;let [a] = 1; 上面的几种形式都会被报错2.使用结构变量可以初始数组 12let [a,...b] = [1,2,3,4];b // [2,3,4] 使用扩展运算符可以将多个数合并为一个数组3.可以在解构赋值的时候使用默认值操作 123456789101112let [x = 1] = [];x // x 在没有被赋值的时候默认使用 1let [x = 1] = [2];x // 2当 x 存在明显只的时候默认值失效// 对于使用默认值, 还可以使用函数的返回值function fn() &#123; return 23&#125;let [a = fn()] = [45];// 这里 因为 a 能够取到值, 因此不会执行 fn 函数console.log(a); // 45 默认值可以引用其他结构值的对象123let [x = 1, y = x] = [];x // 1y // 1 注意: 对于赋值操作两端的值, 在赋值操作两端执行的是 === 全等操作， 因此1234let [a = 1] = [null]a // nulllet [a = 1] = [undefined]a // 1 es6 中对于对象的解构赋值操作 代码如下:1234567let person = &#123; name: &apos;张宁宁&apos;, home: &apos;山东&apos;&#125;;let &#123;name, home&#125; = person;name // &apos;张宁宁&apos;home // &apos;山东&apos; 这种写法无非是下面这种写法的简写:`1let &#123;name: name, home: home&#125; = person; 实际上:12let &#123;name: perName, home: perHome&#125; = person;perName // &apos;张宁宁&apos; 等号左边中 name 用于进行模式匹配，在 person 中找到 name 之后，将 name 的值赋给 perName使用对象的形式解构也可以赋予默认值：当在等号右边的对象中找不到对应的属性的时候, 会使用括号内被默认赋予的值123let &#123;x = 1, y = 5&#125; = &#123;x: 2&#125;x // 2y // 5 es6 中对于字符串的解构赋值 当对于字符串进行解构赋值操作的时候，字符串会被转换为类似数组的对象:这意味着我们可以通过使用数组或者对象的方式进行解构：1234let [a,b,c,d,e] = &apos;hello&apos;;a // &apos;h&apos;b // &apos;e&apos;.... 123let &#123;length&#125; = &apos;hello&apos;;length // 5因为使用解构的时候， 字符串对象含有一个 length 属性 函数参数的解构 1.数组形式进行解构12345function move([x,y]) &#123; return x + y&#125;move([1,2]);// 这里虽然传入的是一个数组，实际上传入函数之后会被解构 2.对象形式进行解构12345678function person(&#123;name, home&#125;) &#123; console.log(home, name)&#125;let per = &#123; name: &apos;张宁宁&apos;, home: &apos;china&apos;&#125;person(per)// china 张宁宁 3.使用对象形式赋予默认值12345function person (&#123;name = &apos;张宁宁&apos;, home = &apos;china&apos;&#125; = &#123;&#125;) &#123; console.log(name, home)&#125;person(); // 张宁宁 china和上面结果相同， 因为传入的是一个空对象，没有找到相应的属性，因此采用默认赋予的值进行操作 使用参数解构中的小技巧 提取函数的返回值:123456function bar () &#123; return [1, 2]&#125;let [a, b] = bar ();a // 1b // 2 应用解构分离对象的键值对12345678910111213let arrObj = [&#123;&#125;, &#123;&#125;, &#123;&#125;];// 取得数组对象中值对应的键function getKey( arrobj, objValue) &#123; for (const obj of arrobj) &#123; // 使用 &#123;&#125; 实现对象的解构赋值 let &#123;key, value&#125; = obj; if (value === objValue) &#123; return key; &#125; &#125;&#125;getKey(arrObj, &apos;someObjValue&apos;) ​]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>变量解构赋值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js学习（一）]]></title>
    <url>%2F2017%2F09%2F09%2FVue%E5%93%8D%E5%BA%94%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }Vue的响应原理 上面这张图表示的就是 vue 的响应原理:当我们将数据添加入 vue 实例中的 data 选项中的时候, vue 将遍历data 中数据的所有属性，并且调用 Object.defineProperty 方法将属性记录为依赖。当数据发生改变的时候,就会调用 object.defineProperty 中的 setter 方法,在组件实例中存在一个 watcher 对象，这个对象的目的是：当被记录的依赖被调用的时候,也就是属性的 setter 被调用的时候，会通知watcher 对象进行重新渲染组件Object.defineProperty 12345678Object.defineProperty(Object, property, &#123; get () &#123; // 读取对象Object 的属性 property 的时候调用的函数 &#125;, set (newVal) &#123; // 设置对象 Object 的属性 property 的时候调用的函数 &#125;&#125;) 通过使用这种方法，调用 getter 和 setter 可以实现追踪对象属性的变化 vue.js 中的 生命周期 在 vue.js 中]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue 响应原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSONP跨域 ajax请求]]></title>
    <url>%2F2017%2F09%2F03%2FJSONP%E8%B7%A8%E5%9F%9F-ajax%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }使用 JSONP 进行的跨域，链接的是聚合数据的手机号查询归属地 API，一开始的时候出现了问题，使用原生的 ajax 请求怎么样也是查询不到数据，后来了解到，使用 ajax 不能进行跨域请求。下面是通过使用 jsonp 实现的跨域请求12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;div id=&quot;div&quot;&gt;&lt;/div&gt;&lt;body&gt;&lt;div&gt; 号码归属地查询&lt;input id=&apos;phone&apos; type=&apos;text&apos; &gt;&lt;button id = &apos;btn&apos;&gt;查询手机号归属地&lt;/button&gt; &lt;p&gt;您的手机号码归属地是 &lt;span id=&apos;city&apos;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function doFunction (data) &#123; if (!data.result) &#123; return; &#125; document.getElementById(&apos;city&apos;).innerHTML = data.result.city; &#125; window.onload = function () &#123; var sendObj = &#123; url: &apos;http://apis.juhe.cn/mobile/get&apos;, phone: &apos;13429667914&apos;, key: &apos;4ebdd2325a4ce36fa7ca55e910c185e9&apos;, callback: &apos;doFunction&apos; &#125;; function sendLink (obj) &#123; var link = obj.url; for (var key in obj) &#123; if (key !== &apos;url&apos;) &#123; link = link + (~link.indexOf(&apos;?&apos;) ? &apos;&amp;&apos; : &apos;?&apos; ); link = link + key + &apos;=&apos; + obj[key]; &#125; &#125; return link; &#125; document.getElementById(&apos;btn&apos;).addEventListener(&apos;click&apos;, function () &#123; var body = document.getElementsByTagName(&apos;body&apos;)[0]; var script = document.createElement(&apos;script&apos;); sendObj.phone = document.getElementById(&apos;phone&apos;).value; script.setAttribute(&apos;src&apos;, sendLink(sendObj)); if (body.getElementsByTagName(&apos;script&apos;).length === 2) &#123; body.replaceChild( script ,body.lastChild); &#125; else &#123; document.getElementsByTagName(&apos;body&apos;)[0].appendChild(script); &#125; &#125;); &#125;&lt;/script&gt;&lt;!-- &lt;script src=&quot;http://apis.juhe.cn/mobile/get?phone=13429667914&amp;key=4ebdd2325a4ce36fa7ca55e910c185e9&amp;callback=doFunction&quot;&gt;&lt;/script&gt;--&gt;&lt;/body&gt;&lt;/html&gt; ajax 请求 原生的 ajax 请求如下:1234567891011121314var request;if (window.XMLHttpRequest) &#123; request = new XMLHttpRequest(); &#125; else &#123;// for IE request = new ActiveObject();&#125;request.onreadystatechange = function () &#123; if (request.readyState == 4 &amp;&amp; request.status == 200) &#123; console.log(request.responseText); &#125;&#125;;request.open(&apos;get&apos;, url, false / true);request.send(); 使用 ajax 的目的在于在没有重新加载页面的时候进行页面部分数据的更新；open 方法使用 open 方法接收三个参数:要发送的请求类型: &#39;get &#39; 或者 &#39;post&#39; 请求的url : 注意 只能向同一个域中使用相同端口和协议 URL 发出请求，如果请求的端口和本地页面不在同一个域的范围内，那么要使用跨域进行；什么是跨域？ 只要是协议，端口，域名当中存在一个不同的值，那么请求就会被认为是跨域:一个 URL 地址如下:https://www.baidu.com:8080https 协议， 用来定义浏览器打开文件的形式www.baidu.com 域名, 其中 baidu.com 主域 www.baidu.com 子域:8080 端口当两个 URL 的协议, 域名 ,端口中存在一个不同的时候，使用 ajax 是无法进行请求得出数据的 但是这种情况:https:// www.a.com/javascript/a.jshttps:// www.a.com/b.js这种情况下, 域名，协议，端口都是相同的, 因此可以进行访问到https://segmentfault.com/a/1190000000718840http://blog.csdn.net/seebetpro/article/details/51326260 布尔值：表示是否进行异步在上面的代码中，请求成功之后，响应的数据会自动填充 request 对象的属性，表示请求成功之后的状态:12345request.onreadystatechange = function () &#123; if (request.readyState == 4 &amp;&amp; request.status == 200) &#123; // 表示请求成功之后，并且有返回数据之后要进行的动作 &#125;&#125; status : 表示响应的 http 状态,对于 http 的状态码， 要记住几个重要的：http状态码2XX : 表示请求成功 200 请求成功， 201 已创建 202 接收 204 无内容 3XX: 表示重定向 300 多路选择 301 永久转移 302 暂时转移 304 未修改4XX: 客户方错误 400 错误请求 401 未认证 408 请求超时 410 失败5XX: 服务器错误500 服务器内部错误 501 未实现 504 网关超时 关于这些请求的具体情况：2XX: 表示已经接受到了请求 状态码 含义 200 表示请求已经成功 201 表示请求已经被创建 202 服务器已经接收到了请求， 但是尚未处理 204 服务器已经处理了请求， 但是没有返回任何 3XX:资源重定向 状态码 含义 301 表示永久性重定向， 请求的资源分配到新的 url 302 表示临时性重定向，表示请求的资源已经分配到新的url, 希望用户本次能够使用新的url 访问 304 表示请求的资源已经找到， 但是不符合条件要求 4XX:客户端请求错误 状态码 说明 400 表示客户端发给服务器的请求存在语法错误， 服务器无法理解这个请求。 401 表示发送的请求需要通过使用 HTTP 认证 403 表示客户端想要请求的资源被服务器拒绝访问 404 表示在服务器上没有找到请求的资源 5XX: 服务器错误 状态码 说明 500（服务器错误） 表示服务器在执行请求的时候发生了错误 503（服务器正忙） 表示现在服务器正在处于超负载状态，无法处理 readyState 表示 request 对象的 readyState 对象，属性可取的值如下：0 : 未初始化，尚未调用 open() 方法1 : 启动， 已经调用 open 方法，尚未调用 send() 方法2 : 发送，已经调用 send() 方法，但是尚未接收到响应3: 接收，表示已经接受到部分数据4: 完成, 已经接收到全部的响应数据 使用 get 和 post 请求的区别 1. 两种方式传递参数的方式不同 Get 请求用于向服务器发送请求查询信息，查询字符串参数添加到 url 的末尾 post 请求是将作为 HTTP 消息的实体内容发送给服务器2. 两者缓存不同 使用 get 方法的数据会被浏览器进行缓存起来，因此其他人可以通过使用浏览器的历史记录进行读取到这些数据3.服务器端 针对这两种方式的获取参数是不同的 在客户端通过使用 get 请求的时候，服务器端通过使用 Request.QueryString 来进行获取参数, 在客户端通过使用 post 进行请求的时候，服务器端通过使用 Request.Form 来进行获取到参数为什么要使用两种方式:当请求没有副作用的时候， 例如进行搜索数据， 可以使用 get 方法， 当请求存在副作用的时候，使用 post 进行请求使用 post 的情况: 请求的结果存在副作用，例如，向数据库内添加新的数据行 使用 GET 方法, 使用表单上添加的数据使得 URL太长 进行传送的数据不是7 位的 ASCII 编码 使用 get 的情况 请求是为了查找资源, HTML 上的表单数据仅仅用来进行搜索 请求结果无持续性的副作用 收集到的数据及HTML 表单内的输入字段名称的总长不超过 1024 字符 如何使用 ajax 实现跨域？ 对于使用原生的 ajax 而言,是无法实现进行跨域请求的,如何使用 ajax 实现跨域呢？1.使用跨源资源共享(CORS) 跨源资源共享定义了当进行访问跨源资源的时候，浏览器和服务器之间应该如何进行通信, 基本的思想是:浏览器向服务器发送请求的时候，添加一个额外的 origin 头部，这个头部包含了请求页面的源信息(协议， 域名， 端口)如果服务器认为请求可以接受，可以在 Access-Control-Allow-Origin 中回发相同的源信息,如果在服务器端设置 为 * 表示公共资源如上图所示，实现了公共资源的共享2.使用 JSONP 使用 jsonp 技术实现的，原理是将请求的参数放入到 js 中，通过使用动态 js 来实现资源的动态请求缺点: 无法处理请求失败之后的动作,并且使用 jsonp 请求到的数据只能使用 get 请求进行]]></content>
      <categories>
        <category>代码集</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS居中效果]]></title>
    <url>%2F2017%2F09%2F02%2FCSS%E5%B1%85%E4%B8%AD%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }使用 CSS 并没有这么的简单，如果CSS 熟练了，开发网页就会快得多，自己实际上能够使用到的 CSS 样式不多，但是,太多的东西自己没有掌握， CSS 也有许多的技术点，只能不断的跳出自己的舒适区，不断的进行探索。居中方法 水平居中 行内元素的水平居中 使用 text-align 的方法实现行内元素的水平居中 text-align: center : 实现块状元素内部 行元素的水平居中 12345678&lt;div id = &apos;content&apos;&gt; &lt;span&gt;我是一段文字&lt;/span&gt;&lt;/div&gt;&lt;style&gt; #content &#123; text-align: center; &#125;&lt;/style&gt; 块状元素的水平居中方法 1.使用 margin 进行定位12345678910111213141516&lt;div id=&apos;content&apos;&gt; &lt;div id = &apos;block&apos;&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; #content &#123; width: 200px; height: 200px; background-color: blue; &#125; #block &#123; width: 50px; height: 50px; margin: auto; &#125;&lt;/style&gt; 注意， 对于块状元素使用 margin: auto 只能实现块状元素在父级块状元素内的水平居中 如果在正常流中一个块元素的 margin-top margin-bottom 设为 auto 的时候，这个元素的 margin 会自动计算为 0​ 效果如下:在上面的图片中，尽管设置了 margin-top : 20px 但是由于 margin: auto 的存在，将块元素的 margin-top 重新计算为 02.借用定位元素 position: absolute借用定位元素实现的居中，可以实现水平，垂直居中的效果垂直居中：1234567父元素：position: relative;子元素：position: absolute;top: 0;bottom: 0;margin: auto; 水平居中：1234567父元素：position: relative;子元素：position: absolute;left: 0;right: 0;margin: auto; 垂直居中：1234567父元素：position: relative;子元素：position: absolute;top: 0;bottom: 0;margin: auot; 完全居中:123456789父元素：position: relative;子元素：position: absolute;top: 0;bottom: 0;left: 0;right: 0;margin: auto 3.借用 display: inline-block 来实现display: inline-block 这个属性很有意思: 使用了 display: inline-block 的元素，这个元素会表现出行内块的特征，这个元素即可以像块状元素一样具有 width 和 height, 也可以是向行内元素一样，呈行内排列 因此，我们的思路是：对于要进行水平居中的块状元素应用 display:inline-block , 使它表现出类似行状元素的特性，对于该元素的父元素，应用 text-align: center垂直居中 行内元素的垂直居中 1.对于单行元素，使用 line-height: height 实现2.对于多行元素的垂直居中方法，使用 display: table-cell1234567891011&lt;div class = &apos;content&apos;&gt; &lt;p&gt;我是一段文字&lt;/p&gt; &lt;p&gt;我是另一段文字&lt;/p&gt;&lt;/div&gt;CSS:.content &#123; display: table-cell; vertical-align: middle&#125; 块状元素的垂直居中 1.使用 position: absolute 来实现2.子元素声明 display: table-cell display: inline-block vertical-align: middle 来实现完全居中 position: absolute 来实现 使用 display: table-cell, 这时候 子元素必须要声明 display: inline-block123456789101112131415161718&lt;div id=&apos;good&apos;&gt; &lt;div class=&apos;child&apos;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; #good&#123; display:table-cell; vertical-align: middle; text-align: center; width: 200px; height: 200px; background-color: blue; &#125; .child &#123; display: inline-block; width: 50px; height: 50px; background-color: red; &#125; 2.使用 display: flex 实现居中的效果1234&lt;div class="parent"&gt; &lt;div class="children"&gt; &lt;/div&gt;&lt;/div&gt; 12345.parent &#123; display: flex; align-items: center; justify-content: center;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS 居中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日历]]></title>
    <url>%2F2017%2F08%2F31%2F%E6%97%A5%E5%8E%86%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }使用面向对象的 js 代码写法，写了一个日历，代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; 单个时间&lt;input type=&quot;text&quot; id=&quot;startTime&quot;&gt; 时间段&lt;input type=&quot;text&quot; id=&quot;longTime&quot;&gt;&lt;/div&gt;&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;&lt;script&gt; (function (window)&#123; function $(tag, parent) &#123; var children = []; if (tag.indexOf(&apos;#&apos;) !== -1) &#123; children = document.getElementById(tag.slice(1)); &#125; else if (tag.indexOf(&apos;.&apos;) !== -1) &#123; children = parent ? parent.getElementsByClassName(tag.slice(1)) : document.getElementsByClassName(tag.slice(1)); &#125; else &#123; children = parent ? parent.getElementsByTagName(tag) : document.getElementsByTagName(tag); &#125; return children; &#125; function listenEvent(dom,event,fn) &#123; if (dom.attachEvent) &#123; dom.attachEvent(&apos;on&apos; + event, fn); &#125; else &#123; dom.addEventListener(event, fn); &#125; &#125; function dateUI (isSingle ,inputIdName, callBack) &#123; this.isSingle = isSingle; this.inputIdName = inputIdName; this.callBack = callBack; var date = new Date(); this.data = &#123; weekDay: [&apos;日&apos;, &apos;一&apos;, &apos;二&apos;, &apos;三&apos;, &apos;四&apos;, &apos;五&apos;, &apos;六&apos;], minDate: &apos;&apos;, maxData: &apos;&apos;, year: 2017, month: 8, selectDays: [] &#125; this.data.year = 2017; this.data.month = 8; &#125; dateUI.prototype = &#123; $ : function (tag, parent) &#123; var children = []; if (tag.indexOf(&apos;#&apos;) !== -1) &#123; children = document.getElementById(tag.slice(1)); &#125; else if (tag.indexOf(&apos;.&apos;) !== -1) &#123; children = parent ? parent.getElementsByClassName(tag.slice(1)) : document.getElementsByClassName(tag.slice(1)); &#125; else &#123; children = parent ? parent.getElementsByTagName(tag) : document.getElementsByTagName(tag); &#125; return children; &#125;, listenEvent: function (dom, event, fn) &#123; if (dom.attachEvent) &#123; dom.attachEvent(&apos;on&apos; + event, fn); &#125; else &#123; dom.addEventListener(event, fn); &#125; &#125;, initTable: function () &#123; var that = this; var title = document.createElement(&apos;div&apos;); title.setAttribute(&apos;id&apos;, &apos;title&apos;); title.innerHTML = &apos;&lt;span id=&quot;pre&quot;&gt;back&lt;/span&gt;&lt;input type=&quot;number&quot; id=&quot;month&quot;&gt;&lt;input type=&quot;number&quot; id=&quot;year&quot;&gt;&lt;span id=&quot;back&quot;&gt;pre&lt;/span&gt;&apos; var main = document.createElement(&apos;div&apos;); main.setAttribute(&apos;id&apos;, &apos;main&apos;); var table = document.createElement(&apos;table&apos;); table.innerHTML = &apos;&lt;thead&gt;&lt;tr&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;/tbody&gt;&apos;; main.appendChild(table); that.$(&apos;#content&apos;).appendChild(title); that.$(&apos;#content&apos;).appendChild(main); for (let i = 0; i &lt; that.data.weekDay.length; i++) &#123; that.$(&apos;tr&apos;, that.$(&apos;thead&apos;)[0])[0].innerHTML += &apos;&lt;th&gt;&apos; + that.data.weekDay[i] + &apos;&lt;/th&gt;&apos;; &#125; var _ROW = 6; var _COL = 7; for (var i = 0; i &lt; _ROW; i++) &#123; that.$(&apos;tbody&apos;)[0].innerHTML += &apos;&lt;tr&gt;&lt;/tr&gt;&apos;; for (var j = 0; j &lt; _COL; j++) &#123; that.$(&apos;tr&apos;, that.$(&apos;tbody&apos;)[0])[i].innerHTML += &apos;&lt;td&gt;&lt;/td&gt;&apos;; &#125; &#125; that.tds = document.getElementsByTagName(&apos;td&apos;); that.tds = [].slice.call(that.tds); &#125;, reactData: function () &#123; var that = this; var props = [&apos;year&apos;, &apos;month&apos;]; props.map(function (item) &#123; var dom = null; item === &apos;year&apos; ? dom = that.$(&apos;#year&apos;) : dom = that.$(&apos;#month&apos;); Object.defineProperty(that.data, item, &#123; get: function () &#123; return dom.value; // 绑定dom, 自动获取到value值 &#125;, set: function (newVal) &#123; if (item === &apos;month&apos;) &#123; if (newVal &gt; 12) &#123; newVal = 1; that.data.year++; &#125; else if (newVal &lt;= 0) &#123; newVal = 12; that.data.year--; &#125; &#125; dom.value = newVal; &#125; &#125;) &#125;); &#125;, dateAct: function () &#123; var that = this; var inputAdd = [&apos;#month&apos;, &apos;#year&apos;]; that.listenEvent(that.$(&apos;#back&apos;) ,&apos;click&apos;, function () &#123; that.data.month++; that.initDate(); &#125;); that.listenEvent(that.$(&apos;#pre&apos;) ,&apos;click&apos;, function () &#123; that.data.month--; that.initDate(); &#125;); inputAdd.map(function (item) &#123; that.listenEvent($(item) ,&apos;change&apos;, function () &#123; if (item === &apos;#month&apos;) &#123; that.data.month = $(item).value; &#125; else &#123; that.data.year = $(item).value; &#125; that.initDate(); &#125;) &#125;); &#125;, initDate: function () &#123; var that = this; var date = new Date(that.data.year, that.$(&apos;#month&apos;).value - 1, 1); var startDate = date.getDay(); var allDates = new Date(that.data.year, that.$(&apos;#month&apos;).value, 0).getDate(); var tds = document.getElementsByTagName(&apos;td&apos;); that.initColor(); var j = 0; startDate = (startDate ? startDate : 7); // startDate 表示这一个月份的一号是星期几，当是星期天的时候，要从下一行开始 for (let i = 0 ; i &lt; 42; i++) &#123; if (i &gt;= startDate) &#123; j &gt;= allDates ? j = 1 : j++; tds[i].innerHTML = j; if(i &lt; allDates + startDate ) &#123; tds[i].onclick = function () &#123; // 这里有bug that.initColor(that.data.year, that.data.month, i); that.initColor(); that.$(&apos;#&apos; + that.inputIdName).value = &apos;&apos;; that.data.selectDays.map(function (item, index, array) &#123; that.$(&apos;#&apos; + that.inputIdName).value = item.year + &apos;-&apos; + item.month + &apos;-&apos; + that.tds[item.day].innerHTML; if (!that.isSingle) &#123; var min; that.data.selectDays.map(function (item, index, array) &#123; if (item.day &lt; that.data.selectDays[0].day) &#123; min = item; &#125; else &#123; min = that.data.selectDays[0]; &#125; &#125; ); &#125; &#125;); that.callBack(); &#125;; &#125; else &#123; tds[i].onclick = null; tds[i].className = &apos;notClick&apos;; &#125; &#125; else &#123; tds[i].className = &apos;notClick&apos;; document.getElementsByTagName(&apos;td&apos;)[i].onclick = null; // 回收 click 事件 tds[i].innerHTML = new Date(that.data.year, that.$(&apos;#month&apos;).value - 1, 0).getDate() + 1 -startDate + i ; &#125; &#125; &#125;, initColor: function (year, month, day) &#123; var that = this; var _minDate; var _maxDate; if (year) &#123; var obj = &#123;&#125;; obj.year = year; obj.month = month; obj.day = day; if (that.isSingle) &#123; that.data.selectDays[0] = obj; &#125; else &#123; that.data.selectDays.push(obj); if (that.data.selectDays.length &gt;= 2) &#123; that.data.selectDays[1] = obj; that.data.selectDays.length = 2; &#125; &#125; &#125; else &#123; that.tds.map(function (item) &#123; item.className = &apos;&apos;; &#125;); that.data.selectDays.map(function (key) &#123; ((key.year === that.data.year) &amp;&amp; (key.month === that.data.month)) ? that.tds[key.day].className = &apos;tdActive&apos; : &apos;&apos; ; &#125;); if (that.data.selectDays.length === 2) &#123; if (that.data.selectDays.length === 2) &#123; if (that.data.selectDays[0].day &lt; that.data.selectDays[1].day) &#123; _minDate = that.data.selectDays[0].day; _maxDate = that.data.selectDays[1].day; &#125; else &#123; _maxDate = that.data.selectDays[0].day; _minDate = that.data.selectDays[1].day; &#125; &#125; for (var j = _minDate + 1; j &lt; _maxDate; j++) &#123; if (that.data.selectDays[0].month === that.data.selectDays[1].month &amp;&amp; that.data.selectDays[0].month === that.data.month) &#123; that.tds[j].className = &apos;timeBar&apos;; &#125; else &#123; that.tds[j].className = &apos;&apos;; &#125; &#125; &#125; &#125; &#125; &#125;; // 使用 $() 类似于 jQuery 中的调用写法，用来调用 dom 元素 // data.year // data.month 表示真实的年和月 // data 对象， 用来集中管理数据信息 // initTable 用于初始化表格，构建日期选择框 // initData 将data 内的数据和 input 输入框内的数据进行同步， // 自动同步 if (window.dateCanlender !== &apos;undefined&apos;) &#123; listenEvent(document.getElementById(&apos;startTime&apos;), &apos;click&apos;, function () &#123; $(&apos;#content&apos;).style.display = &apos;block&apos; &#125;); var dateCanlender = new dateUI(true, &apos;startTime&apos;, function () &#123; &#125;) dateCanlender.initTable(); dateCanlender.tds = document.getElementsByTagName(&apos;td&apos;); dateCanlender.tds = [].slice.call(dateCanlender.tds); dateCanlender.reactData(); var date = new Date(); dateCanlender.data.year = date.getFullYear(); dateCanlender.data.month = date.getMonth() + 1; dateCanlender.initDate(); dateCanlender.dateAct(); &#125; &#125;(window))&lt;/script&gt;&lt;style&gt; #content &#123; display: none; border: 2px solid darkgray; padding: 10px; margin: 50px auto; width: 300px; &#125; #title &#123; margin: 10px 0; display: flex; justify-content: space-between; &#125; #title span, #title input &#123; display: inline-block; width: 25%; text-align: center; flex: 1; &#125; #title input &#123; margin: 0 10px; &#125; #main &#123; width: 300px; &#125; table, table thead &#123; width: 100%; &#125; table thead tr &#123; width: 100%; margin: 10px 0; /* display: flex; justify-content: space-between; */ &#125; table td &#123; text-align: center; &#125; .tdActive &#123; color: white; background-color: skyblue; &#125; .timeBar &#123; background-color: gray; &#125; .notClick&#123; color: lightgray; &#125;&lt;/style&gt;&lt;/body&gt;&lt;/html&gt; 思路 这段代码是使用面向对象的语法写的，面向对象程序设计的主要使用了构造函数和原型的语法。代码如下:12345function person () &#123; &#125;person.prototype.eye = 2;var he = new person();he.eye // 2 上面的代码中，通过使用 new 操作符创建了 person 构造函数的一个实例，在构造函数中定义了一个属性 eye ，根据在原型链中的继承的特性，使用 new 操作符创建的实例，会继承构造函数上定义的属性和方法，因此，我们可以在构造函数上定义公共属性和方法。 在通过 new 操作符的过程中发生了什么？1.创建一个新对象2.将构造函数的作用域赋给新对象，（这时候 this 指向这个新对象）3.执行构造函数的代码 （这个新对象添加属性）4.返回新对象 在上面的代码中123var dateCanlender = new dateUI(true, &apos;startTime&apos;, function () &#123; &#125;) 这段代码创建了构造函数 dateUI 的一个新实例。在构造函数的原型上，给原型添加方法 : initTable reactData initDate initColor dateActinitTable 用来初始化表格，生成表格12345678910111213141516171819202122232425initTable: function () &#123; var that = this; var title = document.createElement(&apos;div&apos;); title.setAttribute(&apos;id&apos;, &apos;title&apos;); title.innerHTML = &apos;&lt;span id=&quot;pre&quot;&gt;back&lt;/span&gt;&lt;input type=&quot;number&quot; id=&quot;month&quot;&gt;&lt;input type=&quot;number&quot; id=&quot;year&quot;&gt;&lt;span id=&quot;back&quot;&gt;pre&lt;/span&gt;&apos; var main = document.createElement(&apos;div&apos;); main.setAttribute(&apos;id&apos;, &apos;main&apos;); var table = document.createElement(&apos;table&apos;); table.innerHTML = &apos;&lt;thead&gt;&lt;tr&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;/tbody&gt;&apos;; main.appendChild(table); that.$(&apos;#content&apos;).appendChild(title); that.$(&apos;#content&apos;).appendChild(main); for (let i = 0; i &lt; that.data.weekDay.length; i++) &#123; that.$(&apos;tr&apos;, that.$(&apos;thead&apos;)[0])[0].innerHTML += &apos;&lt;th&gt;&apos; + that.data.weekDay[i] + &apos;&lt;/th&gt;&apos;; &#125; var _ROW = 6; var _COL = 7; for (var i = 0; i &lt; _ROW; i++) &#123; that.$(&apos;tbody&apos;)[0].innerHTML += &apos;&lt;tr&gt;&lt;/tr&gt;&apos;; for (var j = 0; j &lt; _COL; j++) &#123; that.$(&apos;tr&apos;, that.$(&apos;tbody&apos;)[0])[i].innerHTML += &apos;&lt;td&gt;&lt;/td&gt;&apos;; &#125; &#125; that.tds = document.getElementsByTagName(&apos;td&apos;); that.tds = [].slice.call(that.tds); 上面中的代码 [].slice.call(that.tds) 将类数组对象 tds 转化为数组，从而可以使用数组的方法 数组中 slice 的方法 reactData: 将数据变为可以跟踪变化的形式，类似于在 vue 中的，将 data 数据变为可响应式的，使用的是 Object.defineProperty() 方法, getter setter 等方法构建响应式数据。通过这种方法创建的数据是可以响应式的。代码如下:12345678910111213141516171819202122232425reactData: function () &#123; var that = this; var props = [&apos;year&apos;, &apos;month&apos;]; props.map(function (item) &#123; var dom = null; item === &apos;year&apos; ? dom = that.$(&apos;#year&apos;) : dom = that.$(&apos;#month&apos;); Object.defineProperty(that.data, item, &#123; get: function () &#123; return dom.value; // 绑定dom, 自动获取到value值 &#125;, set: function (newVal) &#123; if (item === &apos;month&apos;) &#123; if (newVal &gt; 12) &#123; newVal = 1; that.data.year++; &#125; else if (newVal &lt;= 0) &#123; newVal = 12; that.data.year--; &#125; &#125; dom.value = newVal; &#125; &#125;) &#125;); &#125;, initDate 用来像表格中填入数据：代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556initDate: function () &#123; // 将 this 值存入 that,为了防止在 onclick 事件中 this 值改变的情况 var that = this; var date = new Date(that.data.year, that.$(&apos;#month&apos;).value - 1, 1); // startDate 得到的是当月 1 号的星期几 var startDate = date.getDay(); // allDates 得到的是当前月全部的日期 var allDates = new Date(that.data.year, that.$(&apos;#month&apos;).value, 0).getDate(); var tds = document.getElementsByTagName(&apos;td&apos;); that.initColor(); var j = 0; startDate = (startDate ? startDate : 7); // startDate 表示这一个月份的一号是星期几，当是星期天的时候，要从下一行开始 // 下面的程序用来向表格内填入天的号数 for (let i = 0 ; i &lt; 42; i++) &#123; // 判断开始时间，即判断表格中位于 1 号之前的表格 if (i &gt;= startDate) &#123; j &gt;= allDates ? j = 1 : j++; tds[i].innerHTML = j; // 定义位于中间的表格可以点击区域 if(i &lt; allDates + startDate ) &#123; tds[i].onclick = function () &#123; // 将当前的年 月 表格输存入数组 that.initColor(that.data.year, that.data.month, i); that.initColor(); // 清空input 框内的数据 that.$(&apos;#&apos; + that.inputIdName).value = &apos;&apos;; that.data.selectDays.map(function (item, index, array) &#123; that.$(&apos;#&apos; + that.inputIdName).value = item.year + &apos;-&apos; + item.month + &apos;-&apos; + that.tds[item.day].innerHTML; if (!that.isSingle) &#123; var min; that.data.selectDays.map(function (item, index, array) &#123; if (item.day &lt; that.data.selectDays[0].day) &#123; min = item; &#125; else &#123; min = that.data.selectDays[0]; &#125; &#125; ); &#125; &#125;); // 点击事件完成之后调用回调函数 that.callBack(); &#125;; &#125; else &#123; // 使用 onclick = null 回收点击事件 tds[i].onclick = null; tds[i].className = &apos;notClick&apos;; &#125; &#125; else &#123; tds[i].className = &apos;notClick&apos;; document.getElementsByTagName(&apos;td&apos;)[i].onclick = null; // 回收 click 事件 tds[i].innerHTML = new Date(that.data.year, that.$(&apos;#month&apos;).value - 1, 0).getDate() + 1 -startDate + i ; &#125; &#125; &#125;, 在上段代码中使用的日期对象的一些方法；initColor ：用来重置表格的颜色dateAct 用来定义日历的一些行为代码总结: 1.使用面向对象的写法进行编写的，而非之前的面向过程编写2.熟悉 js 中关于使用日期事件的一些方法在代码中的一些问题: 1.代码逻辑混乱，这一部分需要加强2.代码中需要规范，包括注释，变量的定义3.使用面向对象的写法的时候，需要知道使用 使用 property 构建函数的时候发生了什么，以及代码中 this 的指向值little Tips addEventListener attachEvent12345678910&lt;div id=&apos;btn&apos;&gt;&lt;/div&gt;&lt;script&gt; window.onload = function () &#123; var button = document.getElementById(&apos;btn&apos;); Good.addEventListener(&apos;click&apos;, function () &#123; console.log(this); // this 指向的是 id 为 good 的 dom 元素 &#125;) &#125;&lt;/script&gt; addEventistener 用于监听事件target.addEventListenter(event, fn , [userCapture])event : 表示要进行监听的事件 [string]fn :表示 监听到事件之后的回调函数userCapture : 表示事件是应用到冒泡阶段还是应用到捕获阶段 [boolean] 在 addEventListener中定义的 this 值指向的是 tartget 对象在 IE 下 使用 attachEvent 来实现类似 addEventListener 的行为:实现兼容性：12345678function listenEvent(dom,event,fn) &#123; if (dom.attachEvent) &#123; dom.attachEvent(&apos;on&apos; + event, fn); &#125; else &#123; dom.addEventListener(event, fn); &#125; &#125; 2.使用 Date对象对于得到月份的天数以及当前月第一天的星期几的求法是不同的]]></content>
      <categories>
        <category>代码集</category>
      </categories>
      <tags>
        <tag>日历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活]]></title>
    <url>%2F2017%2F08%2F26%2F%E7%94%9F%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }圣经 你们看那天上的飞鸟，也不种，也不收，也不积蓄在仓里，你们的天父尚且养活它。你们不比飞鸟贵重得多吗？”​ (耶稣所讲的比喻，载于 马太福音 6:26) 前两天心里面有些焦虑，就想到了这句话。这句话在知乎里面看到过，当时记了下来，现在想一想，这句话挺适合现在的我的心态的。这句话在圣经书上看到过，当时还比较小，只是那圣经书当作故事书来读的，一来那时候家里没有什么书，父亲是农民，也没有给我买过什么书，那本圣经看的挺有趣。二来，其实那本书还挺不错的，家里的圣经书是带插画的，从上帝创造天地开始到耶稣基督升天结束，大约五十几章，每一章都是一个故事，配有插图。故事讲的生动有趣。自己看的津津有味的。现在回头想想，圣经的故事连小孩子都能吸引，基督教成为三大宗教之一也不是没有道理的。人生哪里有这么多的挫折与逆境，不如意这十之八九，可与人言着不过二三，你自认为的困苦，只是一辈子的常态。每天保持向上的力量，努力工作，认真学习，不要想遥远的未来，未来如何，你怎么也想不到，不要幻想将来，将来不是来自于幻想，来自于每天一点一滴的积累。世上的工作无非苦与累，想要安逸，没有错，你是否为了安逸去努力。脚踏实地，才能一步步的走的更远，不要想将来，不要想过去，把自己每天的事情做好。你太懒了，也太怂了，你能否可以克服自己？饮冰十年，难凉热血。不要想着战胜困难，先要战胜自己。]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[函数节流]]></title>
    <url>%2F2017%2F08%2F26%2F%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }函数节流 代码如下:123456789101112131415var processor = &#123; timeoutId: null, preformProcessing: function () &#123; //实际上要进行执行的代码 &#125;， process: function () &#123; clearTimeout(this.timeoutId); var that = this; // 在 setTimeout 函数内部是一个匿名函数，匿名函数的 this 指向值指向了全局作用域 this.timeoutId = setTimeout(function () &#123; that.preformProcessing(); &#125;, 100) &#125;&#125;processor.process() // 开始执行函数 使用函数节流的思想是：假如有一个提交按钮，点击按钮执行提交操作，设置了一个延时器，在点击按钮一段时间之后执行函数，如果在这段时间内，按钮又被点击操作，process 函数会首先清除延时器，重新开始进行延时操作，为了防止用户在点击按钮进行操作的时候，触发多次提交操作，下面是一个节流函数：123456function throttle (method, context) &#123; clearTimeout(method.tId); method.tId = setTimeout(function () &#123; method.call(context) &#125;,100)&#125; 定时器使用 call 方法实现在适当的环境下执行函数，如果传入的 context 为空，那么就会在全局作用域中执行函数。总结 使用函数节流用来防止函数在一定时间内多次被触发操作。setTimeout内的 this 指向值：1234var timer = setTimeout(function () &#123; console.log(this) // window&#125;, 2000);timer; 因为使用 setTimeout this 值指向的是 window 全局对象，使用 es6 中的箭头函树，this 值是一样的效果。]]></content>
      <categories>
        <category>代码集</category>
      </categories>
      <tags>
        <tag>节流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS层叠上下文]]></title>
    <url>%2F2017%2F08%2F22%2FCSS%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }​ 最近看到张鑫旭大神的关于css元素层叠显示的文章，感到收获了很多，对于css元素堆叠有了深入的理解，下面是我做的写笔记。层叠上下文 普通元素使用css的特殊属性可以创建层叠上下文，创建层叠上下文的元素的层级会高于普通的元素 ，这就好像，当我们眼睛看电脑的时候，创建了层叠上下文的元素离我们的眼睛更近了。当层叠上下文与普通元素叠加在一起的时候，层叠上下文元素会叠放在普通元素的上面。在上面的这段话中，自己的理解是不正确的，创建了层叠上下文的元素只是有了层次，但是，并不能说，层叠上下文元素就一定到天然高于普通的元素。关于比较，还是要看 层叠顺序来的。层叠水平 层叠水平类似 &#39;level&#39; , 层叠水平的大小决定了同一层叠上下文元素下元素在 z 轴上的显示顺序，所有的元素都有层叠水平都有层叠水平，但是对于普通元素，讨论其层叠水平是没有意义的。普通元素的层叠水平优先由层叠上下文来决定，层叠水平的比较仅在层叠上下文中比较才有意义。层叠顺序 层叠顺序定义的是在相同的层叠上下文中 元素发生层叠的时候 ，特定的显示顺序, 层叠顺序图表引入顺序如下: 注意: 上面有句话 “当元素发生层叠的时候‘ ，如果元素没有创建层叠上下文，没有发生层叠的现象，下面的层叠顺序是不起作用的，但是，使用 dispplay: inline-block 是个例外，我想是因为在 CSS 中 内容主要，样式次之的原因吧， inline-block 会被认为是内容 ， block 会被认为属于布局的样式 如下代码所示:1234567891011121314151617181920&lt;div class=&quot;con&quot;&gt; &lt;div class=&quot;block2&quot;&gt; &lt;/div&gt; &lt;div class=&quot;block1&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .block1 &#123; width: 200px; height: 200px; background-color: blue; &#125; .block2 &#123; display: inline-block; margin-bottom: -100px; width: 200px; height: 200px; background-color: red; &#125;&lt;/style&gt; 效果如下:如果正常情况下，因为在 DOM 文档中，block1 元素位于 block2 元素下面，因此block 1 应该遮挡住 block2 才是，但是为什么会出现这种情况呢？因为我们给 block2元素添加了 display: inline-block 属性，根据上面的层叠规则图我们可以知道，应用到的 inline-block元素层叠水平上要高于 block 元素，因此 block2 元素会覆盖掉 block1 元素，这就是 使用层叠顺序的作用，用于比较同一层叠水平下的元素顺序。 下面是两条非常重要的层叠准则如下 :1.谁大谁上，当两个元素位于同一层叠上下文中的时候，按照层叠顺序，层叠水平大的要覆盖掉层叠水平小的元素。（要注意这里面当元素位于同一个层叠上下文的时候，才会按照层叠顺序来创建）2.后来居上，当两个元素的层叠水平一致的时候，并且层叠顺序一致的时候，在DOM流中 后面的元素会覆盖掉前面的元素 创建层叠上下文 如何创建层叠上下文呢？这里有三种途径：1.页面的根元素( html )本身带有层叠上下文对于页面的根元素 html 本身具有层叠上下文的2.对于包含有 position: absolute position: relative 的定位元素，当 z-index 不是auto 的时候，会创建层叠上下文。(注意这里，z-index 不能是 auto, 否则不能创建层叠上下文)例如代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;con&quot;&gt; &lt;div class=&quot;block1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;block2&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .block1 &#123; width: 200px; height: 200px; background-color: blue; &#125; .block2 &#123; margin-top: -100px; width: 200px; height: 200px; background-color: red; &#125; // 第一种情况 .block1 &#123; z-index: 2; &#125; .blcok2 &#123; z-index: 1; &#125; // 第二种情况 .block1 &#123; position: relative; z-index: 0; &#125; .blcok2 &#123; z-index: 1000; &#125;&lt;/style&gt;&lt;/body&gt;&lt;/html&gt; 我们通过对于css样式的改变出现下面的这几种情况：第一种情况:这种情况下，实际上 z-index 没有起作用，因为这里面的两个元素都是普通元素，没有创建层叠上下文的元素因此 这里使用 z-index 进行比较没有起作用 使用 z-index只对于层叠上下文的元素起作用第二种情况：使用 position: relative 和 z-index 创建了层叠上下文， 在层次上，层叠上下文的要高于普通元素，因为使用 z-index: 0 的层叠水平会高于 display:block 元素，因此会出现下面的效果3.使用其他特殊的 css3 属性创建的层叠上下文。使用一些特殊的层叠CSS3属性也会创建层叠上下文：有这么几个:1.当一个元素的 父元素 声明 display: flex | display: inline-flex 的时候，并且该元素的 z-index 不是 auto 而是数数值的时候，该元素变为层叠上下文元素；1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;con&quot;&gt; &lt;div class=&quot;block1&quot;&gt; &lt;/div&gt; &lt;div class=&quot;block2&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .con &#123; display: flex; &#125; .block1 &#123; width: 200px; height: 200px; background-color: blue; &#125; .block2 &#123; margin-left: -100px; width: 200px; height: 200px; background-color: red; &#125; .block2 &#123; &#125; .block1 &#123; z-index: 1; &#125;&lt;/style&gt;&lt;/body&gt;&lt;/html&gt; 正常情况下，block2 元素 应该在block元素上面，因为dom流中 block元素位于 后面但是，当我们给 block1 添加了一个 z-index 不为 auto的值的时候，情况发生变化了, Magic !如下：这是因为添加了 z-index 元素就变成了层叠上下文了，在层叠顺序表中， z-index 大于 0 的层叠上下文在 层次上要高于 display: block 的普通元素，如果 z-index 为 -1 的时候，其实情况又不一样了。因为 z-index 为负值的时候是会小于 display: block 元素的。 使用 CSS 中的 opacity 创建的层叠上下文元素:我们有时候会出现想让 不透明元素内的元素显示正常，123456789101112131415161718&lt;div class=&apos;con&apos;&gt; &lt;div class= &apos;text&apos;&gt;我是一段文字&lt;/div&gt;&lt;div&gt;&lt;sytle&gt;.con&#123; width: 100px; height: 100px; background-color: blue; opacity: 0.5;&#125;.text &#123; width: 100px; height: 100px; background-color: red; position: relative; z-index: -1;&#125;&lt;/style&gt; 在实际上，元素内的文字也会被透明度影响，这被认为是 使用 opacity 创建了层叠上下文元素因为，在没有使用 opacity 的时候， 没有创建层叠上下文， 这时候 .text 元素是创建了层叠上下文的，因为 z-index 小于零，在层叠规则上小于 block 元素，所以会被遮盖掉。当我们对于 class=&#39;con&#39; 的元素没有设置 opacity的时候，效果如下：这样效果的原因是因为：使用了 position: relative 和 z-index: -1 形成的层叠上下文，在层叠规则上要低于 其他的block 元素，因此图片中的红色方块就被遮挡住了；然而，当我们对元素应用 opacity 当 opacity 是不为 1 的数字的时候，我们发现层叠顺序发生了改变： Magic!如上,因为我们对于 class = &#39;con&#39; 设置了 opacity: 0.7 创建了层叠上下文，其子元素 class =&#39;text&#39; 虽然也是创建了层叠上下文，但是根据层叠上下文的规则，如果父元素也是创建了层叠上下文，那么子元素创建的层叠上下文要受到父元素的层叠上下文的制约； 上面对于使用 opacity 创建的层叠上下文，来解释子元素会受到父元素 opacity 的影响，实际上，我们也可以认为属性 opacity 具有继承性，子元素会继承父元素的 opacity 属性 对于使用 opacity 会影响到子元素的效果，如果我们想让子元素不受到父元素 opacity 的影响， 解决办法有下面的几种方法： 借用 background: rgba() 了来实现 使用 这个属性可以避免 后代子元素使用 opacity 造成的干扰效果，123456background: rgba(R,G,B,A)// R: 代表红色取值// G: 代表绿色取值// B: 代表蓝色取值// A: 代表透明度// R G B 代表 三原色, 数值为 0 - 255 使用这三种颜色的组合可以实现任何其他的颜色 因此，上面的问题，我们使用 rgba 来解决：background: rgba(0,0,255,0.5) 还有一种方法，是让被 opacity 不作用在父元素上 html: 123456&lt;div class=&apos;con&apos;&gt; &lt;div class=&apos;text&apos;&gt; &lt;p&gt;我是要进行显示的元素&lt;/p&gt; &lt;/div&gt; &lt;div class=&apos;back&apos;&gt;&lt;/div&gt;&lt;/div&gt; CSS:1234567891011121314.blo &#123; position: relative; width: 100px; height: 100px; &#125;.back &#123; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: blue; opacity: 0.2; &#125; ​ 效果如下:层叠上下文的特性： 层叠上下文元素有如下特性： 层叠上下文的层叠水平要比普通元素高； 层叠上下文可以阻断元素的混合模式； 层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的层叠上下文。 每个层叠上下文和兄弟元素独立，也就是当进行层叠变化或渲染的时候，只需要考虑后代元素。 每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS层叠</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[作用域：函数作用域和块作用域]]></title>
    <url>%2F2017%2F08%2F20%2F%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9A%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }作用域单元 作用域单元分为函数作用域和块作用域，使用作用域的目的是将变量单独定义在作用域内，防止变量污染，变量的声明应该距离是用地越近越好，并且最大限度的实现本地化。为什么要创建块作用域 例如代码如下：12345678910if (true) &#123; var bar = 2&#125;console.log(bar) // 2for (var i =0 ;i &lt; 10; i++) &#123; console.log(i)&#125;console.log(i); 在上面的代码中，使用了 var 声明变量，当我们这个变量只在 if 或者 for 代码块中使用的时候，使用 var 声明变量容易造成变量污染，后续开发人员声明变量的时候还要避免声明同样的变量。使用快作用域的作用是：在代码块中被声明的变量只在代码块中使用，不会污染到全局变量。这就需要我们创建块作用域。创建块作用域的几种方式 1.try catch 语句会在 catch 语句中创建一个块作用域1234567try &#123; consolel.log(a);&#125;catch (err) &#123; console.log(err.name); // 抛出错误的名字&#125;console.log(err.name) // err is not defined 声明的catch 内变量只在 catch 语句内部被使用到2.let 会为声明的变量隐式的创建块作用域1234if (true) &#123; let bar = 2&#125;console.log(bar)// bar is not defined 通过使用 let 将声明的变量隐式的绑定到 if 语句上，在外部是不可访问到的。也可以通过使用 { } 来显式的为 let 声明一个用于绑定的块:1234567if () &#123; let bar = 2; &#123; let foo = 3; &#125; console.log(foo); // foo is not defined&#125; 使用 let 可以创建作用域，相对于使用 var 而言,var 会将变量定义到全局作用域中，使用 let 定义变量会被定义到隐式的块状作用域，因此，依赖变量的函数也要放到定义的块状作用域内。3.使用 const也可以创建块状作用域，使用 const 创建的是常量，试图修改会导致错误:1234if (true) &#123; const a = 2;&#125;console.log(a) // a is not defined 总结 使用 var 定义的变量会被定义到全局变量中，使用let 可以创建块状作用域，使用let定义的变量依赖的函数要和声明的变量放在同一个作用域；使用 {} 可以声明显式的作用域；]]></content>
      <categories>
        <category>js读书总结</category>
      </categories>
      <tags>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端touch事件]]></title>
    <url>%2F2017%2F08%2F19%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFtouch%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }touch事件 当我们手指触摸屏幕的时候，touch事件有这几个事件:touchstart : 当手指触摸手机屏幕的时候触发 touchmove : 当手指当手机屏幕上移动的时候触发 touchend: 当手指移开手机屏幕的时候触发 ，事件方法应该在 touchend 中定义调用。touchcancel: 这个事件在 uc 浏览器上，当我们在页面上进行左右滑动的时候会被触发 ,用于防止误操作 touch 事件对象 touch事件对象返回了下面几个属性: touches: 当前屏幕上所有触摸点的集合 ,当只有一个触摸点的时候，使用 touches[0] 获得触摸对象targetTouches: 当前对象上所有触摸点的集合 changedTouched: 自从变化之后的所有touch对象数组 touch 事件返回的对象中的属性集合 返回的触摸点对象如下：1234567891011121314151617TouchList &#123;length: 10: TouchclientX: 57.36600112915039clientY: 31.8700008392334force: 1identifier: 0pageX: 57.36600112915039pageY: 31.8700008392334radiusX: 36.65040588378906radiusY: 36.65040588378906rotationAngle: 0screenX: 547screenY: 167target: div#demo__proto__: Touch__proto__: TouchList 各个触摸点的属性解释如下: clientX，clientY: 触摸点在视口中的距离 pageX, pageY:触摸点在html文档中的距离，当html文档的宽度超过视口的宽度的时候， pageX = clientX + 超出的那一部分距离 screenX, screenY: 触摸点距离屏幕的距离 target: touch事件作用到的事件对象 在uc浏览器下遇到的问题 使用uc浏览器的时候遇到了一个问题，我想要做导航栏随着手指移动而滑动的效果，在android 系统上chrome浏览器表现正常，但是在uc浏览器上出现bug, 手指滑动屏幕的时候导航栏不滑动，当手指离开的时候，导航栏出现滑动效果，貌似滑动效果只被触发了一次，touchend 事件消失，被touchcancel替代:解决办法: 在touchmove的时候阻止默认行为，监听touchcancel 替代 touchend事件:1234567891011121314touch(event) &#123; switch (event.type) &#123; case &apos;touchstart&apos;: .... break; case &apos;touchmove&apos;: .... event.preventDefault(); break; case &apos;touchend&apos;: .... break; &#125; &#125; 情况并不像我之前想的那样，touchcancel 的行为并不是类似于 touchend touchcancel 事件 touchcancel 从字面意思上来讲，是取消touch 操作的意思，在 MDN 上是这样解释的: The touchcancel event is fired when a touch point has been disrupted in an implementation-specific manner (for example, too many touch points are created).\touchcancel 事件是这样被触发的：当触摸点被一种特殊的执行方法被破坏，（例如，创建了太多的触摸点） 我是这样理解的： touchcancel 事件被触发是因为:当我们使用手机操作的时候，例如点击按钮操作，我们在 touchend 事件中定义了点击按钮后调用的方法，如果我们误操作，比如手指在按钮上左右滑动的时候，touchcancel 事件就会被紧跟着被调用（不同于点击事件，浏览器会认为在手机屏幕上的左右滑动是误操作），取消 touchend 事件，从touchend 事件中的方法不会被执行。当手指在按钮上下滑动的时候，touchcancel 事件是不会被调用的。可以把touchcancel 事件视为防止误操作事件。]]></content>
      <tags>
        <tag>移动端touch事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my first blog]]></title>
    <url>%2F2017%2F08%2F18%2Fmy-first-blog%2F</url>
    <content type="text"><![CDATA[function isIn(el) { let bound = el.getBoundingClientRect(); let clientHeight = window.innerHeight; return bound.top img.dataset.type === 'post-pic').forEach(img => { if (isIn(img)) { replaceSrc(img) } }) } function replaceSrc(el) { if (el.dataset.isLoaded !== 'true') { el.src = el.dataset.src el.setAttribute('data-loaded', 'true') el.parentNode.href = el.dataset.src } } window.onload = window.onscroll = function () { loadImg() }这是我的第一篇博客: 折腾来折腾去终于搭建起来github博客，还好中间没有遇到太大的问题，搭建过程也还算顺利。 为什么要写博客？为了记录下自己前端学习中的一些知识点，在写代码的过程中，总结经验，提高自己的编程水平，写下自己在编程中遇到的问题，思考，以及是如何解决的，不断提高自己。千里之行，始于足下 12]]></content>
      <tags>
        <tag>0</tag>
      </tags>
  </entry>
</search>
