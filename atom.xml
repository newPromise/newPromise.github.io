<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>上善若水</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://newpromise.github.io/"/>
  <updated>2025-04-11T02:42:48.319Z</updated>
  <id>https://newpromise.github.io/</id>
  
  <author>
    <name>上善若水</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>拼音编辑器技术实现</title>
    <link href="https://newpromise.github.io/2025/04/11/%E6%8B%BC%E9%9F%B3%E7%BC%96%E8%BE%91%E5%99%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/"/>
    <id>https://newpromise.github.io/2025/04/11/拼音编辑器技术实现/</id>
    <published>2025-04-11T10:40:53.000Z</published>
    <updated>2025-04-11T02:42:48.319Z</updated>
    
    <content type="html"><![CDATA[<h1 id="拼音编辑器">拼音编辑器</h1><h2 id="需求背景">需求背景</h2>实现一个拼音编辑器，提高教研同事工作效率实现功能：<ol><li>三种形式的内容编辑，组合格，四线三格，田字格</li><li>组合格中的拼音支持切换音调，遵循拼音的注音逻辑</li><li>多音字支持切换不同的拼音</li><li>支持新增，删除，换行格子</li><li>四线三格支持跟随内容的输入而宽度变化，自适应</li><li> 支持导出为 svg 形式的 base64</li><li>支持修改编辑，编辑内容回显</li></ol><h2 id="代码结构">代码结构</h2><h3 id="dom-结构">Dom 结构</h3><img src="image-20230409141357370.png" loading="lazy"><ul><li> 最外层<code>svg</code>: 编辑器内容区的容器, 后面的子元素都是相对于这个 svg 进行定位的。</li><li><code>style</code>: 用来放置一些样式，这里是用来放置字体，根据是四线三格还是组合格，分别引入不同的字体文件。</li><li><code>defs</code>:  <a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/defs" target="_blank" rel="noopener">defs</a> 用来放置一些公共的后面会用到的 svg 图形，理解为一个公共组件，这里两个组件：<code>sxsg-lines</code> : 定义四线三格的线段， <code>tzg-lines</code>: 用来定义田字格的线段。在后面使用的时候，通过使用 <code>use</code> 的方式引入： <code>&lt;use href=&quot;#tzg-lines&quot;&gt;&lt;/use&gt;</code></li><li><code>svg.lattice</code>: 使用类名为 <code>lattice</code> 的 svg 为编辑器的格子，编辑器的内容区都是由一个个的这样的格子构成的，通过修改这些格子的 x, y 的属性，来调整位置，实现换行和新增格子的功能。</li></ul><h6 id="svglattice"><code>svg.lattice</code></h6>主要有两部分构成，背景线条以及内容编辑器区域，如下，红色区域内的元素为绘制背景线条的svg元素，蓝色区域内的元素为编辑内容区域：<img src="image-20230409143554997.png" loading="lazy"><ul><li><code>svg.frame-group</code>: 组合格的内容区域，包含 <code>svg.frame-sxsg</code> 和 <code>svg.frame-tzg</code></li><li><code>svg.frame-sxsg</code>: 四线三格的内容区域</li><li><code>svg.frame-tzg</code>: 田字格的内容区域边框</li><li><code>use</code>: 引用前面 <code>defs</code> 元素中声明好的图形</li><li><code>foreignObject</code>  :  用来在 svg 元素中嵌入 html 内容</li></ul><h3 id="代码结构：">代码结构：</h3><code>Editor</code>: 编辑器，对于格子元素进行删除，添加，换行位置的控制，svg 内容的导出，编辑器初始化，接受修改的数据回显<code>Lattice</code>: 编辑器格子，创建格子元素的结构，添加格子内的可编辑内容<code>EditText</code>: 格子内容部分，处理编辑事件，对于输入的内容进行校验，添加一些dom事件<code>Frame</code>: 用来绘制格子中的格子线，创建两种类型的格子线，四线三格和田字格的线段大体结构图示：按照田字格的类型为例<img src="结构图.svg" loading="lazy">另外存在一个 <code>Events</code> 类，<code>Lattice</code> 和 <code>EditText</code> 都有继承，用来方便进行事件通信<h2 id="功能实现">功能实现</h2>一些重要功能实现的流程图：<ul><li>拼音的输入，切换声调的实现<img src="拼音声调.svg" loading="lazy"></li></ul><ul><li>输入汉字获取拼音<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/compositionend_event" target="_blank" rel="noopener">compositionend</a><img src="输入汉字获取拼音.svg" loading="lazy"></li><li>换行，删除，新增格子的实现都是在 <code>EditText</code> 中触发一些事件，向上传递至 <code>Editor</code>, 在 <code>Editor</code> 中进行格子元素的控制</li></ul><h2 id="一些问题">一些问题</h2><h3 id="字体问题">字体问题</h3>确定编辑器的字体：汉字：楷体英文：和人教版pep的字体保持一致（舒窈意大利斜体）<blockquote>四线三格中的字体为手写体，我们常见的英文字体可以称为印刷体，写在四线三格中的手写体和印刷体有写法上的不同，手写体有比较强的个人风格，可以类比为我们汉字字体中的楷书，行书，兰亭体，衡水体小学英语教材中的四线三格英文字体应该采用何种没有明确的规定，是由出版社来决定的</blockquote>拼音：没有要求，但是要考虑到特殊字符（带音调的字母）的适配在拼音字体中存在几个问题需要注意：<ul><li>渲染问题（单层 a 和 双层 a）都可以，但是大多是都是使用单层 a， 没有特殊要求</li><li>选择的字体中需要对于特殊的声调进行处理 因此我们选用的字体文件中，要保证字体的展示</li><li>选择开源免费可商用字体</li><li>中文字体需要减少体积</li></ul>对于上面的问题，选用了免费可商用的字体： <code>OPPOSans-M-2</code>, 并且使用 <code>fontmin</code> 进行字体文件提取<a href="https://github.com/ecomfe/fontmin" target="_blank" rel="noopener">fontmin</a><a href="http://ecomfe.github.io/fontmin/#app" target="_blank" rel="noopener">http://ecomfe.github.io/fontmin/#app</a><h3 id="svg-绘制">SVG 绘制</h3>使用 <a href="https://svgjs.dev/docs/3.0/" target="_blank" rel="noopener">svgjs</a> 来进行 svg 元素的操作控制绘制。<h3 id="svg-中的定位问题">svg 中的定位问题</h3><code>svg</code> 中的元素是通过属性<code>x</code>, <code>y</code> 相对于 <code>svg</code> 左上角的位置（原点）进行定位的，x: 是相对于原点右边的位置，y 是相对于原点下面的位置：<img src="2.png" loading="lazy">但是我们的元素太多，不能相对于一个 svg 原点进行定位，如果这样，就计算很困难，为了方便定位，我们可以通过创建 <code>svg</code> 元素的方式新建一个坐标系，在这个坐标系下进行定位。所以，为什么元素 <code>.frame-sxsg</code> <code>.frame-tzg</code>, <code>.lines</code> 是 <code>svg</code> 元素，是为了方便内部的元素进行定位<h3 id="svg-中的画线">svg 中的画线</h3><h6 id="给定坐标点，是怎么画一条线的-？">给定坐标点，是怎么画一条线的 ？</h6><img src="3.png" loading="lazy">两个坐标点之间画一条线，从这条线上线进行==均分边距==<h4 id="如何画一个包括边框的-50--50-的矩形-？">**如何画一个包括边框的 50 * 50 的矩形 ？</h4><h4 id="实现-box-sizing-border-box-的效果">实现 box-sizing: &#39;border-box&#39; 的效果**</h4><img src="4.png" loading="lazy"><h3 id="svg-中的样式和字体处理">svg 中的样式和字体处理</h3><ul><li>字体要转换为 <code>base64</code> 的格式，避免使用路径找不到的问题</li><li>svg 中涉及到的 style 样式要写在 svg 作用域下面，用于导出时的使用</li></ul><h3 id="兼容性问题">兼容性问题</h3>svg 中混合 <code>foreignObject</code> 在 safari 浏览器上会有展示问题：如下：<img src="pase-1.png" loading="lazy">问题是作用在 <code>foreignObject</code>  上的样式不起作用，同时，我们这里使用的是电脑的默认字体，<code>Kaiti</code>  有的电脑上可能没有安装这种字体@update 2023-05-12<strong>解决safari兼容性问题</strong>通过使用  <code>text-to-path</code> 的方式解决，将文字转为 <code>path</code> 元素：<ul><li>移除了 style 内部的 fontface 引用,  将本来嵌入到 svg 内部的 font 提取到页面引入</li><li>移除了 foreignObject  元素，用 path  进行替换</li><li>选用较小的中文字体 方正简体楷体，只有 3.9 MB，方便快速引用下载</li></ul><p><img src="Pasted image 20230512113526.png" loading="lazy"></p><a href="https://github.com/shrhdk/text-to-svg" target="_blank" rel="noopener">text-to-path </a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;拼音编辑器&quot;&gt;拼音编辑器&lt;/h1&gt;
&lt;h2 id=&quot;需求背景&quot;&gt;需求背景&lt;/h2&gt;
实现一个拼音编辑器，提高教研同事工作效率实现功能：&lt;ol&gt;
&lt;li&gt;三种形式的内容编辑，组合格，四线三格，田字格&lt;/li&gt;
&lt;li&gt;组合格中的拼音支持切换音调，遵循拼音的注音逻辑&lt;
      
    
    </summary>
    
      <category term="frontend, svg, fonts" scheme="https://newpromise.github.io/categories/frontend-svg-fonts/"/>
    
    
      <category term="SVG, DOM, fontmin" scheme="https://newpromise.github.io/tags/SVG-DOM-fontmin/"/>
    
  </entry>
  
  <entry>
    <title>vue-component-lifecycle</title>
    <link href="https://newpromise.github.io/2025/04/11/vue-component-lifecycle/"/>
    <id>https://newpromise.github.io/2025/04/11/vue-component-lifecycle/</id>
    <published>2025-04-11T09:31:08.000Z</published>
    <updated>2025-04-11T02:42:48.317Z</updated>
    
    <content type="html"><![CDATA[<!-- Generated by SpecStory --><h1 id="vue-component-lifecycle-relationships-2025-02-27-170728">Vue Component Lifecycle Relationships (2025-02-27 17:07:28)</h1>Question：vue 中子组件生命周期和父组件生命周期的<hr>Answer：<h1 id="vue-中子组件生命周期和父组件生命周期的关系">Vue 中子组件生命周期和父组件生命周期的关系</h1>在 Vue 中，父组件和子组件的生命周期钩子函数执行顺序遵循一定的规则。以下是它们之间的关系：<h2 id="组件创建和挂载阶段">组件创建和挂载阶段</h2><ol><li>父组件 beforeCreate</li><li>父组件 created</li><li>父组件 beforeMount</li><li>子组件 beforeCreate</li><li>子组件 created</li><li>子组件 beforeMount</li><li>子组件 mounted</li><li>父组件 mounted</li></ol><h2 id="组件更新阶段">组件更新阶段</h2><ol><li>父组件 beforeUpdate</li><li>子组件 beforeUpdate</li><li>子组件 updated</li><li>父组件 updated</li></ol><h2 id="组件销毁阶段">组件销毁阶段</h2><ol><li>父组件 beforeDestroy</li><li>子组件 beforeDestroy</li><li>子组件 destroyed</li><li>父组件 destroyed</li></ol><h2 id="关键点">关键点</h2><ul><li>创建过程是由外到内（父组件先创建，然后是子组件）</li><li>挂载过程是由内到外（子组件先挂载完成，然后是父组件）</li><li>更新过程也是由外到内再由内到外</li><li>销毁过程也是由外到内再由内到外</li></ul>在你的代码中，<code>banner</code>、<code>mysz</code>、<code>jjzd</code>、<code>hot</code> 和 <code>bottomNav</code> 这些子组件的生命周期会在父组件 <code>2025sszz-m</code> 的相应生命周期内按照上述规则执行。例如，当你的页面加载时，父组件的 <code>created</code> 钩子会先执行（其中调用了 <code>initData</code> 方法），然后才会执行子组件的 <code>created</code> 钩子。而在挂载阶段，所有子组件的 <code>mounted</code> 钩子会先执行完毕，然后才会执行父组件的 <code>mounted</code> 钩子。<hr>Question：父组件中在 created 中使用 async await，会阻塞子组件的加载吗<hr>Answer：<h1 id="父组件中在-created-使用-async-await-是否会阻塞子组件加载">父组件中在 created 使用 async await 是否会阻塞子组件加载</h1>父组件在 <code>created</code> 生命周期钩子中使用 <code>async/await</code> <strong>不会阻塞子组件的创建和挂载过程</strong>。<h2 id="原因解释">原因解释</h2><ol><li><strong>JavaScript 的事件循环机制</strong>：<ul><li>当父组件执行到 <code>async/await</code> 时，异步操作会被放入微任务队列</li><li>Vue 的组件创建过程会继续执行，不会等待这些异步操作完成</li></ul></li><li><strong>Vue 组件渲染流程</strong>：<ul><li>父组件的 <code>created</code> 钩子执行后，Vue 会继续处理组件树的渲染</li><li>子组件的创建和挂载过程会正常进行，不受父组件中异步操作的影响</li></ul></li></ol><h2 id="实际情况">实际情况</h2><ul><li>父组件中的 <code>created</code> 钩子执行（包含 <code>async/await</code> 代码）</li><li>父组件继续执行到 <code>beforeMount</code></li><li>子组件开始其生命周期（<code>beforeCreate</code>、<code>created</code>、<code>beforeMount</code>、<code>mounted</code>）</li><li>父组件完成 <code>mounted</code></li><li>父组件中的异步操作在完成后会执行其后续代码</li></ul><h2 id="需要注意的点">需要注意的点</h2>虽然不会阻塞子组件的加载，但如果子组件依赖于父组件异步获取的数据，可能会出现以下情况：<ol><li>子组件首次渲染时拿不到数据（因为异步操作尚未完成）</li><li>数据获取完成后，会触发组件的更新周期</li></ol><h2 id="最佳实践">最佳实践</h2>如果子组件依赖父组件异步获取的数据：<ol><li>使用 <code>v-if</code> 控制子组件的渲染时机</li><li>在父组件模板中添加加载状态指示</li><li>考虑使用 Vuex 或 Pinia 等状态管理工具</li><li>使用 <code>watch</code> 或计算属性处理数据依赖关系</li></ol><hr><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- Generated by SpecStory --&gt;

&lt;h1 id=&quot;vue-component-lifecycle-relationships-2025-02-27-170728&quot;&gt;Vue Component Lifecycle Relationships (202
      
    
    </summary>
    
      <category term="frontend, javascript, framework" scheme="https://newpromise.github.io/categories/frontend-javascript-framework/"/>
    
    
      <category term="vue, lifecycle, async" scheme="https://newpromise.github.io/tags/vue-lifecycle-async/"/>
    
  </entry>
  
  <entry>
    <title>监听元素类名变化的方法</title>
    <link href="https://newpromise.github.io/2025/04/11/%E7%9B%91%E5%90%AC%E5%85%83%E7%B4%A0%E7%B1%BB%E5%90%8D%E5%8F%98%E5%8C%96%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://newpromise.github.io/2025/04/11/监听元素类名变化的方法/</id>
    <published>2025-04-11T09:12:20.000Z</published>
    <updated>2025-04-11T02:42:48.340Z</updated>
    
    <content type="html"><![CDATA[<!-- Generated by SpecStory --><h1 id="监听元素类名变化的方法-2025-04-01-104659">监听元素类名变化的方法 (2025-04-01 10:46:59)</h1>Question：如何监听一个元素 class 类名的变化<hr>Answer：<h1 id="监听元素-class-类名变化的方法">监听元素 class 类名变化的方法</h1>要监听一个元素的 class 类名变化，有几种主要方法：<h2 id="1-mutationobserver-api">1. MutationObserver API</h2>这是现代浏览器中监听元素属性变化的最佳方式：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个观察器实例</span></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function">(<span class="params">mutations</span>) =&gt;</span> &#123;</span><br><span class="line">  mutations.forEach(<span class="function">(<span class="params">mutation</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mutation.attributeName === <span class="string">'class'</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> targetElement = mutation.target;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'类名已更改:'</span>, targetElement.className);</span><br><span class="line">      <span class="comment">// 这里可以执行你的回调函数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择需要观察的节点</span></span><br><span class="line"><span class="keyword">const</span> targetNode = <span class="built_in">document</span>.getElementById(<span class="string">'your-element-id'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置观察选项</span></span><br><span class="line"><span class="keyword">const</span> config = &#123; <span class="attr">attributes</span>: <span class="literal">true</span>, <span class="attr">attributeFilter</span>: [<span class="string">'class'</span>] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始观察目标节点</span></span><br><span class="line">observer.observe(targetNode, config);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后如果要停止观察</span></span><br><span class="line"><span class="comment">// observer.disconnect();</span></span><br></pre></td></tr></table></figure><h2 id="2-重写-classname-属性的-settergetter">2. 重写 className 属性的 setter/getter</h2>对于特定元素，可以通过重写其 className 属性来监听变化：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'your-element-id'</span>);</span><br><span class="line"><span class="keyword">const</span> originalClassName = element.className;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(element, <span class="string">'className'</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> originalClassName;</span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'类名从'</span>, originalClassName, <span class="string">'变为'</span>, value);</span><br><span class="line">    originalClassName = value;</span><br><span class="line">    <span class="comment">// 执行回调函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-使用-css-动画事件（间接方法）">3. 使用 CSS 动画事件（间接方法）</h2>通过 CSS 过渡或动画触发事件来间接监听：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">.monitored-element &#123;</span></span><br><span class="line"><span class="undefined">  transition: opacity 0.01s;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'your-element-id'</span>);</span></span><br><span class="line"><span class="javascript">element.addEventListener(<span class="string">'transitionend'</span>, () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'类名可能已更改:'</span>, element.className);</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-定时轮询（不推荐，但简单）">4. 定时轮询（不推荐，但简单）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'your-element-id'</span>);</span><br><span class="line"><span class="keyword">let</span> lastClassName = element.className;</span><br><span class="line"></span><br><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (element.className !== lastClassName) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'类名从'</span>, lastClassName, <span class="string">'变为'</span>, element.className);</span><br><span class="line">    lastClassName = element.className;</span><br><span class="line">    <span class="comment">// 执行回调函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">100</span>); <span class="comment">// 每100毫秒检查一次</span></span><br></pre></td></tr></table></figure>MutationObserver 是最推荐的方法，因为它效率高且是专门为此类监听设计的浏览器 API。<hr><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- Generated by SpecStory --&gt;

&lt;h1 id=&quot;监听元素类名变化的方法-2025-04-01-104659&quot;&gt;监听元素类名变化的方法 (2025-04-01 10:46:59)&lt;/h1&gt;
Question：如何监听一个元素 class 类名的变化
      
    
    </summary>
    
      <category term="frontend, js, web" scheme="https://newpromise.github.io/categories/frontend-js-web/"/>
    
    
      <category term="MutationObserver, DOM, javascript" scheme="https://newpromise.github.io/tags/MutationObserver-DOM-javascript/"/>
    
  </entry>
  
  <entry>
    <title>使用-closest()-方法判断祖先元素</title>
    <link href="https://newpromise.github.io/2025/04/11/%E4%BD%BF%E7%94%A8-closest()-%E6%96%B9%E6%B3%95%E5%88%A4%E6%96%AD%E7%A5%96%E5%85%88%E5%85%83%E7%B4%A0/"/>
    <id>https://newpromise.github.io/2025/04/11/使用-closest()-方法判断祖先元素/</id>
    <published>2025-04-11T09:07:00.000Z</published>
    <updated>2025-04-11T02:42:48.318Z</updated>
    
    <content type="html"><![CDATA[<!-- Generated by SpecStory --><h1 id="使用-closest-方法判断祖先元素-2025-01-08-113833">使用 closest() 方法判断祖先元素 (2025-01-08 11:38:33)</h1>Question：e.target.closest 可以判断一个元素的祖先元素是否包含某个元素吗<hr>Answer：是的，<code>Element.closest()</code> 方法可以用来判断一个元素的祖先元素是否包含某个选择器匹配的元素。它会从当前元素开始向上遍历 DOM 树，直到找到第一个匹配指定选择器的祖先元素。在你的代码中：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">closeTanChuangInfo(e) &#123;</span><br><span class="line">  const isInside =</span><br><span class="line">    e.target.closest(&quot;.recommend-content-list&quot;) ||</span><br><span class="line">    e.target.closest(&quot;.side-dialog&quot;);</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这段代码的工作原理是：<ol><li><code>e.target</code> 是触发点击事件的具体元素</li><li><code>closest()</code> 方法会检查：<ul><li>该元素本身是否匹配选择器</li><li>如果不匹配，则检查其父元素</li><li>继续向上遍历直到找到匹配的元素或到达文档根节点</li></ul></li></ol>比如：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"side-dialog"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>如果用户点击了 button：<ul><li><code>e.target</code> 是 <code>&lt;button&gt;</code> 元素</li><li><code>e.target.closest(&quot;.side-dialog&quot;)</code> 会返回外层的 div，因为它是最近的匹配 <code>.side-dialog</code> 选择器的祖先元素</li><li>如果没有找到匹配的祖先元素，<code>closest()</code> 会返回 <code>null</code></li></ul>所以这是一个很好的方法来判断点击事件是否发生在特定区域内或其子元素上。<hr>Question：side-dialog 内有个弹窗关闭按钮，为什么点了弹窗按钮之后，e.target.closest(&quot;.side-dialog&quot;) 为 null 呢<hr>Answer：这种情况通常有以下几个可能的原因：<ol><li>选择器名称不匹配：</li></ol><ul><li>检查 HTML 中的 class 名称是否完全一致</li><li>检查是否有多余的空格</li><li>检查是否有大小写问题</li></ul><ol start="2"><li>按钮可能是动态创建的，没有正确附加到 DOM 树中</li></ol>让我们修改代码来调试这个问题：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">closeTanChuangInfo(e) &#123;</span><br><span class="line">  // 添加调试日志</span><br><span class="line">  console.log(&apos;点击的元素:&apos;, e.target);</span><br><span class="line">  console.log(&apos;点击元素的所有父级class:&apos;, e.target.parentElement?.className);</span><br><span class="line">  console.log(&apos;DOM结构:&apos;, e.target.closest(&apos;.side-dialog&apos;));</span><br><span class="line">  </span><br><span class="line">  const isInside =</span><br><span class="line">    e.target.closest(&quot;.recommend-content-list&quot;) ||</span><br><span class="line">    e.target.closest(&quot;.side-dialog&quot;);</span><br><span class="line">    </span><br><span class="line">  if (!isInside) &#123;</span><br><span class="line">    this.$refs[this.type].closeTanChuangInfo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>建议检查：<ol><li>确认弹窗的 HTML 结构：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 正确的结构应该是这样 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"side-dialog"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dialog-content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"close-btn"</span>&gt;</span>关闭<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>检查弹窗是否使用了 <code>v-if</code> 或者其他方式动态渲染，可能导致 DOM 结构不完整</li><li>如果使用了第三方弹窗组件，可能会创建新的 DOM 树或 portal，这种情况下需要检查实际渲染后的 DOM 结构</li></ol>你可以在浏览器开发者工具中：<ol><li>点击 Elements 面板</li><li>找到关闭按钮元素</li><li>检查它的父级元素是否真的有 <code>side-dialog</code> 类名</li></ol><hr>Question：如果出现这种动态创建的方式，如何解决不准确的问题呢<hr>Answer：对于动态创建的元素，有几种解决方案：<ol><li>使用事件委托的方式，监听更上层的稳定元素：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  onOutsideClickCloseSideDialog() &#123;</span><br><span class="line">    // 改为监听更稳定的根元素</span><br><span class="line">    this.$el.addEventListener(&quot;click&quot;, this.closeTanChuangInfo);</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  removeOutsideClickCloseSideDialog() &#123;</span><br><span class="line">    this.$el.removeEventListener(&quot;click&quot;, this.closeTanChuangInfo);</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  closeTanChuangInfo(e) &#123;</span><br><span class="line">    // 1. 先判断是否是关闭按钮</span><br><span class="line">    if (e.target.closest(&apos;.dialog-close-btn&apos;)) &#123;</span><br><span class="line">      this.$refs[this.type].closeTanChuangInfo();</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 2. 再判断点击区域</span><br><span class="line">    const isInside =</span><br><span class="line">      e.target.closest(&quot;.recommend-content-list&quot;) ||</span><br><span class="line">      e.target.closest(&quot;.side-dialog&quot;);</span><br><span class="line">      </span><br><span class="line">    if (!isInside) &#123;</span><br><span class="line">      this.$refs[this.type].closeTanChuangInfo();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 Vue 的自定义指令来处理点击事件：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">  clickOutside: &#123;</span><br><span class="line">    bind(el, binding, vnode) &#123;</span><br><span class="line">      el.clickOutsideEvent = function(e) &#123;</span><br><span class="line">        // 判断点击的是否是关闭按钮</span><br><span class="line">        if (e.target.closest(&apos;.dialog-close-btn&apos;)) &#123;</span><br><span class="line">          binding.value();</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 判断点击是否在元素外部</span><br><span class="line">        if (!(el === e.target || el.contains(e.target))) &#123;</span><br><span class="line">          binding.value();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      document.addEventListener(&apos;click&apos;, el.clickOutsideEvent);</span><br><span class="line">    &#125;,</span><br><span class="line">    unbind(el) &#123;</span><br><span class="line">      document.removeEventListener(&apos;click&apos;, el.clickOutsideEvent);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用 Vue 的 <code>$refs</code> 来获取实际的 DOM 元素进行判断：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">closeTanChuangInfo(e) &#123;</span><br><span class="line">  // 获取实际的弹窗 DOM 元素</span><br><span class="line">  const dialogEl = this.$refs.sideDialog?.$el || this.$refs.sideDialog;</span><br><span class="line">  const listEl = this.$refs.recommendList?.$el || this.$refs.recommendList;</span><br><span class="line">  </span><br><span class="line">  // 判断点击是否在这些元素内</span><br><span class="line">  const isInside = </span><br><span class="line">    (dialogEl &amp;&amp; dialogEl.contains(e.target)) ||</span><br><span class="line">    (listEl &amp;&amp; listEl.contains(e.target));</span><br><span class="line">    </span><br><span class="line">  if (!isInside) &#123;</span><br><span class="line">    this.$refs[this.type].closeTanChuangInfo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>如果使用第三方弹窗组件，建议使用组件提供的事件处理方法：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-dialog</span><br><span class="line">    v-model=&quot;dialogVisible&quot;</span><br><span class="line">    @close=&quot;handleClose&quot;</span><br><span class="line">    @click-outside=&quot;handleClickOutside&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;!-- 弹窗内容 --&gt;</span><br><span class="line">  &lt;/el-dialog&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>最佳实践建议：<ol><li>尽量使用框架提供的事件处理机制</li><li>对于动态内容，使用事件委托</li><li>添加必要的调试日志，方便排查问题</li><li>考虑使用 Vue 的生命周期钩子确保 DOM 已经完全渲染</li><li>使用 <code>nextTick</code> 确保 DOM 更新后再绑定事件</li></ol>选择哪种方案取决于你的具体场景：<ul><li>如果是简单的弹窗，使用 Vue 的自定义指令最清晰</li><li>如果是复杂的交互，建议使用事件委托</li><li>如果使用第三方组件，优先使用组件提供的事件处理方法</li></ul><hr>Question：是否可以用一个js方法，判断某个元素是否是一个元素的祖先元素呢<hr>Answer：是的，可以使用 <code>contains()</code> 方法或者自定义一个函数来判断祖先关系。这里提供两种实现方式：<ol><li>使用 <code>contains()</code> 方法（推荐）：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isAncestor</span>(<span class="params">ancestorElement, childElement</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ancestorElement.contains(childElement);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">const</span> parent = <span class="built_in">document</span>.querySelector(<span class="string">'.side-dialog'</span>);</span><br><span class="line"><span class="keyword">const</span> child = <span class="built_in">document</span>.querySelector(<span class="string">'.close-btn'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(isAncestor(parent, child)); <span class="comment">// true 或 false</span></span><br></pre></td></tr></table></figure><ol start="2"><li>自定义递归方法：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isAncestor</span>(<span class="params">ancestorElement, childElement</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果子元素不存在，返回 false</span></span><br><span class="line">  <span class="keyword">if</span> (!childElement) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果到达文档根节点还没找到，返回 false</span></span><br><span class="line">  <span class="keyword">if</span> (childElement === <span class="built_in">document</span>.documentElement) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果找到了祖先元素，返回 true</span></span><br><span class="line">  <span class="keyword">if</span> (childElement.parentElement === ancestorElement) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 递归检查父元素</span></span><br><span class="line">  <span class="keyword">return</span> isAncestor(ancestorElement, childElement.parentElement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在你的代码中可以这样使用：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">closeTanChuangInfo(e) &#123;</span><br><span class="line">  const sideDialog = document.querySelector(&apos;.side-dialog&apos;);</span><br><span class="line">  const recommendList = document.querySelector(&apos;.recommend-content-list&apos;);</span><br><span class="line">  </span><br><span class="line">  const isInside = </span><br><span class="line">    (sideDialog &amp;&amp; isAncestor(sideDialog, e.target)) ||</span><br><span class="line">    (recommendList &amp;&amp; isAncestor(recommendList, e.target));</span><br><span class="line">    </span><br><span class="line">  if (!isInside) &#123;</span><br><span class="line">    this.$refs[this.type].closeTanChuangInfo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><code>contains()</code> 方法的优点：<ol><li>原生 DOM API，性能更好</li><li>代码更简洁</li><li>浏览器兼容性好</li></ol>注意事项：<ol><li>确保传入的元素都是有效的 DOM 元素</li><li>检查元素是否存在再进行判断</li><li>考虑使用 <code>null</code> 检查避免报错</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更健壮的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isAncestor</span>(<span class="params">ancestorElement, childElement</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ancestorElement &amp;&amp; childElement &amp;&amp; ancestorElement.contains(childElement);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'判断祖先元素关系时出错:'</span>, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- Generated by SpecStory --&gt;

&lt;h1 id=&quot;使用-closest-方法判断祖先元素-2025-01-08-113833&quot;&gt;使用 closest() 方法判断祖先元素 (2025-01-08 11:38:33)&lt;/h1&gt;
Question：e.
      
    
    </summary>
    
      <category term="frontend, js, web" scheme="https://newpromise.github.io/categories/frontend-js-web/"/>
    
    
      <category term="DOM, javascript, vue" scheme="https://newpromise.github.io/tags/DOM-javascript-vue/"/>
    
  </entry>
  
  <entry>
    <title>git 中的合并策略</title>
    <link href="https://newpromise.github.io/2025/04/11/git%20%E4%B8%AD%E7%9A%84%E5%90%88%E5%B9%B6%E7%AD%96%E7%95%A5/"/>
    <id>https://newpromise.github.io/2025/04/11/git 中的合并策略/</id>
    <published>2025-04-11T02:42:48.310Z</published>
    <updated>2025-04-11T02:42:48.310Z</updated>
    
    <content type="html"><![CDATA[当我们合并两个分支的时候，Git 会帮我们自动挑选合适的合并策略，常见的 git 合并策略有 <code>Fast-forward、Recursive 、Ours、Theirs</code> 几种，不同的合并策略适用于不同的合并场景，如果想要强制指定一种合并策略，使用 <code>git merge -s &lt;策略名字&gt;</code> 命令<h4 id="fast-forward"><code>Fast-forward</code>:</h4>这种合并策略是最简单的一种，适用的场景是：合并两个没有分叉的分支，入下图所示，这个时候只是将 master 分支移动到最新的节点就好<img src="v2-e881bee3a250dd0aca96b6a11241ab78_b.jpg" loading="lazy" style="zoom:80%;"><h4 id="recursive：">Recursive：</h4>使用  recursive 进行合并的场景是合并两个有分叉的分支，这是经常使用到的一种合并策略<img src="v2-ab724ead18c6fc8ada3c10257fabf84a_b.png" loading="lazy" style="zoom:80%;">如上图所示，使用 Recursive 的合并过程是：合并中间两个节点 A， B 的时候，先找到它们两个节点的共同祖先节点，最左边的 A，然后这三个节点进行三向合并，最终得到最右边的节点 B‘Recursive 合并策略的合并算法可以总结为：<strong>递归寻找路径最短的唯一共同祖先节点，然后以其为 base 节点进行递归三向合并</strong>so，什么是三向合并就是我们了解这个合并策略最需要知道的内容<h5 id="三向合并">三向合并</h5>假如我们在两个分支上，分别修改了同一个文件，如下图所示， 当对于这两个分支进行合并的时候，那么能否合并成功呢？<img src="v2-8308f536b1986fd877fd360cbd6e9ed9_b.png" loading="lazy" style="zoom:80%;">很显然是不能的，因为 git 无法判断合并之后的文件是采用哪一个文件的代码为了判断合并之后的文件采用哪一个分支修改的代码，我们除了上面的两个文件之外，还需要一个  <code>base</code> 节点的文件，这个节点的作用是作为对比分别和两个文件进行比较：<p><img src="v2-c8ad9474d401b2f1128980911ad3d9b0_b.jpg" loading="lazy"></p>如上图所示，我们通过三个文件进行对比可以得知，在 <code>Yours</code> 分支上的代码修改了文件，因此合并之后的文件中的内容采用这个分支上修改的内容。会不会出现三个文件上相同的文件修改的内容都不相同的情况呢 ？ 会的，这种情况的出现就是我们合并中会遇到的 <strong>冲突</strong><p><img src="v2-763962194d688dad1a479d505f1d8485_b.png" loading="lazy"></p>这个时候就需要我们解决冲突才能进行合并<h5 id="寻找-base-节点">寻找 base 节点</h5>在了解了三向合并的合并策略之后，接下来我们需要关心的是：如何查找 base 节点像recursive 合并算法中描述的： <strong>递归</strong>寻找<strong>路径最短</strong>的的<strong>唯一共同</strong>祖先节点如下图：<blockquote>下面的 Git 流程图中每一个圆圈表示一次提交，圆圈里面的文字表这次提交的文件内容，如果两个圆圈内文件的内容一致，则表示两次提交文件的内容没有被修改</blockquote>我们想要合并中间的两个节点  A 和 B，找到它们共同的祖先节点 A， 以它为base节点进行三向合并得到最右边的 B 节点<img src="v2-ab724ead18c6fc8ada3c10257fabf84a_b.png" loading="lazy" style="zoom:80%;">实际情况可能比较复杂，如下图所示情况：<img src="v2-794b86a469a9acb9770b59f7551cc9dc_1440w.jpg" loading="lazy" style="zoom:60%;">我们想要合并两个节点， B 和 C，查找到 B， C 的节点发现有两个共同的祖先节点： A 和 B，这种情况下我们应该以谁作为祖先节点呢 ？在这种情况下， git 会继续递归查找，寻找 A 和 B 的共同祖先节点，将这个共同的祖先节点为base节点和 A，B进行合并， <img src="Xnip2021-03-06_15-06-03.jpg" loading="lazy" alt="image-20210306150442907" style="zoom:40%;">如上图所示，首先找到了一个合并之后的节点 <code>4/B</code>, 在根据这个节点作为 base 节点，和 节点 B C 进行三向合并<h4 id="ours--theirs">Ours &amp; Theirs</h4>使用 Ours 和 Theirs 这两种合并策略的目的是： 我们希望保留两个分支的历史记录，但是忽略掉一方的代码变更使用 Ours 和 Theirs 应用的场景相似，假如有两个分支，在这两个分支上对于同一功能进行了不同的代码实现，如果我们想要采用其中一种，但是希望另外一种代码实现也能出现在提交记录中的时候，可以执行 <code>git merge -s ours/theirs</code> 命令来实现<img src="Xnip2021-03-06_15-35-10.jpg" loading="lazy" style="zoom:40%;">如上图所示，最终只会保留 master 分支上的代码]]></content>
    
    <summary type="html">
    
      
      
        当我们合并两个分支的时候，Git 会帮我们自动挑选合适的合并策略，常见的 git 合并策略有 &lt;code&gt;Fast-forward、Recursive 、Ours、Theirs&lt;/code&gt; 几种，不同的合并策略适用于不同的合并场景，如果想要强制指定一种合并策略，使用 &lt;code
      
    
    </summary>
    
      <category term="git" scheme="https://newpromise.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://newpromise.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>defer &amp; async</title>
    <link href="https://newpromise.github.io/2025/04/10/defer%20&amp;%20async/"/>
    <id>https://newpromise.github.io/2025/04/10/defer &amp; async/</id>
    <published>2025-04-10T18:22:20.000Z</published>
    <updated>2025-04-11T02:42:48.308Z</updated>
    
    <content type="html"><![CDATA[<!-- Generated by SpecStory --><h1 id="javascript-defer-vs-async-explained-2025-04-09-172422">JavaScript Defer vs Async Explained (2025-04-09 17:24:22)</h1>Question：使用 defer 或者 async 异步下载，是新开了一个线程吗<hr>Answer：不是的,defer 和 async 并不会开启新的线程。JavaScript 是单线程的语言,这两个属性只是改变了脚本的加载和执行时序。让我来详细解释一下:<ol><li>defer 属性:</li></ol><ul><li>脚本的下载是异步的,不会阻塞 HTML 解析</li><li>脚本会等到 HTML 解析完成后,按照它们在文档中的顺序执行</li><li>在 DOMContentLoaded 事件之前执行完成</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"script.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>async 属性:</li></ol><ul><li>脚本的下载是异步的,不会阻塞 HTML 解析</li><li>脚本下载完成后立即执行,不保证执行顺序</li><li>可能在 DOMContentLoaded 事件之前或之后执行</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"script.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>它们的主要区别可以用图表示:普通脚本:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTML 解析 ----||---- HTML 解析</span><br><span class="line">              脚本下载和执行</span><br></pre></td></tr></table></figure>defer:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTML 解析 -------------------|</span><br><span class="line">脚本下载 ------|            |</span><br><span class="line">               脚本执行 ----|</span><br></pre></td></tr></table></figure>async:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTML 解析 ------------|</span><br><span class="line">脚本下载 ------|      |</span><br><span class="line">               脚本执行 --|</span><br></pre></td></tr></table></figure>这些都是在主线程上进行的,只是通过不同的调度方式来优化加载性能。如果真的需要多线程处理,需要使用 Web Workers。<hr>Question：浏览器本身可以并发请求，如果在一个页面底部加载 script 时，加不加 defer 有区别吗<hr>Answer：如果脚本标签放在页面底部(之前)，加不加 defer 实际上区别很小，因为此时 HTML 已经基本解析完成。不过还是存在一些细微差别：<ol><li>不加 defer 的情况:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- HTML 内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"script1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"script2.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>脚本会按顺序下载和执行</li><li>script1.js 必须下载并执行完成后，才会开始处理 script2.js</li><li>会阻塞 DOMContentLoaded 事件</li></ul><ol start="2"><li>加上 defer 的情况:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- HTML 内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"script1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"script2.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>脚本会并行下载</li><li>仍然按照顺序执行，但是不会互相阻塞下载</li><li>会在 DOMContentLoaded 事件之前执行</li></ul>主要区别是：<ol><li>并行下载：defer 允许多个脚本并行下载，而普通脚本是串行的</li><li>DOMContentLoaded 时机：defer 脚本会在 DOMContentLoaded 之前执行完成，而普通脚本会阻塞这个事件</li></ol>所以即使在页面底部，使用 defer 仍然可能带来一些性能优势，特别是当有多个脚本文件需要加载的时候。但如果只有一个脚本文件，差异就不明显了。建议：<ul><li>如果脚本之间有依赖关系，使用 defer 更安全，因为它保证执行顺序</li><li>如果是独立的脚本，可以考虑使用 async，执行时机更灵活</li><li>如果只有一个简单的脚本，放在底部不加 defer 也是可以的</li></ul><hr>Question：既然不加defer 的时候，脚本按顺序下载执行，那么浏览器的并发请求还有什么用呢<hr>Answer：浏览器的并发请求主要用于其他资源的并行下载，而不仅仅是脚本文件。让我解释一下：<ol><li>浏览器并发请求的应用场景：</li></ol><ul><li>图片资源 (img)</li><li>样式文件 (css)</li><li>字体文件 (font)</li><li>媒体文件 (video/audio)</li><li>XHR/Fetch 请求</li><li>其他静态资源</li></ul>例如：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style1.css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style2.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"image1.jpg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"image2.jpg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"image3.jpg"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 这些脚本会串行执行 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"script1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"script2.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>在上面的例子中：<ul><li>所有图片会并行下载</li><li>两个 CSS 文件会并行下载</li><li>但是脚本文件会串行下载和执行</li></ul><ol start="2"><li>为什么脚本要串行？</li></ol><ul><li>JavaScript 可能会修改 DOM</li><li>脚本之间可能有依赖关系</li><li>保证执行顺序的可预测性</li><li>避免竞态条件</li></ul><ol start="3"><li>现代优化方案：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 并行下载，按序执行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"script1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"script2.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 并行下载，谁先下载完谁先执行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"independent1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"independent2.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 预加载提示 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"script1.js"</span> <span class="attr">as</span>=<span class="string">"script"</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol>所以浏览器的并发请求机制主要是为了：<ol><li>优化整体页面加载性能</li><li>充分利用带宽资源</li><li>减少用户等待时间</li><li>提高资源加载效率</li></ol>而脚本的串行执行是出于程序逻辑的正确性考虑，这是两个不同层面的问题。<hr>Question：确认下js文件下载和执行都是串行的吗<hr>Answer：我需要纠正之前的说法。对于普通的 script 标签（不带 defer/async）：<ol><li><strong>下载过程</strong>：</li></ol><ul><li>下载是可以并行的</li><li>浏览器通常会限制并发连接数（通常是每个域名 6-8 个并发）</li><li>多个 script 标签的资源可以同时下载</li></ul><ol start="2"><li><strong>执行过程</strong>：</li></ol><ul><li>执行是严格串行的</li><li>必须按照 script 标签在文档中的顺序执行</li><li>一个脚本执行完成后才会执行下一个</li></ul>例如：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"big-file.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  <span class="comment">&lt;!-- 5MB, 需要10秒下载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"small-file.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> <span class="comment">&lt;!-- 1KB, 需要1秒下载 --&gt;</span></span><br></pre></td></tr></table></figure>实际过程是：<ol><li>big-file.js 和 small-file.js 会同时开始下载</li><li>small-file.js 可能先下载完成，但要等 big-file.js 下载并执行完才能执行</li><li>执行顺序一定是 big-file.js 然后是 small-file.js</li></ol>我为之前说&quot;下载是串行的&quot;这个错误表述道歉。正确的说法是：<ul><li>下载可以并行</li><li>执行必须串行</li><li>后面的脚本执行必须等待前面的脚本下载并执行完成</li></ul>这也是为什么 defer 和 async 这样的属性很有用：<ul><li>defer：并行下载，按序执行</li><li>async：并行下载，下载完就执行，不保证顺序</li></ul><hr>Question：如果是并行下载，串行执行的，那加不加 defer 还有什么区别<hr>Answer：主要区别在于 defer 改变了脚本的执行时机和 HTML 解析的阻塞行为：<ol><li><strong>不带 defer 的普通脚本</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"script1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"script2.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>并行下载脚本</li><li>遇到 script 标签时会暂停 HTML 解析</li><li>等待当前脚本下载并执行完成后，才继续解析 HTML</li><li>执行时机：立即执行（阻塞 HTML 解析）</li></ul>过程示意：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTML解析 ----||---- HTML解析 ----||---- HTML解析</span><br><span class="line">        script1下载    script1执行   script2下载    script2执行</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>带 defer 的脚本</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"script1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"script2.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>并行下载脚本</li><li>不阻塞 HTML 解析，HTML 可以继续解析</li><li>所有脚本等到 HTML 解析完成后才执行</li><li>执行时机：HTML 解析完成后，DOMContentLoaded 事件之前</li></ul>过程示意：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTML解析 --------------------------|</span><br><span class="line">script1下载 -------|              |</span><br><span class="line">script2下载 ----------|           |</span><br><span class="line">                     script1执行--|</span><br><span class="line">                     script2执行--|</span><br><span class="line">DOMContentLoaded 事件 ------------&gt;</span><br></pre></td></tr></table></figure>主要优势：<ol><li><strong>更好的性能</strong>：<ul><li>HTML 解析不被阻塞</li><li>用户可以更快看到页面内容</li><li>特别适合放在 <code>&lt;head&gt;</code> 中的脚本</li></ul></li><li><strong>更可预测的执行环境</strong>：<ul><li>确保在 DOM 完全准备好后执行</li><li>不用担心 DOM 元素是否存在</li><li>适合依赖 DOM 的脚本</li></ul></li></ol>所以即使下载都是并行的，defer 通过改变执行时机，仍然带来了明显的优势。特别是在：<ul><li>脚本放在 <code>&lt;head&gt;</code> 中时</li><li>脚本依赖 DOM 结构时</li><li>页面加载性能关键时</li></ul><hr>Question：多个加了 defer 的 script 执行顺序是什么样<hr>Answer：多个带 defer 的脚本特点是：<ul><li>并行下载</li><li>按照在 HTML 中出现的顺序执行</li><li>都在 HTML 解析完成后，DOMContentLoaded 之前执行</li></ul>例如：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"script1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> <span class="comment">&lt;!-- 5MB，需要10秒下载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"script2.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> <span class="comment">&lt;!-- 1KB，需要1秒下载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"script3.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> <span class="comment">&lt;!-- 2KB，需要2秒下载 --&gt;</span></span><br></pre></td></tr></table></figure>执行过程：<ol><li>script1.js、script2.js、script3.js 同时开始下载</li><li>虽然 script2.js 可能最先下载完成，但要等 script1.js 执行完才能执行</li><li>script3.js 必须等 script2.js 执行完才能执行</li></ol>时序示意图：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTML解析 --------------------------------|</span><br><span class="line">script1下载(10s) ----------|            |</span><br><span class="line">script2下载(1s)  -|                     |</span><br><span class="line">script3下载(2s)   --|                   |</span><br><span class="line">                     script1执行 -------|</span><br><span class="line">                     script2执行 -------|</span><br><span class="line">                     script3执行 -------|</span><br><span class="line">DOMContentLoaded 事件 -----------------&gt;</span><br></pre></td></tr></table></figure>这种行为的好处是：<ol><li>保证了脚本的执行顺序，适合有依赖关系的脚本<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"jquery.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"jquery-plugin.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  <span class="comment">&lt;!-- 依赖 jquery --&gt;</span></span><br></pre></td></tr></table></figure></li><li>比较 async 的行为：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"script1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"script2.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>async 也是并行下载</li><li>但是谁先下载完谁先执行</li><li>不保证执行顺序</li><li>适合独立的脚本（如统计代码、广告代码等）</li></ul>所以选择建议：<ul><li>有依赖关系的脚本用 defer</li><li>完全独立的脚本用 async</li><li>都不加则会阻塞 HTML 解析</li></ul><hr>Question：css 可以添加 prefetch 吗<hr>Answer：是的，CSS 文件可以使用 prefetch，而且还有其他几种预加载的方式。我来详细解释一下：<ol><li><strong>prefetch</strong>（预获取）:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"prefetch"</span> <span class="attr">href</span>=<span class="string">"styles.css"</span> <span class="attr">as</span>=<span class="string">"style"</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>低优先级加载</li><li>浏览器空闲时获取</li><li>为未来可能用到的资源做准备</li><li>适合下一个页面可能需要的资源</li></ul><ol start="2"><li><strong>preload</strong>（预加载）:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"critical.css"</span> <span class="attr">as</span>=<span class="string">"style"</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>高优先级加载</li><li>当前页面必需的资源</li><li>尽早发起请求</li><li>适合当前页面关键资源</li></ul><ol start="3"><li><strong>preconnect</strong>（预连接）:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preconnect"</span> <span class="attr">href</span>=<span class="string">"https://cdn.example.com"</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>预先建立连接</li><li>包括 DNS 查找、TCP 握手、TLS 协商</li><li>适合确定要从某个域名加载资源，但不确定具体是什么资源</li></ul><ol start="4"><li><strong>dns-prefetch</strong>（DNS预解析）:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"https://cdn.example.com"</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>仅预解析 DNS</li><li>比 preconnect 轻量</li><li>适合可能会用到的域名</li></ul>使用建议：<ol><li>当前页面关键 CSS：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"critical.css"</span> <span class="attr">as</span>=<span class="string">"style"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"critical.css"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>下一个页面可能需要的 CSS：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"prefetch"</span> <span class="attr">href</span>=<span class="string">"next-page.css"</span> <span class="attr">as</span>=<span class="string">"style"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>从 CDN 加载的 CSS：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preconnect"</span> <span class="attr">href</span>=<span class="string">"https://cdn.example.com"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.example.com/styles.css"</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol>注意事项：<ol><li>preload 的资源如果 3s 内没有被使用，浏览器控制台会警告</li><li>prefetch 的资源可能会被浏览器忽略（如移动设备或弱网环境）</li><li>不要过度预加载，会占用带宽</li><li>preload 和实际的资源引用都要写，不然资源不会被使用</li></ol>选择建议：<ul><li>当前页面必需的 CSS → preload</li><li>下一个页面可能需要的 CSS → prefetch</li><li>跨域资源 → preconnect</li><li>只需要 DNS 优化 → dns-prefetch</li></ul><hr>Question：webpack 中配置 externals 的，还会被打包吗<hr>Answer：不会，配置为 externals 的模块会被排除在打包文件之外。这些模块被认为是外部依赖，webpack 不会对其进行打包处理。举个例子：<ol><li><strong>webpack 配置</strong>:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  externals: &#123;</span><br><span class="line">    jquery: <span class="string">'jQuery'</span>,    <span class="comment">// 全局变量名</span></span><br><span class="line">    react: <span class="string">'React'</span>,</span><br><span class="line">    <span class="string">'react-dom'</span>: <span class="string">'ReactDOM'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>在代码中使用</strong>:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>;     <span class="comment">// 不会被打包</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;  <span class="comment">// 不会被打包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用这些库</span></span><br><span class="line">$(<span class="string">'#app'</span>);</span><br><span class="line">React.createElement(<span class="string">'div'</span>);</span><br></pre></td></tr></table></figure></li><li><strong>HTML 中需要手动引入</strong>:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 需要在 HTML 中手动引入这些外部依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/react@17.0.2/umd/react.production.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol>externals 的常见使用场景：<ol><li><strong>使用 CDN 资源</strong>：<ul><li>减小打包体积</li><li>利用 CDN 缓存</li><li>并行加载提升性能</li></ul></li><li><strong>避免重复打包</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  externals: &#123;</span><br><span class="line">    <span class="comment">// 对于 commonjs 模块</span></span><br><span class="line">    lodash: <span class="string">'lodash'</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对于 UMD 模块</span></span><br><span class="line">    jquery: &#123;</span><br><span class="line">      commonjs: <span class="string">'jquery'</span>,</span><br><span class="line">      commonjs2: <span class="string">'jquery'</span>,</span><br><span class="line">      amd: <span class="string">'jquery'</span>,</span><br><span class="line">      root: <span class="string">'$'</span>  <span class="comment">// 全局变量名</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>不同格式的 externals</strong>:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  externals: &#123;</span><br><span class="line">    <span class="comment">// 简单的全局变量</span></span><br><span class="line">    jquery: <span class="string">'jQuery'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象形式，指定不同模块系统</span></span><br><span class="line">    react: &#123;</span><br><span class="line">      root: <span class="string">'React'</span>,</span><br><span class="line">      commonjs2: <span class="string">'react'</span>,</span><br><span class="line">      commonjs: <span class="string">'react'</span>,</span><br><span class="line">      amd: <span class="string">'react'</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组形式</span></span><br><span class="line">    subtract: [<span class="string">'./math'</span>, <span class="string">'subtract'</span>],</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正则形式</span></span><br><span class="line">    /^(jquery|\$)$/i: <span class="string">'jquery'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>注意事项：<ol><li>externals 配置的模块必须在运行环境中可用</li><li>需要确保 HTML 中引入的版本与代码兼容</li><li>注意全局变量名的大小写</li><li>考虑模块加载顺序（如果模块间有依赖关系）</li></ol><hr>Question：网络浏览器面板中的优化级：high，highest, low, lowest ,如何在前端控制这些资源的优先级呢<hr>Answer：前端可以通过多种方式控制资源的加载优先级：<ol><li><strong>使用 <code>fetchpriority</code> 属性</strong>（最新的显式优先级控制）:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 图片优先级 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"hero.jpg"</span> <span class="attr">fetchpriority</span>=<span class="string">"high"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"lazy.jpg"</span> <span class="attr">fetchpriority</span>=<span class="string">"low"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 脚本优先级 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"critical.js"</span> <span class="attr">fetchpriority</span>=<span class="string">"high"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"non-critical.js"</span> <span class="attr">fetchpriority</span>=<span class="string">"low"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- CSS优先级 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"critical.css"</span> <span class="attr">fetchpriority</span>=<span class="string">"high"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>使用 <code>preload</code>/<code>prefetch</code> 影响优先级</strong>:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 高优先级加载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"critical.css"</span> <span class="attr">as</span>=<span class="string">"style"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"hero.jpg"</span> <span class="attr">as</span>=<span class="string">"image"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 低优先级加载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"prefetch"</span> <span class="attr">href</span>=<span class="string">"next-page.css"</span> <span class="attr">as</span>=<span class="string">"style"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>通过资源位置影响优先级</strong>:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- head中的CSS默认highest优先级 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"critical.css"</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- head中的script默认为low --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"script.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 添加async降低优先级 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"async-script.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 视口中的图片默认high优先级 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"hero.jpg"</span> /&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 延迟加载的图片low优先级 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">loading</span>=<span class="string">"lazy"</span> <span class="attr">src</span>=<span class="string">"lazy.jpg"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>使用 JavaScript 动态控制</strong>:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Fetch API 设置优先级</span></span><br><span class="line">fetch(<span class="string">'/api/data'</span>, &#123;</span><br><span class="line">  priority: <span class="string">'high'</span>  <span class="comment">// 'high' | 'low' | 'auto'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态创建元素时设置优先级</span></span><br><span class="line"><span class="keyword">const</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.fetchPriority = <span class="string">'high'</span>;</span><br><span class="line">img.src = <span class="string">'hero.jpg'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Priority Hints API</span></span><br><span class="line"><span class="keyword">const</span> hint = <span class="built_in">document</span>.createElement(<span class="string">'link'</span>);</span><br><span class="line">hint.rel = <span class="string">'preload'</span>;</span><br><span class="line">hint.as = <span class="string">'image'</span>;</span><br><span class="line">hint.href = <span class="string">'hero.jpg'</span>;</span><br><span class="line">hint.fetchPriority = <span class="string">'high'</span>;</span><br><span class="line"><span class="built_in">document</span>.head.appendChild(hint);</span><br></pre></td></tr></table></figure></li><li><strong>常见资源的默认优先级</strong>:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Highest --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span> <span class="comment">&lt;!-- 在 head 中的 CSS --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- High --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"hero.jpg"</span>&gt;</span> <span class="comment">&lt;!-- 视口内的图片 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"sync.js"</span>&gt;</span><span class="xml"> <span class="comment">&lt;!-- body 底部的同步脚本 --&gt;</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- Low --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">loading</span>=<span class="string">"lazy"</span> <span class="attr">src</span>=<span class="string">"lazy.jpg"</span>&gt;</span> <span class="comment">&lt;!-- 懒加载图片 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"async.js"</span>&gt;</span><span class="xml"> <span class="comment">&lt;!-- 异步脚本 --&gt;</span></span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- Lowest --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"prefetch"</span>&gt;</span> <span class="comment">&lt;!-- 预获取资源 --&gt;</span></span></span><br></pre></td></tr></table></figure></li></ol>最佳实践：<ol><li><strong>关键资源优先级提升</strong>:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 首屏关键资源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"critical.css"</span> <span class="attr">fetchpriority</span>=<span class="string">"high"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"hero.jpg"</span> <span class="attr">fetchpriority</span>=<span class="string">"high"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>非关键资源优先级降低</strong>:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 非关键资源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">loading</span>=<span class="string">"lazy"</span> <span class="attr">fetchpriority</span>=<span class="string">"low"</span> <span class="attr">src</span>=<span class="string">"below-fold.jpg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">fetchpriority</span>=<span class="string">"low"</span> <span class="attr">src</span>=<span class="string">"non-critical.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>组合使用不同策略</strong>:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 预连接 + 高优先级 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preconnect"</span> <span class="attr">href</span>=<span class="string">"https://cdn.example.com"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">href</span>=<span class="string">"https://cdn.example.com/style.css"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">fetchpriority</span>=<span class="string">"high"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 预加载 + 异步加载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"font.woff2"</span> <span class="attr">as</span>=<span class="string">"font"</span> <span class="attr">crossorigin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"analytics.js"</span> <span class="attr">fetchpriority</span>=<span class="string">"low"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol>注意事项：<ol><li>fetchpriority 是较新的属性，需要注意浏览器兼容性</li><li>不要过度使用高优先级，会影响整体性能</li><li>优先级设置要结合实际场景和用户体验</li><li>可以通过 Chrome DevTools 的 Network 面板观察优先级效果</li></ol><hr>Question：rel=preload 添加到 css 资源上的作用<hr>Answer：rel=&quot;preload&quot; 添加到 CSS 资源上主要用于提前声明重要的 CSS 资源，让浏览器更早地发现并下载这些资源。主要作用和使用场景如下：<ol><li><strong>基本用法</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 预加载关键 CSS --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"critical.css"</span> <span class="attr">as</span>=<span class="string">"style"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 实际使用该 CSS --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"critical.css"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>主要作用</strong>：</li></ol><ul><li>提高优先级（设置为 Highest）</li><li>提前发现资源</li><li>并行下载</li><li>不阻塞 HTML 解析</li></ul><ol start="3"><li><strong>常见使用场景</strong>：</li></ol>a. <strong>关键 CSS 预加载</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 预加载首屏关键样式 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"critical.css"</span> <span class="attr">as</span>=<span class="string">"style"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"header.css"</span> <span class="attr">as</span>=<span class="string">"style"</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 实际引用 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"critical.css"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"header.css"</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 非关键CSS可以用 prefetch --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"prefetch"</span> <span class="attr">href</span>=<span class="string">"footer.css"</span> <span class="attr">as</span>=<span class="string">"style"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>b. <strong>字体文件预加载</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">rel</span>=<span class="string">"preload"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">href</span>=<span class="string">"font.woff2"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">as</span>=<span class="string">"font"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">"font/woff2"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">crossorigin</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure>c. <strong>条件加载</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 响应式设计中的条件预加载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">rel</span>=<span class="string">"preload"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">href</span>=<span class="string">"desktop.css"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">as</span>=<span class="string">"style"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">media</span>=<span class="string">"(min-width: 768px)"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li><strong>注意事项</strong>：</li></ol>a. <strong>必须配对使用</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 错误：预加载但未使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">as</span>=<span class="string">"style"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 正确：预加载并使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">as</span>=<span class="string">"style"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span>&gt;</span></span><br></pre></td></tr></table></figure>b. <strong>避免重复加载</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 不好的实践：重复的 URL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">as</span>=<span class="string">"style"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">as</span>=<span class="string">"style"</span>&gt;</span> <span class="comment">&lt;!-- 重复！ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span>&gt;</span></span><br></pre></td></tr></table></figure>c. <strong>正确设置属性</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整的预加载声明 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">rel</span>=<span class="string">"preload"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">href</span>=<span class="string">"style.css"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">as</span>=<span class="string">"style"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">"text/css"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure><ol start="5"><li><strong>性能优化建议</strong>：</li></ol>a. <strong>组合使用预加载策略</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- DNS预解析 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"https://cdn.example.com"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 预连接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preconnect"</span> <span class="attr">href</span>=<span class="string">"https://cdn.example.com"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 预加载关键资源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"https://cdn.example.com/critical.css"</span> <span class="attr">as</span>=<span class="string">"style"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 预获取未来可能需要的资源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"prefetch"</span> <span class="attr">href</span>=<span class="string">"https://cdn.example.com/non-critical.css"</span> <span class="attr">as</span>=<span class="string">"style"</span>&gt;</span></span><br></pre></td></tr></table></figure>b. <strong>优先级控制</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 最高优先级加载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">rel</span>=<span class="string">"preload"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">href</span>=<span class="string">"critical.css"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">as</span>=<span class="string">"style"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">fetchpriority</span>=<span class="string">"high"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure>使用建议：<ol><li>只预加载当前页面必需的关键 CSS</li><li>确保预加载的资源会被使用</li><li>注意浏览器的缓存策略</li><li>监控预加载对性能的实际影响</li><li>不要过度预加载，可能会影响其他资源加载</li></ol><hr>Question：会阻塞页面吗<hr>Answer：rel=&quot;preload&quot; 本身不会阻塞页面渲染，但需要区分几种情况：<ol><li><strong>单纯的 preload</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">as</span>=<span class="string">"style"</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>不会阻塞 HTML 解析</li><li>不会阻塞页面渲染</li><li>只是提前下载资源</li></ul><ol start="2"><li><strong>preload + stylesheet</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">as</span>=<span class="string">"style"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>preload 不阻塞</li><li>但 stylesheet 仍然会阻塞渲染</li><li>CSS 仍然是渲染阻塞资源</li></ul><ol start="3"><li><strong>使用 onload 延迟应用 CSS</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 不阻塞的方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">as</span>=<span class="string">"style"</span> <span class="attr">onload</span>=<span class="string">"this.rel='stylesheet'"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">noscript</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>preload 不阻塞</li><li>CSS 在加载完成后才应用</li><li>可能造成闪烁（FOUC）</li></ul><ol start="4"><li><strong>关键 CSS 内联 + 非关键 CSS 预加载</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  /* 关键 CSS 直接内联 */</span></span><br><span class="line"><span class="undefined">  .critical &#123; color: red; &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 非关键 CSS 预加载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"non-critical.css"</span> <span class="attr">as</span>=<span class="string">"style"</span> <span class="attr">onload</span>=<span class="string">"this.rel='stylesheet'"</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>关键样式立即生效</li><li>非关键样式异步加载</li><li>最佳性能实践</li></ul>最佳实践建议：<ol><li><strong>区分关键和非关键资源</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 关键 CSS：正常加载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"critical.css"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 非关键 CSS：预加载 + 异步应用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">rel</span>=<span class="string">"preload"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">href</span>=<span class="string">"non-critical.css"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">as</span>=<span class="string">"style"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">onload</span>=<span class="string">"this.rel='stylesheet'"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>使用媒体查询优化加载</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 桌面样式延迟加载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">rel</span>=<span class="string">"preload"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">href</span>=<span class="string">"desktop.css"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">as</span>=<span class="string">"style"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">media</span>=<span class="string">"(min-width: 768px)"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">onload</span>=<span class="string">"this.rel='stylesheet'"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>配合 loadCSS 工具使用</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">// loadCSS polyfill</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">loadCSS</span>(<span class="params">href</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> preload = <span class="built_in">document</span>.createElement(<span class="string">'link'</span>);</span></span><br><span class="line"><span class="javascript">  preload.rel = <span class="string">'preload'</span>;</span></span><br><span class="line"><span class="javascript">  preload.as = <span class="string">'style'</span>;</span></span><br><span class="line"><span class="undefined">  preload.href = href;</span></span><br><span class="line"><span class="javascript">  preload.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.rel = <span class="string">'stylesheet'</span>;</span></span><br><span class="line"><span class="undefined">  &#125;;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.head.appendChild(preload);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 使用</span></span></span><br><span class="line"><span class="javascript">loadCSS(<span class="string">'style.css'</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol>总结：<ul><li>preload 本身不阻塞</li><li>但最终 CSS 应用时仍可能阻塞</li><li>需要根据场景选择合适的加载策略</li><li>关键 CSS 建议直接加载</li><li>非关键 CSS 可以预加载+异步应用</li></ul><hr>Question：cacheGroups 中的 iconfont.js 设置为 lowest<hr>Answer：在 webpack 配置中，我们可以通过 optimization.splitChunks.cacheGroups 来设置 iconfont.js 的加载优先级。这里有几种方法：<ol><li><strong>webpack 配置方式</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        iconfont: &#123;</span><br><span class="line">          test: <span class="regexp">/iconfont\.js$/</span>,</span><br><span class="line">          name: <span class="string">'iconfont'</span>,</span><br><span class="line">          chunks: <span class="string">'all'</span>,</span><br><span class="line">          priority: <span class="number">-20</span>,  <span class="comment">// 设置较低优先级</span></span><br><span class="line">          enforce: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>在 HTML 中使用 fetchpriority</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- webpack 打包后，在 HTML 模板中设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/iconfont.chunk.js"</span> <span class="attr">fetchpriority</span>=<span class="string">"low"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>结合 HTML Webpack Plugin</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'index.html'</span>,</span><br><span class="line">      scriptLoading: <span class="string">'defer'</span>,  <span class="comment">// 使用 defer</span></span><br><span class="line">      inject: <span class="literal">true</span>,</span><br><span class="line">      minify: &#123;</span><br><span class="line">        removeComments: <span class="literal">true</span>,</span><br><span class="line">        collapseWhitespace: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        iconfont: &#123;</span><br><span class="line">          test: <span class="regexp">/iconfont\.js$/</span>,</span><br><span class="line">          name: <span class="string">'iconfont'</span>,</span><br><span class="line">          chunks: <span class="string">'all'</span>,</span><br><span class="line">          priority: <span class="number">-20</span>,</span><br><span class="line">          enforce: <span class="literal">true</span>,</span><br><span class="line">          attributes: &#123;</span><br><span class="line">            fetchpriority: <span class="string">'low'</span>  <span class="comment">// 设置加载优先级</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>完整的优化配置示例</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">'all'</span>,</span><br><span class="line">      minSize: <span class="number">20000</span>,</span><br><span class="line">      minRemainingSize: <span class="number">0</span>,</span><br><span class="line">      minChunks: <span class="number">1</span>,</span><br><span class="line">      maxAsyncRequests: <span class="number">30</span>,</span><br><span class="line">      maxInitialRequests: <span class="number">30</span>,</span><br><span class="line">      enforceSizeThreshold: <span class="number">50000</span>,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        <span class="comment">// 第三方库</span></span><br><span class="line">        vendors: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          priority: <span class="number">-10</span>,</span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// iconfont 单独打包</span></span><br><span class="line">        iconfont: &#123;</span><br><span class="line">          test: <span class="regexp">/iconfont\.js$/</span>,</span><br><span class="line">          name: <span class="string">'iconfont'</span>,</span><br><span class="line">          chunks: <span class="string">'all'</span>,</span><br><span class="line">          priority: <span class="number">-20</span>,</span><br><span class="line">          enforce: <span class="literal">true</span>,</span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 默认配置</span></span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">          minChunks: <span class="number">2</span>,</span><br><span class="line">          priority: <span class="number">-30</span>,</span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>结合动态导入使用</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在代码中动态导入</span></span><br><span class="line"><span class="keyword">const</span> loadIconfont = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">import</span>(</span><br><span class="line">    <span class="comment">/* webpackChunkName: "iconfont" */</span></span><br><span class="line">    <span class="comment">/* webpackPreload: false */</span></span><br><span class="line">    <span class="string">'./iconfont.js'</span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在适当时机加载</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, () =&gt; &#123;</span><br><span class="line">  loadIconfont();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol>注意事项：<ol><li>priority 值越小，优先级越低</li><li>确保 iconfont.js 的正则匹配准确</li><li>考虑与其他缓存组的优先级关系</li><li>可以结合 preload/prefetch 策略</li><li>注意浏览器兼容性</li></ol>建议：<ol><li>如果 iconfont 不是首屏必需，可以设置为低优先级</li><li>考虑使用 CSS 的 font-display 属性优化字体加载</li><li>监控加载性能，确保优化效果</li><li>结合实际项目需求调整配置</li></ol><hr>Question：chunks: &#39;all&#39; 的意思是什么<hr>Answer：chunks: &#39;all&#39; 表示对所有类型的 chunks 都进行分割处理，包括：<ol><li><strong>三种可选值</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cacheGroups: &#123;</span><br><span class="line">  vendors: &#123;</span><br><span class="line">    chunks: <span class="string">'initial'</span>  <span class="comment">// 只处理入口 chunk</span></span><br><span class="line">    <span class="comment">// 或</span></span><br><span class="line">    chunks: <span class="string">'async'</span>    <span class="comment">// 只处理异步 chunk（按需加载的代码）</span></span><br><span class="line">    <span class="comment">// 或</span></span><br><span class="line">    chunks: <span class="string">'all'</span>      <span class="comment">// 处理所有 chunk</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>具体含义</strong>：</li></ol><ul><li><code>initial</code>: 只处理入口文件引入的模块<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入口文件</span></span><br><span class="line"><span class="keyword">import</span> jQuery <span class="keyword">from</span> <span class="string">'jquery'</span>;  <span class="comment">// 会被处理</span></span><br></pre></td></tr></table></figure></li><li><code>async</code>: 只处理动态导入的模块<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态导入</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">'./module.js'</span>).then(...);  <span class="comment">// 会被处理</span></span><br></pre></td></tr></table></figure></li><li><code>all</code>: 处理所有模块<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入口文件静态导入</span></span><br><span class="line"><span class="keyword">import</span> jQuery <span class="keyword">from</span> <span class="string">'jquery'</span>;  <span class="comment">// 会被处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态导入</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">'./module.js'</span>).then(...);  <span class="comment">// 也会被处理</span></span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><strong>实际配置示例</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        <span class="comment">// 处理所有类型的依赖</span></span><br><span class="line">        vendors: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          chunks: <span class="string">'all'</span>,</span><br><span class="line">          priority: <span class="number">-10</span></span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 只处理异步加载的组件</span></span><br><span class="line">        asyncComponents: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]components[\\/]/</span>,</span><br><span class="line">          chunks: <span class="string">'async'</span>,</span><br><span class="line">          priority: <span class="number">-20</span></span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 只处理入口依赖的样式</span></span><br><span class="line">        styles: &#123;</span><br><span class="line">          test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">          chunks: <span class="string">'initial'</span>,</span><br><span class="line">          priority: <span class="number">-30</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>使用建议</strong>：</li></ol><ul><li>通常建议使用 <code>chunks: &#39;all&#39;</code> 以获得最佳的代码分割效果</li><li>特定场景可能需要其他选项：<ul><li>只想分割异步加载的代码时使用 <code>async</code></li><li>只想分割入口依赖时使用 <code>initial</code></li></ul></li><li>配合其他选项使用会更有效：<ul><li>minSize（最小尺寸）</li><li>minChunks（最小引用次数）</li><li>maxAsyncRequests（最大异步请求数）</li><li>maxInitialRequests（最大初始请求数）</li></ul></li></ul><hr>Question：vue 中页面开始加载是在 js 哪个事件之后进行的<hr>Answer：在 Vue 中，页面加载涉及几个关键的生命周期事件，主要顺序如下：<ol><li><strong>创建阶段</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  beforeCreate() &#123;</span><br><span class="line">    <span class="comment">// 1. 实例初始化之后，数据观测和事件配置之前</span></span><br><span class="line">    <span class="comment">// 此时 data、methods 等还不可用</span></span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="comment">// 2. 实例创建完成后</span></span><br><span class="line">    <span class="comment">// 可以访问 data、computed、methods 等</span></span><br><span class="line">    <span class="comment">// 但还没有挂载 DOM，$el 不可用</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeMount() &#123;</span><br><span class="line">    <span class="comment">// 3. 挂载开始之前被调用</span></span><br><span class="line">    <span class="comment">// 相关的 render 函数首次被调用</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="comment">// 4. 挂载完成，DOM 已经渲染</span></span><br><span class="line">    <span class="comment">// 可以访问 DOM 元素</span></span><br><span class="line">    <span class="comment">// 这里开始真正的页面加载</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><strong>实际使用示例</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="comment">// 适合做数据初始化</span></span><br><span class="line">    <span class="keyword">this</span>.fetchInitialData();</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="comment">// DOM 已经可用，开始加载页面内容</span></span><br><span class="line">    <span class="keyword">this</span>.initPage();</span><br><span class="line">    <span class="keyword">this</span>.loadComponents();</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    fetchInitialData() &#123;</span><br><span class="line">      <span class="comment">// API 调用等</span></span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    initPage() &#123;</span><br><span class="line">      <span class="comment">// DOM 操作</span></span><br><span class="line">      <span class="comment">// 第三方库初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>异步组件加载</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="comment">// 异步组件</span></span><br><span class="line">    AsyncComponent: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./AsyncComponent.vue'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="comment">// 主页面已加载，但异步组件可能还在加载中</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>路由组件加载</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./views/Home.vue'</span>),</span><br><span class="line">      beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 路由级别的加载控制</span></span><br><span class="line">        next();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><strong>完整的加载流程控制</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      isLoading: <span class="literal">true</span>,</span><br><span class="line">      loadError: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> created() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 数据预加载</span></span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">this</span>.fetchInitialData();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">this</span>.loadError = error;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> mounted() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// DOM 相关初始化</span></span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">this</span>.initComponents();</span><br><span class="line">      <span class="keyword">this</span>.isLoading = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">this</span>.loadError = error;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="keyword">async</span> fetchInitialData() &#123;</span><br><span class="line">      <span class="comment">// API 调用</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> initComponents() &#123;</span><br><span class="line">      <span class="comment">// 组件初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>性能优化建议</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="comment">// 关键数据优先加载</span></span><br><span class="line">    <span class="keyword">this</span>.loadCriticalData();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非关键数据延迟加载</span></span><br><span class="line">    <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.loadNonCriticalData();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="comment">// DOM 操作放在 mounted 中</span></span><br><span class="line">    <span class="keyword">this</span>.initUI();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 延迟加载非关键组件</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.loadDeferredComponents();</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>总结：<ol><li>页面实际加载从 mounted 开始</li><li>created 适合做数据准备</li><li>mounted 适合做 DOM 操作</li><li>可以利用异步和延迟加载优化性能</li><li>考虑使用加载状态管理用户体验</li></ol><hr>Question：是在页面加载完成之后，即 window.onload 结束之后吗<hr>Answer：不是的，Vue 的生命周期和 window.onload 是独立的事件。Vue 的 mounted 钩子通常会在 window.onload 之前触发。让我解释一下它们的关系：<ol><li><strong>执行顺序</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue 实例</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Vue mounted'</span>);  <span class="comment">// 1. 先执行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// window 事件</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'DOMContentLoaded'</span>);  <span class="comment">// 2. 然后是这个</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Window loaded'</span>);  <span class="comment">// 3. 最后是这个</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><strong>区别</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="comment">// Vue mounted: DOM 已渲染，但外部资源可能还没加载完</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'DOM 已渲染'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'图片可能还在加载中'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// window.onload: 所有资源都加载完成</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'所有资源加载完成'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'包括图片、样式、脚本等'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><strong>实际应用示例</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="comment">// Vue 已挂载，可以操作 DOM</span></span><br><span class="line">    <span class="keyword">this</span>.initUI();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 但如果需要等待所有资源</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.initAfterFullLoad();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    initUI() &#123;</span><br><span class="line">      <span class="comment">// 可以进行 DOM 操作</span></span><br><span class="line">      <span class="comment">// 但外部资源可能还没准备好</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    initAfterFullLoad() &#123;</span><br><span class="line">      <span class="comment">// 所有资源都已加载完成</span></span><br><span class="line">      <span class="comment">// 可以安全地使用依赖外部资源的功能</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>最佳实践</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      isFullyLoaded: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="comment">// 立即需要的初始化</span></span><br><span class="line">    <span class="keyword">this</span>.initCriticalFeatures();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听完整加载</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.isFullyLoaded = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">this</span>.initNonCriticalFeatures();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听图片加载</span></span><br><span class="line">    <span class="keyword">const</span> images = <span class="built_in">document</span>.querySelectorAll(<span class="string">'img'</span>);</span><br><span class="line">    images.forEach(<span class="function"><span class="params">img</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (img.complete) &#123;</span><br><span class="line">        <span class="keyword">this</span>.handleImageLoad(img);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        img.addEventListener(<span class="string">'load'</span>, () =&gt; &#123;</span><br><span class="line">          <span class="keyword">this</span>.handleImageLoad(img);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    initCriticalFeatures() &#123;</span><br><span class="line">      <span class="comment">// 关键功能初始化</span></span><br><span class="line">      <span class="comment">// 不依赖外部资源的操作</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    initNonCriticalFeatures() &#123;</span><br><span class="line">      <span class="comment">// 非关键功能初始化</span></span><br><span class="line">      <span class="comment">// 依赖完整加载的操作</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    handleImageLoad(img) &#123;</span><br><span class="line">      <span class="comment">// 处理单个图片加载完成</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>性能优化建议</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="comment">// 分阶段初始化</span></span><br><span class="line">    <span class="keyword">this</span>.initPhase1();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 requestAnimationFrame 延迟非关键初始化</span></span><br><span class="line">    requestAnimationFrame(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.initPhase2();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 load 事件处理最终初始化</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.initPhase3();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    initPhase1() &#123;</span><br><span class="line">      <span class="comment">// 立即需要的功能</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    initPhase2() &#123;</span><br><span class="line">      <span class="comment">// 可以稍微延迟的功能</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    initPhase3() &#123;</span><br><span class="line">      <span class="comment">// 所有资源加载后的功能</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>总结：<ol><li>Vue mounted 在 window.onload 之前触发</li><li>mounted 时 DOM 已渲染，但外部资源可能未加载完</li><li>window.onload 表示所有资源都加载完成</li><li>根据需求选择合适的初始化时机</li><li>可以组合使用不同事件实现最佳性能</li></ol><hr>Question：是在 DCL 之后 vue 开始渲染吗<hr>Answer：是的，Vue 的渲染是在 DOMContentLoaded (DCL) 事件之后开始的。让我详细解释一下这个过程：<ol><li><strong>典型的加载顺序</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1. DCL'</span>);  <span class="comment">// 首先触发</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  beforeCreate() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2. Vue beforeCreate'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3. Vue created'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4. Vue beforeMount'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'5. Vue mounted'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'6. Window load'</span>);  <span class="comment">// 最后触发</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><strong>实际执行流程</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- Vue 模板 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 1. 解析 HTML</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 2. 触发 DOMContentLoaded</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 3. Vue 开始初始化和渲染</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 4. 外部资源继续加载</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 5. 触发 window.load</span></span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>生命周期与事件的关系</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听各个阶段</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'readystatechange'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">document</span>.readyState);</span><br><span class="line">  <span class="comment">// loading -&gt; interactive(DCL) -&gt; complete(load)</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'DOM 准备就绪'</span>);</span><br><span class="line">  <span class="comment">// Vue 将在这之后开始工作</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Vue 渲染完成'</span>);</span><br><span class="line">    <span class="comment">// DOM 已经更新</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><strong>实际应用示例</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完整的初始化流程</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// DOM 已准备好，可以初始化 Vue</span></span><br><span class="line">  initVueApp();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initVueApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      isReady: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    created() &#123;</span><br><span class="line">      <span class="comment">// 数据初始化</span></span><br><span class="line">      <span class="keyword">this</span>.initData();</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    mounted() &#123;</span><br><span class="line">      <span class="comment">// DOM 操作</span></span><br><span class="line">      <span class="keyword">this</span>.isReady = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).$mount(<span class="string">'#app'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>性能优化建议</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分阶段加载</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 1. 核心功能初始化</span></span><br><span class="line">  initCoreFeatures();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. Vue 初始化</span></span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="comment">// ...配置</span></span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3. 延迟加载非关键功能</span></span><br><span class="line">  requestIdleCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    initNonCriticalFeatures();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 完整加载后的操作</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, () =&gt; &#123;</span><br><span class="line">  initAfterFullLoad();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><strong>常见的加载优化模式</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 关键资源预加载</span></span><br><span class="line">&lt;link rel=<span class="string">"preload"</span> href=<span class="string">"vue.js"</span> <span class="keyword">as</span>=<span class="string">"script"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 非关键组件异步加载</span></span><br><span class="line">components: &#123;</span><br><span class="line">  <span class="string">'heavy-component'</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./HeavyComponent.vue'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 条件渲染等待 DOM 准备</span></span><br><span class="line">&lt;div v-<span class="keyword">if</span>=<span class="string">"isDomReady"</span>&gt;</span><br><span class="line">  &lt;!-- 需要 DOM 准备好的内容 --&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure></li></ol>总结：<ol><li>DCL 事件触发表示 DOM 准备就绪</li><li>Vue 在 DCL 之后开始初始化和渲染</li><li>Vue 的生命周期钩子在 DCL 和 load 之间执行</li><li>可以利用这个顺序来优化加载性能</li><li>考虑使用分阶段加载策略</li></ol>注意事项：<ul><li>DCL 只保证 DOM 准备好，不包括外部资源</li><li>Vue 渲染可能在外部资源加载完成之前</li><li>需要考虑资源依赖关系进行优化</li></ul><hr>Question：如果body底部有 script 加载，那么DCL 触发是在 script 加载之前还是之后<hr>Answer：对于位于 body 底部的 script，分几种情况：<ol><li><strong>普通 script</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 普通脚本 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"large-script.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- DCL 会等这个脚本下载和执行完才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>async script</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- async 脚本不阻塞 DCL --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"analytics.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- DCL 不会等待 async 脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>defer script</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- defer 脚本不阻塞 DCL --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"non-critical.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- DCL 不会等待 defer 脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>混合情况</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 会阻塞 DCL --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"critical.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 不会阻塞 DCL --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"non-critical.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"analytics.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// DCL 触发顺序示意</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'DCL'</span>);  <span class="comment">// 在 critical.js 之后，其他可能在之前或之后</span></span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol>总结：<ol><li>普通 script：DCL 在脚本加载和执行之后触发</li><li>async script：DCL 不等待这类脚本</li><li>defer script：DCL 不等待这类脚本</li><li>内联脚本：DCL 等待执行完成</li></ol>最佳实践：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 页面内容 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 关键脚本：阻塞 DCL --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 非关键脚本：不阻塞 DCL --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"analytics.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"non-critical.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 初始化代码 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 这里的代码会在 vue.js 加载完后执行</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 且 DCL 会等待这段代码执行完</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// ...</span></span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><hr>Question：@index.html 页面中的这种情况，DCL 是在script加载之前触发吗<hr>Answer：让我分析一下这个 index.html 中的脚本加载情况：<ol><li><strong>head 中的脚本</strong>（会阻塞 DCL）：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- CDN js --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"&lt;%= htmlWebpackPlugin.options.cdn.js[i].href %&gt;"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- jQuery --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//zxxkstatic.zxxk.com/xkwjs/lib/jquery-1.10.2.js?v=0.0128"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 阿里播放器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://g.alicdn.com/de/prismplayer/2.8.2/aliplayer-min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>body 底部的脚本</strong>（都使用了 async，不会阻塞 DCL）：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"https://downloadnew.zxxk.com/risk-control-dialog/control-iframe-dialog.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"//zxxkstatic.zxxk.com/ued/common/xep/xep.js?v=1.0.0"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"//zxxkstatic.zxxk.com/xkwjs/xkw.element-monitor.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"//zxxkstatic.zxxk.com/Common/Scripts/searchlog/jquery-search-log.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol>在这种情况下：<ol><li>DCL 会等待 head 中的普通脚本加载和执行完成</li><li>但不会等待 body 底部的 async 脚本</li><li>DCL 触发顺序：<ul><li>head 中的脚本加载完成</li><li>DOM 解析完成</li><li>DCL 触发</li><li>async 脚本在某个时间点加载完成并执行</li></ul></li></ol>所以对于这个页面：<ul><li>DCL 会在 body 底部那些 async 脚本加载之前触发</li><li>但会等待 head 中的普通脚本加载完成</li></ul>建议优化：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- head 中非关键脚本也可以使用 defer --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"//zxxkstatic.zxxk.com/xkwjs/lib/jquery-1.10.2.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 或者使用 preload 提前加载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"//zxxkstatic.zxxk.com/xkwjs/lib/jquery-1.10.2.js"</span> <span class="attr">as</span>=<span class="string">"script"</span>&gt;</span></span><br></pre></td></tr></table></figure>这样可以让 DCL 更早触发，提升页面性能。<hr>Question：这个项目是一个 vue 项目，如果vue组件中存在使用 jquery 的情况，还能加 defer 吗<hr>Answer：<hr>将 jQuery 加上 defer 在 Vue 项目中可能会有问题，特别是当组件直接依赖 jQuery 时。分析这种情况的依赖关系：<ol><li><strong>当前加载顺序</strong>:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery加载 -&gt; HTML解析 -&gt; DCL触发 -&gt; Vue初始化 -&gt; 组件渲染</span><br></pre></td></tr></table></figure></li><li><strong>如果给 jQuery 加 defer</strong>:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTML解析 -&gt; DCL触发 -&gt; Vue初始化/jQuery加载(并行) -&gt; 组件渲染</span><br></pre></td></tr></table></figure></li></ol>可能出现的问题：<ul><li>jQuery 可能在 Vue 组件初始化时还未加载完成</li><li>组件中的 <code>$</code> 会是 <code>undefined</code></li><li>导致 <code>$ is not defined</code> 错误</li></ul>几种可能的解决方案：<ol><li><strong>不使用 defer，但考虑 preload</strong>:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 预加载但不延迟执行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"//zxxkstatic.zxxk.com/xkwjs/lib/jquery-1.10.2.js"</span> <span class="attr">as</span>=<span class="string">"script"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//zxxkstatic.zxxk.com/xkwjs/lib/jquery-1.10.2.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>使用 Webpack 的 externals 并改变引入方式</strong>:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  externals: &#123;</span><br><span class="line">    jquery: <span class="string">'jQuery'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件中</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">const</span> $ = <span class="built_in">window</span>.jQuery;</span><br></pre></td></tr></table></figure></li><li><strong>条件检查 jQuery 可用性</strong>:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="comment">// 确保 jQuery 已加载</span></span><br><span class="line">    <span class="keyword">const</span> checkJQuery = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">window</span>.jQuery) &#123;</span><br><span class="line">        <span class="keyword">this</span>.initWithJQuery();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setTimeout(checkJQuery, <span class="number">50</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    checkJQuery();</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    initWithJQuery() &#123;</span><br><span class="line">      <span class="comment">// 使用 jQuery 的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>结论：<ul><li>如果组件直接依赖 jQuery，不建议给 jQuery 添加 defer</li><li>可以通过其他方式优化（如 preload）</li><li>或者重构代码减少对 jQuery 的依赖</li><li>最好的做法是在 Vue 项目中减少对 jQuery 的直接使用</li></ul><hr>Question：可以将外部引用的 css 文件放到底部吗<hr>Answer：<hr>将 CSS 放到底部<strong>不是推荐的做法</strong>，这可能会导致严重的用户体验问题。原因如下：<ol><li><strong>会导致无样式闪烁(FOUC)</strong>:<ul><li>页面会先以无样式方式渲染</li><li>然后突然应用样式</li><li>造成视觉跳动和闪烁</li></ul></li><li><strong>导致布局偏移(CLS)</strong>:<ul><li>内容先以默认样式布局</li><li>CSS 加载后重新布局</li><li>这是 Google Core Web Vitals 中的负面指标</li></ul></li></ol>更好的替代方案：<ol><li><strong>关键CSS内联 + 非关键CSS异步加载</strong>:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 关键CSS内联 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    /* 关键首屏样式 */</span></span><br><span class="line"><span class="undefined">    body &#123; font-family: sans-serif; margin: 0; &#125;</span></span><br><span class="line"><span class="undefined">    header &#123; /* 样式... */ &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 非关键CSS异步加载 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"styles.css"</span> <span class="attr">as</span>=<span class="string">"style"</span> <span class="attr">onload</span>=<span class="string">"this.rel='stylesheet'"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">noscript</span>&gt;</span><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"styles.css"</span>&gt;</span><span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>使用 media 属性延迟非关键样式</strong>:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 关键样式立即加载 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"critical.css"</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 印刷样式延迟加载 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"print.css"</span> <span class="attr">media</span>=<span class="string">"print"</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 桌面样式延迟加载(手机上) --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"desktop.css"</span> <span class="attr">media</span>=<span class="string">"(min-width: 1024px)"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>使用工具提取关键CSS</strong>:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 使用工具如 Critical, CriticalCSS, Penthouse 等</span><br><span class="line">// 自动提取首屏关键CSS</span><br></pre></td></tr></table></figure></li></ol>如果一定要将部分 CSS 放在底部（不推荐），可以使用 JavaScript 动态加载：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 在 DOMContentLoaded 后加载非关键CSS</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">'link'</span>);</span></span><br><span class="line"><span class="javascript">    link.rel = <span class="string">'stylesheet'</span>;</span></span><br><span class="line"><span class="javascript">    link.href = <span class="string">'non-critical.css'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.appendChild(link);</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>最佳实践总结：<ol><li>关键 CSS 放在 <code>&lt;head&gt;</code> 中</li><li>使用预加载、延迟加载等技术优化非关键 CSS</li><li>避免将所有 CSS 放到底部</li><li>考虑使用现代工具提取和优化 CSS</li></ol><hr>Question：使用 preload 进行异步加载，异步体现在哪个地方<hr>Answer：<hr><code>preload</code> 的异步特性主要体现在几个方面：<ol><li><strong>并行下载不阻塞渲染</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">as</span>=<span class="string">"style"</span> <span class="attr">onload</span>=<span class="string">"this.rel='stylesheet'"</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>浏览器会在解析到这行代码时立即开始下载资源</li><li>但不会阻塞 HTML 解析和页面渲染</li><li>页面可以继续加载，同时 CSS 在后台下载</li></ul><ol start="2"><li><strong>应用与下载分离</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 下载过程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">as</span>=<span class="string">"style"</span> <span class="attr">onload</span>=<span class="string">"this.rel='stylesheet'"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 或者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"script.js"</span> <span class="attr">as</span>=<span class="string">"script"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 应用过程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"script.js"</span> <span class="attr">defer</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>资源的下载和应用是分开的两个步骤</li><li>资源可以在不被使用的情况下提前下载</li></ul><ol start="3"><li><strong>不阻塞 DOMContentLoaded 事件</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"large-file.css"</span> <span class="attr">as</span>=<span class="string">"style"</span> <span class="attr">onload</span>=<span class="string">"this.rel='stylesheet'"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'DCL fired!'</span>); <span class="comment">// 不会等待 preload 完成</span></span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>即使大型 CSS 文件还在下载中，DCL 事件也会触发</li><li>允许基于 DCL 的脚本更早执行</li></ul><ol start="4"><li><strong>手动控制应用时机</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">as</span>=<span class="string">"style"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 通过 JS 控制应用时机</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> link = <span class="built_in">document</span>.createElement(<span class="string">'link'</span>);</span></span><br><span class="line"><span class="javascript">    link.rel = <span class="string">'stylesheet'</span>;</span></span><br><span class="line"><span class="javascript">    link.href = <span class="string">'style.css'</span>; <span class="comment">// 已经被预加载</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.head.appendChild(link);</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>开发者可以精确控制资源的应用时机</li><li>资源已经在缓存中，应用时不需要再下载</li></ul><ol start="5"><li><strong>示例：异步应用 CSS</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 关键CSS内联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  /* 最基本的样式 */</span></span><br><span class="line"><span class="undefined">  body &#123; margin: 0; font-family: sans-serif; &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 异步加载其他CSS --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"full-styles.css"</span> <span class="attr">as</span>=<span class="string">"style"</span> <span class="attr">onload</span>=<span class="string">"this.rel='stylesheet'"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">noscript</span>&gt;</span><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"full-styles.css"</span>&gt;</span><span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>页面会首先使用内联的基本样式渲染</li><li>完整样式异步加载，完成后自动应用</li><li>用户可以看到基本内容，而不必等待所有样式</li></ul>总结：preload 的异步性主要体现在下载过程与渲染流程的解耦，以及资源获取与应用的分离，这使得页面加载更高效，用户体验更流畅;]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- Generated by SpecStory --&gt;

&lt;h1 id=&quot;javascript-defer-vs-async-explained-2025-04-09-172422&quot;&gt;JavaScript Defer vs Async Explained (2025-04
      
    
    </summary>
    
      <category term="js, java, frontend, backend" scheme="https://newpromise.github.io/categories/js-java-frontend-backend/"/>
    
    
      <category term="javascript, js, node, npm, vue, react, webpack, ts, java, go, html, css, api" scheme="https://newpromise.github.io/tags/javascript-js-node-npm-vue-react-webpack-ts-java-go-html-css-api/"/>
    
  </entry>
  
  <entry>
    <title>前缀树原理与实现</title>
    <link href="https://newpromise.github.io/2025/04/10/%E5%89%8D%E7%BC%80%E6%A0%91%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>https://newpromise.github.io/2025/04/10/前缀树原理与实现/</id>
    <published>2025-04-10T00:00:00.000Z</published>
    <updated>2025-04-11T02:42:48.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前缀树原理与实现-2025-04-10-153349">前缀树原理与实现 (2025-04-10 15:33:49)</h1><em><strong>User</strong></em>什么是前缀树，原理讲解，用 js 实现，什么情况下使用<hr><em><strong>Assistant</strong></em><hr><h1 id="前缀树-trie">前缀树 (Trie)</h1><h2 id="什么是前缀树">什么是前缀树</h2>前缀树（Trie），也称为字典树，是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。与二叉查找树不同，前缀树中的键不是直接存储在节点中，而是由从根到节点的路径所决定。<h2 id="原理">原理</h2>前缀树的基本原理包括：<ol><li>根节点不包含字符，除根节点外的每个节点都只包含一个字符</li><li>从根节点到某一节点的路径上的字符连接起来，即为该节点对应的字符串</li><li>每个节点的所有子节点包含的字符都不相同</li><li>通常在节点中设置一个标志，用于标记该节点处是否构成一个完整的单词</li></ol>前缀树最大的优势在于查询和插入的效率，时间复杂度为 O(m)，其中 m 是键的长度。<h2 id="javascript-实现">JavaScript 实现</h2>下面是一个基本的前缀树 JavaScript 实现：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义前缀树节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.children = &#123;&#125;; <span class="comment">// 子节点映射</span></span><br><span class="line">    <span class="keyword">this</span>.isEndOfWord = <span class="literal">false</span>; <span class="comment">// 标记是否是单词结尾</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前缀树类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode(); <span class="comment">// 根节点</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入单词</span></span><br><span class="line">  insert(word) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="keyword">this</span>.root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; word.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> char = word[i];</span><br><span class="line">      <span class="comment">// 如果当前字符不存在于子节点中，创建新节点</span></span><br><span class="line">      <span class="keyword">if</span> (!current.children[char]) &#123;</span><br><span class="line">        current.children[char] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 移动到下一个节点</span></span><br><span class="line">      current = current.children[char];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 标记单词结尾</span></span><br><span class="line">    current.isEndOfWord = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 搜索单词</span></span><br><span class="line">  search(word) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="keyword">this</span>.root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; word.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> char = word[i];</span><br><span class="line">      <span class="comment">// 如果当前字符不存在于子节点中，单词不存在</span></span><br><span class="line">      <span class="keyword">if</span> (!current.children[char]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 移动到下一个节点</span></span><br><span class="line">      current = current.children[char];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只有当节点被标记为单词结尾时，才表示单词存在</span></span><br><span class="line">    <span class="keyword">return</span> current.isEndOfWord;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查是否有以指定前缀开头的单词</span></span><br><span class="line">  startsWith(prefix) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="keyword">this</span>.root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prefix.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> char = prefix[i];</span><br><span class="line">      <span class="comment">// 如果当前字符不存在于子节点中，前缀不存在</span></span><br><span class="line">      <span class="keyword">if</span> (!current.children[char]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 移动到下一个节点</span></span><br><span class="line">      current = current.children[char];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到前缀</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">const</span> trie = <span class="keyword">new</span> Trie();</span><br><span class="line">trie.insert(<span class="string">"苹果"</span>);</span><br><span class="line">trie.insert(<span class="string">"香蕉"</span>);</span><br><span class="line">trie.insert(<span class="string">"苹"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(trie.search(<span class="string">"苹果"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(trie.search(<span class="string">"苹"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(trie.search(<span class="string">"橙子"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(trie.startsWith(<span class="string">"苹"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(trie.startsWith(<span class="string">"香"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(trie.startsWith(<span class="string">"梨"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="使用场景">使用场景</h2>前缀树适用于以下场景：<ol><li><strong>自动补全功能</strong>：当用户输入部分文字时，系统可以快速找出所有以该前缀开头的单词</li><li><strong>拼写检查</strong>：可以快速检查单词是否正确拼写</li><li><strong>IP路由表</strong>：用于存储和查找IP地址</li><li><strong>字典查找</strong>：高效实现字典功能，特别是对于前缀搜索</li><li><strong>文本压缩</strong>：某些压缩算法使用前缀树来优化</li><li><strong>搜索引擎</strong>：用于实现搜索关键词的快速匹配</li><li><strong>数据库索引</strong>：某些场景下可作为索引结构</li></ol>相比于哈希表等其他数据结构，前缀树在处理字符串前缀相关的操作时效率更高，且能够按字典序遍历所有键。当您需要频繁进行前缀查询或按字典序访问数据时，前缀树是一个很好的选择。<hr><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前缀树原理与实现-2025-04-10-153349&quot;&gt;前缀树原理与实现 (2025-04-10 15:33:49)&lt;/h1&gt;
&lt;em&gt;&lt;strong&gt;User&lt;/strong&gt;&lt;/em&gt;什么是前缀树，原理讲解，用 js 实现，什么情况下使用&lt;hr&gt;
&lt;em&gt;&lt;s
      
    
    </summary>
    
      <category term="算法" scheme="https://newpromise.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://newpromise.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>git 中的数据存储</title>
    <link href="https://newpromise.github.io/2021/03/04/git%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    <id>https://newpromise.github.io/2021/03/04/git 中的数据存储/</id>
    <published>2021-03-04T09:42:33.886Z</published>
    <updated>2021-03-04T09:42:33.886Z</updated>
    
    <content type="html"><![CDATA[<h3 id="版本控制系统">版本控制系统</h3>代码版本控制系统大致可以分为三代：<h4 id="本地版本控制系统">本地版本控制系统</h4>代码存储在本地，无法实现多人协作的需求<h4 id="集中化的版本控制系统">集中化的版本控制系统</h4>解决了多人协作的问题，但是因为代码都是统一存储在服务器上，当无法连接服务器上的时候，无法查看日志和提交比较代码<h4 id="分布式的版本控制系统">分布式的版本控制系统</h4>这种控制系统的特点是，任何人都可以复制一份和服务上相同的代码，当无法连接服务器的时候，仍然可以提交代码，创建分支<h3 id="git-中文件夹-git">Git 中文件夹 .git</h3>当我们使用 <code>git init </code> 初始化<code>git</code> 仓库的时候，当前文件夹下出生成一个 <code>.git</code>  的隐藏文件夹，这个文件夹内存储着我们进行 git 操作的一些数据：<ul><li>存储当前的分支（<code>HEAD</code>）</li><li>存储当前所有的分支信息（<code>config</code>）</li><li>存储提交的文件快照数据（<code>objects</code>）</li><li>....</li></ul><h3 id="三种基本文件">三种基本文件</h3>当我们输入一些git命令的时候，git 根据的输入的命令会生成一些文件，有的文件用来存储当前提交的文件内容，有的文件用来存储我们当前提交的信息，这些文件都被存储在 <code>objects</code> 这个文件夹之内，有三种基本文件在我们使用 git 进行数据存储时是息息相关的：<ul><li><code>blob</code> 文件</li><li><code>tree</code> 文件</li><li><code>commit</code> 文件</li></ul><h4 id="blob-文件"><code>blob</code> 文件</h4>blob 文件用来存储我们提交代码的文件快照，这种文件存储的是压缩后的文件内容代码实践下 blob 文件是如何生成的：<ol><li>git 初始化：</li></ol><img src="image-20210303164432105.png" loading="lazy" alt="image-20210303164432105" style="zoom:50%;"><ol start="2"><li>初始化的 git 仓库内创建两个文件: <code>1.txt</code> 与 <code>2.txt</code>, 内容分别是 1 和 2</li><li>执行 <code>git add</code>：</li></ol><img src="image-20210303164241534.png" loading="lazy" alt="image-20210303164241534" style="zoom:50%;"><ol start="4"><li>查看出现的 <code>d8</code> 和 <code>56</code> 这两个文件夹</li></ol><img src="image-20210303164846117.png" loading="lazy" alt="image-20210303164846117" style="zoom:50%;">​     如图，发现是乱码的形式，这是因为 Git 将信息压缩成了二进制，对于这种文件，使用 <code>git cat-file [-t][-p]</code> 来查看文件类型或者    文件内容<img src="image-20210303165312098.png" loading="lazy" alt="image-20210303165312098" style="zoom:50%;">​    <img src="image-20210303165323101.png" loading="lazy" alt="image-20210303165323101" style="zoom:50%;">可以看到，使用 <code>git add</code> 命令生成的 <code>56</code> 和 <code>d8</code> 文件都是 <code>blob</code> 类型文件，并且存储的是文件的内容<h4 id="tree-文件"><code>tree</code> 文件</h4>继续上面的操作，这次执行 <code>git commit </code> 命令：<img src="image-20210303170500072.png" loading="lazy" alt="image-20210303170500072" style="zoom:50%;">查看 <code>objects</code> 文件：<img src="image-20210303170606368.png" loading="lazy" alt="image-20210303170606368" style="zoom:50%;">相比之前多出了两个文件夹：<code>3c</code> 和 <code>96</code> 查看 <code>3c</code> 文件夹​                                                        <img src="image-20210303170851619.png" loading="lazy" alt="image-20210303170851619" style="zoom:50%;">​    可以看到， 3c 文件夹下的文件存储的内容为我们这次 commit 修改的两个文件 1.txt 和 2.txt ，除了文件名之外，还保存有此次修改的blob文件的文件名以及文件类型3c文件夹下的文件类型为 tree, 这种文件存储的信息是当前提交的文件目录<h4 id="commit-文件"><code>commit</code> 文件</h4>查看生成的 <code>96</code> 文件夹，我们可以看到如下内容：<img src="image-20210303171533671.png" loading="lazy" alt="image-20210303171533671" style="zoom:50%;"><img src="image-20210303171612008.png" loading="lazy" alt="image-20210303171612008" style="zoom:50%;">96 文件夹下的文件类型为 commit 文件， 存储的内容是本次 commit 的信息: 提交人，提交信息（git test）等，其中还存储了 tree 文件的文件名，除了这些信息之外， 还存储有上一次提交的 commit 文件（父点），因为我们这里是初次提交，没有上一次提交，因此没有父节点<h4 id="三种文件之间的关系">三种文件之间的关系</h4>综上所述，三种类型的文件的主要作用是：blob：存储提交文件的快照tree：存储提交文件的文件目录以及文件名，blob 文件地址等信息commit： 存储提交信息，提交生成的 tree 文件用一张图可以说明三种类型文件之间的关系：<img src="image-20210303171943546.png" loading="lazy" alt="image-20210303171943546" style="zoom:33%;"><h4 id="总结">总结</h4><ul><li> 使用 <code>git add .</code> 命令时，将变动内容的文件保存生成 blob 文件</li><li>使用 <code>git commit</code> 命令时， 生成 tree 文件与 commit 文件</li><li>当前分支的指针指向新的 commit 节点，节点中存在 parent 字段，表明上一次提交 commit 文件，逐级向上，一直到第一次提交，这些 commit 连接成为提交记录（<code>git log</code>）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;版本控制系统&quot;&gt;版本控制系统&lt;/h3&gt;
代码版本控制系统大致可以分为三代：&lt;h4 id=&quot;本地版本控制系统&quot;&gt;本地版本控制系统&lt;/h4&gt;
代码存储在本地，无法实现多人协作的需求&lt;h4 id=&quot;集中化的版本控制系统&quot;&gt;集中化的版本控制系统&lt;/h4&gt;
解决了多人协作的
      
    
    </summary>
    
      <category term="git" scheme="https://newpromise.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://newpromise.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝</title>
    <link href="https://newpromise.github.io/2021/03/03/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>https://newpromise.github.io/2021/03/03/深拷贝/</id>
    <published>2021-03-03T10:09:11.273Z</published>
    <updated>2021-03-04T03:35:48.341Z</updated>
    
    <content type="html"><![CDATA[深拷贝和浅拷贝的区别：<code>浅拷贝</code> : 当对于一个对象进行浅拷贝的时候，会创建一个新的对象，新对象包含有旧对象的所有属性，当属性值为基本类型时，拷贝的就是这个基本类型的值，当属性值为引用类型的时候，拷贝的是这个引用类型的内存地址<code>深拷贝</code>：将一个对象从内存中完整的拷贝出来，开辟一个新的区域存储新对象，并且修改新对象不会影响旧对象<h3 id="实现深拷贝">实现深拷贝</h3><ul><li>使用 <code>JSON.parse(JSON.stringify())</code>这种最简单的实现深拷贝的方法同时存在许多的缺点<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  date: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">  nan: <span class="literal">NaN</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>: <span class="title">new</span> <span class="title">Function</span>(<span class="params"></span>),</span></span><br><span class="line"><span class="function">  <span class="title">undefined</span>: <span class="title">undefined</span>,</span></span><br><span class="line"><span class="function">  <span class="title">regexp</span>: <span class="title">new</span> <span class="title">RegExp</span>(<span class="params"><span class="string">'\\w+'</span></span>),</span></span><br><span class="line"><span class="function">  <span class="title">symbol</span>: <span class="title">Symbol</span>(<span class="params"><span class="string">'symbol'</span></span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cloneObj = deepClone(obj)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cloneObj)</span><br><span class="line"><span class="comment">// 打印结果如下</span></span><br><span class="line">&#123; <span class="attr">date</span>: <span class="string">'2021-02-26T07:22:37.173Z'</span>, <span class="attr">nan</span>: <span class="literal">null</span>, <span class="attr">regexp</span>: &#123;&#125; &#125;</span><br></pre></td></tr></table></figure>使用这种方法进行深拷贝的时候，对于上面一些特殊的属性值，会出现拷贝异常的情况：<ul><li><code>undefined</code>, <code>symbol</code>, <code>函数</code> 会被忽略掉</li><li><code>NaN</code> 会被转换为 <code>null</code></li><li><code>regexp</code> 会被转换为 空对象</li><li><code>date</code> 对象会被转换为日期字符串</li></ul>同时，无法拷贝循环引用的对象</li><li>一种 <code>cloneDeep</code> 的方法：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> value === <span class="string">'object'</span> &amp;&amp; value !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> isArray = <span class="built_in">Array</span>.isArray(value)</span><br><span class="line">    <span class="keyword">let</span> result = isArray ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (isArray) &#123;</span><br><span class="line">      value.forEach(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        result.push(cloneDeep(val))</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> value) &#123;</span><br><span class="line">        result[k] = cloneDeep(value[k])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="lodash-中的-clonedeep-方法"><code>lodash</code> 中的 <code>cloneDeep</code> 方法</h3><h4 id="入口">入口</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> baseClone <span class="keyword">from</span> <span class="string">'./.internal/baseClone.js'</span></span><br><span class="line"><span class="keyword">const</span> CLONE_DEEP_FLAG = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> CLONE_SYMBOLS_FLAG = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>入口调用  <code>baseClone</code> 文件中的 <code>baseClone</code> 方法，向这个方法中传入了两个数据：<code>value</code>: 要进行复制的数据<code>CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG</code>:  掩码，表明使用 <code>baseClone</code> 来进行深拷贝以及 <code>symbol</code> 数据类型的拷贝<h4 id="baseclone"><code>baseClone</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The base implementation of `clone` and `cloneDeep` which tracks</span></span><br><span class="line"><span class="comment"> * traversed objects.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>value 需要克隆的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>bitmask 掩码标识</span></span><br><span class="line"><span class="comment"> *  1 - Deep clone</span></span><br><span class="line"><span class="comment"> *  2 - Flatten inherited properties</span></span><br><span class="line"><span class="comment"> *  4 - Clone symbols</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>[customizer] 定制 clone 的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>[key] value 的属性 key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>[object] 值的父对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>[stack] 用来追踪遍历的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;*&#125;</span> </span>Returns the cloned value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseClone</span>(<span class="params">value, bitmask, customizer, key, object, stack</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result</span><br><span class="line">  <span class="comment">// 三种克隆的配置值</span></span><br><span class="line">  <span class="keyword">const</span> isDeep = bitmask &amp; CLONE_DEEP_FLAG</span><br><span class="line">  <span class="keyword">const</span> isFlat = bitmask &amp; CLONE_FLAT_FLAG</span><br><span class="line">  <span class="keyword">const</span> isFull = bitmask &amp; CLONE_SYMBOLS_FLAG</span><br><span class="line">  <span class="comment">// 使用定制化的 clone 方法</span></span><br><span class="line">  <span class="keyword">if</span> (customizer) &#123;</span><br><span class="line">    result = object ? customizer(value, key, object, stack) : customizer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定制化的 clone 方法执行之后，返回结果</span></span><br><span class="line">  <span class="keyword">if</span> (result !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当非 引用类型的时候，返回值</span></span><br><span class="line">  <span class="keyword">if</span> (!isObject(value)) &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> isArr = <span class="built_in">Array</span>.isArray(value)</span><br><span class="line">  <span class="comment">// 获取当前数据的类型</span></span><br><span class="line">  <span class="keyword">const</span> tag = getTag(value)</span><br><span class="line">  <span class="keyword">if</span> (isArr) &#123;</span><br><span class="line">    <span class="comment">// 初始化 clone 数组</span></span><br><span class="line">    result = initCloneArray(value)</span><br><span class="line">    <span class="keyword">if</span> (!isDeep) &#123;</span><br><span class="line">      <span class="keyword">return</span> copyArray(value, result)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> isFunc = <span class="keyword">typeof</span> value === <span class="string">'function'</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当 value 是一种 buffer 数据的时候</span></span><br><span class="line">    <span class="keyword">if</span> (isBuffer(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> cloneBuffer(value, isDeep)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当当前的数据类型为 对象，参数对象，函数的时候</span></span><br><span class="line">    <span class="keyword">if</span> (tag == objectTag || tag == argsTag || (isFunc &amp;&amp; !object)) &#123;</span><br><span class="line">      <span class="comment">// 当是一个函数的时候，初始化为一个空对象，否则，调用 initCloneObject</span></span><br><span class="line">      result = (isFlat || isFunc) ? &#123;&#125; : initCloneObject(value)</span><br><span class="line">      <span class="keyword">if</span> (!isDeep) &#123;</span><br><span class="line">        <span class="keyword">return</span> isFlat</span><br><span class="line">          ? copySymbolsIn(value, copyObject(value, keysIn(value), result))</span><br><span class="line">          : copySymbols(value, <span class="built_in">Object</span>.assign(result, value))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 对于 typeof value === 'object' 但是 调用 `getTag` 方法并不是严格对象的值的处理</span></span><br><span class="line">      <span class="comment">// 例如：let n = new Number()</span></span><br><span class="line">      <span class="comment">// typeof n === 'number' but Object.prototype.toString.call(n) === '[object Number]'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isFunc || !cloneableTags[tag]) &#123;</span><br><span class="line">        <span class="keyword">return</span> object ? value : &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      result = initCloneByTag(value, tag, isDeep)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Check for circular references and return its corresponding clone.</span></span><br><span class="line">  <span class="comment">// 创建一个 Stack 的数据结果</span></span><br><span class="line">  <span class="comment">// 使用 stack 目的可以检查循环引用，返回对应的 clone 数据</span></span><br><span class="line">  stack || (stack = <span class="keyword">new</span> Stack)</span><br><span class="line">  <span class="keyword">const</span> stacked = stack.get(value)</span><br><span class="line">  <span class="keyword">if</span> (stacked) &#123;</span><br><span class="line">    <span class="keyword">return</span> stacked</span><br><span class="line">  &#125;</span><br><span class="line">  stack.set(value, result)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当当前数据为 map 结构的时候</span></span><br><span class="line">  <span class="comment">// result 为 map 数据</span></span><br><span class="line">  <span class="keyword">if</span> (tag == mapTag) &#123;</span><br><span class="line">    value.forEach(<span class="function">(<span class="params">subValue, key</span>) =&gt;</span> &#123;</span><br><span class="line">      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当 当前数据为。set 数据的时候</span></span><br><span class="line">  <span class="keyword">if</span> (tag == setTag) &#123;</span><br><span class="line">    value.forEach(<span class="function">(<span class="params">subValue</span>) =&gt;</span> &#123;</span><br><span class="line">      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isTypedArray(value)) &#123;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="keyword">const</span> keysFunc = isFull</span><br><span class="line">    ? (isFlat ? getAllKeysIn : getAllKeys)</span><br><span class="line">    : (isFlat ? keysIn : keys)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> props = isArr ? <span class="literal">undefined</span> : keysFunc(value)</span><br><span class="line">  arrayEach(props || value, (subValue, key) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (props) &#123;</span><br><span class="line">      key = subValue</span><br><span class="line">      subValue = value[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Recursively populate clone (susceptible to call stack limits).</span></span><br><span class="line">    <span class="comment">// 递归式的 clone</span></span><br><span class="line">    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack))</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> baseClone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="gettag"><code>getTag</code></h6><code>getTag</code> 方法用来获取元素的类型<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toString = <span class="built_in">Object</span>.prototype.toString</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets the `toStringTag` of `value`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>value The value to query.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;string&#125;</span> </span>Returns the `toStringTag`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTag</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value === <span class="literal">undefined</span> ? <span class="string">'[object Undefined]'</span> : <span class="string">'[object Null]'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> toString.call(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> getTag</span><br></pre></td></tr></table></figure><h6 id="initcloneobject"><code>initCloneObject</code></h6><code>initCloneObject</code> 用来初始化克隆对象：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// object 用来初始化克隆的对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initCloneObject</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当 object 为非原型对象的时候，返回一个对象，这个对象的继承 obj 的原型</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">typeof</span> object.constructor === <span class="string">'function'</span> &amp;&amp; !isPrototype(object))</span><br><span class="line">    ? <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(object))</span><br><span class="line">    : &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> initCloneObject</span><br></pre></td></tr></table></figure><h6 id="isprototype"><code>isPrototype</code></h6>判断 <code>value</code> 是否为原型，如果是，返回 <code>true</code>对于 <code>原型</code> 对象上面包含有 <code>constructor</code> 属性<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> objectProto = <span class="built_in">Object</span>.prototype</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Checks if `value` is likely a prototype object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>value The value to check.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;boolean&#125;</span> </span>Returns `true` if `value` is a prototype, else `false`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrototype</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Ctor = value &amp;&amp; value.constructor</span><br><span class="line">  <span class="keyword">const</span> proto = (<span class="keyword">typeof</span> Ctor === <span class="string">'function'</span> &amp;&amp; Ctor.prototype) || objectProto</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> value === proto</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>对于边界条件的处理：如果仅仅按照下面的代码进行判断是有问题的： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrototype</span>(<span class="params">vlaue</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> Ctor = value &amp;&amp; value.constructor</span><br><span class="line">  <span class="keyword">const</span> proto = (<span class="keyword">typeof</span> Ctor === <span class="string">'function'</span> &amp;&amp; Ctor.prototype)</span><br><span class="line">  <span class="keyword">return</span> value === proto</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>如果我们传入一个 <code>false</code>,  <code>isPrototype</code> 返回的结果为 <code>true</code>, 与结果不符合，因此设置 一个 objectProto 来防止这种情况]]></content>
    
    <summary type="html">
    
      
      
        深拷贝和浅拷贝的区别：&lt;code&gt;浅拷贝&lt;/code&gt; : 当对于一个对象进行浅拷贝的时候，会创建一个新的对象，新对象包含有旧对象的所有属性，当属性值为基本类型时，拷贝的就是这个基本类型的值，当属性值为引用类型的时候，拷贝的是这个引用类型的内存地址&lt;code&gt;深拷贝&lt;/code&gt;
      
    
    </summary>
    
      <category term="js" scheme="https://newpromise.github.io/categories/js/"/>
    
    
      <category term="深拷贝" scheme="https://newpromise.github.io/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>协商缓存和强缓存</title>
    <link href="https://newpromise.github.io/2020/09/26/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E5%92%8C%E5%BC%BA%E7%BC%93%E5%AD%98/"/>
    <id>https://newpromise.github.io/2020/09/26/协商缓存和强缓存/</id>
    <published>2020-09-26T04:15:09.000Z</published>
    <updated>2021-03-04T07:57:54.780Z</updated>
    
    <content type="html"><![CDATA[缓存是指代理服务器或者客户端本地磁盘内保存的资源副本。使用缓存可以减少对于源服务器的访问，从而节省通信流量和通信时间。在服务器与客户端的通信过程中，对于数据的缓存方式可以分为 <strong>强缓存</strong> 和 <strong>协商缓存</strong> 两种，通过http请求头中的 <code>Cache-Control</code> 可以决定是否采用上面两种方式缓存涉及到的相关字段有：<code>Cache-Control</code>  <code>Expires</code>  <code>Last-Modified</code> <code>If-Modified-Since</code> <code>Etag</code>  <code>If-None-Match</code><h3 id="强缓存">强缓存</h3>强缓存就是当客户端发起请求之前，首先检查浏览器缓存中是否有要请求的内容，并且根据结果的缓存规则来判断是否实际向服务器发起请求客户端发起请求时，会有下面三种结果：<ol><li>没有缓存结果，那么需要向服务器请求内容</li><li>存在缓存结果，并且缓存规则未失效，那么直接使用缓存的内容</li><li>存在缓存结果，但缓存规则已经失效，那么也需要重新向服务器请求内容，效果同 1</li></ol>使用请求返回头中的：<code>Cache-Control</code> 字段来配置缓存的行为：<ul><li><code>public</code>:  可以向任意方提供响应的缓存，发送请求的客户端或者代理服务器都可以缓存数据</li><li><code>private</code>: 只有浏览器才能缓存内容</li><li><code>no-cache</code>: 强制所有缓存了该响应的用户，在使用已经缓存的数据前，发送带有验证的请求到服务器，需要等待服务器确认之后，才能使用浏览器缓存</li><li><code>no-store</code>: 不进行缓存，每次请求都需要向服务器重新请求数据</li><li><code>max-age</code>: 指定资源的缓存时间，在客户端请求头中添加时，表示如果缓存资源的缓存时间数值比设置的 <code>max-age</code> 的数值小的话，那么客户端就接收缓存的资源当服务器响应头中添加时，表示当前返回的资源内容在浏览器中的最大缓存时间，在没有禁用缓存并且没有超过有效时间的情况下，再次访问这个资源就命中了缓存，不会向服务器请求资源而是直接从浏览器缓存中取。</li></ul><h3 id="协商缓存">协商缓存</h3>协商缓存就是当强制缓存失效后，客户端和服务器根据请求头或者响应头的相关字段来判断是否采用浏览器缓存的资源，因为有可能客户端请求的资源过了有效期，但是此时资源内容和服务器上的资源没有差别，仍然可以使用浏览器缓存资源来避免再次请求服务器资源协商缓存是由服务器来决定是否使用缓存的因此关键是：<strong>如何判断服务器上的资源和浏览器上缓存的资源是不是相同的</strong>，下面的两种方式分别是根据文件修改时间和文件唯一标识来判断的，两种方式：<ul><li><strong>Last-modified/If-Modified-Since</strong>这两个字段是一种时间戳的形式字符串服务器响应头中带有： Last-modified 表示资源最后被修改的时间，当客户端再次请求相同资源时，在请求头中添加 <code>If-Modified-Since</code> 字段为上次请求资源时服务器返回的资源最后修改时间，服务器收到请求之后，会将 <code>If-Modified-Since</code> 的时间与  <code>Last-modified</code> 进行对比，如果不一致，则重新请求资源，如果一致，那么使用浏览器缓存的资源（304）</li><li><strong>Etag/If-None-Match</strong>这两个值都是请求当前资源文件的唯一标识，这个标识是由服务器生成的类似于上面的过程，<code>Etag</code> 由服务器返回，<code>If-None-Match</code> 是再次请求资源时添加在请求头中的字段，值是上次请求时返回头中返回的 <code>Etag</code> 字段的值，在服务器中，根据 <code>If-None-Match</code>的字段值与该资源在服务器的Etag值做对比，如果不一致，重新请求资源，如果一致，同样使用浏览器缓存资源（304）</li></ul><blockquote>在 http 中，状态码 304 （Not Modified）返回的内容为空，因为这个时候表示当前请求的资源和服务器上的资源一致，可以直接使用浏览器缓存的内容</blockquote><h3 id="总结">总结</h3>概括来说：<strong>强缓存</strong>是直接使用浏览器内缓存的内容，使用到的字段有：<strong>Expires</strong> 或者 <strong>Cache-Control: max-age=3600</strong> (表示资源的缓存时间是 3600 s)<strong>协商缓存</strong>是需要服务器参与确认是否使用浏览器缓存的内容的机制，应用在强缓存失效之后这个过程可以用下面的示意图来说明：<img src="1.png" loading="lazy"><img src="/2020/09/26/协商缓存和强缓存/1.png">]]></content>
    
    <summary type="html">
    
      
      
        缓存是指代理服务器或者客户端本地磁盘内保存的资源副本。使用缓存可以减少对于源服务器的访问，从而节省通信流量和通信时间。在服务器与客户端的通信过程中，对于数据的缓存方式可以分为 &lt;strong&gt;强缓存&lt;/strong&gt; 和 &lt;strong&gt;协商缓存&lt;/strong&gt; 两种，通过ht
      
    
    </summary>
    
      <category term="http" scheme="https://newpromise.github.io/categories/http/"/>
    
    
      <category term="缓存" scheme="https://newpromise.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>axios + vue 实现页面销毁时请求取消</title>
    <link href="https://newpromise.github.io/2020/09/22/axios%20+%20vue%20%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E9%94%80%E6%AF%81%E6%97%B6%E8%AF%B7%E6%B1%82%E5%8F%96%E6%B6%88/"/>
    <id>https://newpromise.github.io/2020/09/22/axios + vue 实现页面销毁时请求取消/</id>
    <published>2020-09-22T13:28:39.000Z</published>
    <updated>2021-03-03T10:09:11.236Z</updated>
    
    <content type="html"><![CDATA[在日常的开发中，会遇到这样的需求：我们想要当离开当前页面的时候， 这个页面上的请求的接口不会继续请求使用 <code>vue</code> + <code>axios</code> 来实现手动取消请求的功能：代码如下：<code>cancelRequest.js</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(axiosIns, cancelList) &#123;</span><br><span class="line">    <span class="keyword">this</span>.axiosIns = axiosIns</span><br><span class="line">    <span class="keyword">this</span>.cancelList = cancelList || []</span><br><span class="line">    <span class="keyword">const</span> handlersCount = <span class="keyword">this</span>.getAllHandlers().length</span><br><span class="line">    <span class="keyword">this</span>.handlerIndex = handlersCount ? handlersCount - <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">    <span class="keyword">this</span>.insertInterceptors = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  getCancelKeys() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.cancelList.map(<span class="function">(<span class="params">&#123; key &#125;</span>) =&gt;</span> key)</span><br><span class="line">  &#125;</span><br><span class="line">  hasKey(key) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getCancelKeys().includes(key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span>(cancelKey) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.cancelList.find(<span class="function">(<span class="params">&#123; key &#125;</span>) =&gt;</span> cancelKey === key)</span><br><span class="line">  &#125;</span><br><span class="line">  getAllHandlers() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.cancelList.reduce(<span class="function">(<span class="params">allHandlers, &#123; handlerList &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      allHandlers = [...allHandlers, ...handlerList]</span><br><span class="line">      <span class="keyword">return</span> allHandlers</span><br><span class="line">    &#125;, [])</span><br><span class="line">  &#125;</span><br><span class="line">  getHandlers(cancelKey) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.hasKey(cancelKey)) &#123;</span><br><span class="line">      <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.get(cancelKey).handlerList</span><br><span class="line">  &#125;</span><br><span class="line">  removeInsertInterceptors() &#123;</span><br><span class="line">    <span class="keyword">const</span> interceptors = <span class="keyword">this</span>.axiosIns.interceptors</span><br><span class="line">    <span class="built_in">Object</span>.entries(<span class="keyword">this</span>.insertInterceptors).forEach(<span class="function">(<span class="params">[type, incpts]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> handlers = interceptors[type].handlers</span><br><span class="line">      incpts.forEach(<span class="function"><span class="params">interceptor</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> incptIndex = handlers.indexOf(interceptor)</span><br><span class="line">        <span class="keyword">if</span> (incptIndex !== <span class="number">-1</span>) &#123;</span><br><span class="line">          interceptors[type].handlers.splice(incptIndex, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.insertInterceptors = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  removeHandler(removeKey, handlerIndex) &#123;</span><br><span class="line">    <span class="keyword">const</span> handlerList = <span class="keyword">this</span>.getHandlers(removeKey)</span><br><span class="line">    handlerList.length &amp;&amp; handlerList.splice(handlerIndex, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (!handlerList.length) &#123;</span><br><span class="line">      <span class="keyword">this</span>.remove(removeKey)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  remove(key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.hasKey(key)) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">const</span> keyIndex = <span class="keyword">this</span>.getCancelKeys().indexOf(key)</span><br><span class="line">    <span class="keyword">this</span>.cancelList.splice(keyIndex, <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  cancel(key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> handlerList = <span class="keyword">this</span>.getHandlers(key)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; handlerList.length; i++) &#123;</span><br><span class="line">        handlerList[i]()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.remove(key)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> handlerList = <span class="keyword">this</span>.getAllHandlers()</span><br><span class="line">      handlerList.forEach(<span class="function"><span class="params">handler</span> =&gt;</span> handler())</span><br><span class="line">      <span class="keyword">this</span>.cancelList = []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  add(cancelObj) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; key, handler &#125; = cancelObj</span><br><span class="line">    <span class="keyword">this</span>.handlerIndex++</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.hasKey(key)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.cancelList.push(&#123; key, <span class="attr">handlerList</span>: [handler] &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> existHandlers = <span class="keyword">this</span>.getHandlers(key)</span><br><span class="line">      <span class="keyword">this</span>.get(key).handlerList = [...existHandlers, handler]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CancelRequest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(config) &#123;</span><br><span class="line">    <span class="keyword">const</span> defaultConfig = &#123;</span><br><span class="line">      vm: <span class="literal">null</span>,</span><br><span class="line">      includes: []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.config = <span class="built_in">Object</span>.assign(&#123;&#125;, defaultConfig, config)</span><br><span class="line">    <span class="keyword">this</span>.cancelReqCollectorList = []</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.config.vm) &#123;</span><br><span class="line">      <span class="keyword">this</span>._vmDestroyedCancel()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(<span class="string">'config vm is null, request will not be canceld when component destroyed'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  getAllAxiosInstance() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.cancelReqCollectorList.map(<span class="function">(<span class="params">&#123; axiosIns &#125;</span>) =&gt;</span> axiosIns)</span><br><span class="line">  &#125;</span><br><span class="line">  getCollector(instance) &#123;</span><br><span class="line">    <span class="keyword">let</span> existCollector = <span class="keyword">this</span>.cancelReqCollectorList.find(<span class="function">(<span class="params">&#123; axiosIns &#125;</span>) =&gt;</span> axiosIns === instance)</span><br><span class="line">    <span class="keyword">if</span> (!existCollector) &#123;</span><br><span class="line">      existCollector = <span class="keyword">new</span> Collector(instance)</span><br><span class="line">      <span class="keyword">this</span>.cancelReqCollectorList.push(existCollector)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> existCollector</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 拦截 vue 中的 _isDestroyed 属性， 当组件销毁时，取消请求</span></span><br><span class="line">  _vmDestroyedCancel() &#123;</span><br><span class="line">    <span class="keyword">let</span> isDestroyed = <span class="keyword">this</span>.config.vm._isDestroyed</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>.config.vm, <span class="string">'_isDestroyed'</span>, &#123;</span><br><span class="line">      <span class="keyword">set</span>: val =&gt; &#123;</span><br><span class="line">        isDestroyed = val</span><br><span class="line">        <span class="keyword">if</span> (val) <span class="keyword">this</span>.cancel(<span class="literal">true</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> isDestroyed</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  getTokenKey(config) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; baseURL, url &#125; = config</span><br><span class="line">    <span class="keyword">if</span> (url.startsWith(<span class="string">'http'</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> url</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;baseURL&#125;</span><span class="subst">$&#123;url&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">  getSource() &#123;</span><br><span class="line">    <span class="keyword">const</span> cancelToken = axios.CancelToken</span><br><span class="line">    <span class="keyword">let</span> source = cancelToken.source()</span><br><span class="line">    <span class="keyword">return</span> source</span><br><span class="line">  &#125;</span><br><span class="line">  insertInterceptor(interceptors, collector) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; request, response &#125; = interceptors</span><br><span class="line">    <span class="keyword">const</span> requestInt = &#123;</span><br><span class="line">      fulfilled: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> setKey = <span class="keyword">this</span>.getTokenKey(config)</span><br><span class="line">        <span class="keyword">const</span> source = <span class="keyword">this</span>.getSource()</span><br><span class="line">        <span class="keyword">const</span> isValidIncludes = <span class="built_in">Array</span>.isArray(<span class="keyword">this</span>.config.includes) &amp;&amp; <span class="keyword">this</span>.config.includes.length</span><br><span class="line">        <span class="keyword">const</span> isMatch = isValidIncludes &amp;&amp; <span class="keyword">this</span>.config.includes.some(<span class="function"><span class="params">includeKey</span> =&gt;</span> setKey.includes(includeKey))</span><br><span class="line">        <span class="keyword">if</span> (!isValidIncludes || isMatch) &#123;</span><br><span class="line">          config.cancelToken = source.token</span><br><span class="line">          collector.add(&#123; <span class="attr">key</span>: setKey, <span class="attr">handler</span>: source.cancel &#125;)</span><br><span class="line">          config.cancelHandlerIndex = collector.handlerIndex</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config</span><br><span class="line">      &#125;,</span><br><span class="line">      rejected: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> successRespInt = &#123;</span><br><span class="line">      fulfilled: <span class="function"><span class="params">resp</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> handlerIndex = resp.config.cancelHandlerIndex</span><br><span class="line">        <span class="keyword">const</span> removeKey = <span class="keyword">this</span>.getTokenKey(resp.config)</span><br><span class="line">        collector.remove(removeKey, handlerIndex)</span><br><span class="line">        <span class="keyword">return</span> resp</span><br><span class="line">      &#125;,</span><br><span class="line">      rejected: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> errorRespInt = &#123;</span><br><span class="line">      fulfilled: <span class="literal">null</span>,</span><br><span class="line">      rejected: <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> isCancel = axios.isCancel(error)</span><br><span class="line">        <span class="keyword">if</span> (!isCancel) &#123;</span><br><span class="line">          <span class="keyword">const</span> handlerIndex = error.config.cancelHandlerIndex</span><br><span class="line">          collector.remove(<span class="keyword">this</span>.getTokenKey(error.config), handlerIndex)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    collector.insertInterceptors = &#123;</span><br><span class="line">      request: [requestInt],</span><br><span class="line">      response: [successRespInt, errorRespInt]</span><br><span class="line">    &#125;</span><br><span class="line">    request.handlers.unshift(requestInt)</span><br><span class="line">    response.handlers.unshift(successRespInt, errorRespInt)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向 axios 实例中注入token</span></span><br><span class="line">  insertToken(axiosInstance) &#123;</span><br><span class="line">    <span class="keyword">const</span> collector = <span class="keyword">this</span>.getCollector(axiosInstance)</span><br><span class="line">    <span class="keyword">const</span> interceptors = axiosInstance.interceptors</span><br><span class="line">    <span class="keyword">this</span>.insertInterceptor(interceptors, collector)</span><br><span class="line">    <span class="keyword">return</span> collector</span><br><span class="line">  &#125;</span><br><span class="line">  cancel(isDestroyed) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cancelReqCollectorList.forEach(<span class="function"><span class="params">collector</span> =&gt;</span> &#123;</span><br><span class="line">      collector.cancel()</span><br><span class="line">      <span class="keyword">if</span> (isDestroyed) &#123;</span><br><span class="line">        collector.removeInsertInterceptors()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (isDestroyed) &#123;</span><br><span class="line">      <span class="keyword">this</span>.cancelReqCollectorList = []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> CancelRequest</span><br></pre></td></tr></table></figure>使用方法如下：在组件中<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http = axios.create()</span><br><span class="line"><span class="comment">// this 为当前组件对象</span></span><br><span class="line"><span class="comment">// 在使用 http 来请求时，调用下面的方法</span></span><br><span class="line"><span class="keyword">const</span> cancelRes = <span class="keyword">new</span> CancelRequest(&#123; <span class="attr">vm</span>: <span class="keyword">this</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> cancelCollector = cancelRes.insertToken(http)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当需要取消请求时：</span></span><br><span class="line"><span class="comment">// 使用 cancel 方法来取消使用 http axios 实例来发起的请求</span></span><br><span class="line">cancelCollector.cancel() </span><br><span class="line"><span class="comment">// 或者传入配置 vm: this 时</span></span><br><span class="line"><span class="comment">// 当当前页面销毁时，会自动将当前页面正在发起的请求 cancel 掉</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        在日常的开发中，会遇到这样的需求：我们想要当离开当前页面的时候， 这个页面上的请求的接口不会继续请求使用 &lt;code&gt;vue&lt;/code&gt; + &lt;code&gt;axios&lt;/code&gt; 来实现手动取消请求的功能：代码如下：&lt;code&gt;cancelRequest.js&lt;/code&gt;&lt;f
      
    
    </summary>
    
      <category term="代码" scheme="https://newpromise.github.io/categories/%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="cancel request" scheme="https://newpromise.github.io/tags/cancel-request/"/>
    
  </entry>
  
  <entry>
    <title>排序算法（一）（选择，插入，冒泡，归并，快速）</title>
    <link href="https://newpromise.github.io/2020/09/20/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%88%E9%80%89%E6%8B%A9%EF%BC%8C%E6%8F%92%E5%85%A5%EF%BC%8C%E5%86%92%E6%B3%A1%EF%BC%8C%E5%BD%92%E5%B9%B6%EF%BC%8C%E5%BF%AB%E9%80%9F%EF%BC%89/"/>
    <id>https://newpromise.github.io/2020/09/20/排序算法（一）（选择，插入，冒泡，归并，快速）/</id>
    <published>2020-09-20T13:13:09.000Z</published>
    <updated>2021-03-04T07:34:47.845Z</updated>
    
    <content type="html"><![CDATA[下面是选择排序，插入排序，冒泡排序，归并排序，快速排序五种算法的原理以及具体的代码实现<h3 id="选择排序">选择排序</h3><ol><li>从数组中选取一个元素 item，初次为第一个元素</li><li>在 item 剩余的元素中找到最小的元素</li><li>将这个最小的元素与 item 交换位置</li><li>重复 1，2， 3的过程，一直到数组结束</li></ol>示意图如下<img src="1.png" loading="lazy">代码如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">let</span> minIdx = i;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[i];</span><br><span class="line">        <span class="comment">// 从剩余的元素中查找到最小的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.length; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIdx]) &#123;</span><br><span class="line">                minIdx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = arr[minIdx];</span><br><span class="line">        arr[minIdx] = temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序">插入排序</h3><ol><li>从数组中的第二个元素开始抽取元素 item</li><li>将 item 与 item 左边第一个元素进行比较，如果左边的元素大于item，那么继续与左边第二个元素继续比较，直到遇到不大于item 的元素，然后将这个元素插入到 item 的右边</li><li>继续选取第 3， 4， 5 个元素， 重复 2 过程， 直到数组结束</li></ol>示意图如下<img src="2.png" loading="lazy">代码如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">let</span> k = i;</span><br><span class="line">        <span class="keyword">let</span> item = arr[i]</span><br><span class="line">        <span class="keyword">while</span> (k &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            k --;</span><br><span class="line">            <span class="comment">// 当找到比当前要插入的元素小的元素时</span></span><br><span class="line">            <span class="comment">// 将插入元素插入到小元素的右边</span></span><br><span class="line">            <span class="comment">// 或者 k &lt; 0 时，这个时候表示找到最左边</span></span><br><span class="line">            <span class="comment">// 都没有找到比 arr[i] 还要小的元素</span></span><br><span class="line">            <span class="keyword">if</span> (item &gt; arr[k] || k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                arr[k + <span class="number">1</span>] = item;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 整体向右边移</span></span><br><span class="line">                arr[k + <span class="number">1</span>] = arr[k]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序">冒泡排序</h3><ol><li>将第一个元素与第二个元素进行比较，如果第一个元素比第二个大，那么交换他们的位置，接着继续比较第二个元素和第三个元素</li><li>经过一轮比较之后，现在最右边的元素是数组里面最大的元素</li><li>除去最右边已经筛选后的元素之后，再对剩余的元素执行 1 过程</li></ol>示意图如下<img src="3.png" loading="lazy">代码如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr, sortedIndex = arr.length - <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> nextIdx = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; arr[nextIdx]) &#123;</span><br><span class="line">            <span class="keyword">let</span> temp = arr[i]</span><br><span class="line">            arr[i] = arr[nextIdx]</span><br><span class="line">            arr[nextIdx] = temp</span><br><span class="line">        &#125;</span><br><span class="line">        i ++</span><br><span class="line">    &#125;</span><br><span class="line">    sortedIndex --</span><br><span class="line">    <span class="keyword">return</span>  sortedIndex === <span class="number">0</span> ? arr : bubbleSort(arr, sortedIndex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序">归并排序</h3><ol><li>将大数组拆分为小数组，再拆分小数组，一直拆分到数组内只有一个元素</li><li>对于小数组内的元素进行排序操作，然后将小数组进行组合</li><li>最后组合的大数组为已经排好序的数组</li></ol>示意图如下：<img src="4.png" loading="lazy">代码如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">arr, left, mid, right</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(right - left + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> i = left;</span><br><span class="line"><span class="keyword">let</span> j = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 将两个数组进行组合</span></span><br><span class="line">  <span class="comment">// 这两个数组分别为 arr[left, ... mid] 以及 arr[mid + 1, ... right]</span></span><br><span class="line"><span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">a[k++] = arr[i++]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">a[k++] = arr[j++]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当还有剩余的 i 数组元素时</span></span><br><span class="line">  <span class="comment">// 压入数组中</span></span><br><span class="line"><span class="keyword">while</span>(i &lt;= mid) &#123;</span><br><span class="line">a[k++] = a[i++]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当还有剩余的 j 数组元素时</span></span><br><span class="line">  <span class="comment">// 同样压入数组中</span></span><br><span class="line"><span class="keyword">while</span>(j &lt;= right) &#123;</span><br><span class="line">a[k++] = a[j++]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将排好序的 a 数组复制到 arr 中</span></span><br><span class="line">  <span class="comment">// 这里的数组 a 已经排好序了</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; k; i ++) &#123;</span><br><span class="line">arr[left ++] = a[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left !== right) &#123;</span><br><span class="line"><span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((right + left) / <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 对于左边的元素进行排序</span></span><br><span class="line">arr = mergeSort(arr, left, mid)</span><br><span class="line">    <span class="comment">// 对于右边的元素进行排序</span></span><br><span class="line">    arr = mergeSort(arr, mid + <span class="number">1</span>, right)</span><br><span class="line">merge(arr, left, mid, right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序">快速排序</h3><ol><li>选取数组中的一个元素为中轴元素，将数组中所有小于中轴元素的元素放在左边，所有大于或者等于中轴元素的元素放在右边</li><li>进行完过程 1 之后，这时候中轴元素的位置已经确定了，这个元素左边都是比它小的元素，右边都是比它大的元素</li><li>对于中轴元素左右两边的元素再分别进行 1 过程，直到所有的元素作为中轴元素位置都确定了为止</li></ol>示意图如下：<img src="5.png" 我是一张图片"" loading="lazy">代码如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pivot = arr[left]</span><br><span class="line">    <span class="keyword">let</span> i = left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> j = right;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j &amp;&amp; arr[i] &lt;= pivot) &#123;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j &amp;&amp; arr[j] &gt;= pivot) &#123;</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[i]</span><br><span class="line">        arr[i] = arr[j]</span><br><span class="line">        arr[j] = temp</span><br><span class="line">    &#125;</span><br><span class="line">    arr[left] = arr[j]</span><br><span class="line">    arr[j] = pivot</span><br><span class="line">    <span class="keyword">return</span> j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = partition(arr, left, right)</span><br><span class="line">        arr = quickSort(arr, left, mid - <span class="number">1</span>)</span><br><span class="line">        arr = quickSort(arr, mid + <span class="number">1</span>, right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        下面是选择排序，插入排序，冒泡排序，归并排序，快速排序五种算法的原理以及具体的代码实现&lt;h3 id=&quot;选择排序&quot;&gt;选择排序&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;从数组中选取一个元素 item，初次为第一个元素&lt;/li&gt;
&lt;li&gt;在 item 剩余的元素中找到最小的元素&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="算法" scheme="https://newpromise.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="https://newpromise.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>node中的 events 模块</title>
    <link href="https://newpromise.github.io/2020/09/14/node%E4%B8%AD%E7%9A%84%20events%20%E6%A8%A1%E5%9D%97/"/>
    <id>https://newpromise.github.io/2020/09/14/node中的 events 模块/</id>
    <published>2020-09-14T03:31:54.000Z</published>
    <updated>2021-03-04T07:57:25.610Z</updated>
    
    <content type="html"><![CDATA[了解 Node 中的 Events 模块node 中的 events 模块是 node 中使用较多的模块，比如在 node 中的流（stream），其内部使用 <code>events</code> 模块作为父类：<img src="/2020/09/14/node中的%20events%20模块/image-20200803102619367.png">作为一个使用广泛的基础模块，其代码中是有些东西值得我们学习和借鉴的。<h4 id="发布订阅模式">发布/订阅模式</h4>发布/订阅模式定义了一种一对多的依赖关系，观察者同时监听某一个对象相应的状态变化， 当状态变化时通知到所有观察者， 这种设计模式解决了主体对象和观察者之间的耦合问题。图示如下： <img src="/2020/09/14/node中的%20events%20模块/eventsPic.jpg"><em>上图中左边为观察者模式， 右边为 发布/订阅 模式， 可以看出它们之间的区别是发布/订阅模式通过事件调度中心（Event Channel）来对于事件进行统一管理</em>观察上图可知，发布/订阅这种设计模式的组成特点：<ul><li>整体结构有三部分组成， 订阅者（Subscriber）, 发布者（Publisher）以及 事件调度器（Event Channel）</li><li>订阅者在事件调度器中订阅（Subscribe）事件， 发布者发布事件时，订阅该事件的订阅者将会收到消息通知（事件触发的形式）</li></ul>在 Node 中的 Events 模块中， 采用了这种设计模式，模块内部维护了一个事件列表（<code>_events</code>）,提供了基础的 api 来进行发布和订阅（<code>emit</code>, <code>on</code>）在 Events 中，订阅事件时需要传入两个参数： 事件名（eventName）以及 事件触发时的回调方法（listener），订阅之后按照下面的结构存储在 <code>_events</code> 中：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_events = &#123;</span><br><span class="line">  eventName: listener, wrapFn &#123; <span class="attr">fired</span>: <span class="literal">false</span>/<span class="literal">true</span>, listener &#125;</span><br><span class="line">eventName: [listener1, listener2 ....]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>当调用 <code>this.emit(eventName)</code> 来发布特定事件时，将会依次调用<code>_events</code> 中的事件（<code>listener</code>）<h4 id="events-模块代码实现">Events 模块代码实现</h4><ol><li><code>on</code> / <code>addListener(eventName, listener)</code>这个方法的作用是订阅<code>eventName</code> 事件, 当事件被发布时， <code>listener</code> 方法被执行具体代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅事件</span></span><br><span class="line"><span class="comment">// target: EventEmitter 实例</span></span><br><span class="line"><span class="comment">// type: 事件类型</span></span><br><span class="line"><span class="comment">// listener: 事件触发后的回调方法</span></span><br><span class="line"><span class="comment">// prepend: 是否将回调方法前置（首先触发）,默认为 false, 将会被放到回调方法的最后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_addListener</span>(<span class="params">target, type, listener, prepend</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m;</span><br><span class="line">  <span class="keyword">var</span> events;</span><br><span class="line">  <span class="keyword">var</span> existing;</span><br><span class="line">  <span class="comment">// 判断是否为有效的函数    </span></span><br><span class="line">  checkListener(listener);</span><br><span class="line"></span><br><span class="line">  events = target._events;</span><br><span class="line">  <span class="keyword">if</span> (events === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    events = target._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    target._eventsCount = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// To avoid recursion in the case that type === "newListener"! Before</span></span><br><span class="line">    <span class="comment">// adding it to the listeners, first emit "newListener".</span></span><br><span class="line">    <span class="keyword">if</span> (events.newListener !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      target.emit(<span class="string">'newListener'</span>, type,</span><br><span class="line">                  listener.listener ? listener.listener : listener);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Re-assign `events` because a newListener handler could have caused the</span></span><br><span class="line">      <span class="comment">// this._events to be assigned to a new object</span></span><br><span class="line">      events = target._events;</span><br><span class="line">    &#125;</span><br><span class="line">    existing = events[type];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (existing === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// Optimize the case of one listener. Don't need the extra array object.</span></span><br><span class="line">    <span class="comment">// 只有一个 listener 的情况， 存储的直接是这个函数</span></span><br><span class="line">    existing = events[type] = listener;</span><br><span class="line">    ++target._eventsCount;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> existing === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// Adding the second element, need to change to array.</span></span><br><span class="line">      existing = events[type] =</span><br><span class="line">        prepend ? [listener, existing] : [existing, listener];</span><br><span class="line">      <span class="comment">// If we've already got an array, just append.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prepend) &#123;</span><br><span class="line">      existing.unshift(listener);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      existing.push(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for listener leak</span></span><br><span class="line">    <span class="comment">// 获取到一个事件最多的 listener 数量</span></span><br><span class="line">    m = _getMaxListeners(target);</span><br><span class="line">    <span class="keyword">if</span> (m &gt; <span class="number">0</span> &amp;&amp; existing.length &gt; m &amp;&amp; !existing.warned) &#123;</span><br><span class="line">      existing.warned = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// No error code for this since it is a Warning</span></span><br><span class="line">      <span class="comment">// eslint-disable-next-line no-restricted-syntax</span></span><br><span class="line">      <span class="keyword">var</span> w = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Possible EventEmitter memory leak detected. '</span> +</span><br><span class="line">                          existing.length + <span class="string">' '</span> + <span class="built_in">String</span>(type) + <span class="string">' listeners '</span> +</span><br><span class="line">                          <span class="string">'added. Use emitter.setMaxListeners() to '</span> +</span><br><span class="line">                          <span class="string">'increase limit'</span>);</span><br><span class="line">      w.name = <span class="string">'MaxListenersExceededWarning'</span>;</span><br><span class="line">      w.emitter = target;</span><br><span class="line">      w.type = type;</span><br><span class="line">      w.count = existing.length;</span><br><span class="line">      ProcessEmitWarning(w);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.addListener = <span class="function"><span class="keyword">function</span> <span class="title">addListener</span>(<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _addListener(<span class="keyword">this</span>, type, listener, <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.on = EventEmitter.prototype.addListener</span><br></pre></td></tr></table></figure></li><li><code>emit(eventName[, ...args])</code>作用：发布 <code>eventName</code> 事件， 传入的 args 将会作为该事件下 <code>listener</code> 的参数代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里包含了 type 为 "error" 或者其他需要 emit 的触发</span></span><br><span class="line">EventEmitter.prototype.emit = <span class="function"><span class="keyword">function</span> <span class="title">emit</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">  <span class="keyword">var</span> doError = (type === <span class="string">'error'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> events = <span class="keyword">this</span>._events;</span><br><span class="line">  <span class="comment">// 当 events 存在的时候</span></span><br><span class="line">  <span class="keyword">if</span> (events !== <span class="literal">undefined</span>)</span><br><span class="line">    <span class="comment">// 当 events 中不存在 error 事件时还 emit 了 error 事件</span></span><br><span class="line">    doError = (doError &amp;&amp; events.error === <span class="literal">undefined</span>);</span><br><span class="line">  <span class="comment">// 当 events 不存在， 并且 type 为非 error时， 直接返回 false</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!doError)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If there is no 'error' event listener then throw.</span></span><br><span class="line">  <span class="comment">// events 中没有 error 的时候</span></span><br><span class="line">  <span class="keyword">if</span> (doError) &#123;</span><br><span class="line">    <span class="keyword">var</span> er;</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>)</span><br><span class="line">      er = args[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (er <span class="keyword">instanceof</span> <span class="built_in">Error</span>) &#123;</span><br><span class="line">      <span class="comment">// Note: The comments on the `throw` lines are intentional, they show</span></span><br><span class="line">      <span class="comment">// up in Node's output if this results in an unhandled exception.</span></span><br><span class="line">      <span class="keyword">throw</span> er; <span class="comment">// Unhandled 'error' event</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// At least give some kind of context to the user</span></span><br><span class="line">    <span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Unhandled error.'</span> + (er ? <span class="string">' ('</span> + er.message + <span class="string">')'</span> : <span class="string">''</span>));</span><br><span class="line">    err.context = er;</span><br><span class="line">    <span class="keyword">throw</span> err; <span class="comment">// Unhandled 'error' event</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> handler = events[type];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (handler === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> handler === <span class="string">'function'</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    ReflectApply(handler, <span class="keyword">this</span>, args);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> len = handler.length;</span><br><span class="line">    <span class="keyword">var</span> listeners = arrayClone(handler, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">      ReflectApply(listeners[i], <span class="keyword">this</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><code>off</code> / <code>removeListener(eventName, listener)</code>作用： 从事件名为 <code>eventName</code> 的事件下移除特定的回调方法（<code>listener</code>）代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Emits a 'removeListener' event if and only if the listener was removed.</span></span><br><span class="line"><span class="comment">// 移除特定事件的 listener &amp;&amp; </span></span><br><span class="line"><span class="comment">// EventEmitter.on('removeListener'， handler) 触发</span></span><br><span class="line"><span class="comment">// type: 特定事件名称</span></span><br><span class="line"><span class="comment">// listener: 移除的函数</span></span><br><span class="line">EventEmitter.prototype.removeListener =</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">removeListener</span>(<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> list, events, position, i, originalListener;</span><br><span class="line"></span><br><span class="line">      checkListener(listener);</span><br><span class="line"></span><br><span class="line">      events = <span class="keyword">this</span>._events;</span><br><span class="line">      <span class="keyword">if</span> (events === <span class="literal">undefined</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">      list = events[type];</span><br><span class="line">      <span class="keyword">if</span> (list === <span class="literal">undefined</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 这里判断是否 list 中只有一个 listener 或者 list 是 wrap fn 的情况</span></span><br><span class="line">      <span class="keyword">if</span> (list === listener || list.listener === listener) &#123;</span><br><span class="line">        <span class="keyword">if</span> (--<span class="keyword">this</span>._eventsCount === <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">delete</span> events[type];</span><br><span class="line">          <span class="keyword">if</span> (events.removeListener)</span><br><span class="line">            <span class="keyword">this</span>.emit(<span class="string">'removeListener'</span>, type, list.listener || listener);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当 list 不是一个函数的时候，这个时候这个 list 是一个数组</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> list !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        position = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = list.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">          <span class="keyword">if</span> (list[i] === listener || list[i].listener === listener) &#123;</span><br><span class="line">            originalListener = list[i].listener;</span><br><span class="line">            position = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找不到listener</span></span><br><span class="line">        <span class="keyword">if</span> (position &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">          <span class="comment">// 第一个是要找到的 listener</span></span><br><span class="line">        <span class="keyword">if</span> (position === <span class="number">0</span>)</span><br><span class="line">          list.shift();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如果要进行删除的元素在 list 数组之中</span></span><br><span class="line">          <span class="comment">// splice</span></span><br><span class="line">          spliceOne(list, position);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当 list 删除完成之后只有一个 listener 时， 直接将这个 listener 作为 events[type] 的值</span></span><br><span class="line">        <span class="keyword">if</span> (list.length === <span class="number">1</span>)</span><br><span class="line">          events[type] = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (events.removeListener !== <span class="literal">undefined</span>)</span><br><span class="line">          <span class="keyword">this</span>.emit(<span class="string">'removeListener'</span>, type, originalListener || listener);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">EventEmitter.prototype.off = EventEmitter.prototype.removeListener;</span><br></pre></td></tr></table></figure>特别：<code>spliceOne</code> 方法, 而非使用<code>splice</code> 方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 这里是删除数组的方法</span><br><span class="line">// 用的方法是找到一个数组的位置， 然后往前挪</span><br><span class="line">// 这种方法性能提升比较大</span><br><span class="line">function spliceOne(list, index) &#123;</span><br><span class="line">  for (; index + 1 &lt; list.length; index++)</span><br><span class="line">    list[index] = list[index + 1];</span><br><span class="line">  list.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>once(eventName, listener)</code>作用：添加只能调用一次的 <code>listener</code> 方法代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onceWrapper</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里的 fired 或许是为了更方便的暴露给外部使用</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.fired) &#123;</span><br><span class="line">    <span class="comment">// 移除之后这里的闭包将会被回收了</span></span><br><span class="line">    <span class="keyword">this</span>.target.removeListener(<span class="keyword">this</span>.type, <span class="keyword">this</span>.wrapFn);</span><br><span class="line">    <span class="keyword">this</span>.fired = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.listener.call(<span class="keyword">this</span>.target);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.listener.apply(<span class="keyword">this</span>.target, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 onceWrap 维持了一个 state 状态 用来保存是否被触发过的状态</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_onceWrap</span>(<span class="params">target, type, listener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> state = &#123; <span class="attr">fired</span>: <span class="literal">false</span>, <span class="attr">wrapFn</span>: <span class="literal">undefined</span>, <span class="attr">target</span>: target, <span class="attr">type</span>: type, <span class="attr">listener</span>: listener &#125;;</span><br><span class="line">  <span class="comment">// 这里是注入里一些状态字段</span></span><br><span class="line">  <span class="comment">// 这里保存一些状态字段， 比如： fired 用来表示这个函数有没有被触发过</span></span><br><span class="line">  <span class="keyword">var</span> wrapped = onceWrapper.bind(state);</span><br><span class="line">  wrapped.listener = listener;</span><br><span class="line">  state.wrapFn = wrapped;</span><br><span class="line">  <span class="keyword">return</span> wrapped;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 _oncewrap 方法执行之后是一个方法， 方法上的 listener 属性才是传入 once 方法的</span></span><br><span class="line"><span class="comment">// listener 参数</span></span><br><span class="line"><span class="comment">// 这里的 _onceWrap 方法的包装解释了代码中存在的 listener.listener || listener 的判断</span></span><br><span class="line">EventEmitter.prototype.once = <span class="function"><span class="keyword">function</span> <span class="title">once</span>(<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">  checkListener(listener);</span><br><span class="line">  <span class="keyword">this</span>.on(type, _onceWrap(<span class="keyword">this</span>, type, listener));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><code>prependListener(eventName, listener)</code>作用：添加 <code>listener</code> 到事件 <code>eventName</code> 回调数组中的第一个， 当事件被发布时， 添加的 <code>listener</code> 第一个执行代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventEmitter.prototype.prependListener =</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">prependListener</span>(<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _addListener(<span class="keyword">this</span>, type, listener, <span class="literal">true</span>);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></li><li><code>prependOnceListener(eventName, listener)</code>作用： 添加一次性的 listener 到事件回调函数队列头部代码：就是 <code>prependListener</code> 和 <code>_onceWrap</code> 方法的结合<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EventEmitter.prototype.prependOnceListener =</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">prependOnceListener</span>(<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">      checkListener(listener);</span><br><span class="line">      <span class="keyword">this</span>.prependListener(type, _onceWrap(<span class="keyword">this</span>, type, listener));</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></li><li><code>removeAllListeners([eventName])</code>作用： 移除 <code>eventName</code> 事件的全部 <code>listener</code>代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">EventEmitter.prototype.removeAllListeners =</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">removeAllListeners</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> listeners, events, i;</span><br><span class="line"></span><br><span class="line">      events = <span class="keyword">this</span>._events;</span><br><span class="line">      <span class="keyword">if</span> (events === <span class="literal">undefined</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// not listening for removeListener, no need to emit</span></span><br><span class="line">      <span class="comment">// 为了保证 removeListener 方法在删除完之后最后触发，</span></span><br><span class="line">      <span class="comment">// 需要判断是否存在这个 removeListener 方法是否存在</span></span><br><span class="line">      <span class="keyword">if</span> (events.removeListener === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">          <span class="keyword">this</span>._eventsCount = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[type] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (--<span class="keyword">this</span>._eventsCount === <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">delete</span> events[type];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// emit removeListener for all listeners on all events</span></span><br><span class="line">      <span class="comment">// _events 中存在 removeListener 方法</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(events);</span><br><span class="line">        <span class="keyword">var</span> key;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; keys.length; ++i) &#123;</span><br><span class="line">          key = keys[i];</span><br><span class="line">          <span class="keyword">if</span> (key === <span class="string">'removeListener'</span>) <span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">this</span>.removeAllListeners(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保证之前移除listener 时能够触发 removeListener 回调</span></span><br><span class="line">        <span class="keyword">this</span>.removeAllListeners(<span class="string">'removeListener'</span>);</span><br><span class="line">        <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">this</span>._eventsCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 删除单个事件</span></span><br><span class="line"></span><br><span class="line">      listeners = events[type];</span><br><span class="line">      <span class="comment">// 兼容 listeners 中单个 listener 或者 多个 listener 的问题</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> listeners === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.removeListener(type, listeners);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (listeners !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="comment">// LIFO order</span></span><br><span class="line">        <span class="keyword">for</span> (i = listeners.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">          <span class="keyword">this</span>.removeListener(type, listeners[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></li><li><code>rawListeners(eventName)</code> 作用： 获取到 <code>eventName</code> 事件的全部 <code>listeners</code>, 包括是通过 <code>once</code> 方法创建的包裹 <code>listener</code>代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法用来获取到所有的 listener 无论是原生的还是放在 wrapper 上面的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unwrapListeners</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = <span class="keyword">new</span> <span class="built_in">Array</span>(arr.length);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ret.length; ++i) &#123;</span><br><span class="line">    ret[i] = arr[i].listener || arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取到全部的 _listeners </span></span><br><span class="line"><span class="comment">// type event 名称</span></span><br><span class="line"><span class="comment">// unwrap 是否是获取 非once 方法创建的 wrapper listener</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_listeners</span>(<span class="params">target, type, unwrap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> events = target._events;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (events === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> evlistener = events[type];</span><br><span class="line">  <span class="keyword">if</span> (evlistener === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> evlistener === <span class="string">'function'</span>)</span><br><span class="line">    <span class="keyword">return</span> unwrap ? [evlistener.listener || evlistener] : [evlistener];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> unwrap ?</span><br><span class="line">    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);</span><br><span class="line">&#125;</span><br><span class="line">EventEmitter.prototype.rawListeners = <span class="function"><span class="keyword">function</span> <span class="title">rawListeners</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _listeners(<span class="keyword">this</span>, type, <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        了解 Node 中的 Events 模块node 中的 events 模块是 node 中使用较多的模块，比如在 node 中的流（stream），其内部使用 &lt;code&gt;events&lt;/code&gt; 模块作为父类：&lt;img src=&quot;/2020/09/14/node中的%20ev
      
    
    </summary>
    
      <category term="源码阅读" scheme="https://newpromise.github.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="node" scheme="https://newpromise.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>使用 browserify 处理virtual-dom模块的一个例子</title>
    <link href="https://newpromise.github.io/2020/09/13/%E4%BD%BF%E7%94%A8%20browserify%20%E5%A4%84%E7%90%86virtual-dom%E6%A8%A1%E5%9D%97%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90/"/>
    <id>https://newpromise.github.io/2020/09/13/使用 browserify 处理virtual-dom模块的一个例子/</id>
    <published>2020-09-13T13:38:20.000Z</published>
    <updated>2021-03-03T10:09:11.254Z</updated>
    
    <content type="html"><![CDATA[使用 browserify 来实现程序在node环境和浏览器环境的适配： 适配不同的模块加载方式有的时候js文件需要在 node 和 浏览器环境下都能执行，除了兼容性问题之外，还有一点是 node 和 浏览器平台引入文件时的模块机制是不同的 ：Node 中使用 <code>Commonjs</code> 的模块加载机制，Commonjs 模块加载机制如下：使用：使用 <code>require</code> 加载模块， 使用 <code>module.exports</code> 向外部暴露模块特定： 模块同时加载，这种特点在 node 环境下是不存在问题的， 因为 node 环境下模块都是在本地磁盘，加载比较快， 但是在浏览器环境下时会出现阻塞渲染的问题为了解决异步加载模块的问题，<code>AMD(https://github.com/amdjs/amdjs-api/wiki)</code>  和 <code>CMD</code> 通过不同的方式实现异步加载模块：AMD   :  相关库： <code>requireJs</code>写法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">"module"</span>, [<span class="string">"dep1"</span>, <span class="string">"dep2"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">d1, d2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someExportedValue;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">require</span>([<span class="string">"module"</span>, <span class="string">"../file"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">module, file</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;);</span><br></pre></td></tr></table></figure>CMD:  相关库： <code>seaJs</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> add = <span class="built_in">require</span>(<span class="string">'math'</span>).add;</span><br><span class="line">  exports.increment = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(val, <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>除了 <code>AMD</code> 和 <code>CMD</code> 两个规范之外，使用<code>es6</code>  的模块加载是浏览器的另一种模块加载机制，也是未来的主流使用 <code>es6</code> 模块加载实现动态加载的方法： <code>import(module)</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 导入 dayJs 模块</span><br><span class="line">// import(...) 返回 promise</span><br><span class="line">const dayJs = await import(&apos;dayjs&apos;);</span><br></pre></td></tr></table></figure>使用 <code>browserify</code> 是如何实现的适配各种模块加载的呢 ？具体代码如下：按照 <a href="https://github.com/Matt-Esch/virtual-dom" target="_blank" rel="noopener"><code>virtual-dom</code></a> 这个包为例：这个包的作用是生成虚拟dom对象执行 <code>package.json</code> 中的命令：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"dist"</span>: <span class="string">"browserify  virtual-dom index.js &gt; dist/virtual-dom.js"</span>,</span><br></pre></td></tr></table></figure>打包时，使用 <code>browserify</code> 来处理， 最终打包完成后的文件输出到 <code>dist/virtual-dom.js</code> 中， 在打包后的代码中，我们可以看到如下的代码结构：处理之后的代码中：将原来文件中 <code>require(...)</code> 这样的文件引用替换为具体的执行函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自执行方法 f 为下面的 函数1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里根据不同的模块加载方式来导出 virtual-dom 这个包的代码</span></span><br><span class="line">    <span class="comment">// 如果是 CommonJs 规范，比如在 node 中使用</span></span><br><span class="line">    <span class="comment">// 这里当执行 f() 之后，执行路径是：</span></span><br><span class="line">    <span class="comment">// 函数1 作为参数 f 传入， 执行 f 函数1 执行 ==&gt;</span></span><br><span class="line">    <span class="comment">// 函数1 执行 ==&gt; 返回函数 e （为自执行函数）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> exports === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">        <span class="built_in">module</span>.exports = f()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">"function"</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">        define([], f)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> g;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">            g = <span class="built_in">window</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> global !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">            g = global</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">            g = self</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            g = <span class="keyword">this</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在不同环境下，给不同全局变量挂载 virtualDom 变量值为 f 函数执行后的结果</span></span><br><span class="line">        g.virtualDom = f()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)(</span><br><span class="line">  <span class="comment">// 函数1 作为参数 f 传入上面的参数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> define, <span class="built_in">module</span>, exports;</span><br><span class="line">    <span class="comment">// 函数 e 也是一个自执行函数，接受三个参数：</span></span><br><span class="line">    <span class="comment">// 这里参数的各个部分</span></span><br><span class="line">    <span class="comment">// t: 表示下面的对象1</span></span><br><span class="line">    <span class="comment">// n: 表示下面的对象2</span></span><br><span class="line">    <span class="comment">// r: 表示下面的对象3</span></span><br><span class="line">    <span class="comment">// 这里返回的结构为 (function e(t, n, r) &#123;&#125;)(对象1,对象2,对象3)(4)</span></span><br><span class="line">    <span class="comment">// 函数e为自执行函数，执行后返回函数 s， s 接受 4 作为参数，最终这里 return</span></span><br><span class="line">    <span class="comment">// 的结果为 s(4) 之后的返回值</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params">t, n, r</span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params">o, u</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!n[o]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!t[o]) &#123;</span><br><span class="line">                    <span class="keyword">var</span> a = <span class="keyword">typeof</span> <span class="built_in">require</span> == <span class="string">"function"</span> &amp;&amp; <span class="built_in">require</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!u &amp;&amp; a) <span class="keyword">return</span> a(o, !<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (i) <span class="keyword">return</span> i(o, !<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Cannot find module '"</span> + o + <span class="string">"'"</span>);</span><br><span class="line">                    <span class="keyword">throw</span> f.code = <span class="string">"MODULE_NOT_FOUND"</span>, f</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">var</span> l = n[o] = &#123;</span><br><span class="line">                    exports: &#123;&#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">// 这里的 t[o]0 表示每个模块的方法</span></span><br><span class="line">                <span class="comment">// 这里的 t[o]1 表示文件对象，文件对象的键名为引用的文件地址，建值为该文件在对象1中的key</span></span><br><span class="line">                <span class="comment">// 这里使用 call 会立即执行 t[o]0 这个方法</span></span><br><span class="line">                t[o][<span class="number">0</span>].call(l.exports, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">                    <span class="comment">// 这里的 function (e) &#123;&#125;, l, l.exports </span></span><br><span class="line">                    <span class="comment">// 分别表示 function (require, module, exports) 中的 require, module,         </span></span><br><span class="line">                    <span class="comment">// exports 这三个参数</span></span><br><span class="line">                    <span class="comment">// 所以当调用 module.exports 的时候， 实际上 module.exports === l.exports</span></span><br><span class="line">                    <span class="keyword">var</span> n = t[o][<span class="number">1</span>][e];</span><br><span class="line">                    <span class="comment">// 获取到文件地址对象对应的值</span></span><br><span class="line">                    <span class="keyword">return</span> s(n ? n : e)</span><br><span class="line">                &#125;, l, l.exports, e, t, n, r)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里是 s 方法的返回值</span></span><br><span class="line">            <span class="keyword">return</span> n[o].exports</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="keyword">typeof</span> <span class="built_in">require</span> == <span class="string">"function"</span> &amp;&amp; <span class="built_in">require</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> o = <span class="number">0</span>; o &lt; r.length; o++) s(r[o]);</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    &#125;)(</span><br><span class="line">      <span class="comment">// 对象1</span></span><br><span class="line">      &#123;</span><br><span class="line">      ===== 从之前的代码中抽取出来的一些代码 =====</span><br><span class="line">      这个对象中的元素的结构都是一样的：</span><br><span class="line">      对象的键key为数字，表示当前文件的标识</span><br><span class="line">      对象的值是一个数组， 这个数组中有两个元素，一个元素是 <span class="string">`function(require, module, exports) &#123;&#125;`</span> 方法包裹的文件内的方法，另外一个元素是上面文件中使用 <span class="built_in">require</span> 引用的文件路径和文件标识对象</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 为什么这里要先进行处理呢 ？ 因为可以认为这里是程序的主入口</span></span><br><span class="line">      <span class="comment">// 分析程序先从这里进入开始分析</span></span><br><span class="line">      <span class="number">4</span>: [<span class="function"><span class="keyword">function</span> (<span class="params">require, module, exports</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> diff = <span class="built_in">require</span>(<span class="string">"./diff.js"</span>)</span><br><span class="line">        <span class="keyword">var</span> patch = <span class="built_in">require</span>(<span class="string">"./patch.js"</span>)</span><br><span class="line">        <span class="keyword">var</span> h = <span class="built_in">require</span>(<span class="string">"./h.js"</span>)</span><br><span class="line">        <span class="keyword">var</span> create = <span class="built_in">require</span>(<span class="string">"./create-element.js"</span>)</span><br><span class="line">        <span class="keyword">var</span> VNode = <span class="built_in">require</span>(<span class="string">'./vnode/vnode.js'</span>)</span><br><span class="line">        <span class="keyword">var</span> VText = <span class="built_in">require</span>(<span class="string">'./vnode/vtext.js'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">          diff: diff,</span><br><span class="line">          patch: patch,</span><br><span class="line">          h: h,</span><br><span class="line">          create: create,</span><br><span class="line">          VNode: VNode,</span><br><span class="line">          VText: VText</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        <span class="string">"./create-element.js"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">"./diff.js"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">"./h.js"</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="string">"./patch.js"</span>: <span class="number">13</span>,</span><br><span class="line">        <span class="string">"./vnode/vnode.js"</span>: <span class="number">31</span>,</span><br><span class="line">        <span class="string">"./vnode/vtext.js"</span>: <span class="number">33</span></span><br><span class="line">      &#125;],</span><br><span class="line">      ...</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="comment">// 对象2</span></span><br><span class="line">    &#123;&#125;, </span><br><span class="line">    <span class="comment">// 对象3</span></span><br><span class="line">    [<span class="number">4</span>]</span><br><span class="line">    <span class="comment">// 这里的参数 （4） 实际上是 上面函数 s 接受的参数</span></span><br><span class="line">   )(<span class="number">4</span>)</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        使用 browserify 来实现程序在node环境和浏览器环境的适配： 适配不同的模块加载方式有的时候js文件需要在 node 和 浏览器环境下都能执行，除了兼容性问题之外，还有一点是 node 和 浏览器平台引入文件时的模块机制是不同的 ：Node 中使用 &lt;code&gt;Com
      
    
    </summary>
    
      <category term="源码阅读" scheme="https://newpromise.github.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="js-module" scheme="https://newpromise.github.io/tags/js-module/"/>
    
  </entry>
  
  <entry>
    <title>js-Worker</title>
    <link href="https://newpromise.github.io/2019/10/27/js-Worker/"/>
    <id>https://newpromise.github.io/2019/10/27/js-Worker/</id>
    <published>2019-10-27T11:27:07.000Z</published>
    <updated>2021-03-04T07:57:54.780Z</updated>
    
    <content type="html"><![CDATA[<h2 id="what-is-the-worker">What is the worker</h2>浏览器是多线程的， 在浏览器中，存在下面几个线程：<ul><li>浏览器事件触发线程</li><li>UI 渲染线程</li><li>JS 引擎线程</li><li>定时触发器线程</li><li>http 请求线程</li></ul>js 语言的一个重要特征是单线程，因为在js 中会设计到一些页面交互的逻辑， 比如操作 dom 树， css 样式树等， 单线程的设计避免了复杂的同步问题。因为在 js 中我们是可以进行 dom 操作的， 因此 UI 渲染线程和 js 引擎线程是互斥的，如果我们在页面上要进行一些耗时较大的 js 逻辑计算的时候， 页面可能会出现卡顿现象。为了利用多核 CPU 的计算能力，在 HTML5 中引入的工作线程使得浏览器端的 JavaScript 引擎可以并发地执行 JavaScript 代码，但是引入的工作线程并没有改变 js 单线程的本质， 因为子线程完全受主线程控制， 并且不能操作dom。工作线程的一些特点：<ul><li>工作线程内不能操作 dom，或者使用 window 对象下的一些属性和方法</li><li>工作线程和主线程之间通过消息传递系统实现，消息之间传递的数据是复制而不是共享一个存储空间（深复制和浅复制）<blockquote>both sides send their messages using the <code>postMessage()</code> method, and respond to messages via the <code>onmessage</code> event handler (the message is contained within the <code>Message</code> event&#39;s <code>data</code> property). The data is copied rather than shared.</blockquote></li></ul><h2 id="how-to-create-worker">How to create worker</h2>一个 Worker 的创建是通过js 中的构造函数： <code>Worker()</code> 来实现的：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myWorker = <span class="keyword">new</span> Worker(aURL, options);</span><br></pre></td></tr></table></figure>具体看 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker/Worker" target="_blank" rel="noopener">worker</a>当我们创建一个 worker 的时候， 我们需要手动创建一个 js 文件，这种方式过于死板， 我们希望我们能直接指定在 worker 中运行的代码，而不需要创建多余的文件， 那有没有可能我们直接传入一个方法呢？比如如下代码，我们对于函数代码进行了四次转换，从而实现将一个普通函数转换为 webWroker:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWorker</span>(<span class="params">workerFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> url = URL.createObjectURL(<span class="keyword">new</span> Blob([<span class="string">`(<span class="subst">$&#123;workerFn.toString ()&#125;</span>)()`</span>]));</span><br><span class="line">  <span class="keyword">const</span> worker = <span class="keyword">new</span> Worker(url);</span><br><span class="line">  <span class="keyword">let</span> promiseResolve;</span><br><span class="line">  worker.onmessage = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    promiseResolve(msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      promiseResolve = resolve;</span><br><span class="line">      worker.postMessage(message);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  onmessage = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`resceive message`</span>, msg.data);</span><br><span class="line">    postMessage(<span class="string">'hello'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> worker = createWorker(fn);</span><br><span class="line"></span><br><span class="line">worker(<span class="string">'send message'</span>).then(<span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'msg'</span>, msg.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>上面代码实现了在不额外创建文件的情况下，实现创建 worker 代码的过程如下是上面代码普通函数到 worker 的四种转换过程：<img src="v2-5887674cb213a45bef388a2f580da222_hd.jpg" loading="lazy"><img src="/2019/10/27/js-Worker/v2-5887674cb213a45bef388a2f580da222_hd.jpg">在上面的代码中，我们需要理解的是：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URL.createObjectURL(<span class="keyword">new</span> Blob([<span class="string">`(<span class="subst">$&#123;workerFn.toString ()&#125;</span>)()`</span>]));</span><br></pre></td></tr></table></figure><ol><li><code>Function.toString()</code> 方法可以将函数转换为代码字符串,例如上面的代码中， 执行完成<code>toString</code> 方法之后：</li></ol>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// workerFn.toString ()</span><br><span class="line">() =&gt; &#123;</span><br><span class="line">  onmessage = (msg) =&gt; &#123;</span><br><span class="line">    console.log(`resceive message`, msg.data);</span><br><span class="line">    postMessage(&apos;hello&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote>The <strong>toString()</strong> method returns a string representing the source code of the function.</blockquote><ol start="2"><li><code>URL.createObjectURL()</code><code>createObjectURL</code> 可以创建指向 blob 对象的 URL，  需要注意的是， 使用这种方法创建的是一个链接，这个链接指向数据对象， 这个数据对象可以是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/File" target="_blank" rel="noopener"><code>File</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" target="_blank" rel="noopener"><code>Blob</code></a> or <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaSource" target="_blank" rel="noopener"><code>MediaSource</code></a> 对象，真正的数据存放在 上面三种数据对象中。在上面的代码中， <code>URL.createObjectURL</code> 创建的链接， 指向的是保存有 <code>(${workerFn.toString ()})()</code> 的 blob 对象中关于 <a href="https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL" target="_blank" rel="noopener">createObjectURL</a></li></ol><h2 id="worker-loader">Worker-loader</h2><a href="https://github.com/webpack-contrib/worker-loader" target="_blank" rel="noopener">worker-loader</a> 是用来在 webpack 中实现 worker 的，核心代码如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> URL = <span class="built_in">window</span>.URL || <span class="built_in">window</span>.webkitURL;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content, url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> blob;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// BlobBuilder = Deprecated, but widely implemented</span></span><br><span class="line">        <span class="keyword">var</span> BlobBuilder = <span class="built_in">window</span>.BlobBuilder ||</span><br><span class="line">        <span class="built_in">window</span>.WebKitBlobBuilder ||</span><br><span class="line">        <span class="built_in">window</span>.MozBlobBuilder ||</span><br><span class="line">        <span class="built_in">window</span>.MSBlobBuilder;</span><br><span class="line"></span><br><span class="line">        blob = <span class="keyword">new</span> BlobBuilder();</span><br><span class="line"></span><br><span class="line">        blob.append(content);</span><br><span class="line"></span><br><span class="line">        blob = blob.getBlob();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">// The proposed API</span></span><br><span class="line">        blob = <span class="keyword">new</span> Blob([content]);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Worker(URL.createObjectURL(blob));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// 这里对于 js 数据进行编码</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Worker(<span class="string">'data:application/javascript,'</span> + <span class="built_in">encodeURIComponent</span>(content));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!url) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Inline worker is not supported'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Worker(url);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>使用多种不同的 api 主要是为了不同浏览器的兼容性问题，<h2 id="参考链接"><strong>参考链接</strong></h2><ol><li><a href="https://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string" target="_blank" rel="noopener">how-to-create-a-web-worker-from-a-string</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;what-is-the-worker&quot;&gt;What is the worker&lt;/h2&gt;
浏览器是多线程的， 在浏览器中，存在下面几个线程：&lt;ul&gt;
&lt;li&gt;浏览器事件触发线程&lt;/li&gt;
&lt;li&gt;UI 渲染线程&lt;/li&gt;
&lt;li&gt;JS 引擎线程&lt;/li&gt;
&lt;li&gt;定
      
    
    </summary>
    
      <category term="js" scheme="https://newpromise.github.io/categories/js/"/>
    
    
      <category term="Worker" scheme="https://newpromise.github.io/tags/Worker/"/>
    
  </entry>
  
  <entry>
    <title>promisify callback-style function</title>
    <link href="https://newpromise.github.io/2019/10/03/PromisifyCallback/"/>
    <id>https://newpromise.github.io/2019/10/03/PromisifyCallback/</id>
    <published>2019-10-03T14:47:16.000Z</published>
    <updated>2021-03-03T10:09:11.236Z</updated>
    
    <content type="html"><![CDATA[将一个回调函数转换为 <code>promise</code> 类函数，在  <code>promisify</code> 化的函数的 <code>then</code> 方法里面执行回调函数， 避免回调地狱。这样相当于我们日常代码开发中，对于某个函数返回一个 <code>promise</code>, 以期在函数的 <code>then</code> 方法里面处理数据的方法的一个封装。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// some data process code...</span></span><br><span class="line">    <span class="keyword">try</span> () &#123;</span><br><span class="line">      resolve(data);      </span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;...&#125;);</span><br></pre></td></tr></table></figure>在 node.js 中， 存在一个工具方法为 <code>utils.promisfy</code> 的工具方法， 这个方法将回调转换为 <code>promise</code> 类方法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error-first 类型回调</span></span><br><span class="line"><span class="comment">// 回调cb 的第一个参数为 error， 如果没有传 false</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cb(<span class="literal">false</span>, <span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> utils = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promiseFn = utils.promisify(fn);</span><br><span class="line"></span><br><span class="line">promiseFn().then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 使用这个方法， 可以将 node 中的一些异步的回调</span></span><br><span class="line"><span class="comment">// 比如： readFile 等</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promiseReadFile = utils.promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line">promiseReadFile(<span class="string">'./.gitignore'</span>, <span class="string">'utf-8'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">fs.readFile(<span class="string">'./.gitignore'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>在 <code>promisify</code> 出现之前，使用 <a href="https://github.com/sindresorhus/pify" target="_blank" rel="noopener">pify</a> 实现相同的功能<code>pify</code> 模块的核心代码不多,  下面是全部的代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心处理方法</span></span><br><span class="line"><span class="comment">// fn：将要被 promise 化的函数</span></span><br><span class="line"><span class="comment">// options: 相关配置选项</span></span><br><span class="line"><span class="comment">// args: 传入函数的相关参数</span></span><br><span class="line"><span class="comment">// 实际执行的时候， 执行这个方法返回的方法， 其中 args 为传入的参数</span></span><br><span class="line"><span class="comment">// 这里 args 是一个数组， 通过 push 回调的方法</span></span><br><span class="line"><span class="keyword">const</span> processFn = <span class="function">(<span class="params">fn, options</span>) =&gt;</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> P = options.promiseModule;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> P(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// multiArgs： 是否传入多个参数</span></span><br><span class="line">    <span class="keyword">if</span> (options.multiArgs) &#123;</span><br><span class="line">      <span class="comment">// push 一个方法函数， 这个函数就是我们在原函数中手动</span></span><br><span class="line">      <span class="comment">// 调用的回调函数 cb， 参数是我们手动写入回调函数中的参数</span></span><br><span class="line">      args.push(<span class="function">(<span class="params">...result</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// errorFirst: 是否包含错误， 适配 node 如 fs.exists() 类的方法</span></span><br><span class="line">        <span class="keyword">if</span> (options.errorFirst) &#123;</span><br><span class="line">          <span class="keyword">if</span> (result[<span class="number">0</span>]) &#123;</span><br><span class="line">            reject(result);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.shift();</span><br><span class="line">            resolve(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.errorFirst) &#123;</span><br><span class="line">      args.push(<span class="function">(<span class="params">error, result</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">          reject(error);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      args.push(resolve);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个时候， args 中传入了相关的回调方法</span></span><br><span class="line">    fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">input, options</span>) =&gt;</span> &#123;</span><br><span class="line">  options = <span class="built_in">Object</span>.assign(&#123;</span><br><span class="line">    exclude: [<span class="regexp">/.+(Sync|Stream)$/</span>],</span><br><span class="line">    <span class="comment">// errorFirst: 回调函数中是否第一个参数为 error</span></span><br><span class="line">    errorFirst: <span class="literal">true</span>,</span><br><span class="line">    promiseModule: <span class="built_in">Promise</span></span><br><span class="line">  &#125;, options);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> objType = <span class="keyword">typeof</span> input;</span><br><span class="line">  <span class="keyword">if</span> (!(input !== <span class="literal">null</span> &amp;&amp; (objType === <span class="string">'object'</span> || objType === <span class="string">'function'</span>))) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`Expected \`input\` to be a \`Function\` or \`Object\`, got \`<span class="subst">$&#123;input === <span class="literal">null</span> ? <span class="string">'null'</span> : objType&#125;</span>\``</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> filter = <span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> match = <span class="function"><span class="params">pattern</span> =&gt;</span> <span class="keyword">typeof</span> pattern === <span class="string">'string'</span> ? key === pattern : pattern.test(key);</span><br><span class="line">    <span class="comment">// options 中的 include 和 exclude 属性分别表示</span></span><br><span class="line">    <span class="comment">// 模块中可以被序列化的方法</span></span><br><span class="line">    <span class="keyword">return</span> options.include ? options.include.some(match) : !options.exclude.some(match);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> ret;</span><br><span class="line">  <span class="comment">// 当传入的 input 为函数的时候</span></span><br><span class="line">  <span class="keyword">if</span> (objType === <span class="string">'function'</span>) &#123;</span><br><span class="line">    ret = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// excludeMain：是否对于一些 module 内部方法 做 promise 化</span></span><br><span class="line">      <span class="keyword">return</span> options.excludeMain ? input(...args) : processFn(input, options).apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 否则 ret 为包含有 input 上面的属性的对象</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ret = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(input));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于 input 参数对象或者函数上面的每一个方法都做 promise 化</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> input) &#123; <span class="comment">// eslint-disable-line guard-for-in</span></span><br><span class="line">    <span class="keyword">const</span> property = input[key];</span><br><span class="line">    ret[key] = <span class="keyword">typeof</span> property === <span class="string">'function'</span> &amp;&amp; filter(key) ? processFn(property, options) : property;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><code>utils.promisify</code> 方法<code>promisify</code> 方法是 node 内置的 <code>promise</code> 化回调函数的工具方法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promisify = <span class="function"><span class="keyword">function</span> <span class="title">promisify</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> kCustomPromisifiedSymbol = <span class="keyword">typeof</span> <span class="built_in">Symbol</span> !== <span class="string">'undefined'</span> ? <span class="built_in">Symbol</span>(<span class="string">'util.promisify.custom'</span>) : <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> original !== <span class="string">'function'</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'The "original" argument must be of type Function'</span>);</span><br><span class="line">   <span class="comment">// 在 original 方法上面存在有 `kCustomPromisifyedSymbol 这个属性</span></span><br><span class="line">  <span class="comment">// 这个属性上面存储的是被 promise 化的方法</span></span><br><span class="line">  <span class="keyword">if</span> (kCustomPromisifiedSymbol &amp;&amp; original[kCustomPromisifiedSymbol]) &#123;</span><br><span class="line">    <span class="keyword">var</span> fn = original[kCustomPromisifiedSymbol];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'The "util.promisify.custom" argument must be of type Function'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(fn, kCustomPromisifiedSymbol, &#123;</span><br><span class="line">      value: fn, <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="attr">writable</span>: <span class="literal">false</span>, <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> promiseResolve, promiseReject;</span><br><span class="line">    <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      promiseResolve = resolve;</span><br><span class="line">      promiseReject = reject;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">      args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    args.push(<span class="function"><span class="keyword">function</span> (<span class="params">err, value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        promiseReject(err);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        promiseResolve(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      original.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      promiseReject(err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 fn 上的原型设置为 original 上的原型</span></span><br><span class="line">  <span class="built_in">Object</span>.setPrototypeOf(fn, <span class="built_in">Object</span>.getPrototypeOf(original));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (kCustomPromisifiedSymbol) <span class="built_in">Object</span>.defineProperty(fn, kCustomPromisifiedSymbol, &#123;</span><br><span class="line">    value: fn, <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="attr">writable</span>: <span class="literal">false</span>, <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 设置 fn 上的属性为 original 方法上面的属性</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.defineProperties(</span><br><span class="line">    fn,</span><br><span class="line">    getOwnPropertyDescriptors(original)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        将一个回调函数转换为 &lt;code&gt;promise&lt;/code&gt; 类函数，在  &lt;code&gt;promisify&lt;/code&gt; 化的函数的 &lt;code&gt;then&lt;/code&gt; 方法里面执行回调函数， 避免回调地狱。这样相当于我们日常代码开发中，对于某个函数返回一个 &lt;code&gt;pro
      
    
    </summary>
    
      <category term="promsie" scheme="https://newpromise.github.io/categories/promsie/"/>
    
    
      <category term="promisify" scheme="https://newpromise.github.io/tags/promisify/"/>
    
  </entry>
  
  <entry>
    <title>数据结构：树</title>
    <link href="https://newpromise.github.io/2019/10/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91/"/>
    <id>https://newpromise.github.io/2019/10/03/数据结构：树/</id>
    <published>2019-10-03T03:19:09.000Z</published>
    <updated>2021-03-03T10:09:11.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树">树</h1>树是这样的一种结构：<img src="/2019/10/03/数据结构：树/image-20191003112501951.png"><img src="image-20191003112501951.png" loading="lazy">对于树的定义如下：<blockquote>树是 n (n &gt;= 0) 个结点的有限集，n = 0 时称为空树，在任意一棵非空树中，<ol><li>有且仅用一个特定的称为 根（root）的节点</li><li>当 n &gt; 1 时，其余结点可分为 m（m &gt; 0）个互不相交的有限集 T1, T2, ...Tn, 其中每一个集合本身也是一棵树， 并且称为 根的子树， </li></ol></blockquote>对于树的存储方式， 可以使用三种表示法来存储树之间结点之间的相互关系：双亲表示法， 孩子表示法， 孩子兄弟表示法双亲表示法：以一段连续的空间存储树的结点， 在每一个结点中，存储当前结点其双亲结点的存储位置：<img src="/2019/10/03/数据结构：树/image-20191003120639803.png"><img src="image-20191003120639803.png" loading="lazy">data为数据域， 存储当前结点的相关数据， parent 为指针域， 存储当前节点的双亲结点在数组中的下标比如下面的树使用双亲表示法表示：<img src="/2019/10/03/数据结构：树/image-20191003120919003.png"><img src="image-20191003120919003.png" loading="lazy">根结点的双亲位置为 -1；上面的表示法表示的树用于查找结点的双亲元素比较方便， 但是，如果这个结点下面包含有多个的子结点， 我们可以需要设置多个的指针域， 比如， 长子域， 右兄弟域等等。孩子表示法：孩子表示法的方式是：将每个结点的孩子结点排列起来，以单链表作为存储结构，则 n 个结点有 n 个孩子链表，如果是叶子结点， 那么这个单链表为空，然后 n 个头指针又组成一个线性表，存放在一个一维数组中。使用孩子表示法表示上面的树形结构：<img src="/2019/10/03/数据结构：树/image-20191003131535048.png"><img src="image-20191003131535048.png" loading="lazy">在上面的孩子表示法中，设计有两种结构：<ol><li>孩子链表<img src="/2019/10/03/数据结构：树/image-20191003131750956.png"><img src="image-20191003131750956.png" loading="lazy">child 为数据域， 用来存储当前的子结点在表头数组中的下标， next 为指针域，存放的是下一个孩子的这个结构指针地址。</li><li>表头结点<img src="/2019/10/03/数据结构：树/image-20191003131943353.png"><img src="image-20191003131943353.png" loading="lazy">表头结点存储每个结点， 用于树形结点的遍历使用，另外， 存储长子结点的指针域；</li></ol>孩子兄弟表示法：孩子兄弟表示法的数据结构如下：<img src="/2019/10/03/数据结构：树/image-20191003132343485.png"><img src="image-20191003132343485.png" loading="lazy">data 为数据域firstchild 为该结点第一个孩子结点的指针域rightsib 为该结点的兄弟结点指针域使用 孩子兄弟表示法组织后的数据结构如下：<img src="/2019/10/03/数据结构：树/image-20191003132738591.png"><img src="image-20191003132738591.png" loading="lazy">上面的重新组织后的结构将一棵树转换为了一棵二叉树<h2 id="二叉树">二叉树</h2><h3 id="二叉树的定义">二叉树的定义</h3><blockquote>二叉树是 n 个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的，分别称为 根结点的左子树和右子树的二叉树组成 </blockquote>二叉树的特点：<ol><li>每个结点最多有两棵子树</li><li>左子树和右子树是有顺序的， 并且不能颠倒</li><li>即使树中某结点只有一棵子树，也要区分顺序</li></ol>如下图， 是一棵二叉树的示意图：<img src="/2019/10/03/数据结构：树/image-20191003190231702.png"><img src="image-20191003190231702.png" loading="lazy">根据二叉树的结构显示， 可以将二叉树分为：满二叉树， 斜树 和 完全二叉树；如下， 是满二叉树的图示：<img src="/2019/10/03/数据结构：树/image-20191003190415734.png"><img src="image-20191003190415734.png" loading="lazy">树的每个结点都有左右两个结点， 故称为满二叉树。<h3 id="二叉树的存储">二叉树的存储</h3><h4 id="顺序存储">顺序存储</h4>按照顺序存储二叉树， 主要是使用一维数组来顺序存储树中的各个结点，比如， 存储如下树结构：<img src="/2019/10/03/数据结构：树/image-20191003190805122.png"><img src="image-20191003190805122.png" loading="lazy">使用顺序存储如下：<img src="/2019/10/03/数据结构：树/image-20191003190824306.png"><img src="image-20191003190824306.png" loading="lazy">对于不存在的结点， 我们将不存在的结点设为 <code>^</code> 即可。使用顺序存储存在的问题在于， 我们需要对于不存在的结点分配存储空间，比如，对于下面这个右斜树而言：<img src="/2019/10/03/数据结构：树/image-20191003191127941.png"><img src="image-20191003191127941.png" loading="lazy">这样造成了存储空间的浪费。<h4 id="链式存储">链式存储</h4>对于二叉树结点的存储， 我们使用一种被称为 “二叉链表” 的链式存储结构来存储，二叉链表是下面的这种结构：<img src="/2019/10/03/数据结构：树/image-20191003191435274.png"><img src="image-20191003191435274.png" loading="lazy">这个结构中包含有一个数据域和两个指针域， 数据域表明当前结点的数据，指针域分别为二叉树左右两个结点的地址指针。使用链式存储后的最终的存储链表结构如下：<img src="/2019/10/03/数据结构：树/image-20191003191659327.png"><img src="image-20191003191659327.png" loading="lazy"><h3 id="二叉树的遍历">二叉树的遍历</h3>二叉树的遍历是指从根结点出发， 依次访问到二叉树中的每一个结点，使得每个结点被访问到并且仅被访问到一次。二叉树的遍历方法， 按照访问次序的不同， 可以分为 前序遍历， 中序遍历 以及 后序遍历<h4 id="前序遍历">前序遍历</h4>前序遍历的遍历顺序是先访问二叉树的左子树， 然后访问二叉树的右子树<img src="/2019/10/03/数据结构：树/image-20191012122817189.png"><img src="image-20191012122817189-0854497.png" loading="lazy">如， 上图， 二叉树的访问顺序是：ABDGHCEIF<h4 id="中序遍历">中序遍历</h4>中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树<img src="/2019/10/03/数据结构：树/image-20191014162511259.png"><img src="image-20191014162511259-1041511.png" loading="lazy">如上图， 那么 二叉树的访问顺序是：GDHBAEICF<h4 id="后序遍历">后序遍历</h4>判断二叉树是否为空， 如果是空， 那么空操作返回，否则的话， 从左到 右通过先叶子后结点的方式遍历访问左右子树<img src="/2019/10/03/数据结构：树/image-20191014163237408.png"><img src="image-20191014163237408-1041957.png" loading="lazy">使用后序遍历的方法来访问二叉树的顺序是：GHDBIEFCA<h3 id="二叉树的创建">二叉树的创建</h3>二叉树的创建可以像二叉树创建方法中传入一串树来实现，通过一定的二叉树的遍历顺序来依次创建结点， 对于空结点， 二叉树中的字符串可以为 ‘#’按照前序遍历创建的二叉树的方法如下:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建二叉树</span></span><br><span class="line"><span class="comment">// treeStr: 树的字符串， 空结点 ‘#’</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTree</span>(<span class="params">treeStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> tree = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 创建树节点</span></span><br><span class="line">  <span class="keyword">let</span> treeStack = treeStr.split(<span class="string">''</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createNode</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> nodeData = treeStack.shift();</span><br><span class="line">    <span class="keyword">if</span> (!nodeData) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (nodeData !== <span class="string">'#'</span>) &#123;</span><br><span class="line">      node.data = nodeData;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当父节点没有左结点的时候， 创建左结点</span></span><br><span class="line">    <span class="keyword">if</span> (!node.lChild || !node.lChild.hasOwnProperty(<span class="string">'data'</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (treeStack.length &gt;= <span class="number">1</span>) node.lChild = &#123;&#125;;</span><br><span class="line">      <span class="keyword">if</span> (createNode(node.lChild)) <span class="keyword">delete</span> node.lChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!node.rChild || !node.rChild.hasOwnProperty(<span class="string">'data'</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (treeStack.length &gt;= <span class="number">1</span>) node.rChild = &#123;&#125;;</span><br><span class="line">      <span class="keyword">if</span> (createNode(node.rChild)) <span class="keyword">delete</span> node.rChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  createNode(tree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>对于树的创建和访问一样， 也是进行依次遍历， 使用递归进行遍历访问， 需要注意的是：要存在相应的条件， 使得能够跳出递归。对于递归而言， 注意递归循环的跳出是比较重要的。同样，也可以按照中序遍历和后序遍历的次序来创建树， 只是递归的顺序不同而已。另外， 判断对象中某个属性是否存在， 最好不要用直接访问属性的方式进行判断， 因为不知道这个属性的值可能是 <code>undefined</code>,  或者 <code>0</code> 等导致属性访问后为 <code>false</code> 的值。可以使用 <code>hasOwnProperty</code> 的方式来判断属性是否在对象上面:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.hasOwnPropery(prop);</span><br></pre></td></tr></table></figure>注意： 这个方法只能够获取到该对象上面的自身属性， 不能获取到该对象原型上面的属性（for in 是可以获取到继承的属性的， 并且继承的属性是可枚举的）为了防止对象上面有 <code>hasOwnProperty</code> 属性覆盖掉从对象上面继承的， 我们需要通过 <code>Object</code> 来调用：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.hasOwnProperty.call(obj, &apos;property&apos;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;树&quot;&gt;树&lt;/h1&gt;
树是这样的一种结构：&lt;img src=&quot;/2019/10/03/数据结构：树/image-20191003112501951.png&quot;&gt;
&lt;img src=&quot;image-20191003112501951.png&quot; loading=&quot;lazy&quot;
      
    
    </summary>
    
      <category term="数据结构" scheme="https://newpromise.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="树" scheme="https://newpromise.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构：栈和队列</title>
    <link href="https://newpromise.github.io/2019/09/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>https://newpromise.github.io/2019/09/28/数据结构：栈和队列/</id>
    <published>2019-09-28T09:05:33.000Z</published>
    <updated>2021-03-03T10:09:11.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="栈">栈</h2>栈是一种特殊的线性表，这种线性表仅允许在表尾（栈顶）进行插入和删除工作：将可以被插入和删除元素的位置称为<code>栈顶</code>， 将另一端称为 <code>栈底</code>， 如果栈没有任何的元素， 这个栈被称为 <code>空栈</code>；栈的数据元素的进出遵循后进先出的原则，简称为  <em>LIFO (Last In First Out)</em> 结构；栈的插入被称为入栈， 栈的删除被称为出栈， 在程序中我们可以将其称为 <code>push</code> 和 <code>pop</code>;在 js 中， 我们使用数组的 <code>push</code> 和 <code>pop</code> 方法模拟栈的入栈和出栈操作；<h3 id="栈的应用">栈的应用</h3><h4 id="递归">递归</h4>我们将调用函数自身或者间接调用自身的函数称为 <em>递归</em> 在每一层递归的过程中， 我们需要存储当前调用函数的局部变量， 参数值等数据信息存储到栈中，当递归返回之后， 再将这些数据从栈中弹出数据<h4 id="使用栈实现四则运算表达式">使用栈实现四则运算表达式</h4>如下面程序， 实现将一串运算表达式进行计算的代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于逆波兰法表示的后缀表达式计算求值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RPNcompute</span>(<span class="params">mathStrStack</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> stack = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> mathStrStack) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Number</span>.isNaN(+num)) &#123;</span><br><span class="line">      <span class="keyword">const</span> num1 = stack.pop();</span><br><span class="line">      <span class="keyword">const</span> num2 = stack.pop();</span><br><span class="line">      <span class="keyword">const</span> total = num2 + num + num1;</span><br><span class="line">      stack.push(<span class="built_in">eval</span>(total));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      stack.push(num);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stack.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将中缀表达式转为后缀表达式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toPostFixExpression</span>(<span class="params">expression</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> expressionArr = expression.split(<span class="string">' '</span>);</span><br><span class="line">  <span class="keyword">let</span> stack = [];</span><br><span class="line">  <span class="keyword">let</span> outputStr = <span class="string">''</span>;</span><br><span class="line">  <span class="comment">// 处理符号入栈与出栈</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">pushStack</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">if</span> (!stack.length) &#123;</span><br><span class="line">      stack.push(s);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">      <span class="keyword">let</span> stackTopData = stack.pop();</span><br><span class="line">      <span class="keyword">if</span> (s === <span class="string">')'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stackTopData === <span class="string">'('</span>) <span class="keyword">break</span>;</span><br><span class="line">        result += stackTopData + <span class="string">' '</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="string">'+'</span>, <span class="string">'-'</span>, <span class="string">'*'</span>, <span class="string">'/'</span>].includes(s))&#123;</span><br><span class="line">        <span class="keyword">const</span> isLower = [<span class="string">'+'</span>, <span class="string">'-'</span>].includes(s);</span><br><span class="line">        <span class="comment">// 当栈顶元素优先级大于等于当前入栈元素时， 栈顶元素依次出栈</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="string">'/'</span>, <span class="string">'*'</span>].concat(isLower ? [<span class="string">'+'</span>, <span class="string">'-'</span>] : []).includes(stackTopData)) &#123;</span><br><span class="line">          result += stackTopData + <span class="string">' '</span>;</span><br><span class="line">          <span class="keyword">if</span> (!stack.length) &#123;</span><br><span class="line">            stack.push(s);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          stack.push(stackTopData);</span><br><span class="line">          stack.push(s);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stack.push(stackTopData);</span><br><span class="line">        stack.push(s);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> expressionArr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Number</span>.isNaN(+num)) &#123;</span><br><span class="line">      outputStr += pushStack(num);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      outputStr += <span class="string">`<span class="subst">$&#123;num&#125;</span> `</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> outputStr + stack.reverse().join(<span class="string">' '</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compute</span>(<span class="params">mathStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> stackArr = toPostFixExpression(mathStr).split(<span class="string">' '</span>);</span><br><span class="line">  <span class="keyword">return</span> RPNcompute(stackArr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line">compute(<span class="string">'9 + ( 3 - 1 ) * 3 + 10 / 2'</span>);</span><br><span class="line"><span class="comment">// 20</span></span><br><span class="line">compute(<span class="string">'9 + 3 * ( 2 + 2 / 2 ) - 10 / 5'</span>);</span><br><span class="line"><span class="comment">// 16</span></span><br></pre></td></tr></table></figure>关于 中缀表达式转后缀表达式（逆波兰）法规则如下:从左到右遍历中缀表达式的每个数字和符号，如果是数字那么就输出，成为后缀表达式的一部分，如果是符号， 那么判断该符号与栈顶符号的优先级，是右括号或者优先级低于等于栈顶符号， 那么栈顶符号依次出栈并输出，并将当前符号进栈， 一直到最终输出后缀表达式为止。运算符号优先级： 乘除 &gt; 加减对于后缀表达式的计算规则如下：从左到右遍历后缀表达式的每个数字和符号，如果遇到数字那么就入栈，遇到是符号， 那么就将处于栈顶的两个数字出栈， 进行运算，并将运算结果入栈， 一直到最终获得到结果。<h2 id="队列">队列</h2><blockquote>队列是只允许在一端进行插入操作， 而在另一端进行删除操作的线性表</blockquote>队列遵循的是先进先出的线性表， 在程序设计中的应用， 比如我们在显示器上记事本上文字的输出。在日常生活中， 比如我们购买火车票时的排队。<h3 id="队列的线式存储结构">队列的线式存储结构</h3>在 js 中， 我们使用数组的 <code>push</code> 和 <code>shift(表头弹出)</code> 这两个 api 实现队列的模拟。<h4 id="顺序存储">顺序存储</h4>使用顺序存储时，我们将队列数据元素按照顺序存储到数组中， 当我们想要对于队列进行出列操作时， 因为出列操作是在表头出列， 因此，出列数据元素后面的每一个数据都会向前移动一个元素位置， 这样会造成程序性能的损耗。<img src="/2019/09/28/数据结构：栈和队列/image-20191002114710061-9988030.png"><img src="image-20191002114710061-9988030.png" loading="lazy">这个时候的时间复杂度为  <code>O(n)</code>为了解决这个移动队列数据元素的问题， 我们可以引入两个指针： <code>front</code>: 指向队头元素， <code>rear</code>: 指向队尾元素的下一个位置当我们对于队列进行添加和删除元素的时候， 只要改变 <code>front</code> 和 <code>rear</code> 指针的位置就可以了， 不需要移动每个队列元素:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queue</span>(<span class="params">queueLen</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> queueArr = <span class="keyword">new</span> <span class="built_in">Array</span>(queueLen);</span><br><span class="line">  <span class="keyword">let</span> front = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> rear = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.out = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    queueArr[front] = <span class="literal">undefined</span>;</span><br><span class="line">    front ++;</span><br><span class="line">    <span class="keyword">return</span> queueArr;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    queueArr[rear] = data;</span><br><span class="line">    rear ++;</span><br><span class="line">    <span class="keyword">return</span> queueArr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>对于上面的代码， 存在一个问题是， 如果我们当删除数据时， 队列不往前移动， 那么当我们新增队列数据元素的时候， 可以会增加到规定的队列长度之外的元素：比如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queueList = queue(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">queueList.add(<span class="number">1</span>);</span><br><span class="line">queueList.add(<span class="number">2</span>);</span><br><span class="line">queueList.out();</span><br><span class="line"><span class="built_in">console</span>.log(queueList.add(<span class="number">3</span>));</span><br><span class="line"><span class="comment">// [ undefined, 2, 3 ]</span></span><br><span class="line"><span class="comment">// 队列长度超出了我们规定的 2 的长度的队列长度</span></span><br></pre></td></tr></table></figure>这个时候， 队列数据填充情况如下图所示：<img src="/2019/09/28/数据结构：栈和队列/image-20191002141645991-9997006.png"><img src="image-20191002141645991-9997006.png" loading="lazy">这个时候虽然添加的数据位置超出了队列的长度， 但是删除的队列的第 0 位 和 第 1 位元素却是空的， 我们的溢出是“假溢出”。我们思考， 如何能够利用删除之后的空间， 防止假溢出？<h4 id="循环队列"><strong>循环队列</strong></h4>循环队列相比上面的存储方法而言， 有一些不同， 主要是体现在  <code>rear</code> 指针的指向，<code>rear</code> 指针在队列初始化的时候指向下标 为 0 的位置,  当到达队列列尾的时候， <code>rear</code> 指针移动到队列列头<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queue</span>(<span class="params">queueSize</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> queueArr = <span class="keyword">new</span> <span class="built_in">Array</span>(queueSize);</span><br><span class="line">  <span class="keyword">let</span> front = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> rear = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.out = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (front === rear) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'empty'</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    queueArr[front] = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 使用 %（取模）操作来进行归 0 操作</span></span><br><span class="line">    front = (front + <span class="number">1</span>) % queueSize;</span><br><span class="line">    <span class="keyword">return</span> queueArr;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'full'</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    queueArr[rear] = data;</span><br><span class="line">    rear = (rear + <span class="number">1</span>) % queueSize;</span><br><span class="line">    <span class="keyword">return</span> queueArr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.queueLength = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (rear - front + queueSize) % queueSize;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isFull</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (rear + <span class="number">1</span>) % queueSize === front;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链式存储结构">链式存储结构</h3>队列的链式存储结构其实就是单链表。与普通的单链表不同的是， 只能操作链表的头部和尾部节点，队列的链式存储结构被称为 <code>链队列</code>；<h3 id="总结">总结</h3>当已知队列空间大小的情况下， 可以使用 <code>循环队列</code>， 否则， 如果不知道队列的长度， 使用 <code>链对列</code>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;栈&quot;&gt;栈&lt;/h2&gt;
栈是一种特殊的线性表，这种线性表仅允许在表尾（栈顶）进行插入和删除工作：将可以被插入和删除元素的位置称为&lt;code&gt;栈顶&lt;/code&gt;， 将另一端称为 &lt;code&gt;栈底&lt;/code&gt;， 如果栈没有任何的元素， 这个栈被称为 &lt;code&gt;空栈&lt;/
      
    
    </summary>
    
      <category term="数据结构" scheme="https://newpromise.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="栈 和 队列" scheme="https://newpromise.github.io/tags/%E6%A0%88-%E5%92%8C-%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>promise中的错误捕获</title>
    <link href="https://newpromise.github.io/2019/09/27/promise%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E6%8D%95%E8%8E%B7/"/>
    <id>https://newpromise.github.io/2019/09/27/promise中的错误捕获/</id>
    <published>2019-09-27T09:02:31.000Z</published>
    <updated>2021-03-03T10:09:11.250Z</updated>
    
    <content type="html"><![CDATA[在代码中， 我们对于不能预知的代码通常会使用 <code>try catch</code> 来捕获代码错误，当代码内部发生错误时， 对于错误进行捕获， 可以防止代码的错误阻塞后续代码的执行，并且我们可以对于代码的错误进行后续处理；在 <code>promise</code> 中， 对于错误的处理或许稍有不同， 需要注意下面几点：<ul><li>使用 <code>try catch</code> 只能捕获同步代码， 不能捕获异步代码， 在 <code>async</code> 函数内， 使用 <code>await</code> 可以捕获异步代码，这里实际上是异步代码变成了同步代码</li><li><code>promise</code> 内部代码的错误会沿着 <code>promise</code> 代码链传递， 直到被 <code>promise</code> 的 <code>catch</code> 方法或者上一层 <code>async</code>  函数内的  <code>try catch</code> 方法捕获到, 如果没有使用 <code>catch</code> 方法指定错误处理的回调函数， <code>Promise</code> 对象抛出的错误不会传递到外层的 <code>promise</code>；这个时候会报： <code>UnhandledPromiseRejectionWarning:</code></li></ul><h4 id="try-catch-处理async-函数内异步"><code>try catch</code> 处理<code>async</code> 函数内异步</h4>使用 <code>try catch</code> 只能处理同步的代码， 对于异步代码中的代码错误， 使用 <code>try catch</code> 是无法捕获到的：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryError</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    promise();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tryError();</span><br><span class="line"><span class="comment">// UnhandledPromiseRejectionWarning: Error: error</span></span><br></pre></td></tr></table></figure>在 <code>async </code> 函数内部使用 <code>try catch</code>可以捕获到异步错误：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">tryError</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> promise();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">tryError();</span><br><span class="line"><span class="comment">// error</span></span><br></pre></td></tr></table></figure><h4 id="promisecatch-错误捕获"><code>promise.catch 错误捕获</code></h4>使用 <code>promise.catch</code> 方法可以对于当前 <code>promise</code> 链上的代码进行错误捕获，当 <code>promise</code> 内部发生错误的时候， 错误会沿着 <code>promise</code> 链向后传递， 直到被 <code>promise</code> 后面的 <code>catch</code> 方法捕获到：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">apromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apromise().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'error'</span>, err);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// error: b is not defined</span></span><br></pre></td></tr></table></figure>当在 <code>promise</code> 链中没有 <code>catch</code> 方法的时候， <code>promise</code> 中发生的错误不会被上层的 <code>promise</code> 中的catch 捕获, 即使我们使用了 <code>throw new Error</code> 的方式对错误进行抛出也是如此；因为 <code>async</code> 函数返回一个 <code>promise</code> 对象， 我们在 <code>async</code> 函数内部定义一个 <code>Error</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>);</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">promise();</span><br><span class="line"><span class="comment">// UnhandledPromiseRejectionWarning: Error: error</span></span><br><span class="line"><span class="comment">// 这里 async 函数内部抛出的错误不会被外部的 catch 方法捕获到， 因为错误不能传递到外层</span></span><br><span class="line"><span class="comment">// 的 `promise`</span></span><br></pre></td></tr></table></figure><h4 id="总结">总结</h4>防止出现 <code>unhandledRejection</code> 问题的解决方法是：<ol><li>在 <code>async</code> 函数内部使用 <code>try catch</code> 捕获异步错误</li><li> <code>promise</code> 内部使用 <code>.catch</code> 方法来捕获 <code>promise</code> 内部代码错误</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        在代码中， 我们对于不能预知的代码通常会使用 &lt;code&gt;try catch&lt;/code&gt; 来捕获代码错误，当代码内部发生错误时， 对于错误进行捕获， 可以防止代码的错误阻塞后续代码的执行，并且我们可以对于代码的错误进行后续处理；在 &lt;code&gt;promise&lt;/code&gt; 中，
      
    
    </summary>
    
      <category term="promise" scheme="https://newpromise.github.io/categories/promise/"/>
    
    
      <category term="promise catch" scheme="https://newpromise.github.io/tags/promise-catch/"/>
    
  </entry>
  
  <entry>
    <title>数据结构（一）：线性表</title>
    <link href="https://newpromise.github.io/2019/09/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>https://newpromise.github.io/2019/09/21/数据结构：线性表/</id>
    <published>2019-09-21T12:28:52.000Z</published>
    <updated>2021-03-03T10:09:11.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构简介">数据结构简介</h2><blockquote>数据结构是相互之间存在一种或者多种特定关系的数据元素的集合</blockquote>数据结构分为<strong>逻辑结构</strong>和<strong>物理结构</strong>；数据对象中数据元素之间的关系称为逻辑结构， 在数据结构中， 存在下面四种逻辑结构：<ul><li>集合结构集合结构中的元素除了同属于同一集合之外。 没有其他的任何关系， 如同所示：<img src="/2019/09/21/数据结构：线性表/image-20190921203850921-9069530.png"><img src="image-20190921203850921-9069530.png" loading="lazy"></li><li>线性结构： 线性结构中的元素是一对一的关系：<img src="/2019/09/21/数据结构：线性表/image-顺序表.jpg"><img src="image-顺序表.jpg" loading="lazy"></li><li>树形结构：树形结构中的元素关系是一对多的层次关系, 比如： 二叉树<img src="/2019/09/21/数据结构：线性表/image-20190921211634571-9071794.png"><img src="image-20190921211634571-9071794.png" loading="lazy"></li><li>图形结构： 图形结构中的元素之间的关系是一对多的关系<img src="/2019/09/21/数据结构：线性表/image-20190921211723626-9071843.png"></li></ul>  <img src="image-20190921211723626-9071843.png" loading="lazy">物理结构： 是指数据的逻辑结构在计算机中的存储方式；物理结构包括顺序存储结构和链式存储结构；顺序存储结构的数据逻辑关系和物理关系是一致的， 即是数据存放在地址连续的存储单元里面；链式存储结构数据间的存储地址并不连续，数据之间的存储关系并不表示他们之间的逻辑关系，这些数据的地址信息存放在数据的指针中。通过数据的指针来表明数据之间的存储关系。<h2 id="数据结构之线性表">数据结构之线性表</h2><blockquote>线性表是零个或者多个数据元素的有限序列</blockquote>线性表是一种序列， 这表明线性表中数据的关系之间都是一对一的关系，如果元素存在多个， 那么第一个元素没有前元素， 最后一个元素没有后元素， 其他元素有且只有一个前元素和后元素，<h3 id="线性表的顺序存储结构">线性表的顺序存储结构</h3>顺序存储结构是物理结构和逻辑结构一致的一种结构， 比如， 我们使用一个一维数组来存储数据，实现顺序存储结构；<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list  = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure>在顺序存储结构中， 地址和数据之间的关系是一致的，比如， 我们想要获取 第 i 个元素， 我们可以通过   <code>list[i - 1]</code> 来获取数据。<h4 id="删除和插入元素">删除和插入元素</h4>当我们需要删除或者插入元素的时候， 对于顺序存储结构需要移动比较多的元素， 当我们需要删除一个元素， 需要将该数据项后面的数据都需要向前提前一位：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从线性表中删除某个数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteData</span>(<span class="params">list, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (list.length === <span class="number">0</span>) <span class="keyword">return</span> list;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; list.length) <span class="keyword">return</span> list;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; list.length) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = i; index &lt; list.length; index ++) &#123;</span><br><span class="line">      list[index <span class="number">-1</span>] = list[index];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  list.length --;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(deleteData(list, <span class="number">2</span>));</span><br><span class="line"><span class="comment">// [1, 3, 4]</span></span><br></pre></td></tr></table></figure>对于线性表的插入和删除数据操作，其时间复杂度为 O(n);<h4 id="优缺点">优缺点</h4>对于线性表的顺序存储结构， 其优点是：<ol><li>可以快速的存取表中任意位置的元素</li><li>无须为表中的逻辑关系增加额外的存储空间</li></ol>缺点：对于线性表中插入和删除元素操作需要移动大量的元素<h3 id="线性表的链式存储结构">线性表的链式存储结构</h3>顺序存储结构对于插入和删除元素需要移动大量元素的原因是数据之间的逻辑关系和存储关系一致且相互之间按照次序排列，需要移动大量的元素来保持相互之间的存储关系和逻辑关系的一致。这种问题可以通过使用链式存储结构来解决，链式存储结果的特点是逻辑关系和存储关系分离， 当逻辑关系改变时， 不会引起存储关系的变化线性表的链式结构由一个个的节点（Node）构成， 每个节点中包含有一个数据域和一个或者多个指针域， 顾名思义， 数据域用于存储当前节点的数据， 指针域用来存储下一个节点的位置信息， 根据节点中指针域的数量不同， 将链表分为单链表和双链表；<h4 id="单链表">单链表</h4>单链表示意图如下：<img src="/2019/09/21/数据结构：线性表/image-20190921230012405-9078012.png"><img src="image-20190921230012405-9078012.png" loading="lazy">在上图中我们可以看到， 在链表中相邻的数据的存储位置并不连续，数据之间的关系通过节点中的指针域中的地址来表明。一些要点：<ol><li>链表中的最后一个节点的指针为空， 我们常常将其置为 <code>null</code></li><li>为了更方便的对于链表进行操作， 我们在第一个节点之前设置一个头节点，这个节点的指针指向第一个节点， 节点中的数据可以包含有链表的长度等信息。</li><li>头指针不为空，是链表的必要元素</li></ol>链表中节点之间的逻辑关系如图所示：<img src="/2019/09/21/数据结构：线性表/image-20190921231032685-9078632.png"><img src="image-20190921231032685-9078632.png" loading="lazy"><h5 id="单链表的读取">单链表的读取</h5>链表中数据的关系是通过指针来表示的，想要读取单链表的数据，我们需要通过指针来操作， 比如读取程序如下:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的链表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">linkList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> list = &#123;</span><br><span class="line">    data: &#123; <span class="attr">length</span>: <span class="number">0</span> &#125;,</span><br><span class="line">    next: <span class="literal">null</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> headNodeData = list.data;</span><br><span class="line">  <span class="keyword">const</span> headNode = list;</span><br><span class="line">  <span class="comment">// 链表新增节点</span></span><br><span class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> node = &#123; <span class="attr">data</span>: value, <span class="attr">next</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> next = list.next;</span><br><span class="line">    <span class="keyword">let</span> currentNode = list;</span><br><span class="line">    <span class="keyword">while</span> (next) &#123;</span><br><span class="line">      currentNode = next;</span><br><span class="line">      next = next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    currentNode.next = node;</span><br><span class="line">    headNodeData.length ++;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取链表中的某个节点</span></span><br><span class="line">  <span class="keyword">this</span>.get = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; headNodeData.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> next = list.next;</span><br><span class="line">    <span class="keyword">let</span> nodeIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (next) &#123;</span><br><span class="line">      nodeIndex ++;</span><br><span class="line">      <span class="keyword">if</span> (i === nodeIndex) <span class="keyword">break</span>;</span><br><span class="line">      next = next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> linkedList = linkList();</span><br><span class="line">linkedList.add(<span class="number">1</span>)；</span><br><span class="line"><span class="comment">// &#123; data: &#123; length: 1 &#125;, next: &#123; data: 1, next: null &#125; &#125;</span></span><br><span class="line">linkedList.get(<span class="number">1</span>)；</span><br><span class="line"><span class="comment">// &#123; data: 1, next: null &#125;</span></span><br></pre></td></tr></table></figure>单链表的查找数据的核心思想是<strong>工作指针后移</strong>；<h5 id="单链表的插入和删除">单链表的插入和删除</h5>代码如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在第 i 个数据后插入元素, 元素值为 value</span></span><br><span class="line"><span class="keyword">this</span>.append = <span class="function"><span class="keyword">function</span> (<span class="params">i, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">this</span>.get(i);</span><br><span class="line">  <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'node not exist'</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> newNode = &#123; <span class="attr">data</span>: value, <span class="attr">next</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">  newNode.next = node.next;</span><br><span class="line">  node.next = newNode;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> linkedList = linkList();</span><br><span class="line">linkedList.add(<span class="number">1</span>);</span><br><span class="line">linkedList.append(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// &#123; data: &#123; length: 1 &#125;,</span></span><br><span class="line"><span class="comment">// next: &#123; data: 1, next: &#123; data: 2, next: null &#125; &#125; &#125;</span></span><br></pre></td></tr></table></figure>对于单链表的插入数据项， 我们要做的仅仅是改变相应节点的指针的指向，原理如图所示：<img src="/2019/09/21/数据结构：线性表/image-20190922101043201-9118243.png"><img src="image-20190922101043201-9118243.png" loading="lazy">我们想要在<code>p</code> 节点之后插入节点 <code>s</code>, 我们要做的是将 p 节点的指针 <code>next</code> 指向要插入的节点， 同时将要插入的节点的指针指向插入前的下一个节点。注意： 这里的顺序是：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.next --&gt; p.next;</span><br><span class="line">p.next --&gt; s;</span><br></pre></td></tr></table></figure>顺序不可以更换；插入成功之后的效果如下图所示：<img src="/2019/09/21/数据结构：线性表/image-20190922101526386-9118526.png"><img src="image-20190922101526386-9118526.png" loading="lazy">单链表的删除：实现单链表的删除功能也是通过指针来完成的，实现原理如下图所示：<img src="/2019/09/21/数据结构：线性表/image-20190922102047839-9118847.png"><img src="image-20190922102047839-9118847.png" loading="lazy">代码如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除第 i 个节点的元素</span></span><br><span class="line"><span class="keyword">this</span>.delete = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> nodeNext = ((i - <span class="number">1</span> === <span class="number">0</span>) ? headNode : <span class="keyword">this</span>.get(i - <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (!nodeNext || !nodeNext.next) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> deleteNode = nodeNext.next;</span><br><span class="line">  nodeNext.next =  nodeNext.next.next;</span><br><span class="line">  headNodeData.length --;</span><br><span class="line">  deleteNode = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> linkedList = linkList();</span><br><span class="line">linkedList.add(<span class="number">1</span>);</span><br><span class="line">linkedList.add(<span class="number">2</span>);</span><br><span class="line">linkedList.delete(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// &#123; data: &#123; length: 1 &#125;, next: &#123; data: 2, next: null &#125; &#125;</span></span><br><span class="line">linkedList.delete(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// &#123; data: &#123; length: 0 &#125;, next: null &#125;</span></span><br></pre></td></tr></table></figure><h5 id="单链表的整表删除">单链表的整表删除</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.deleteAll = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> deleteNode = headNode</span><br><span class="line">  <span class="keyword">let</span> freeNode;</span><br><span class="line">  <span class="keyword">while</span> (deleteNode &amp;&amp; deleteNode.next) &#123;</span><br><span class="line">    freeNode = deleteNode.next;</span><br><span class="line">    deleteNode.next = <span class="literal">null</span>;</span><br><span class="line">    deleteNode = freeNode;</span><br><span class="line">    headNodeData.length --;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> linkedList = linkList();</span><br><span class="line">linkedList.add(<span class="number">1</span>);</span><br><span class="line">linkedList.add(<span class="number">2</span>);</span><br><span class="line">linkedList.deleteAll();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'list'</span>, linkedList.list);</span><br><span class="line"><span class="comment">// &#123; data: &#123; length: 0 &#125;, next: null &#125;</span></span><br></pre></td></tr></table></figure><h4 id="循环链表">循环链表</h4><blockquote>在单链表中终端节点的指针端由空指针指向头节点，就使得整个单链表形成一个环，这种头尾相接的链表称为循环链表</blockquote>循环链表如下图所示：<img src="/2019/09/21/数据结构：线性表/image-20190923224009682-9249609.png"><img src="image-20190923224009682-9249609.png" loading="lazy">循环链表相比于单链表不同的地方在于终端节点的指针指向不同的，使用循环链表的作用是可以从一个节点出发，查找到列表中的所有节点。<h4 id="双向链表">双向链表</h4>双向链表和单链表的区别在于： 实现双向链表的节点中存在两个指针域，在单链表的基础上，创建另外一个指针指向上一个节点，如下图所示：<img src="/2019/09/21/数据结构：线性表/image-20190923224650271-9250010.png"><img src="image-20190923224650271-9250010.png" loading="lazy">相比于单链表而言， 使用双向链表可以实现在前后两个方向上面的节点查找， 比单链表相比，双向链表可以实现在前后两个方向上面的数据节点查找， 当然缺点是会多出一个指针域来指向上一个节点。<h3 id="对比">对比</h3>如果线性表需要频繁的查找， 很少进行插入和删除工作时， 适合采用顺序存储结构；如果涉及到频繁的插入和删除数据工作， 那么适合采用链式存储结构]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据结构简介&quot;&gt;数据结构简介&lt;/h2&gt;
&lt;blockquote&gt;
数据结构是相互之间存在一种或者多种特定关系的数据元素的集合&lt;/blockquote&gt;
数据结构分为&lt;strong&gt;逻辑结构&lt;/strong&gt;和&lt;strong&gt;物理结构&lt;/strong&gt;；数据对象中数
      
    
    </summary>
    
      <category term="数据结构" scheme="https://newpromise.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="线性表" scheme="https://newpromise.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
</feed>
