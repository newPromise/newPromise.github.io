<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>上善若水</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://newpromise.github.io/"/>
  <updated>2021-03-06T07:37:25.332Z</updated>
  <id>https://newpromise.github.io/</id>
  
  <author>
    <name>上善若水</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git 中的合并策略</title>
    <link href="https://newpromise.github.io/2021/03/06/git%20%E4%B8%AD%E7%9A%84%E5%90%88%E5%B9%B6%E7%AD%96%E7%95%A5/"/>
    <id>https://newpromise.github.io/2021/03/06/git 中的合并策略/</id>
    <published>2021-03-06T07:37:25.332Z</published>
    <updated>2021-03-06T07:37:25.332Z</updated>
    
    <content type="html"><![CDATA[当我们合并两个分支的时候，Git 会帮我们自动挑选合适的合并策略，常见的 git 合并策略有 <code>Fast-forward、Recursive 、Ours、Theirs</code> 几种，不同的合并策略适用于不同的合并场景，如果想要强制指定一种合并策略，使用 <code>git merge -s &lt;策略名字&gt;</code> 命令<h4 id="fast-forward"><code>Fast-forward</code>:</h4>这种合并策略是最简单的一种，适用的场景是：合并两个没有分叉的分支，入下图所示，这个时候只是将 master 分支移动到最新的节点就好<img src="v2-e881bee3a250dd0aca96b6a11241ab78_b.jpg" loading="lazy" style="zoom:80%;"><h4 id="recursive：">Recursive：</h4>使用  recursive 进行合并的场景是合并两个有分叉的分支，这是经常使用到的一种合并策略<img src="v2-ab724ead18c6fc8ada3c10257fabf84a_b.png" loading="lazy" style="zoom:80%;">如上图所示，使用 Recursive 的合并过程是：合并中间两个节点 A， B 的时候，先找到它们两个节点的共同祖先节点，最左边的 A，然后这三个节点进行三向合并，最终得到最右边的节点 B‘Recursive 合并策略的合并算法可以总结为：<strong>递归寻找路径最短的唯一共同祖先节点，然后以其为 base 节点进行递归三向合并</strong>so，什么是三向合并就是我们了解这个合并策略最需要知道的内容<h5 id="三向合并">三向合并</h5>假如我们在两个分支上，分别修改了同一个文件，如下图所示， 当对于这两个分支进行合并的时候，那么能否合并成功呢？<img src="v2-8308f536b1986fd877fd360cbd6e9ed9_b.png" loading="lazy" style="zoom:80%;">很显然是不能的，因为 git 无法判断合并之后的文件是采用哪一个文件的代码为了判断合并之后的文件采用哪一个分支修改的代码，我们除了上面的两个文件之外，还需要一个  <code>base</code> 节点的文件，这个节点的作用是作为对比分别和两个文件进行比较：<p><img src="v2-c8ad9474d401b2f1128980911ad3d9b0_b.jpg" loading="lazy"></p>如上图所示，我们通过三个文件进行对比可以得知，在 <code>Yours</code> 分支上的代码修改了文件，因此合并之后的文件中的内容采用这个分支上修改的内容。会不会出现三个文件上相同的文件修改的内容都不相同的情况呢 ？ 会的，这种情况的出现就是我们合并中会遇到的 <strong>冲突</strong><p><img src="v2-763962194d688dad1a479d505f1d8485_b.png" loading="lazy"></p>这个时候就需要我们解决冲突才能进行合并<h5 id="寻找-base-节点">寻找 base 节点</h5>在了解了三向合并的合并策略之后，接下来我们需要关心的是：如何查找 base 节点像recursive 合并算法中描述的： <strong>递归</strong>寻找<strong>路径最短</strong>的的<strong>唯一共同</strong>祖先节点如下图：<blockquote>下面的 Git 流程图中每一个圆圈表示一次提交，圆圈里面的文字表这次提交的文件内容，如果两个圆圈内文件的内容一致，则表示两次提交文件的内容没有被修改</blockquote>我们想要合并中间的两个节点  A 和 B，找到它们共同的祖先节点 A， 以它为base节点进行三向合并得到最右边的 B 节点<img src="v2-ab724ead18c6fc8ada3c10257fabf84a_b.png" loading="lazy" style="zoom:80%;">实际情况可能比较复杂，如下图所示情况：<img src="v2-794b86a469a9acb9770b59f7551cc9dc_1440w.jpg" loading="lazy" style="zoom:60%;">我们想要合并两个节点， B 和 C，查找到 B， C 的节点发现有两个共同的祖先节点： A 和 B，这种情况下我们应该以谁作为祖先节点呢 ？在这种情况下， git 会继续递归查找，寻找 A 和 B 的共同祖先节点，将这个共同的祖先节点为base节点和 A，B进行合并， <img src="Xnip2021-03-06_15-06-03.jpg" loading="lazy" alt="image-20210306150442907" style="zoom:40%;">如上图所示，首先找到了一个合并之后的节点 <code>4/B</code>, 在根据这个节点作为 base 节点，和 节点 B C 进行三向合并<h4 id="ours--theirs">Ours &amp; Theirs</h4>使用 Ours 和 Theirs 这两种合并策略的目的是： 我们希望保留两个分支的历史记录，但是忽略掉一方的代码变更使用 Ours 和 Theirs 应用的场景相似，假如有两个分支，在这两个分支上对于同一功能进行了不同的代码实现，如果我们想要采用其中一种，但是希望另外一种代码实现也能出现在提交记录中的时候，可以执行 <code>git merge -s ours/theirs</code> 命令来实现<img src="Xnip2021-03-06_15-35-10.jpg" loading="lazy" style="zoom:40%;">如上图所示，最终只会保留 master 分支上的代码]]></content>
    
    <summary type="html">
    
      
      
        当我们合并两个分支的时候，Git 会帮我们自动挑选合适的合并策略，常见的 git 合并策略有 &lt;code&gt;Fast-forward、Recursive 、Ours、Theirs&lt;/code&gt; 几种，不同的合并策略适用于不同的合并场景，如果想要强制指定一种合并策略，使用 &lt;code
      
    
    </summary>
    
      <category term="git" scheme="https://newpromise.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://newpromise.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git 中的数据存储</title>
    <link href="https://newpromise.github.io/2021/03/04/git%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    <id>https://newpromise.github.io/2021/03/04/git 中的数据存储/</id>
    <published>2021-03-04T09:42:33.886Z</published>
    <updated>2021-03-04T09:42:33.886Z</updated>
    
    <content type="html"><![CDATA[<h3 id="版本控制系统">版本控制系统</h3>代码版本控制系统大致可以分为三代：<h4 id="本地版本控制系统">本地版本控制系统</h4>代码存储在本地，无法实现多人协作的需求<h4 id="集中化的版本控制系统">集中化的版本控制系统</h4>解决了多人协作的问题，但是因为代码都是统一存储在服务器上，当无法连接服务器上的时候，无法查看日志和提交比较代码<h4 id="分布式的版本控制系统">分布式的版本控制系统</h4>这种控制系统的特点是，任何人都可以复制一份和服务上相同的代码，当无法连接服务器的时候，仍然可以提交代码，创建分支<h3 id="git-中文件夹-git">Git 中文件夹 .git</h3>当我们使用 <code>git init </code> 初始化<code>git</code> 仓库的时候，当前文件夹下出生成一个 <code>.git</code>  的隐藏文件夹，这个文件夹内存储着我们进行 git 操作的一些数据：<ul><li>存储当前的分支（<code>HEAD</code>）</li><li>存储当前所有的分支信息（<code>config</code>）</li><li>存储提交的文件快照数据（<code>objects</code>）</li><li>....</li></ul><h3 id="三种基本文件">三种基本文件</h3>当我们输入一些git命令的时候，git 根据的输入的命令会生成一些文件，有的文件用来存储当前提交的文件内容，有的文件用来存储我们当前提交的信息，这些文件都被存储在 <code>objects</code> 这个文件夹之内，有三种基本文件在我们使用 git 进行数据存储时是息息相关的：<ul><li><code>blob</code> 文件</li><li><code>tree</code> 文件</li><li><code>commit</code> 文件</li></ul><h4 id="blob-文件"><code>blob</code> 文件</h4>blob 文件用来存储我们提交代码的文件快照，这种文件存储的是压缩后的文件内容代码实践下 blob 文件是如何生成的：<ol><li>git 初始化：</li></ol><img src="image-20210303164432105.png" loading="lazy" alt="image-20210303164432105" style="zoom:50%;"><ol start="2"><li>初始化的 git 仓库内创建两个文件: <code>1.txt</code> 与 <code>2.txt</code>, 内容分别是 1 和 2</li><li>执行 <code>git add</code>：</li></ol><img src="image-20210303164241534.png" loading="lazy" alt="image-20210303164241534" style="zoom:50%;"><ol start="4"><li>查看出现的 <code>d8</code> 和 <code>56</code> 这两个文件夹</li></ol><img src="image-20210303164846117.png" loading="lazy" alt="image-20210303164846117" style="zoom:50%;">​     如图，发现是乱码的形式，这是因为 Git 将信息压缩成了二进制，对于这种文件，使用 <code>git cat-file [-t][-p]</code> 来查看文件类型或者    文件内容<img src="image-20210303165312098.png" loading="lazy" alt="image-20210303165312098" style="zoom:50%;">​    <img src="image-20210303165323101.png" loading="lazy" alt="image-20210303165323101" style="zoom:50%;">可以看到，使用 <code>git add</code> 命令生成的 <code>56</code> 和 <code>d8</code> 文件都是 <code>blob</code> 类型文件，并且存储的是文件的内容<h4 id="tree-文件"><code>tree</code> 文件</h4>继续上面的操作，这次执行 <code>git commit </code> 命令：<img src="image-20210303170500072.png" loading="lazy" alt="image-20210303170500072" style="zoom:50%;">查看 <code>objects</code> 文件：<img src="image-20210303170606368.png" loading="lazy" alt="image-20210303170606368" style="zoom:50%;">相比之前多出了两个文件夹：<code>3c</code> 和 <code>96</code> 查看 <code>3c</code> 文件夹​                                                        <img src="image-20210303170851619.png" loading="lazy" alt="image-20210303170851619" style="zoom:50%;">​    可以看到， 3c 文件夹下的文件存储的内容为我们这次 commit 修改的两个文件 1.txt 和 2.txt ，除了文件名之外，还保存有此次修改的blob文件的文件名以及文件类型3c文件夹下的文件类型为 tree, 这种文件存储的信息是当前提交的文件目录<h4 id="commit-文件"><code>commit</code> 文件</h4>查看生成的 <code>96</code> 文件夹，我们可以看到如下内容：<img src="image-20210303171533671.png" loading="lazy" alt="image-20210303171533671" style="zoom:50%;"><img src="image-20210303171612008.png" loading="lazy" alt="image-20210303171612008" style="zoom:50%;">96 文件夹下的文件类型为 commit 文件， 存储的内容是本次 commit 的信息: 提交人，提交信息（git test）等，其中还存储了 tree 文件的文件名，除了这些信息之外， 还存储有上一次提交的 commit 文件（父点），因为我们这里是初次提交，没有上一次提交，因此没有父节点<h4 id="三种文件之间的关系">三种文件之间的关系</h4>综上所述，三种类型的文件的主要作用是：blob：存储提交文件的快照tree：存储提交文件的文件目录以及文件名，blob 文件地址等信息commit： 存储提交信息，提交生成的 tree 文件用一张图可以说明三种类型文件之间的关系：<img src="image-20210303171943546.png" loading="lazy" alt="image-20210303171943546" style="zoom:33%;"><h4 id="总结">总结</h4><ul><li> 使用 <code>git add .</code> 命令时，将变动内容的文件保存生成 blob 文件</li><li>使用 <code>git commit</code> 命令时， 生成 tree 文件与 commit 文件</li><li>当前分支的指针指向新的 commit 节点，节点中存在 parent 字段，表明上一次提交 commit 文件，逐级向上，一直到第一次提交，这些 commit 连接成为提交记录（<code>git log</code>）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;版本控制系统&quot;&gt;版本控制系统&lt;/h3&gt;
代码版本控制系统大致可以分为三代：&lt;h4 id=&quot;本地版本控制系统&quot;&gt;本地版本控制系统&lt;/h4&gt;
代码存储在本地，无法实现多人协作的需求&lt;h4 id=&quot;集中化的版本控制系统&quot;&gt;集中化的版本控制系统&lt;/h4&gt;
解决了多人协作的
      
    
    </summary>
    
      <category term="git" scheme="https://newpromise.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://newpromise.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝</title>
    <link href="https://newpromise.github.io/2021/03/03/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>https://newpromise.github.io/2021/03/03/深拷贝/</id>
    <published>2021-03-03T10:09:11.273Z</published>
    <updated>2021-03-04T03:35:48.341Z</updated>
    
    <content type="html"><![CDATA[深拷贝和浅拷贝的区别：<code>浅拷贝</code> : 当对于一个对象进行浅拷贝的时候，会创建一个新的对象，新对象包含有旧对象的所有属性，当属性值为基本类型时，拷贝的就是这个基本类型的值，当属性值为引用类型的时候，拷贝的是这个引用类型的内存地址<code>深拷贝</code>：将一个对象从内存中完整的拷贝出来，开辟一个新的区域存储新对象，并且修改新对象不会影响旧对象<h3 id="实现深拷贝">实现深拷贝</h3><ul><li>使用 <code>JSON.parse(JSON.stringify())</code>这种最简单的实现深拷贝的方法同时存在许多的缺点<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  date: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">  nan: <span class="literal">NaN</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>: <span class="title">new</span> <span class="title">Function</span>(<span class="params"></span>),</span></span><br><span class="line"><span class="function">  <span class="title">undefined</span>: <span class="title">undefined</span>,</span></span><br><span class="line"><span class="function">  <span class="title">regexp</span>: <span class="title">new</span> <span class="title">RegExp</span>(<span class="params"><span class="string">'\\w+'</span></span>),</span></span><br><span class="line"><span class="function">  <span class="title">symbol</span>: <span class="title">Symbol</span>(<span class="params"><span class="string">'symbol'</span></span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cloneObj = deepClone(obj)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cloneObj)</span><br><span class="line"><span class="comment">// 打印结果如下</span></span><br><span class="line">&#123; <span class="attr">date</span>: <span class="string">'2021-02-26T07:22:37.173Z'</span>, <span class="attr">nan</span>: <span class="literal">null</span>, <span class="attr">regexp</span>: &#123;&#125; &#125;</span><br></pre></td></tr></table></figure>使用这种方法进行深拷贝的时候，对于上面一些特殊的属性值，会出现拷贝异常的情况：<ul><li><code>undefined</code>, <code>symbol</code>, <code>函数</code> 会被忽略掉</li><li><code>NaN</code> 会被转换为 <code>null</code></li><li><code>regexp</code> 会被转换为 空对象</li><li><code>date</code> 对象会被转换为日期字符串</li></ul>同时，无法拷贝循环引用的对象</li><li>一种 <code>cloneDeep</code> 的方法：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> value === <span class="string">'object'</span> &amp;&amp; value !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> isArray = <span class="built_in">Array</span>.isArray(value)</span><br><span class="line">    <span class="keyword">let</span> result = isArray ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (isArray) &#123;</span><br><span class="line">      value.forEach(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        result.push(cloneDeep(val))</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> value) &#123;</span><br><span class="line">        result[k] = cloneDeep(value[k])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="lodash-中的-clonedeep-方法"><code>lodash</code> 中的 <code>cloneDeep</code> 方法</h3><h4 id="入口">入口</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> baseClone <span class="keyword">from</span> <span class="string">'./.internal/baseClone.js'</span></span><br><span class="line"><span class="keyword">const</span> CLONE_DEEP_FLAG = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> CLONE_SYMBOLS_FLAG = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>入口调用  <code>baseClone</code> 文件中的 <code>baseClone</code> 方法，向这个方法中传入了两个数据：<code>value</code>: 要进行复制的数据<code>CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG</code>:  掩码，表明使用 <code>baseClone</code> 来进行深拷贝以及 <code>symbol</code> 数据类型的拷贝<h4 id="baseclone"><code>baseClone</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The base implementation of `clone` and `cloneDeep` which tracks</span></span><br><span class="line"><span class="comment"> * traversed objects.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>value 需要克隆的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>bitmask 掩码标识</span></span><br><span class="line"><span class="comment"> *  1 - Deep clone</span></span><br><span class="line"><span class="comment"> *  2 - Flatten inherited properties</span></span><br><span class="line"><span class="comment"> *  4 - Clone symbols</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>[customizer] 定制 clone 的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>[key] value 的属性 key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>[object] 值的父对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>[stack] 用来追踪遍历的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;*&#125;</span> </span>Returns the cloned value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseClone</span>(<span class="params">value, bitmask, customizer, key, object, stack</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result</span><br><span class="line">  <span class="comment">// 三种克隆的配置值</span></span><br><span class="line">  <span class="keyword">const</span> isDeep = bitmask &amp; CLONE_DEEP_FLAG</span><br><span class="line">  <span class="keyword">const</span> isFlat = bitmask &amp; CLONE_FLAT_FLAG</span><br><span class="line">  <span class="keyword">const</span> isFull = bitmask &amp; CLONE_SYMBOLS_FLAG</span><br><span class="line">  <span class="comment">// 使用定制化的 clone 方法</span></span><br><span class="line">  <span class="keyword">if</span> (customizer) &#123;</span><br><span class="line">    result = object ? customizer(value, key, object, stack) : customizer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定制化的 clone 方法执行之后，返回结果</span></span><br><span class="line">  <span class="keyword">if</span> (result !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当非 引用类型的时候，返回值</span></span><br><span class="line">  <span class="keyword">if</span> (!isObject(value)) &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> isArr = <span class="built_in">Array</span>.isArray(value)</span><br><span class="line">  <span class="comment">// 获取当前数据的类型</span></span><br><span class="line">  <span class="keyword">const</span> tag = getTag(value)</span><br><span class="line">  <span class="keyword">if</span> (isArr) &#123;</span><br><span class="line">    <span class="comment">// 初始化 clone 数组</span></span><br><span class="line">    result = initCloneArray(value)</span><br><span class="line">    <span class="keyword">if</span> (!isDeep) &#123;</span><br><span class="line">      <span class="keyword">return</span> copyArray(value, result)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> isFunc = <span class="keyword">typeof</span> value === <span class="string">'function'</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当 value 是一种 buffer 数据的时候</span></span><br><span class="line">    <span class="keyword">if</span> (isBuffer(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> cloneBuffer(value, isDeep)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当当前的数据类型为 对象，参数对象，函数的时候</span></span><br><span class="line">    <span class="keyword">if</span> (tag == objectTag || tag == argsTag || (isFunc &amp;&amp; !object)) &#123;</span><br><span class="line">      <span class="comment">// 当是一个函数的时候，初始化为一个空对象，否则，调用 initCloneObject</span></span><br><span class="line">      result = (isFlat || isFunc) ? &#123;&#125; : initCloneObject(value)</span><br><span class="line">      <span class="keyword">if</span> (!isDeep) &#123;</span><br><span class="line">        <span class="keyword">return</span> isFlat</span><br><span class="line">          ? copySymbolsIn(value, copyObject(value, keysIn(value), result))</span><br><span class="line">          : copySymbols(value, <span class="built_in">Object</span>.assign(result, value))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 对于 typeof value === 'object' 但是 调用 `getTag` 方法并不是严格对象的值的处理</span></span><br><span class="line">      <span class="comment">// 例如：let n = new Number()</span></span><br><span class="line">      <span class="comment">// typeof n === 'number' but Object.prototype.toString.call(n) === '[object Number]'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isFunc || !cloneableTags[tag]) &#123;</span><br><span class="line">        <span class="keyword">return</span> object ? value : &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      result = initCloneByTag(value, tag, isDeep)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Check for circular references and return its corresponding clone.</span></span><br><span class="line">  <span class="comment">// 创建一个 Stack 的数据结果</span></span><br><span class="line">  <span class="comment">// 使用 stack 目的可以检查循环引用，返回对应的 clone 数据</span></span><br><span class="line">  stack || (stack = <span class="keyword">new</span> Stack)</span><br><span class="line">  <span class="keyword">const</span> stacked = stack.get(value)</span><br><span class="line">  <span class="keyword">if</span> (stacked) &#123;</span><br><span class="line">    <span class="keyword">return</span> stacked</span><br><span class="line">  &#125;</span><br><span class="line">  stack.set(value, result)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当当前数据为 map 结构的时候</span></span><br><span class="line">  <span class="comment">// result 为 map 数据</span></span><br><span class="line">  <span class="keyword">if</span> (tag == mapTag) &#123;</span><br><span class="line">    value.forEach(<span class="function">(<span class="params">subValue, key</span>) =&gt;</span> &#123;</span><br><span class="line">      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当 当前数据为。set 数据的时候</span></span><br><span class="line">  <span class="keyword">if</span> (tag == setTag) &#123;</span><br><span class="line">    value.forEach(<span class="function">(<span class="params">subValue</span>) =&gt;</span> &#123;</span><br><span class="line">      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isTypedArray(value)) &#123;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="keyword">const</span> keysFunc = isFull</span><br><span class="line">    ? (isFlat ? getAllKeysIn : getAllKeys)</span><br><span class="line">    : (isFlat ? keysIn : keys)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> props = isArr ? <span class="literal">undefined</span> : keysFunc(value)</span><br><span class="line">  arrayEach(props || value, (subValue, key) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (props) &#123;</span><br><span class="line">      key = subValue</span><br><span class="line">      subValue = value[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Recursively populate clone (susceptible to call stack limits).</span></span><br><span class="line">    <span class="comment">// 递归式的 clone</span></span><br><span class="line">    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack))</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> baseClone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="gettag"><code>getTag</code></h6><code>getTag</code> 方法用来获取元素的类型<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toString = <span class="built_in">Object</span>.prototype.toString</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets the `toStringTag` of `value`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>value The value to query.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;string&#125;</span> </span>Returns the `toStringTag`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTag</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value === <span class="literal">undefined</span> ? <span class="string">'[object Undefined]'</span> : <span class="string">'[object Null]'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> toString.call(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> getTag</span><br></pre></td></tr></table></figure><h6 id="initcloneobject"><code>initCloneObject</code></h6><code>initCloneObject</code> 用来初始化克隆对象：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// object 用来初始化克隆的对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initCloneObject</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当 object 为非原型对象的时候，返回一个对象，这个对象的继承 obj 的原型</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">typeof</span> object.constructor === <span class="string">'function'</span> &amp;&amp; !isPrototype(object))</span><br><span class="line">    ? <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(object))</span><br><span class="line">    : &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> initCloneObject</span><br></pre></td></tr></table></figure><h6 id="isprototype"><code>isPrototype</code></h6>判断 <code>value</code> 是否为原型，如果是，返回 <code>true</code>对于 <code>原型</code> 对象上面包含有 <code>constructor</code> 属性<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> objectProto = <span class="built_in">Object</span>.prototype</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Checks if `value` is likely a prototype object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>value The value to check.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;boolean&#125;</span> </span>Returns `true` if `value` is a prototype, else `false`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrototype</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Ctor = value &amp;&amp; value.constructor</span><br><span class="line">  <span class="keyword">const</span> proto = (<span class="keyword">typeof</span> Ctor === <span class="string">'function'</span> &amp;&amp; Ctor.prototype) || objectProto</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> value === proto</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>对于边界条件的处理：如果仅仅按照下面的代码进行判断是有问题的： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrototype</span>(<span class="params">vlaue</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> Ctor = value &amp;&amp; value.constructor</span><br><span class="line">  <span class="keyword">const</span> proto = (<span class="keyword">typeof</span> Ctor === <span class="string">'function'</span> &amp;&amp; Ctor.prototype)</span><br><span class="line">  <span class="keyword">return</span> value === proto</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>如果我们传入一个 <code>false</code>,  <code>isPrototype</code> 返回的结果为 <code>true</code>, 与结果不符合，因此设置 一个 objectProto 来防止这种情况]]></content>
    
    <summary type="html">
    
      
      
        深拷贝和浅拷贝的区别：&lt;code&gt;浅拷贝&lt;/code&gt; : 当对于一个对象进行浅拷贝的时候，会创建一个新的对象，新对象包含有旧对象的所有属性，当属性值为基本类型时，拷贝的就是这个基本类型的值，当属性值为引用类型的时候，拷贝的是这个引用类型的内存地址&lt;code&gt;深拷贝&lt;/code&gt;
      
    
    </summary>
    
      <category term="js" scheme="https://newpromise.github.io/categories/js/"/>
    
    
      <category term="深拷贝" scheme="https://newpromise.github.io/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>协商缓存和强缓存</title>
    <link href="https://newpromise.github.io/2020/09/26/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E5%92%8C%E5%BC%BA%E7%BC%93%E5%AD%98/"/>
    <id>https://newpromise.github.io/2020/09/26/协商缓存和强缓存/</id>
    <published>2020-09-26T04:15:09.000Z</published>
    <updated>2021-03-04T07:57:54.780Z</updated>
    
    <content type="html"><![CDATA[缓存是指代理服务器或者客户端本地磁盘内保存的资源副本。使用缓存可以减少对于源服务器的访问，从而节省通信流量和通信时间。在服务器与客户端的通信过程中，对于数据的缓存方式可以分为 <strong>强缓存</strong> 和 <strong>协商缓存</strong> 两种，通过http请求头中的 <code>Cache-Control</code> 可以决定是否采用上面两种方式缓存涉及到的相关字段有：<code>Cache-Control</code>  <code>Expires</code>  <code>Last-Modified</code> <code>If-Modified-Since</code> <code>Etag</code>  <code>If-None-Match</code><h3 id="强缓存">强缓存</h3>强缓存就是当客户端发起请求之前，首先检查浏览器缓存中是否有要请求的内容，并且根据结果的缓存规则来判断是否实际向服务器发起请求客户端发起请求时，会有下面三种结果：<ol><li>没有缓存结果，那么需要向服务器请求内容</li><li>存在缓存结果，并且缓存规则未失效，那么直接使用缓存的内容</li><li>存在缓存结果，但缓存规则已经失效，那么也需要重新向服务器请求内容，效果同 1</li></ol>使用请求返回头中的：<code>Cache-Control</code> 字段来配置缓存的行为：<ul><li><code>public</code>:  可以向任意方提供响应的缓存，发送请求的客户端或者代理服务器都可以缓存数据</li><li><code>private</code>: 只有浏览器才能缓存内容</li><li><code>no-cache</code>: 强制所有缓存了该响应的用户，在使用已经缓存的数据前，发送带有验证的请求到服务器，需要等待服务器确认之后，才能使用浏览器缓存</li><li><code>no-store</code>: 不进行缓存，每次请求都需要向服务器重新请求数据</li><li><code>max-age</code>: 指定资源的缓存时间，在客户端请求头中添加时，表示如果缓存资源的缓存时间数值比设置的 <code>max-age</code> 的数值小的话，那么客户端就接收缓存的资源当服务器响应头中添加时，表示当前返回的资源内容在浏览器中的最大缓存时间，在没有禁用缓存并且没有超过有效时间的情况下，再次访问这个资源就命中了缓存，不会向服务器请求资源而是直接从浏览器缓存中取。</li></ul><h3 id="协商缓存">协商缓存</h3>协商缓存就是当强制缓存失效后，客户端和服务器根据请求头或者响应头的相关字段来判断是否采用浏览器缓存的资源，因为有可能客户端请求的资源过了有效期，但是此时资源内容和服务器上的资源没有差别，仍然可以使用浏览器缓存资源来避免再次请求服务器资源协商缓存是由服务器来决定是否使用缓存的因此关键是：<strong>如何判断服务器上的资源和浏览器上缓存的资源是不是相同的</strong>，下面的两种方式分别是根据文件修改时间和文件唯一标识来判断的，两种方式：<ul><li><strong>Last-modified/If-Modified-Since</strong>这两个字段是一种时间戳的形式字符串服务器响应头中带有： Last-modified 表示资源最后被修改的时间，当客户端再次请求相同资源时，在请求头中添加 <code>If-Modified-Since</code> 字段为上次请求资源时服务器返回的资源最后修改时间，服务器收到请求之后，会将 <code>If-Modified-Since</code> 的时间与  <code>Last-modified</code> 进行对比，如果不一致，则重新请求资源，如果一致，那么使用浏览器缓存的资源（304）</li><li><strong>Etag/If-None-Match</strong>这两个值都是请求当前资源文件的唯一标识，这个标识是由服务器生成的类似于上面的过程，<code>Etag</code> 由服务器返回，<code>If-None-Match</code> 是再次请求资源时添加在请求头中的字段，值是上次请求时返回头中返回的 <code>Etag</code> 字段的值，在服务器中，根据 <code>If-None-Match</code>的字段值与该资源在服务器的Etag值做对比，如果不一致，重新请求资源，如果一致，同样使用浏览器缓存资源（304）</li></ul><blockquote>在 http 中，状态码 304 （Not Modified）返回的内容为空，因为这个时候表示当前请求的资源和服务器上的资源一致，可以直接使用浏览器缓存的内容</blockquote><h3 id="总结">总结</h3>概括来说：<strong>强缓存</strong>是直接使用浏览器内缓存的内容，使用到的字段有：<strong>Expires</strong> 或者 <strong>Cache-Control: max-age=3600</strong> (表示资源的缓存时间是 3600 s)<strong>协商缓存</strong>是需要服务器参与确认是否使用浏览器缓存的内容的机制，应用在强缓存失效之后这个过程可以用下面的示意图来说明：<img src="1.png" loading="lazy"><img src="/2020/09/26/协商缓存和强缓存/1.png">]]></content>
    
    <summary type="html">
    
      
      
        缓存是指代理服务器或者客户端本地磁盘内保存的资源副本。使用缓存可以减少对于源服务器的访问，从而节省通信流量和通信时间。在服务器与客户端的通信过程中，对于数据的缓存方式可以分为 &lt;strong&gt;强缓存&lt;/strong&gt; 和 &lt;strong&gt;协商缓存&lt;/strong&gt; 两种，通过ht
      
    
    </summary>
    
      <category term="http" scheme="https://newpromise.github.io/categories/http/"/>
    
    
      <category term="缓存" scheme="https://newpromise.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>axios + vue 实现页面销毁时请求取消</title>
    <link href="https://newpromise.github.io/2020/09/22/axios%20+%20vue%20%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E9%94%80%E6%AF%81%E6%97%B6%E8%AF%B7%E6%B1%82%E5%8F%96%E6%B6%88/"/>
    <id>https://newpromise.github.io/2020/09/22/axios + vue 实现页面销毁时请求取消/</id>
    <published>2020-09-22T13:28:39.000Z</published>
    <updated>2021-03-03T10:09:11.236Z</updated>
    
    <content type="html"><![CDATA[在日常的开发中，会遇到这样的需求：我们想要当离开当前页面的时候， 这个页面上的请求的接口不会继续请求使用 <code>vue</code> + <code>axios</code> 来实现手动取消请求的功能：代码如下：<code>cancelRequest.js</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(axiosIns, cancelList) &#123;</span><br><span class="line">    <span class="keyword">this</span>.axiosIns = axiosIns</span><br><span class="line">    <span class="keyword">this</span>.cancelList = cancelList || []</span><br><span class="line">    <span class="keyword">const</span> handlersCount = <span class="keyword">this</span>.getAllHandlers().length</span><br><span class="line">    <span class="keyword">this</span>.handlerIndex = handlersCount ? handlersCount - <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">    <span class="keyword">this</span>.insertInterceptors = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  getCancelKeys() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.cancelList.map(<span class="function">(<span class="params">&#123; key &#125;</span>) =&gt;</span> key)</span><br><span class="line">  &#125;</span><br><span class="line">  hasKey(key) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getCancelKeys().includes(key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span>(cancelKey) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.cancelList.find(<span class="function">(<span class="params">&#123; key &#125;</span>) =&gt;</span> cancelKey === key)</span><br><span class="line">  &#125;</span><br><span class="line">  getAllHandlers() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.cancelList.reduce(<span class="function">(<span class="params">allHandlers, &#123; handlerList &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      allHandlers = [...allHandlers, ...handlerList]</span><br><span class="line">      <span class="keyword">return</span> allHandlers</span><br><span class="line">    &#125;, [])</span><br><span class="line">  &#125;</span><br><span class="line">  getHandlers(cancelKey) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.hasKey(cancelKey)) &#123;</span><br><span class="line">      <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.get(cancelKey).handlerList</span><br><span class="line">  &#125;</span><br><span class="line">  removeInsertInterceptors() &#123;</span><br><span class="line">    <span class="keyword">const</span> interceptors = <span class="keyword">this</span>.axiosIns.interceptors</span><br><span class="line">    <span class="built_in">Object</span>.entries(<span class="keyword">this</span>.insertInterceptors).forEach(<span class="function">(<span class="params">[type, incpts]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> handlers = interceptors[type].handlers</span><br><span class="line">      incpts.forEach(<span class="function"><span class="params">interceptor</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> incptIndex = handlers.indexOf(interceptor)</span><br><span class="line">        <span class="keyword">if</span> (incptIndex !== <span class="number">-1</span>) &#123;</span><br><span class="line">          interceptors[type].handlers.splice(incptIndex, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.insertInterceptors = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  removeHandler(removeKey, handlerIndex) &#123;</span><br><span class="line">    <span class="keyword">const</span> handlerList = <span class="keyword">this</span>.getHandlers(removeKey)</span><br><span class="line">    handlerList.length &amp;&amp; handlerList.splice(handlerIndex, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (!handlerList.length) &#123;</span><br><span class="line">      <span class="keyword">this</span>.remove(removeKey)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  remove(key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.hasKey(key)) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">const</span> keyIndex = <span class="keyword">this</span>.getCancelKeys().indexOf(key)</span><br><span class="line">    <span class="keyword">this</span>.cancelList.splice(keyIndex, <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  cancel(key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> handlerList = <span class="keyword">this</span>.getHandlers(key)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; handlerList.length; i++) &#123;</span><br><span class="line">        handlerList[i]()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.remove(key)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> handlerList = <span class="keyword">this</span>.getAllHandlers()</span><br><span class="line">      handlerList.forEach(<span class="function"><span class="params">handler</span> =&gt;</span> handler())</span><br><span class="line">      <span class="keyword">this</span>.cancelList = []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  add(cancelObj) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; key, handler &#125; = cancelObj</span><br><span class="line">    <span class="keyword">this</span>.handlerIndex++</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.hasKey(key)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.cancelList.push(&#123; key, <span class="attr">handlerList</span>: [handler] &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> existHandlers = <span class="keyword">this</span>.getHandlers(key)</span><br><span class="line">      <span class="keyword">this</span>.get(key).handlerList = [...existHandlers, handler]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CancelRequest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(config) &#123;</span><br><span class="line">    <span class="keyword">const</span> defaultConfig = &#123;</span><br><span class="line">      vm: <span class="literal">null</span>,</span><br><span class="line">      includes: []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.config = <span class="built_in">Object</span>.assign(&#123;&#125;, defaultConfig, config)</span><br><span class="line">    <span class="keyword">this</span>.cancelReqCollectorList = []</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.config.vm) &#123;</span><br><span class="line">      <span class="keyword">this</span>._vmDestroyedCancel()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(<span class="string">'config vm is null, request will not be canceld when component destroyed'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  getAllAxiosInstance() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.cancelReqCollectorList.map(<span class="function">(<span class="params">&#123; axiosIns &#125;</span>) =&gt;</span> axiosIns)</span><br><span class="line">  &#125;</span><br><span class="line">  getCollector(instance) &#123;</span><br><span class="line">    <span class="keyword">let</span> existCollector = <span class="keyword">this</span>.cancelReqCollectorList.find(<span class="function">(<span class="params">&#123; axiosIns &#125;</span>) =&gt;</span> axiosIns === instance)</span><br><span class="line">    <span class="keyword">if</span> (!existCollector) &#123;</span><br><span class="line">      existCollector = <span class="keyword">new</span> Collector(instance)</span><br><span class="line">      <span class="keyword">this</span>.cancelReqCollectorList.push(existCollector)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> existCollector</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 拦截 vue 中的 _isDestroyed 属性， 当组件销毁时，取消请求</span></span><br><span class="line">  _vmDestroyedCancel() &#123;</span><br><span class="line">    <span class="keyword">let</span> isDestroyed = <span class="keyword">this</span>.config.vm._isDestroyed</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>.config.vm, <span class="string">'_isDestroyed'</span>, &#123;</span><br><span class="line">      <span class="keyword">set</span>: val =&gt; &#123;</span><br><span class="line">        isDestroyed = val</span><br><span class="line">        <span class="keyword">if</span> (val) <span class="keyword">this</span>.cancel(<span class="literal">true</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> isDestroyed</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  getTokenKey(config) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; baseURL, url &#125; = config</span><br><span class="line">    <span class="keyword">if</span> (url.startsWith(<span class="string">'http'</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> url</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;baseURL&#125;</span><span class="subst">$&#123;url&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">  getSource() &#123;</span><br><span class="line">    <span class="keyword">const</span> cancelToken = axios.CancelToken</span><br><span class="line">    <span class="keyword">let</span> source = cancelToken.source()</span><br><span class="line">    <span class="keyword">return</span> source</span><br><span class="line">  &#125;</span><br><span class="line">  insertInterceptor(interceptors, collector) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; request, response &#125; = interceptors</span><br><span class="line">    <span class="keyword">const</span> requestInt = &#123;</span><br><span class="line">      fulfilled: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> setKey = <span class="keyword">this</span>.getTokenKey(config)</span><br><span class="line">        <span class="keyword">const</span> source = <span class="keyword">this</span>.getSource()</span><br><span class="line">        <span class="keyword">const</span> isValidIncludes = <span class="built_in">Array</span>.isArray(<span class="keyword">this</span>.config.includes) &amp;&amp; <span class="keyword">this</span>.config.includes.length</span><br><span class="line">        <span class="keyword">const</span> isMatch = isValidIncludes &amp;&amp; <span class="keyword">this</span>.config.includes.some(<span class="function"><span class="params">includeKey</span> =&gt;</span> setKey.includes(includeKey))</span><br><span class="line">        <span class="keyword">if</span> (!isValidIncludes || isMatch) &#123;</span><br><span class="line">          config.cancelToken = source.token</span><br><span class="line">          collector.add(&#123; <span class="attr">key</span>: setKey, <span class="attr">handler</span>: source.cancel &#125;)</span><br><span class="line">          config.cancelHandlerIndex = collector.handlerIndex</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config</span><br><span class="line">      &#125;,</span><br><span class="line">      rejected: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> successRespInt = &#123;</span><br><span class="line">      fulfilled: <span class="function"><span class="params">resp</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> handlerIndex = resp.config.cancelHandlerIndex</span><br><span class="line">        <span class="keyword">const</span> removeKey = <span class="keyword">this</span>.getTokenKey(resp.config)</span><br><span class="line">        collector.remove(removeKey, handlerIndex)</span><br><span class="line">        <span class="keyword">return</span> resp</span><br><span class="line">      &#125;,</span><br><span class="line">      rejected: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> errorRespInt = &#123;</span><br><span class="line">      fulfilled: <span class="literal">null</span>,</span><br><span class="line">      rejected: <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> isCancel = axios.isCancel(error)</span><br><span class="line">        <span class="keyword">if</span> (!isCancel) &#123;</span><br><span class="line">          <span class="keyword">const</span> handlerIndex = error.config.cancelHandlerIndex</span><br><span class="line">          collector.remove(<span class="keyword">this</span>.getTokenKey(error.config), handlerIndex)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    collector.insertInterceptors = &#123;</span><br><span class="line">      request: [requestInt],</span><br><span class="line">      response: [successRespInt, errorRespInt]</span><br><span class="line">    &#125;</span><br><span class="line">    request.handlers.unshift(requestInt)</span><br><span class="line">    response.handlers.unshift(successRespInt, errorRespInt)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向 axios 实例中注入token</span></span><br><span class="line">  insertToken(axiosInstance) &#123;</span><br><span class="line">    <span class="keyword">const</span> collector = <span class="keyword">this</span>.getCollector(axiosInstance)</span><br><span class="line">    <span class="keyword">const</span> interceptors = axiosInstance.interceptors</span><br><span class="line">    <span class="keyword">this</span>.insertInterceptor(interceptors, collector)</span><br><span class="line">    <span class="keyword">return</span> collector</span><br><span class="line">  &#125;</span><br><span class="line">  cancel(isDestroyed) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cancelReqCollectorList.forEach(<span class="function"><span class="params">collector</span> =&gt;</span> &#123;</span><br><span class="line">      collector.cancel()</span><br><span class="line">      <span class="keyword">if</span> (isDestroyed) &#123;</span><br><span class="line">        collector.removeInsertInterceptors()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (isDestroyed) &#123;</span><br><span class="line">      <span class="keyword">this</span>.cancelReqCollectorList = []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> CancelRequest</span><br></pre></td></tr></table></figure>使用方法如下：在组件中<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http = axios.create()</span><br><span class="line"><span class="comment">// this 为当前组件对象</span></span><br><span class="line"><span class="comment">// 在使用 http 来请求时，调用下面的方法</span></span><br><span class="line"><span class="keyword">const</span> cancelRes = <span class="keyword">new</span> CancelRequest(&#123; <span class="attr">vm</span>: <span class="keyword">this</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> cancelCollector = cancelRes.insertToken(http)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当需要取消请求时：</span></span><br><span class="line"><span class="comment">// 使用 cancel 方法来取消使用 http axios 实例来发起的请求</span></span><br><span class="line">cancelCollector.cancel() </span><br><span class="line"><span class="comment">// 或者传入配置 vm: this 时</span></span><br><span class="line"><span class="comment">// 当当前页面销毁时，会自动将当前页面正在发起的请求 cancel 掉</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        在日常的开发中，会遇到这样的需求：我们想要当离开当前页面的时候， 这个页面上的请求的接口不会继续请求使用 &lt;code&gt;vue&lt;/code&gt; + &lt;code&gt;axios&lt;/code&gt; 来实现手动取消请求的功能：代码如下：&lt;code&gt;cancelRequest.js&lt;/code&gt;&lt;f
      
    
    </summary>
    
      <category term="代码" scheme="https://newpromise.github.io/categories/%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="cancel request" scheme="https://newpromise.github.io/tags/cancel-request/"/>
    
  </entry>
  
  <entry>
    <title>排序算法（一）（选择，插入，冒泡，归并，快速）</title>
    <link href="https://newpromise.github.io/2020/09/20/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%88%E9%80%89%E6%8B%A9%EF%BC%8C%E6%8F%92%E5%85%A5%EF%BC%8C%E5%86%92%E6%B3%A1%EF%BC%8C%E5%BD%92%E5%B9%B6%EF%BC%8C%E5%BF%AB%E9%80%9F%EF%BC%89/"/>
    <id>https://newpromise.github.io/2020/09/20/排序算法（一）（选择，插入，冒泡，归并，快速）/</id>
    <published>2020-09-20T13:13:09.000Z</published>
    <updated>2021-03-04T07:34:47.845Z</updated>
    
    <content type="html"><![CDATA[下面是选择排序，插入排序，冒泡排序，归并排序，快速排序五种算法的原理以及具体的代码实现<h3 id="选择排序">选择排序</h3><ol><li>从数组中选取一个元素 item，初次为第一个元素</li><li>在 item 剩余的元素中找到最小的元素</li><li>将这个最小的元素与 item 交换位置</li><li>重复 1，2， 3的过程，一直到数组结束</li></ol>示意图如下<img src="1.png" loading="lazy">代码如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">let</span> minIdx = i;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[i];</span><br><span class="line">        <span class="comment">// 从剩余的元素中查找到最小的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.length; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIdx]) &#123;</span><br><span class="line">                minIdx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = arr[minIdx];</span><br><span class="line">        arr[minIdx] = temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序">插入排序</h3><ol><li>从数组中的第二个元素开始抽取元素 item</li><li>将 item 与 item 左边第一个元素进行比较，如果左边的元素大于item，那么继续与左边第二个元素继续比较，直到遇到不大于item 的元素，然后将这个元素插入到 item 的右边</li><li>继续选取第 3， 4， 5 个元素， 重复 2 过程， 直到数组结束</li></ol>示意图如下<img src="2.png" loading="lazy">代码如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">let</span> k = i;</span><br><span class="line">        <span class="keyword">let</span> item = arr[i]</span><br><span class="line">        <span class="keyword">while</span> (k &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            k --;</span><br><span class="line">            <span class="comment">// 当找到比当前要插入的元素小的元素时</span></span><br><span class="line">            <span class="comment">// 将插入元素插入到小元素的右边</span></span><br><span class="line">            <span class="comment">// 或者 k &lt; 0 时，这个时候表示找到最左边</span></span><br><span class="line">            <span class="comment">// 都没有找到比 arr[i] 还要小的元素</span></span><br><span class="line">            <span class="keyword">if</span> (item &gt; arr[k] || k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                arr[k + <span class="number">1</span>] = item;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 整体向右边移</span></span><br><span class="line">                arr[k + <span class="number">1</span>] = arr[k]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序">冒泡排序</h3><ol><li>将第一个元素与第二个元素进行比较，如果第一个元素比第二个大，那么交换他们的位置，接着继续比较第二个元素和第三个元素</li><li>经过一轮比较之后，现在最右边的元素是数组里面最大的元素</li><li>除去最右边已经筛选后的元素之后，再对剩余的元素执行 1 过程</li></ol>示意图如下<img src="3.png" loading="lazy">代码如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr, sortedIndex = arr.length - <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> nextIdx = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; arr[nextIdx]) &#123;</span><br><span class="line">            <span class="keyword">let</span> temp = arr[i]</span><br><span class="line">            arr[i] = arr[nextIdx]</span><br><span class="line">            arr[nextIdx] = temp</span><br><span class="line">        &#125;</span><br><span class="line">        i ++</span><br><span class="line">    &#125;</span><br><span class="line">    sortedIndex --</span><br><span class="line">    <span class="keyword">return</span>  sortedIndex === <span class="number">0</span> ? arr : bubbleSort(arr, sortedIndex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序">归并排序</h3><ol><li>将大数组拆分为小数组，再拆分小数组，一直拆分到数组内只有一个元素</li><li>对于小数组内的元素进行排序操作，然后将小数组进行组合</li><li>最后组合的大数组为已经排好序的数组</li></ol>示意图如下：<img src="4.png" loading="lazy">代码如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">arr, left, mid, right</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(right - left + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> i = left;</span><br><span class="line"><span class="keyword">let</span> j = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 将两个数组进行组合</span></span><br><span class="line">  <span class="comment">// 这两个数组分别为 arr[left, ... mid] 以及 arr[mid + 1, ... right]</span></span><br><span class="line"><span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">a[k++] = arr[i++]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">a[k++] = arr[j++]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当还有剩余的 i 数组元素时</span></span><br><span class="line">  <span class="comment">// 压入数组中</span></span><br><span class="line"><span class="keyword">while</span>(i &lt;= mid) &#123;</span><br><span class="line">a[k++] = a[i++]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当还有剩余的 j 数组元素时</span></span><br><span class="line">  <span class="comment">// 同样压入数组中</span></span><br><span class="line"><span class="keyword">while</span>(j &lt;= right) &#123;</span><br><span class="line">a[k++] = a[j++]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将排好序的 a 数组复制到 arr 中</span></span><br><span class="line">  <span class="comment">// 这里的数组 a 已经排好序了</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; k; i ++) &#123;</span><br><span class="line">arr[left ++] = a[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left !== right) &#123;</span><br><span class="line"><span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((right + left) / <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 对于左边的元素进行排序</span></span><br><span class="line">arr = mergeSort(arr, left, mid)</span><br><span class="line">    <span class="comment">// 对于右边的元素进行排序</span></span><br><span class="line">    arr = mergeSort(arr, mid + <span class="number">1</span>, right)</span><br><span class="line">merge(arr, left, mid, right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序">快速排序</h3><ol><li>选取数组中的一个元素为中轴元素，将数组中所有小于中轴元素的元素放在左边，所有大于或者等于中轴元素的元素放在右边</li><li>进行完过程 1 之后，这时候中轴元素的位置已经确定了，这个元素左边都是比它小的元素，右边都是比它大的元素</li><li>对于中轴元素左右两边的元素再分别进行 1 过程，直到所有的元素作为中轴元素位置都确定了为止</li></ol>示意图如下：<img src="5.png" 我是一张图片"" loading="lazy">代码如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pivot = arr[left]</span><br><span class="line">    <span class="keyword">let</span> i = left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> j = right;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j &amp;&amp; arr[i] &lt;= pivot) &#123;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j &amp;&amp; arr[j] &gt;= pivot) &#123;</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[i]</span><br><span class="line">        arr[i] = arr[j]</span><br><span class="line">        arr[j] = temp</span><br><span class="line">    &#125;</span><br><span class="line">    arr[left] = arr[j]</span><br><span class="line">    arr[j] = pivot</span><br><span class="line">    <span class="keyword">return</span> j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = partition(arr, left, right)</span><br><span class="line">        arr = quickSort(arr, left, mid - <span class="number">1</span>)</span><br><span class="line">        arr = quickSort(arr, mid + <span class="number">1</span>, right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        下面是选择排序，插入排序，冒泡排序，归并排序，快速排序五种算法的原理以及具体的代码实现&lt;h3 id=&quot;选择排序&quot;&gt;选择排序&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;从数组中选取一个元素 item，初次为第一个元素&lt;/li&gt;
&lt;li&gt;在 item 剩余的元素中找到最小的元素&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="算法" scheme="https://newpromise.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="https://newpromise.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>node中的 events 模块</title>
    <link href="https://newpromise.github.io/2020/09/14/node%E4%B8%AD%E7%9A%84%20events%20%E6%A8%A1%E5%9D%97/"/>
    <id>https://newpromise.github.io/2020/09/14/node中的 events 模块/</id>
    <published>2020-09-14T03:31:54.000Z</published>
    <updated>2021-03-04T07:57:25.610Z</updated>
    
    <content type="html"><![CDATA[了解 Node 中的 Events 模块node 中的 events 模块是 node 中使用较多的模块，比如在 node 中的流（stream），其内部使用 <code>events</code> 模块作为父类：<img src="/2020/09/14/node中的%20events%20模块/image-20200803102619367.png">作为一个使用广泛的基础模块，其代码中是有些东西值得我们学习和借鉴的。<h4 id="发布订阅模式">发布/订阅模式</h4>发布/订阅模式定义了一种一对多的依赖关系，观察者同时监听某一个对象相应的状态变化， 当状态变化时通知到所有观察者， 这种设计模式解决了主体对象和观察者之间的耦合问题。图示如下： <img src="/2020/09/14/node中的%20events%20模块/eventsPic.jpg"><em>上图中左边为观察者模式， 右边为 发布/订阅 模式， 可以看出它们之间的区别是发布/订阅模式通过事件调度中心（Event Channel）来对于事件进行统一管理</em>观察上图可知，发布/订阅这种设计模式的组成特点：<ul><li>整体结构有三部分组成， 订阅者（Subscriber）, 发布者（Publisher）以及 事件调度器（Event Channel）</li><li>订阅者在事件调度器中订阅（Subscribe）事件， 发布者发布事件时，订阅该事件的订阅者将会收到消息通知（事件触发的形式）</li></ul>在 Node 中的 Events 模块中， 采用了这种设计模式，模块内部维护了一个事件列表（<code>_events</code>）,提供了基础的 api 来进行发布和订阅（<code>emit</code>, <code>on</code>）在 Events 中，订阅事件时需要传入两个参数： 事件名（eventName）以及 事件触发时的回调方法（listener），订阅之后按照下面的结构存储在 <code>_events</code> 中：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_events = &#123;</span><br><span class="line">  eventName: listener, wrapFn &#123; <span class="attr">fired</span>: <span class="literal">false</span>/<span class="literal">true</span>, listener &#125;</span><br><span class="line">eventName: [listener1, listener2 ....]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>当调用 <code>this.emit(eventName)</code> 来发布特定事件时，将会依次调用<code>_events</code> 中的事件（<code>listener</code>）<h4 id="events-模块代码实现">Events 模块代码实现</h4><ol><li><code>on</code> / <code>addListener(eventName, listener)</code>这个方法的作用是订阅<code>eventName</code> 事件, 当事件被发布时， <code>listener</code> 方法被执行具体代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅事件</span></span><br><span class="line"><span class="comment">// target: EventEmitter 实例</span></span><br><span class="line"><span class="comment">// type: 事件类型</span></span><br><span class="line"><span class="comment">// listener: 事件触发后的回调方法</span></span><br><span class="line"><span class="comment">// prepend: 是否将回调方法前置（首先触发）,默认为 false, 将会被放到回调方法的最后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_addListener</span>(<span class="params">target, type, listener, prepend</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m;</span><br><span class="line">  <span class="keyword">var</span> events;</span><br><span class="line">  <span class="keyword">var</span> existing;</span><br><span class="line">  <span class="comment">// 判断是否为有效的函数    </span></span><br><span class="line">  checkListener(listener);</span><br><span class="line"></span><br><span class="line">  events = target._events;</span><br><span class="line">  <span class="keyword">if</span> (events === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    events = target._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    target._eventsCount = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// To avoid recursion in the case that type === "newListener"! Before</span></span><br><span class="line">    <span class="comment">// adding it to the listeners, first emit "newListener".</span></span><br><span class="line">    <span class="keyword">if</span> (events.newListener !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      target.emit(<span class="string">'newListener'</span>, type,</span><br><span class="line">                  listener.listener ? listener.listener : listener);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Re-assign `events` because a newListener handler could have caused the</span></span><br><span class="line">      <span class="comment">// this._events to be assigned to a new object</span></span><br><span class="line">      events = target._events;</span><br><span class="line">    &#125;</span><br><span class="line">    existing = events[type];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (existing === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// Optimize the case of one listener. Don't need the extra array object.</span></span><br><span class="line">    <span class="comment">// 只有一个 listener 的情况， 存储的直接是这个函数</span></span><br><span class="line">    existing = events[type] = listener;</span><br><span class="line">    ++target._eventsCount;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> existing === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// Adding the second element, need to change to array.</span></span><br><span class="line">      existing = events[type] =</span><br><span class="line">        prepend ? [listener, existing] : [existing, listener];</span><br><span class="line">      <span class="comment">// If we've already got an array, just append.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prepend) &#123;</span><br><span class="line">      existing.unshift(listener);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      existing.push(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for listener leak</span></span><br><span class="line">    <span class="comment">// 获取到一个事件最多的 listener 数量</span></span><br><span class="line">    m = _getMaxListeners(target);</span><br><span class="line">    <span class="keyword">if</span> (m &gt; <span class="number">0</span> &amp;&amp; existing.length &gt; m &amp;&amp; !existing.warned) &#123;</span><br><span class="line">      existing.warned = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// No error code for this since it is a Warning</span></span><br><span class="line">      <span class="comment">// eslint-disable-next-line no-restricted-syntax</span></span><br><span class="line">      <span class="keyword">var</span> w = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Possible EventEmitter memory leak detected. '</span> +</span><br><span class="line">                          existing.length + <span class="string">' '</span> + <span class="built_in">String</span>(type) + <span class="string">' listeners '</span> +</span><br><span class="line">                          <span class="string">'added. Use emitter.setMaxListeners() to '</span> +</span><br><span class="line">                          <span class="string">'increase limit'</span>);</span><br><span class="line">      w.name = <span class="string">'MaxListenersExceededWarning'</span>;</span><br><span class="line">      w.emitter = target;</span><br><span class="line">      w.type = type;</span><br><span class="line">      w.count = existing.length;</span><br><span class="line">      ProcessEmitWarning(w);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.addListener = <span class="function"><span class="keyword">function</span> <span class="title">addListener</span>(<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _addListener(<span class="keyword">this</span>, type, listener, <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.on = EventEmitter.prototype.addListener</span><br></pre></td></tr></table></figure></li><li><code>emit(eventName[, ...args])</code>作用：发布 <code>eventName</code> 事件， 传入的 args 将会作为该事件下 <code>listener</code> 的参数代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里包含了 type 为 "error" 或者其他需要 emit 的触发</span></span><br><span class="line">EventEmitter.prototype.emit = <span class="function"><span class="keyword">function</span> <span class="title">emit</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">  <span class="keyword">var</span> doError = (type === <span class="string">'error'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> events = <span class="keyword">this</span>._events;</span><br><span class="line">  <span class="comment">// 当 events 存在的时候</span></span><br><span class="line">  <span class="keyword">if</span> (events !== <span class="literal">undefined</span>)</span><br><span class="line">    <span class="comment">// 当 events 中不存在 error 事件时还 emit 了 error 事件</span></span><br><span class="line">    doError = (doError &amp;&amp; events.error === <span class="literal">undefined</span>);</span><br><span class="line">  <span class="comment">// 当 events 不存在， 并且 type 为非 error时， 直接返回 false</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!doError)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If there is no 'error' event listener then throw.</span></span><br><span class="line">  <span class="comment">// events 中没有 error 的时候</span></span><br><span class="line">  <span class="keyword">if</span> (doError) &#123;</span><br><span class="line">    <span class="keyword">var</span> er;</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>)</span><br><span class="line">      er = args[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (er <span class="keyword">instanceof</span> <span class="built_in">Error</span>) &#123;</span><br><span class="line">      <span class="comment">// Note: The comments on the `throw` lines are intentional, they show</span></span><br><span class="line">      <span class="comment">// up in Node's output if this results in an unhandled exception.</span></span><br><span class="line">      <span class="keyword">throw</span> er; <span class="comment">// Unhandled 'error' event</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// At least give some kind of context to the user</span></span><br><span class="line">    <span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Unhandled error.'</span> + (er ? <span class="string">' ('</span> + er.message + <span class="string">')'</span> : <span class="string">''</span>));</span><br><span class="line">    err.context = er;</span><br><span class="line">    <span class="keyword">throw</span> err; <span class="comment">// Unhandled 'error' event</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> handler = events[type];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (handler === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> handler === <span class="string">'function'</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    ReflectApply(handler, <span class="keyword">this</span>, args);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> len = handler.length;</span><br><span class="line">    <span class="keyword">var</span> listeners = arrayClone(handler, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">      ReflectApply(listeners[i], <span class="keyword">this</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><code>off</code> / <code>removeListener(eventName, listener)</code>作用： 从事件名为 <code>eventName</code> 的事件下移除特定的回调方法（<code>listener</code>）代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Emits a 'removeListener' event if and only if the listener was removed.</span></span><br><span class="line"><span class="comment">// 移除特定事件的 listener &amp;&amp; </span></span><br><span class="line"><span class="comment">// EventEmitter.on('removeListener'， handler) 触发</span></span><br><span class="line"><span class="comment">// type: 特定事件名称</span></span><br><span class="line"><span class="comment">// listener: 移除的函数</span></span><br><span class="line">EventEmitter.prototype.removeListener =</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">removeListener</span>(<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> list, events, position, i, originalListener;</span><br><span class="line"></span><br><span class="line">      checkListener(listener);</span><br><span class="line"></span><br><span class="line">      events = <span class="keyword">this</span>._events;</span><br><span class="line">      <span class="keyword">if</span> (events === <span class="literal">undefined</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">      list = events[type];</span><br><span class="line">      <span class="keyword">if</span> (list === <span class="literal">undefined</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 这里判断是否 list 中只有一个 listener 或者 list 是 wrap fn 的情况</span></span><br><span class="line">      <span class="keyword">if</span> (list === listener || list.listener === listener) &#123;</span><br><span class="line">        <span class="keyword">if</span> (--<span class="keyword">this</span>._eventsCount === <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">delete</span> events[type];</span><br><span class="line">          <span class="keyword">if</span> (events.removeListener)</span><br><span class="line">            <span class="keyword">this</span>.emit(<span class="string">'removeListener'</span>, type, list.listener || listener);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当 list 不是一个函数的时候，这个时候这个 list 是一个数组</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> list !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        position = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = list.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">          <span class="keyword">if</span> (list[i] === listener || list[i].listener === listener) &#123;</span><br><span class="line">            originalListener = list[i].listener;</span><br><span class="line">            position = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找不到listener</span></span><br><span class="line">        <span class="keyword">if</span> (position &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">          <span class="comment">// 第一个是要找到的 listener</span></span><br><span class="line">        <span class="keyword">if</span> (position === <span class="number">0</span>)</span><br><span class="line">          list.shift();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如果要进行删除的元素在 list 数组之中</span></span><br><span class="line">          <span class="comment">// splice</span></span><br><span class="line">          spliceOne(list, position);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当 list 删除完成之后只有一个 listener 时， 直接将这个 listener 作为 events[type] 的值</span></span><br><span class="line">        <span class="keyword">if</span> (list.length === <span class="number">1</span>)</span><br><span class="line">          events[type] = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (events.removeListener !== <span class="literal">undefined</span>)</span><br><span class="line">          <span class="keyword">this</span>.emit(<span class="string">'removeListener'</span>, type, originalListener || listener);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">EventEmitter.prototype.off = EventEmitter.prototype.removeListener;</span><br></pre></td></tr></table></figure>特别：<code>spliceOne</code> 方法, 而非使用<code>splice</code> 方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 这里是删除数组的方法</span><br><span class="line">// 用的方法是找到一个数组的位置， 然后往前挪</span><br><span class="line">// 这种方法性能提升比较大</span><br><span class="line">function spliceOne(list, index) &#123;</span><br><span class="line">  for (; index + 1 &lt; list.length; index++)</span><br><span class="line">    list[index] = list[index + 1];</span><br><span class="line">  list.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>once(eventName, listener)</code>作用：添加只能调用一次的 <code>listener</code> 方法代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onceWrapper</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里的 fired 或许是为了更方便的暴露给外部使用</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.fired) &#123;</span><br><span class="line">    <span class="comment">// 移除之后这里的闭包将会被回收了</span></span><br><span class="line">    <span class="keyword">this</span>.target.removeListener(<span class="keyword">this</span>.type, <span class="keyword">this</span>.wrapFn);</span><br><span class="line">    <span class="keyword">this</span>.fired = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.listener.call(<span class="keyword">this</span>.target);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.listener.apply(<span class="keyword">this</span>.target, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 onceWrap 维持了一个 state 状态 用来保存是否被触发过的状态</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_onceWrap</span>(<span class="params">target, type, listener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> state = &#123; <span class="attr">fired</span>: <span class="literal">false</span>, <span class="attr">wrapFn</span>: <span class="literal">undefined</span>, <span class="attr">target</span>: target, <span class="attr">type</span>: type, <span class="attr">listener</span>: listener &#125;;</span><br><span class="line">  <span class="comment">// 这里是注入里一些状态字段</span></span><br><span class="line">  <span class="comment">// 这里保存一些状态字段， 比如： fired 用来表示这个函数有没有被触发过</span></span><br><span class="line">  <span class="keyword">var</span> wrapped = onceWrapper.bind(state);</span><br><span class="line">  wrapped.listener = listener;</span><br><span class="line">  state.wrapFn = wrapped;</span><br><span class="line">  <span class="keyword">return</span> wrapped;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 _oncewrap 方法执行之后是一个方法， 方法上的 listener 属性才是传入 once 方法的</span></span><br><span class="line"><span class="comment">// listener 参数</span></span><br><span class="line"><span class="comment">// 这里的 _onceWrap 方法的包装解释了代码中存在的 listener.listener || listener 的判断</span></span><br><span class="line">EventEmitter.prototype.once = <span class="function"><span class="keyword">function</span> <span class="title">once</span>(<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">  checkListener(listener);</span><br><span class="line">  <span class="keyword">this</span>.on(type, _onceWrap(<span class="keyword">this</span>, type, listener));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><code>prependListener(eventName, listener)</code>作用：添加 <code>listener</code> 到事件 <code>eventName</code> 回调数组中的第一个， 当事件被发布时， 添加的 <code>listener</code> 第一个执行代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventEmitter.prototype.prependListener =</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">prependListener</span>(<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _addListener(<span class="keyword">this</span>, type, listener, <span class="literal">true</span>);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></li><li><code>prependOnceListener(eventName, listener)</code>作用： 添加一次性的 listener 到事件回调函数队列头部代码：就是 <code>prependListener</code> 和 <code>_onceWrap</code> 方法的结合<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EventEmitter.prototype.prependOnceListener =</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">prependOnceListener</span>(<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">      checkListener(listener);</span><br><span class="line">      <span class="keyword">this</span>.prependListener(type, _onceWrap(<span class="keyword">this</span>, type, listener));</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></li><li><code>removeAllListeners([eventName])</code>作用： 移除 <code>eventName</code> 事件的全部 <code>listener</code>代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">EventEmitter.prototype.removeAllListeners =</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">removeAllListeners</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> listeners, events, i;</span><br><span class="line"></span><br><span class="line">      events = <span class="keyword">this</span>._events;</span><br><span class="line">      <span class="keyword">if</span> (events === <span class="literal">undefined</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// not listening for removeListener, no need to emit</span></span><br><span class="line">      <span class="comment">// 为了保证 removeListener 方法在删除完之后最后触发，</span></span><br><span class="line">      <span class="comment">// 需要判断是否存在这个 removeListener 方法是否存在</span></span><br><span class="line">      <span class="keyword">if</span> (events.removeListener === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">          <span class="keyword">this</span>._eventsCount = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[type] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (--<span class="keyword">this</span>._eventsCount === <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">delete</span> events[type];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// emit removeListener for all listeners on all events</span></span><br><span class="line">      <span class="comment">// _events 中存在 removeListener 方法</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(events);</span><br><span class="line">        <span class="keyword">var</span> key;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; keys.length; ++i) &#123;</span><br><span class="line">          key = keys[i];</span><br><span class="line">          <span class="keyword">if</span> (key === <span class="string">'removeListener'</span>) <span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">this</span>.removeAllListeners(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保证之前移除listener 时能够触发 removeListener 回调</span></span><br><span class="line">        <span class="keyword">this</span>.removeAllListeners(<span class="string">'removeListener'</span>);</span><br><span class="line">        <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">this</span>._eventsCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 删除单个事件</span></span><br><span class="line"></span><br><span class="line">      listeners = events[type];</span><br><span class="line">      <span class="comment">// 兼容 listeners 中单个 listener 或者 多个 listener 的问题</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> listeners === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.removeListener(type, listeners);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (listeners !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="comment">// LIFO order</span></span><br><span class="line">        <span class="keyword">for</span> (i = listeners.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">          <span class="keyword">this</span>.removeListener(type, listeners[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></li><li><code>rawListeners(eventName)</code> 作用： 获取到 <code>eventName</code> 事件的全部 <code>listeners</code>, 包括是通过 <code>once</code> 方法创建的包裹 <code>listener</code>代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法用来获取到所有的 listener 无论是原生的还是放在 wrapper 上面的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unwrapListeners</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = <span class="keyword">new</span> <span class="built_in">Array</span>(arr.length);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ret.length; ++i) &#123;</span><br><span class="line">    ret[i] = arr[i].listener || arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取到全部的 _listeners </span></span><br><span class="line"><span class="comment">// type event 名称</span></span><br><span class="line"><span class="comment">// unwrap 是否是获取 非once 方法创建的 wrapper listener</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_listeners</span>(<span class="params">target, type, unwrap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> events = target._events;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (events === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> evlistener = events[type];</span><br><span class="line">  <span class="keyword">if</span> (evlistener === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> evlistener === <span class="string">'function'</span>)</span><br><span class="line">    <span class="keyword">return</span> unwrap ? [evlistener.listener || evlistener] : [evlistener];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> unwrap ?</span><br><span class="line">    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);</span><br><span class="line">&#125;</span><br><span class="line">EventEmitter.prototype.rawListeners = <span class="function"><span class="keyword">function</span> <span class="title">rawListeners</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _listeners(<span class="keyword">this</span>, type, <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        了解 Node 中的 Events 模块node 中的 events 模块是 node 中使用较多的模块，比如在 node 中的流（stream），其内部使用 &lt;code&gt;events&lt;/code&gt; 模块作为父类：&lt;img src=&quot;/2020/09/14/node中的%20ev
      
    
    </summary>
    
      <category term="源码阅读" scheme="https://newpromise.github.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="node" scheme="https://newpromise.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>使用 browserify 处理virtual-dom模块的一个例子</title>
    <link href="https://newpromise.github.io/2020/09/13/%E4%BD%BF%E7%94%A8%20browserify%20%E5%A4%84%E7%90%86virtual-dom%E6%A8%A1%E5%9D%97%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90/"/>
    <id>https://newpromise.github.io/2020/09/13/使用 browserify 处理virtual-dom模块的一个例子/</id>
    <published>2020-09-13T13:38:20.000Z</published>
    <updated>2021-03-03T10:09:11.254Z</updated>
    
    <content type="html"><![CDATA[使用 browserify 来实现程序在node环境和浏览器环境的适配： 适配不同的模块加载方式有的时候js文件需要在 node 和 浏览器环境下都能执行，除了兼容性问题之外，还有一点是 node 和 浏览器平台引入文件时的模块机制是不同的 ：Node 中使用 <code>Commonjs</code> 的模块加载机制，Commonjs 模块加载机制如下：使用：使用 <code>require</code> 加载模块， 使用 <code>module.exports</code> 向外部暴露模块特定： 模块同时加载，这种特点在 node 环境下是不存在问题的， 因为 node 环境下模块都是在本地磁盘，加载比较快， 但是在浏览器环境下时会出现阻塞渲染的问题为了解决异步加载模块的问题，<code>AMD(https://github.com/amdjs/amdjs-api/wiki)</code>  和 <code>CMD</code> 通过不同的方式实现异步加载模块：AMD   :  相关库： <code>requireJs</code>写法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">"module"</span>, [<span class="string">"dep1"</span>, <span class="string">"dep2"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">d1, d2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someExportedValue;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">require</span>([<span class="string">"module"</span>, <span class="string">"../file"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">module, file</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;);</span><br></pre></td></tr></table></figure>CMD:  相关库： <code>seaJs</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> add = <span class="built_in">require</span>(<span class="string">'math'</span>).add;</span><br><span class="line">  exports.increment = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(val, <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>除了 <code>AMD</code> 和 <code>CMD</code> 两个规范之外，使用<code>es6</code>  的模块加载是浏览器的另一种模块加载机制，也是未来的主流使用 <code>es6</code> 模块加载实现动态加载的方法： <code>import(module)</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 导入 dayJs 模块</span><br><span class="line">// import(...) 返回 promise</span><br><span class="line">const dayJs = await import(&apos;dayjs&apos;);</span><br></pre></td></tr></table></figure>使用 <code>browserify</code> 是如何实现的适配各种模块加载的呢 ？具体代码如下：按照 <a href="https://github.com/Matt-Esch/virtual-dom" target="_blank" rel="noopener"><code>virtual-dom</code></a> 这个包为例：这个包的作用是生成虚拟dom对象执行 <code>package.json</code> 中的命令：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"dist"</span>: <span class="string">"browserify  virtual-dom index.js &gt; dist/virtual-dom.js"</span>,</span><br></pre></td></tr></table></figure>打包时，使用 <code>browserify</code> 来处理， 最终打包完成后的文件输出到 <code>dist/virtual-dom.js</code> 中， 在打包后的代码中，我们可以看到如下的代码结构：处理之后的代码中：将原来文件中 <code>require(...)</code> 这样的文件引用替换为具体的执行函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自执行方法 f 为下面的 函数1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里根据不同的模块加载方式来导出 virtual-dom 这个包的代码</span></span><br><span class="line">    <span class="comment">// 如果是 CommonJs 规范，比如在 node 中使用</span></span><br><span class="line">    <span class="comment">// 这里当执行 f() 之后，执行路径是：</span></span><br><span class="line">    <span class="comment">// 函数1 作为参数 f 传入， 执行 f 函数1 执行 ==&gt;</span></span><br><span class="line">    <span class="comment">// 函数1 执行 ==&gt; 返回函数 e （为自执行函数）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> exports === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">        <span class="built_in">module</span>.exports = f()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">"function"</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">        define([], f)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> g;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">            g = <span class="built_in">window</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> global !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">            g = global</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">            g = self</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            g = <span class="keyword">this</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在不同环境下，给不同全局变量挂载 virtualDom 变量值为 f 函数执行后的结果</span></span><br><span class="line">        g.virtualDom = f()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)(</span><br><span class="line">  <span class="comment">// 函数1 作为参数 f 传入上面的参数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> define, <span class="built_in">module</span>, exports;</span><br><span class="line">    <span class="comment">// 函数 e 也是一个自执行函数，接受三个参数：</span></span><br><span class="line">    <span class="comment">// 这里参数的各个部分</span></span><br><span class="line">    <span class="comment">// t: 表示下面的对象1</span></span><br><span class="line">    <span class="comment">// n: 表示下面的对象2</span></span><br><span class="line">    <span class="comment">// r: 表示下面的对象3</span></span><br><span class="line">    <span class="comment">// 这里返回的结构为 (function e(t, n, r) &#123;&#125;)(对象1,对象2,对象3)(4)</span></span><br><span class="line">    <span class="comment">// 函数e为自执行函数，执行后返回函数 s， s 接受 4 作为参数，最终这里 return</span></span><br><span class="line">    <span class="comment">// 的结果为 s(4) 之后的返回值</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params">t, n, r</span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params">o, u</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!n[o]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!t[o]) &#123;</span><br><span class="line">                    <span class="keyword">var</span> a = <span class="keyword">typeof</span> <span class="built_in">require</span> == <span class="string">"function"</span> &amp;&amp; <span class="built_in">require</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!u &amp;&amp; a) <span class="keyword">return</span> a(o, !<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (i) <span class="keyword">return</span> i(o, !<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Cannot find module '"</span> + o + <span class="string">"'"</span>);</span><br><span class="line">                    <span class="keyword">throw</span> f.code = <span class="string">"MODULE_NOT_FOUND"</span>, f</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">var</span> l = n[o] = &#123;</span><br><span class="line">                    exports: &#123;&#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">// 这里的 t[o]0 表示每个模块的方法</span></span><br><span class="line">                <span class="comment">// 这里的 t[o]1 表示文件对象，文件对象的键名为引用的文件地址，建值为该文件在对象1中的key</span></span><br><span class="line">                <span class="comment">// 这里使用 call 会立即执行 t[o]0 这个方法</span></span><br><span class="line">                t[o][<span class="number">0</span>].call(l.exports, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">                    <span class="comment">// 这里的 function (e) &#123;&#125;, l, l.exports </span></span><br><span class="line">                    <span class="comment">// 分别表示 function (require, module, exports) 中的 require, module,         </span></span><br><span class="line">                    <span class="comment">// exports 这三个参数</span></span><br><span class="line">                    <span class="comment">// 所以当调用 module.exports 的时候， 实际上 module.exports === l.exports</span></span><br><span class="line">                    <span class="keyword">var</span> n = t[o][<span class="number">1</span>][e];</span><br><span class="line">                    <span class="comment">// 获取到文件地址对象对应的值</span></span><br><span class="line">                    <span class="keyword">return</span> s(n ? n : e)</span><br><span class="line">                &#125;, l, l.exports, e, t, n, r)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里是 s 方法的返回值</span></span><br><span class="line">            <span class="keyword">return</span> n[o].exports</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="keyword">typeof</span> <span class="built_in">require</span> == <span class="string">"function"</span> &amp;&amp; <span class="built_in">require</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> o = <span class="number">0</span>; o &lt; r.length; o++) s(r[o]);</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    &#125;)(</span><br><span class="line">      <span class="comment">// 对象1</span></span><br><span class="line">      &#123;</span><br><span class="line">      ===== 从之前的代码中抽取出来的一些代码 =====</span><br><span class="line">      这个对象中的元素的结构都是一样的：</span><br><span class="line">      对象的键key为数字，表示当前文件的标识</span><br><span class="line">      对象的值是一个数组， 这个数组中有两个元素，一个元素是 <span class="string">`function(require, module, exports) &#123;&#125;`</span> 方法包裹的文件内的方法，另外一个元素是上面文件中使用 <span class="built_in">require</span> 引用的文件路径和文件标识对象</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 为什么这里要先进行处理呢 ？ 因为可以认为这里是程序的主入口</span></span><br><span class="line">      <span class="comment">// 分析程序先从这里进入开始分析</span></span><br><span class="line">      <span class="number">4</span>: [<span class="function"><span class="keyword">function</span> (<span class="params">require, module, exports</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> diff = <span class="built_in">require</span>(<span class="string">"./diff.js"</span>)</span><br><span class="line">        <span class="keyword">var</span> patch = <span class="built_in">require</span>(<span class="string">"./patch.js"</span>)</span><br><span class="line">        <span class="keyword">var</span> h = <span class="built_in">require</span>(<span class="string">"./h.js"</span>)</span><br><span class="line">        <span class="keyword">var</span> create = <span class="built_in">require</span>(<span class="string">"./create-element.js"</span>)</span><br><span class="line">        <span class="keyword">var</span> VNode = <span class="built_in">require</span>(<span class="string">'./vnode/vnode.js'</span>)</span><br><span class="line">        <span class="keyword">var</span> VText = <span class="built_in">require</span>(<span class="string">'./vnode/vtext.js'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">          diff: diff,</span><br><span class="line">          patch: patch,</span><br><span class="line">          h: h,</span><br><span class="line">          create: create,</span><br><span class="line">          VNode: VNode,</span><br><span class="line">          VText: VText</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        <span class="string">"./create-element.js"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">"./diff.js"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">"./h.js"</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="string">"./patch.js"</span>: <span class="number">13</span>,</span><br><span class="line">        <span class="string">"./vnode/vnode.js"</span>: <span class="number">31</span>,</span><br><span class="line">        <span class="string">"./vnode/vtext.js"</span>: <span class="number">33</span></span><br><span class="line">      &#125;],</span><br><span class="line">      ...</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="comment">// 对象2</span></span><br><span class="line">    &#123;&#125;, </span><br><span class="line">    <span class="comment">// 对象3</span></span><br><span class="line">    [<span class="number">4</span>]</span><br><span class="line">    <span class="comment">// 这里的参数 （4） 实际上是 上面函数 s 接受的参数</span></span><br><span class="line">   )(<span class="number">4</span>)</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        使用 browserify 来实现程序在node环境和浏览器环境的适配： 适配不同的模块加载方式有的时候js文件需要在 node 和 浏览器环境下都能执行，除了兼容性问题之外，还有一点是 node 和 浏览器平台引入文件时的模块机制是不同的 ：Node 中使用 &lt;code&gt;Com
      
    
    </summary>
    
      <category term="源码阅读" scheme="https://newpromise.github.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="js-module" scheme="https://newpromise.github.io/tags/js-module/"/>
    
  </entry>
  
  <entry>
    <title>js-Worker</title>
    <link href="https://newpromise.github.io/2019/10/27/js-Worker/"/>
    <id>https://newpromise.github.io/2019/10/27/js-Worker/</id>
    <published>2019-10-27T11:27:07.000Z</published>
    <updated>2021-03-04T07:57:54.780Z</updated>
    
    <content type="html"><![CDATA[<h2 id="what-is-the-worker">What is the worker</h2>浏览器是多线程的， 在浏览器中，存在下面几个线程：<ul><li>浏览器事件触发线程</li><li>UI 渲染线程</li><li>JS 引擎线程</li><li>定时触发器线程</li><li>http 请求线程</li></ul>js 语言的一个重要特征是单线程，因为在js 中会设计到一些页面交互的逻辑， 比如操作 dom 树， css 样式树等， 单线程的设计避免了复杂的同步问题。因为在 js 中我们是可以进行 dom 操作的， 因此 UI 渲染线程和 js 引擎线程是互斥的，如果我们在页面上要进行一些耗时较大的 js 逻辑计算的时候， 页面可能会出现卡顿现象。为了利用多核 CPU 的计算能力，在 HTML5 中引入的工作线程使得浏览器端的 JavaScript 引擎可以并发地执行 JavaScript 代码，但是引入的工作线程并没有改变 js 单线程的本质， 因为子线程完全受主线程控制， 并且不能操作dom。工作线程的一些特点：<ul><li>工作线程内不能操作 dom，或者使用 window 对象下的一些属性和方法</li><li>工作线程和主线程之间通过消息传递系统实现，消息之间传递的数据是复制而不是共享一个存储空间（深复制和浅复制）<blockquote>both sides send their messages using the <code>postMessage()</code> method, and respond to messages via the <code>onmessage</code> event handler (the message is contained within the <code>Message</code> event&#39;s <code>data</code> property). The data is copied rather than shared.</blockquote></li></ul><h2 id="how-to-create-worker">How to create worker</h2>一个 Worker 的创建是通过js 中的构造函数： <code>Worker()</code> 来实现的：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myWorker = <span class="keyword">new</span> Worker(aURL, options);</span><br></pre></td></tr></table></figure>具体看 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker/Worker" target="_blank" rel="noopener">worker</a>当我们创建一个 worker 的时候， 我们需要手动创建一个 js 文件，这种方式过于死板， 我们希望我们能直接指定在 worker 中运行的代码，而不需要创建多余的文件， 那有没有可能我们直接传入一个方法呢？比如如下代码，我们对于函数代码进行了四次转换，从而实现将一个普通函数转换为 webWroker:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWorker</span>(<span class="params">workerFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> url = URL.createObjectURL(<span class="keyword">new</span> Blob([<span class="string">`(<span class="subst">$&#123;workerFn.toString ()&#125;</span>)()`</span>]));</span><br><span class="line">  <span class="keyword">const</span> worker = <span class="keyword">new</span> Worker(url);</span><br><span class="line">  <span class="keyword">let</span> promiseResolve;</span><br><span class="line">  worker.onmessage = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    promiseResolve(msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      promiseResolve = resolve;</span><br><span class="line">      worker.postMessage(message);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  onmessage = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`resceive message`</span>, msg.data);</span><br><span class="line">    postMessage(<span class="string">'hello'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> worker = createWorker(fn);</span><br><span class="line"></span><br><span class="line">worker(<span class="string">'send message'</span>).then(<span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'msg'</span>, msg.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>上面代码实现了在不额外创建文件的情况下，实现创建 worker 代码的过程如下是上面代码普通函数到 worker 的四种转换过程：<img src="v2-5887674cb213a45bef388a2f580da222_hd.jpg" loading="lazy"><img src="/2019/10/27/js-Worker/v2-5887674cb213a45bef388a2f580da222_hd.jpg">在上面的代码中，我们需要理解的是：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URL.createObjectURL(<span class="keyword">new</span> Blob([<span class="string">`(<span class="subst">$&#123;workerFn.toString ()&#125;</span>)()`</span>]));</span><br></pre></td></tr></table></figure><ol><li><code>Function.toString()</code> 方法可以将函数转换为代码字符串,例如上面的代码中， 执行完成<code>toString</code> 方法之后：</li></ol>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// workerFn.toString ()</span><br><span class="line">() =&gt; &#123;</span><br><span class="line">  onmessage = (msg) =&gt; &#123;</span><br><span class="line">    console.log(`resceive message`, msg.data);</span><br><span class="line">    postMessage(&apos;hello&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote>The <strong>toString()</strong> method returns a string representing the source code of the function.</blockquote><ol start="2"><li><code>URL.createObjectURL()</code><code>createObjectURL</code> 可以创建指向 blob 对象的 URL，  需要注意的是， 使用这种方法创建的是一个链接，这个链接指向数据对象， 这个数据对象可以是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/File" target="_blank" rel="noopener"><code>File</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" target="_blank" rel="noopener"><code>Blob</code></a> or <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaSource" target="_blank" rel="noopener"><code>MediaSource</code></a> 对象，真正的数据存放在 上面三种数据对象中。在上面的代码中， <code>URL.createObjectURL</code> 创建的链接， 指向的是保存有 <code>(${workerFn.toString ()})()</code> 的 blob 对象中关于 <a href="https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL" target="_blank" rel="noopener">createObjectURL</a></li></ol><h2 id="worker-loader">Worker-loader</h2><a href="https://github.com/webpack-contrib/worker-loader" target="_blank" rel="noopener">worker-loader</a> 是用来在 webpack 中实现 worker 的，核心代码如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> URL = <span class="built_in">window</span>.URL || <span class="built_in">window</span>.webkitURL;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content, url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> blob;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// BlobBuilder = Deprecated, but widely implemented</span></span><br><span class="line">        <span class="keyword">var</span> BlobBuilder = <span class="built_in">window</span>.BlobBuilder ||</span><br><span class="line">        <span class="built_in">window</span>.WebKitBlobBuilder ||</span><br><span class="line">        <span class="built_in">window</span>.MozBlobBuilder ||</span><br><span class="line">        <span class="built_in">window</span>.MSBlobBuilder;</span><br><span class="line"></span><br><span class="line">        blob = <span class="keyword">new</span> BlobBuilder();</span><br><span class="line"></span><br><span class="line">        blob.append(content);</span><br><span class="line"></span><br><span class="line">        blob = blob.getBlob();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">// The proposed API</span></span><br><span class="line">        blob = <span class="keyword">new</span> Blob([content]);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Worker(URL.createObjectURL(blob));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// 这里对于 js 数据进行编码</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Worker(<span class="string">'data:application/javascript,'</span> + <span class="built_in">encodeURIComponent</span>(content));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!url) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Inline worker is not supported'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Worker(url);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>使用多种不同的 api 主要是为了不同浏览器的兼容性问题，<h2 id="参考链接"><strong>参考链接</strong></h2><ol><li><a href="https://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string" target="_blank" rel="noopener">how-to-create-a-web-worker-from-a-string</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;what-is-the-worker&quot;&gt;What is the worker&lt;/h2&gt;
浏览器是多线程的， 在浏览器中，存在下面几个线程：&lt;ul&gt;
&lt;li&gt;浏览器事件触发线程&lt;/li&gt;
&lt;li&gt;UI 渲染线程&lt;/li&gt;
&lt;li&gt;JS 引擎线程&lt;/li&gt;
&lt;li&gt;定
      
    
    </summary>
    
      <category term="js" scheme="https://newpromise.github.io/categories/js/"/>
    
    
      <category term="Worker" scheme="https://newpromise.github.io/tags/Worker/"/>
    
  </entry>
  
  <entry>
    <title>promisify callback-style function</title>
    <link href="https://newpromise.github.io/2019/10/03/PromisifyCallback/"/>
    <id>https://newpromise.github.io/2019/10/03/PromisifyCallback/</id>
    <published>2019-10-03T14:47:16.000Z</published>
    <updated>2021-03-03T10:09:11.236Z</updated>
    
    <content type="html"><![CDATA[将一个回调函数转换为 <code>promise</code> 类函数，在  <code>promisify</code> 化的函数的 <code>then</code> 方法里面执行回调函数， 避免回调地狱。这样相当于我们日常代码开发中，对于某个函数返回一个 <code>promise</code>, 以期在函数的 <code>then</code> 方法里面处理数据的方法的一个封装。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// some data process code...</span></span><br><span class="line">    <span class="keyword">try</span> () &#123;</span><br><span class="line">      resolve(data);      </span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;...&#125;);</span><br></pre></td></tr></table></figure>在 node.js 中， 存在一个工具方法为 <code>utils.promisfy</code> 的工具方法， 这个方法将回调转换为 <code>promise</code> 类方法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error-first 类型回调</span></span><br><span class="line"><span class="comment">// 回调cb 的第一个参数为 error， 如果没有传 false</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cb(<span class="literal">false</span>, <span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> utils = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promiseFn = utils.promisify(fn);</span><br><span class="line"></span><br><span class="line">promiseFn().then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 使用这个方法， 可以将 node 中的一些异步的回调</span></span><br><span class="line"><span class="comment">// 比如： readFile 等</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promiseReadFile = utils.promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line">promiseReadFile(<span class="string">'./.gitignore'</span>, <span class="string">'utf-8'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">fs.readFile(<span class="string">'./.gitignore'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>在 <code>promisify</code> 出现之前，使用 <a href="https://github.com/sindresorhus/pify" target="_blank" rel="noopener">pify</a> 实现相同的功能<code>pify</code> 模块的核心代码不多,  下面是全部的代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心处理方法</span></span><br><span class="line"><span class="comment">// fn：将要被 promise 化的函数</span></span><br><span class="line"><span class="comment">// options: 相关配置选项</span></span><br><span class="line"><span class="comment">// args: 传入函数的相关参数</span></span><br><span class="line"><span class="comment">// 实际执行的时候， 执行这个方法返回的方法， 其中 args 为传入的参数</span></span><br><span class="line"><span class="comment">// 这里 args 是一个数组， 通过 push 回调的方法</span></span><br><span class="line"><span class="keyword">const</span> processFn = <span class="function">(<span class="params">fn, options</span>) =&gt;</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> P = options.promiseModule;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> P(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// multiArgs： 是否传入多个参数</span></span><br><span class="line">    <span class="keyword">if</span> (options.multiArgs) &#123;</span><br><span class="line">      <span class="comment">// push 一个方法函数， 这个函数就是我们在原函数中手动</span></span><br><span class="line">      <span class="comment">// 调用的回调函数 cb， 参数是我们手动写入回调函数中的参数</span></span><br><span class="line">      args.push(<span class="function">(<span class="params">...result</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// errorFirst: 是否包含错误， 适配 node 如 fs.exists() 类的方法</span></span><br><span class="line">        <span class="keyword">if</span> (options.errorFirst) &#123;</span><br><span class="line">          <span class="keyword">if</span> (result[<span class="number">0</span>]) &#123;</span><br><span class="line">            reject(result);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.shift();</span><br><span class="line">            resolve(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.errorFirst) &#123;</span><br><span class="line">      args.push(<span class="function">(<span class="params">error, result</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">          reject(error);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      args.push(resolve);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个时候， args 中传入了相关的回调方法</span></span><br><span class="line">    fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">input, options</span>) =&gt;</span> &#123;</span><br><span class="line">  options = <span class="built_in">Object</span>.assign(&#123;</span><br><span class="line">    exclude: [<span class="regexp">/.+(Sync|Stream)$/</span>],</span><br><span class="line">    <span class="comment">// errorFirst: 回调函数中是否第一个参数为 error</span></span><br><span class="line">    errorFirst: <span class="literal">true</span>,</span><br><span class="line">    promiseModule: <span class="built_in">Promise</span></span><br><span class="line">  &#125;, options);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> objType = <span class="keyword">typeof</span> input;</span><br><span class="line">  <span class="keyword">if</span> (!(input !== <span class="literal">null</span> &amp;&amp; (objType === <span class="string">'object'</span> || objType === <span class="string">'function'</span>))) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`Expected \`input\` to be a \`Function\` or \`Object\`, got \`<span class="subst">$&#123;input === <span class="literal">null</span> ? <span class="string">'null'</span> : objType&#125;</span>\``</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> filter = <span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> match = <span class="function"><span class="params">pattern</span> =&gt;</span> <span class="keyword">typeof</span> pattern === <span class="string">'string'</span> ? key === pattern : pattern.test(key);</span><br><span class="line">    <span class="comment">// options 中的 include 和 exclude 属性分别表示</span></span><br><span class="line">    <span class="comment">// 模块中可以被序列化的方法</span></span><br><span class="line">    <span class="keyword">return</span> options.include ? options.include.some(match) : !options.exclude.some(match);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> ret;</span><br><span class="line">  <span class="comment">// 当传入的 input 为函数的时候</span></span><br><span class="line">  <span class="keyword">if</span> (objType === <span class="string">'function'</span>) &#123;</span><br><span class="line">    ret = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// excludeMain：是否对于一些 module 内部方法 做 promise 化</span></span><br><span class="line">      <span class="keyword">return</span> options.excludeMain ? input(...args) : processFn(input, options).apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 否则 ret 为包含有 input 上面的属性的对象</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ret = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(input));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于 input 参数对象或者函数上面的每一个方法都做 promise 化</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> input) &#123; <span class="comment">// eslint-disable-line guard-for-in</span></span><br><span class="line">    <span class="keyword">const</span> property = input[key];</span><br><span class="line">    ret[key] = <span class="keyword">typeof</span> property === <span class="string">'function'</span> &amp;&amp; filter(key) ? processFn(property, options) : property;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><code>utils.promisify</code> 方法<code>promisify</code> 方法是 node 内置的 <code>promise</code> 化回调函数的工具方法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promisify = <span class="function"><span class="keyword">function</span> <span class="title">promisify</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> kCustomPromisifiedSymbol = <span class="keyword">typeof</span> <span class="built_in">Symbol</span> !== <span class="string">'undefined'</span> ? <span class="built_in">Symbol</span>(<span class="string">'util.promisify.custom'</span>) : <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> original !== <span class="string">'function'</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'The "original" argument must be of type Function'</span>);</span><br><span class="line">   <span class="comment">// 在 original 方法上面存在有 `kCustomPromisifyedSymbol 这个属性</span></span><br><span class="line">  <span class="comment">// 这个属性上面存储的是被 promise 化的方法</span></span><br><span class="line">  <span class="keyword">if</span> (kCustomPromisifiedSymbol &amp;&amp; original[kCustomPromisifiedSymbol]) &#123;</span><br><span class="line">    <span class="keyword">var</span> fn = original[kCustomPromisifiedSymbol];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'The "util.promisify.custom" argument must be of type Function'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(fn, kCustomPromisifiedSymbol, &#123;</span><br><span class="line">      value: fn, <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="attr">writable</span>: <span class="literal">false</span>, <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> promiseResolve, promiseReject;</span><br><span class="line">    <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      promiseResolve = resolve;</span><br><span class="line">      promiseReject = reject;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">      args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    args.push(<span class="function"><span class="keyword">function</span> (<span class="params">err, value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        promiseReject(err);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        promiseResolve(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      original.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      promiseReject(err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 fn 上的原型设置为 original 上的原型</span></span><br><span class="line">  <span class="built_in">Object</span>.setPrototypeOf(fn, <span class="built_in">Object</span>.getPrototypeOf(original));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (kCustomPromisifiedSymbol) <span class="built_in">Object</span>.defineProperty(fn, kCustomPromisifiedSymbol, &#123;</span><br><span class="line">    value: fn, <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="attr">writable</span>: <span class="literal">false</span>, <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 设置 fn 上的属性为 original 方法上面的属性</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.defineProperties(</span><br><span class="line">    fn,</span><br><span class="line">    getOwnPropertyDescriptors(original)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        将一个回调函数转换为 &lt;code&gt;promise&lt;/code&gt; 类函数，在  &lt;code&gt;promisify&lt;/code&gt; 化的函数的 &lt;code&gt;then&lt;/code&gt; 方法里面执行回调函数， 避免回调地狱。这样相当于我们日常代码开发中，对于某个函数返回一个 &lt;code&gt;pro
      
    
    </summary>
    
      <category term="promsie" scheme="https://newpromise.github.io/categories/promsie/"/>
    
    
      <category term="promisify" scheme="https://newpromise.github.io/tags/promisify/"/>
    
  </entry>
  
  <entry>
    <title>数据结构：树</title>
    <link href="https://newpromise.github.io/2019/10/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91/"/>
    <id>https://newpromise.github.io/2019/10/03/数据结构：树/</id>
    <published>2019-10-03T03:19:09.000Z</published>
    <updated>2021-03-03T10:09:11.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树">树</h1>树是这样的一种结构：<img src="/2019/10/03/数据结构：树/image-20191003112501951.png"><img src="image-20191003112501951.png" loading="lazy">对于树的定义如下：<blockquote>树是 n (n &gt;= 0) 个结点的有限集，n = 0 时称为空树，在任意一棵非空树中，<ol><li>有且仅用一个特定的称为 根（root）的节点</li><li>当 n &gt; 1 时，其余结点可分为 m（m &gt; 0）个互不相交的有限集 T1, T2, ...Tn, 其中每一个集合本身也是一棵树， 并且称为 根的子树， </li></ol></blockquote>对于树的存储方式， 可以使用三种表示法来存储树之间结点之间的相互关系：双亲表示法， 孩子表示法， 孩子兄弟表示法双亲表示法：以一段连续的空间存储树的结点， 在每一个结点中，存储当前结点其双亲结点的存储位置：<img src="/2019/10/03/数据结构：树/image-20191003120639803.png"><img src="image-20191003120639803.png" loading="lazy">data为数据域， 存储当前结点的相关数据， parent 为指针域， 存储当前节点的双亲结点在数组中的下标比如下面的树使用双亲表示法表示：<img src="/2019/10/03/数据结构：树/image-20191003120919003.png"><img src="image-20191003120919003.png" loading="lazy">根结点的双亲位置为 -1；上面的表示法表示的树用于查找结点的双亲元素比较方便， 但是，如果这个结点下面包含有多个的子结点， 我们可以需要设置多个的指针域， 比如， 长子域， 右兄弟域等等。孩子表示法：孩子表示法的方式是：将每个结点的孩子结点排列起来，以单链表作为存储结构，则 n 个结点有 n 个孩子链表，如果是叶子结点， 那么这个单链表为空，然后 n 个头指针又组成一个线性表，存放在一个一维数组中。使用孩子表示法表示上面的树形结构：<img src="/2019/10/03/数据结构：树/image-20191003131535048.png"><img src="image-20191003131535048.png" loading="lazy">在上面的孩子表示法中，设计有两种结构：<ol><li>孩子链表<img src="/2019/10/03/数据结构：树/image-20191003131750956.png"><img src="image-20191003131750956.png" loading="lazy">child 为数据域， 用来存储当前的子结点在表头数组中的下标， next 为指针域，存放的是下一个孩子的这个结构指针地址。</li><li>表头结点<img src="/2019/10/03/数据结构：树/image-20191003131943353.png"><img src="image-20191003131943353.png" loading="lazy">表头结点存储每个结点， 用于树形结点的遍历使用，另外， 存储长子结点的指针域；</li></ol>孩子兄弟表示法：孩子兄弟表示法的数据结构如下：<img src="/2019/10/03/数据结构：树/image-20191003132343485.png"><img src="image-20191003132343485.png" loading="lazy">data 为数据域firstchild 为该结点第一个孩子结点的指针域rightsib 为该结点的兄弟结点指针域使用 孩子兄弟表示法组织后的数据结构如下：<img src="/2019/10/03/数据结构：树/image-20191003132738591.png"><img src="image-20191003132738591.png" loading="lazy">上面的重新组织后的结构将一棵树转换为了一棵二叉树<h2 id="二叉树">二叉树</h2><h3 id="二叉树的定义">二叉树的定义</h3><blockquote>二叉树是 n 个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的，分别称为 根结点的左子树和右子树的二叉树组成 </blockquote>二叉树的特点：<ol><li>每个结点最多有两棵子树</li><li>左子树和右子树是有顺序的， 并且不能颠倒</li><li>即使树中某结点只有一棵子树，也要区分顺序</li></ol>如下图， 是一棵二叉树的示意图：<img src="/2019/10/03/数据结构：树/image-20191003190231702.png"><img src="image-20191003190231702.png" loading="lazy">根据二叉树的结构显示， 可以将二叉树分为：满二叉树， 斜树 和 完全二叉树；如下， 是满二叉树的图示：<img src="/2019/10/03/数据结构：树/image-20191003190415734.png"><img src="image-20191003190415734.png" loading="lazy">树的每个结点都有左右两个结点， 故称为满二叉树。<h3 id="二叉树的存储">二叉树的存储</h3><h4 id="顺序存储">顺序存储</h4>按照顺序存储二叉树， 主要是使用一维数组来顺序存储树中的各个结点，比如， 存储如下树结构：<img src="/2019/10/03/数据结构：树/image-20191003190805122.png"><img src="image-20191003190805122.png" loading="lazy">使用顺序存储如下：<img src="/2019/10/03/数据结构：树/image-20191003190824306.png"><img src="image-20191003190824306.png" loading="lazy">对于不存在的结点， 我们将不存在的结点设为 <code>^</code> 即可。使用顺序存储存在的问题在于， 我们需要对于不存在的结点分配存储空间，比如，对于下面这个右斜树而言：<img src="/2019/10/03/数据结构：树/image-20191003191127941.png"><img src="image-20191003191127941.png" loading="lazy">这样造成了存储空间的浪费。<h4 id="链式存储">链式存储</h4>对于二叉树结点的存储， 我们使用一种被称为 “二叉链表” 的链式存储结构来存储，二叉链表是下面的这种结构：<img src="/2019/10/03/数据结构：树/image-20191003191435274.png"><img src="image-20191003191435274.png" loading="lazy">这个结构中包含有一个数据域和两个指针域， 数据域表明当前结点的数据，指针域分别为二叉树左右两个结点的地址指针。使用链式存储后的最终的存储链表结构如下：<img src="/2019/10/03/数据结构：树/image-20191003191659327.png"><img src="image-20191003191659327.png" loading="lazy"><h3 id="二叉树的遍历">二叉树的遍历</h3>二叉树的遍历是指从根结点出发， 依次访问到二叉树中的每一个结点，使得每个结点被访问到并且仅被访问到一次。二叉树的遍历方法， 按照访问次序的不同， 可以分为 前序遍历， 中序遍历 以及 后序遍历<h4 id="前序遍历">前序遍历</h4>前序遍历的遍历顺序是先访问二叉树的左子树， 然后访问二叉树的右子树<img src="/2019/10/03/数据结构：树/image-20191012122817189.png"><img src="image-20191012122817189-0854497.png" loading="lazy">如， 上图， 二叉树的访问顺序是：ABDGHCEIF<h4 id="中序遍历">中序遍历</h4>中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树<img src="/2019/10/03/数据结构：树/image-20191014162511259.png"><img src="image-20191014162511259-1041511.png" loading="lazy">如上图， 那么 二叉树的访问顺序是：GDHBAEICF<h4 id="后序遍历">后序遍历</h4>判断二叉树是否为空， 如果是空， 那么空操作返回，否则的话， 从左到 右通过先叶子后结点的方式遍历访问左右子树<img src="/2019/10/03/数据结构：树/image-20191014163237408.png"><img src="image-20191014163237408-1041957.png" loading="lazy">使用后序遍历的方法来访问二叉树的顺序是：GHDBIEFCA<h3 id="二叉树的创建">二叉树的创建</h3>二叉树的创建可以像二叉树创建方法中传入一串树来实现，通过一定的二叉树的遍历顺序来依次创建结点， 对于空结点， 二叉树中的字符串可以为 ‘#’按照前序遍历创建的二叉树的方法如下:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建二叉树</span></span><br><span class="line"><span class="comment">// treeStr: 树的字符串， 空结点 ‘#’</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTree</span>(<span class="params">treeStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> tree = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 创建树节点</span></span><br><span class="line">  <span class="keyword">let</span> treeStack = treeStr.split(<span class="string">''</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createNode</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> nodeData = treeStack.shift();</span><br><span class="line">    <span class="keyword">if</span> (!nodeData) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (nodeData !== <span class="string">'#'</span>) &#123;</span><br><span class="line">      node.data = nodeData;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当父节点没有左结点的时候， 创建左结点</span></span><br><span class="line">    <span class="keyword">if</span> (!node.lChild || !node.lChild.hasOwnProperty(<span class="string">'data'</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (treeStack.length &gt;= <span class="number">1</span>) node.lChild = &#123;&#125;;</span><br><span class="line">      <span class="keyword">if</span> (createNode(node.lChild)) <span class="keyword">delete</span> node.lChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!node.rChild || !node.rChild.hasOwnProperty(<span class="string">'data'</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (treeStack.length &gt;= <span class="number">1</span>) node.rChild = &#123;&#125;;</span><br><span class="line">      <span class="keyword">if</span> (createNode(node.rChild)) <span class="keyword">delete</span> node.rChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  createNode(tree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>对于树的创建和访问一样， 也是进行依次遍历， 使用递归进行遍历访问， 需要注意的是：要存在相应的条件， 使得能够跳出递归。对于递归而言， 注意递归循环的跳出是比较重要的。同样，也可以按照中序遍历和后序遍历的次序来创建树， 只是递归的顺序不同而已。另外， 判断对象中某个属性是否存在， 最好不要用直接访问属性的方式进行判断， 因为不知道这个属性的值可能是 <code>undefined</code>,  或者 <code>0</code> 等导致属性访问后为 <code>false</code> 的值。可以使用 <code>hasOwnProperty</code> 的方式来判断属性是否在对象上面:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.hasOwnPropery(prop);</span><br></pre></td></tr></table></figure>注意： 这个方法只能够获取到该对象上面的自身属性， 不能获取到该对象原型上面的属性（for in 是可以获取到继承的属性的， 并且继承的属性是可枚举的）为了防止对象上面有 <code>hasOwnProperty</code> 属性覆盖掉从对象上面继承的， 我们需要通过 <code>Object</code> 来调用：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.hasOwnProperty.call(obj, &apos;property&apos;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;树&quot;&gt;树&lt;/h1&gt;
树是这样的一种结构：&lt;img src=&quot;/2019/10/03/数据结构：树/image-20191003112501951.png&quot;&gt;
&lt;img src=&quot;image-20191003112501951.png&quot; loading=&quot;lazy&quot;
      
    
    </summary>
    
      <category term="数据结构" scheme="https://newpromise.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="树" scheme="https://newpromise.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构：栈和队列</title>
    <link href="https://newpromise.github.io/2019/09/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>https://newpromise.github.io/2019/09/28/数据结构：栈和队列/</id>
    <published>2019-09-28T09:05:33.000Z</published>
    <updated>2021-03-03T10:09:11.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="栈">栈</h2>栈是一种特殊的线性表，这种线性表仅允许在表尾（栈顶）进行插入和删除工作：将可以被插入和删除元素的位置称为<code>栈顶</code>， 将另一端称为 <code>栈底</code>， 如果栈没有任何的元素， 这个栈被称为 <code>空栈</code>；栈的数据元素的进出遵循后进先出的原则，简称为  <em>LIFO (Last In First Out)</em> 结构；栈的插入被称为入栈， 栈的删除被称为出栈， 在程序中我们可以将其称为 <code>push</code> 和 <code>pop</code>;在 js 中， 我们使用数组的 <code>push</code> 和 <code>pop</code> 方法模拟栈的入栈和出栈操作；<h3 id="栈的应用">栈的应用</h3><h4 id="递归">递归</h4>我们将调用函数自身或者间接调用自身的函数称为 <em>递归</em> 在每一层递归的过程中， 我们需要存储当前调用函数的局部变量， 参数值等数据信息存储到栈中，当递归返回之后， 再将这些数据从栈中弹出数据<h4 id="使用栈实现四则运算表达式">使用栈实现四则运算表达式</h4>如下面程序， 实现将一串运算表达式进行计算的代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于逆波兰法表示的后缀表达式计算求值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RPNcompute</span>(<span class="params">mathStrStack</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> stack = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> mathStrStack) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Number</span>.isNaN(+num)) &#123;</span><br><span class="line">      <span class="keyword">const</span> num1 = stack.pop();</span><br><span class="line">      <span class="keyword">const</span> num2 = stack.pop();</span><br><span class="line">      <span class="keyword">const</span> total = num2 + num + num1;</span><br><span class="line">      stack.push(<span class="built_in">eval</span>(total));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      stack.push(num);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stack.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将中缀表达式转为后缀表达式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toPostFixExpression</span>(<span class="params">expression</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> expressionArr = expression.split(<span class="string">' '</span>);</span><br><span class="line">  <span class="keyword">let</span> stack = [];</span><br><span class="line">  <span class="keyword">let</span> outputStr = <span class="string">''</span>;</span><br><span class="line">  <span class="comment">// 处理符号入栈与出栈</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">pushStack</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">if</span> (!stack.length) &#123;</span><br><span class="line">      stack.push(s);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">      <span class="keyword">let</span> stackTopData = stack.pop();</span><br><span class="line">      <span class="keyword">if</span> (s === <span class="string">')'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stackTopData === <span class="string">'('</span>) <span class="keyword">break</span>;</span><br><span class="line">        result += stackTopData + <span class="string">' '</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="string">'+'</span>, <span class="string">'-'</span>, <span class="string">'*'</span>, <span class="string">'/'</span>].includes(s))&#123;</span><br><span class="line">        <span class="keyword">const</span> isLower = [<span class="string">'+'</span>, <span class="string">'-'</span>].includes(s);</span><br><span class="line">        <span class="comment">// 当栈顶元素优先级大于等于当前入栈元素时， 栈顶元素依次出栈</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="string">'/'</span>, <span class="string">'*'</span>].concat(isLower ? [<span class="string">'+'</span>, <span class="string">'-'</span>] : []).includes(stackTopData)) &#123;</span><br><span class="line">          result += stackTopData + <span class="string">' '</span>;</span><br><span class="line">          <span class="keyword">if</span> (!stack.length) &#123;</span><br><span class="line">            stack.push(s);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          stack.push(stackTopData);</span><br><span class="line">          stack.push(s);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stack.push(stackTopData);</span><br><span class="line">        stack.push(s);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> expressionArr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Number</span>.isNaN(+num)) &#123;</span><br><span class="line">      outputStr += pushStack(num);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      outputStr += <span class="string">`<span class="subst">$&#123;num&#125;</span> `</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> outputStr + stack.reverse().join(<span class="string">' '</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compute</span>(<span class="params">mathStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> stackArr = toPostFixExpression(mathStr).split(<span class="string">' '</span>);</span><br><span class="line">  <span class="keyword">return</span> RPNcompute(stackArr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line">compute(<span class="string">'9 + ( 3 - 1 ) * 3 + 10 / 2'</span>);</span><br><span class="line"><span class="comment">// 20</span></span><br><span class="line">compute(<span class="string">'9 + 3 * ( 2 + 2 / 2 ) - 10 / 5'</span>);</span><br><span class="line"><span class="comment">// 16</span></span><br></pre></td></tr></table></figure>关于 中缀表达式转后缀表达式（逆波兰）法规则如下:从左到右遍历中缀表达式的每个数字和符号，如果是数字那么就输出，成为后缀表达式的一部分，如果是符号， 那么判断该符号与栈顶符号的优先级，是右括号或者优先级低于等于栈顶符号， 那么栈顶符号依次出栈并输出，并将当前符号进栈， 一直到最终输出后缀表达式为止。运算符号优先级： 乘除 &gt; 加减对于后缀表达式的计算规则如下：从左到右遍历后缀表达式的每个数字和符号，如果遇到数字那么就入栈，遇到是符号， 那么就将处于栈顶的两个数字出栈， 进行运算，并将运算结果入栈， 一直到最终获得到结果。<h2 id="队列">队列</h2><blockquote>队列是只允许在一端进行插入操作， 而在另一端进行删除操作的线性表</blockquote>队列遵循的是先进先出的线性表， 在程序设计中的应用， 比如我们在显示器上记事本上文字的输出。在日常生活中， 比如我们购买火车票时的排队。<h3 id="队列的线式存储结构">队列的线式存储结构</h3>在 js 中， 我们使用数组的 <code>push</code> 和 <code>shift(表头弹出)</code> 这两个 api 实现队列的模拟。<h4 id="顺序存储">顺序存储</h4>使用顺序存储时，我们将队列数据元素按照顺序存储到数组中， 当我们想要对于队列进行出列操作时， 因为出列操作是在表头出列， 因此，出列数据元素后面的每一个数据都会向前移动一个元素位置， 这样会造成程序性能的损耗。<img src="/2019/09/28/数据结构：栈和队列/image-20191002114710061-9988030.png"><img src="image-20191002114710061-9988030.png" loading="lazy">这个时候的时间复杂度为  <code>O(n)</code>为了解决这个移动队列数据元素的问题， 我们可以引入两个指针： <code>front</code>: 指向队头元素， <code>rear</code>: 指向队尾元素的下一个位置当我们对于队列进行添加和删除元素的时候， 只要改变 <code>front</code> 和 <code>rear</code> 指针的位置就可以了， 不需要移动每个队列元素:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queue</span>(<span class="params">queueLen</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> queueArr = <span class="keyword">new</span> <span class="built_in">Array</span>(queueLen);</span><br><span class="line">  <span class="keyword">let</span> front = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> rear = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.out = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    queueArr[front] = <span class="literal">undefined</span>;</span><br><span class="line">    front ++;</span><br><span class="line">    <span class="keyword">return</span> queueArr;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    queueArr[rear] = data;</span><br><span class="line">    rear ++;</span><br><span class="line">    <span class="keyword">return</span> queueArr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>对于上面的代码， 存在一个问题是， 如果我们当删除数据时， 队列不往前移动， 那么当我们新增队列数据元素的时候， 可以会增加到规定的队列长度之外的元素：比如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queueList = queue(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">queueList.add(<span class="number">1</span>);</span><br><span class="line">queueList.add(<span class="number">2</span>);</span><br><span class="line">queueList.out();</span><br><span class="line"><span class="built_in">console</span>.log(queueList.add(<span class="number">3</span>));</span><br><span class="line"><span class="comment">// [ undefined, 2, 3 ]</span></span><br><span class="line"><span class="comment">// 队列长度超出了我们规定的 2 的长度的队列长度</span></span><br></pre></td></tr></table></figure>这个时候， 队列数据填充情况如下图所示：<img src="/2019/09/28/数据结构：栈和队列/image-20191002141645991-9997006.png"><img src="image-20191002141645991-9997006.png" loading="lazy">这个时候虽然添加的数据位置超出了队列的长度， 但是删除的队列的第 0 位 和 第 1 位元素却是空的， 我们的溢出是“假溢出”。我们思考， 如何能够利用删除之后的空间， 防止假溢出？<h4 id="循环队列"><strong>循环队列</strong></h4>循环队列相比上面的存储方法而言， 有一些不同， 主要是体现在  <code>rear</code> 指针的指向，<code>rear</code> 指针在队列初始化的时候指向下标 为 0 的位置,  当到达队列列尾的时候， <code>rear</code> 指针移动到队列列头<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queue</span>(<span class="params">queueSize</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> queueArr = <span class="keyword">new</span> <span class="built_in">Array</span>(queueSize);</span><br><span class="line">  <span class="keyword">let</span> front = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> rear = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.out = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (front === rear) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'empty'</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    queueArr[front] = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 使用 %（取模）操作来进行归 0 操作</span></span><br><span class="line">    front = (front + <span class="number">1</span>) % queueSize;</span><br><span class="line">    <span class="keyword">return</span> queueArr;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'full'</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    queueArr[rear] = data;</span><br><span class="line">    rear = (rear + <span class="number">1</span>) % queueSize;</span><br><span class="line">    <span class="keyword">return</span> queueArr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.queueLength = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (rear - front + queueSize) % queueSize;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isFull</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (rear + <span class="number">1</span>) % queueSize === front;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链式存储结构">链式存储结构</h3>队列的链式存储结构其实就是单链表。与普通的单链表不同的是， 只能操作链表的头部和尾部节点，队列的链式存储结构被称为 <code>链队列</code>；<h3 id="总结">总结</h3>当已知队列空间大小的情况下， 可以使用 <code>循环队列</code>， 否则， 如果不知道队列的长度， 使用 <code>链对列</code>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;栈&quot;&gt;栈&lt;/h2&gt;
栈是一种特殊的线性表，这种线性表仅允许在表尾（栈顶）进行插入和删除工作：将可以被插入和删除元素的位置称为&lt;code&gt;栈顶&lt;/code&gt;， 将另一端称为 &lt;code&gt;栈底&lt;/code&gt;， 如果栈没有任何的元素， 这个栈被称为 &lt;code&gt;空栈&lt;/
      
    
    </summary>
    
      <category term="数据结构" scheme="https://newpromise.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="栈 和 队列" scheme="https://newpromise.github.io/tags/%E6%A0%88-%E5%92%8C-%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>promise中的错误捕获</title>
    <link href="https://newpromise.github.io/2019/09/27/promise%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E6%8D%95%E8%8E%B7/"/>
    <id>https://newpromise.github.io/2019/09/27/promise中的错误捕获/</id>
    <published>2019-09-27T09:02:31.000Z</published>
    <updated>2021-03-03T10:09:11.250Z</updated>
    
    <content type="html"><![CDATA[在代码中， 我们对于不能预知的代码通常会使用 <code>try catch</code> 来捕获代码错误，当代码内部发生错误时， 对于错误进行捕获， 可以防止代码的错误阻塞后续代码的执行，并且我们可以对于代码的错误进行后续处理；在 <code>promise</code> 中， 对于错误的处理或许稍有不同， 需要注意下面几点：<ul><li>使用 <code>try catch</code> 只能捕获同步代码， 不能捕获异步代码， 在 <code>async</code> 函数内， 使用 <code>await</code> 可以捕获异步代码，这里实际上是异步代码变成了同步代码</li><li><code>promise</code> 内部代码的错误会沿着 <code>promise</code> 代码链传递， 直到被 <code>promise</code> 的 <code>catch</code> 方法或者上一层 <code>async</code>  函数内的  <code>try catch</code> 方法捕获到, 如果没有使用 <code>catch</code> 方法指定错误处理的回调函数， <code>Promise</code> 对象抛出的错误不会传递到外层的 <code>promise</code>；这个时候会报： <code>UnhandledPromiseRejectionWarning:</code></li></ul><h4 id="try-catch-处理async-函数内异步"><code>try catch</code> 处理<code>async</code> 函数内异步</h4>使用 <code>try catch</code> 只能处理同步的代码， 对于异步代码中的代码错误， 使用 <code>try catch</code> 是无法捕获到的：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryError</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    promise();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tryError();</span><br><span class="line"><span class="comment">// UnhandledPromiseRejectionWarning: Error: error</span></span><br></pre></td></tr></table></figure>在 <code>async </code> 函数内部使用 <code>try catch</code>可以捕获到异步错误：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">tryError</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> promise();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">tryError();</span><br><span class="line"><span class="comment">// error</span></span><br></pre></td></tr></table></figure><h4 id="promisecatch-错误捕获"><code>promise.catch 错误捕获</code></h4>使用 <code>promise.catch</code> 方法可以对于当前 <code>promise</code> 链上的代码进行错误捕获，当 <code>promise</code> 内部发生错误的时候， 错误会沿着 <code>promise</code> 链向后传递， 直到被 <code>promise</code> 后面的 <code>catch</code> 方法捕获到：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">apromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apromise().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'error'</span>, err);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// error: b is not defined</span></span><br></pre></td></tr></table></figure>当在 <code>promise</code> 链中没有 <code>catch</code> 方法的时候， <code>promise</code> 中发生的错误不会被上层的 <code>promise</code> 中的catch 捕获, 即使我们使用了 <code>throw new Error</code> 的方式对错误进行抛出也是如此；因为 <code>async</code> 函数返回一个 <code>promise</code> 对象， 我们在 <code>async</code> 函数内部定义一个 <code>Error</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>);</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">promise();</span><br><span class="line"><span class="comment">// UnhandledPromiseRejectionWarning: Error: error</span></span><br><span class="line"><span class="comment">// 这里 async 函数内部抛出的错误不会被外部的 catch 方法捕获到， 因为错误不能传递到外层</span></span><br><span class="line"><span class="comment">// 的 `promise`</span></span><br></pre></td></tr></table></figure><h4 id="总结">总结</h4>防止出现 <code>unhandledRejection</code> 问题的解决方法是：<ol><li>在 <code>async</code> 函数内部使用 <code>try catch</code> 捕获异步错误</li><li> <code>promise</code> 内部使用 <code>.catch</code> 方法来捕获 <code>promise</code> 内部代码错误</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        在代码中， 我们对于不能预知的代码通常会使用 &lt;code&gt;try catch&lt;/code&gt; 来捕获代码错误，当代码内部发生错误时， 对于错误进行捕获， 可以防止代码的错误阻塞后续代码的执行，并且我们可以对于代码的错误进行后续处理；在 &lt;code&gt;promise&lt;/code&gt; 中，
      
    
    </summary>
    
      <category term="promise" scheme="https://newpromise.github.io/categories/promise/"/>
    
    
      <category term="promise catch" scheme="https://newpromise.github.io/tags/promise-catch/"/>
    
  </entry>
  
  <entry>
    <title>数据结构（一）：线性表</title>
    <link href="https://newpromise.github.io/2019/09/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>https://newpromise.github.io/2019/09/21/数据结构：线性表/</id>
    <published>2019-09-21T12:28:52.000Z</published>
    <updated>2021-03-03T10:09:11.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构简介">数据结构简介</h2><blockquote>数据结构是相互之间存在一种或者多种特定关系的数据元素的集合</blockquote>数据结构分为<strong>逻辑结构</strong>和<strong>物理结构</strong>；数据对象中数据元素之间的关系称为逻辑结构， 在数据结构中， 存在下面四种逻辑结构：<ul><li>集合结构集合结构中的元素除了同属于同一集合之外。 没有其他的任何关系， 如同所示：<img src="/2019/09/21/数据结构：线性表/image-20190921203850921-9069530.png"><img src="image-20190921203850921-9069530.png" loading="lazy"></li><li>线性结构： 线性结构中的元素是一对一的关系：<img src="/2019/09/21/数据结构：线性表/image-顺序表.jpg"><img src="image-顺序表.jpg" loading="lazy"></li><li>树形结构：树形结构中的元素关系是一对多的层次关系, 比如： 二叉树<img src="/2019/09/21/数据结构：线性表/image-20190921211634571-9071794.png"><img src="image-20190921211634571-9071794.png" loading="lazy"></li><li>图形结构： 图形结构中的元素之间的关系是一对多的关系<img src="/2019/09/21/数据结构：线性表/image-20190921211723626-9071843.png"></li></ul>  <img src="image-20190921211723626-9071843.png" loading="lazy">物理结构： 是指数据的逻辑结构在计算机中的存储方式；物理结构包括顺序存储结构和链式存储结构；顺序存储结构的数据逻辑关系和物理关系是一致的， 即是数据存放在地址连续的存储单元里面；链式存储结构数据间的存储地址并不连续，数据之间的存储关系并不表示他们之间的逻辑关系，这些数据的地址信息存放在数据的指针中。通过数据的指针来表明数据之间的存储关系。<h2 id="数据结构之线性表">数据结构之线性表</h2><blockquote>线性表是零个或者多个数据元素的有限序列</blockquote>线性表是一种序列， 这表明线性表中数据的关系之间都是一对一的关系，如果元素存在多个， 那么第一个元素没有前元素， 最后一个元素没有后元素， 其他元素有且只有一个前元素和后元素，<h3 id="线性表的顺序存储结构">线性表的顺序存储结构</h3>顺序存储结构是物理结构和逻辑结构一致的一种结构， 比如， 我们使用一个一维数组来存储数据，实现顺序存储结构；<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list  = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure>在顺序存储结构中， 地址和数据之间的关系是一致的，比如， 我们想要获取 第 i 个元素， 我们可以通过   <code>list[i - 1]</code> 来获取数据。<h4 id="删除和插入元素">删除和插入元素</h4>当我们需要删除或者插入元素的时候， 对于顺序存储结构需要移动比较多的元素， 当我们需要删除一个元素， 需要将该数据项后面的数据都需要向前提前一位：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从线性表中删除某个数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteData</span>(<span class="params">list, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (list.length === <span class="number">0</span>) <span class="keyword">return</span> list;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; list.length) <span class="keyword">return</span> list;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; list.length) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = i; index &lt; list.length; index ++) &#123;</span><br><span class="line">      list[index <span class="number">-1</span>] = list[index];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  list.length --;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(deleteData(list, <span class="number">2</span>));</span><br><span class="line"><span class="comment">// [1, 3, 4]</span></span><br></pre></td></tr></table></figure>对于线性表的插入和删除数据操作，其时间复杂度为 O(n);<h4 id="优缺点">优缺点</h4>对于线性表的顺序存储结构， 其优点是：<ol><li>可以快速的存取表中任意位置的元素</li><li>无须为表中的逻辑关系增加额外的存储空间</li></ol>缺点：对于线性表中插入和删除元素操作需要移动大量的元素<h3 id="线性表的链式存储结构">线性表的链式存储结构</h3>顺序存储结构对于插入和删除元素需要移动大量元素的原因是数据之间的逻辑关系和存储关系一致且相互之间按照次序排列，需要移动大量的元素来保持相互之间的存储关系和逻辑关系的一致。这种问题可以通过使用链式存储结构来解决，链式存储结果的特点是逻辑关系和存储关系分离， 当逻辑关系改变时， 不会引起存储关系的变化线性表的链式结构由一个个的节点（Node）构成， 每个节点中包含有一个数据域和一个或者多个指针域， 顾名思义， 数据域用于存储当前节点的数据， 指针域用来存储下一个节点的位置信息， 根据节点中指针域的数量不同， 将链表分为单链表和双链表；<h4 id="单链表">单链表</h4>单链表示意图如下：<img src="/2019/09/21/数据结构：线性表/image-20190921230012405-9078012.png"><img src="image-20190921230012405-9078012.png" loading="lazy">在上图中我们可以看到， 在链表中相邻的数据的存储位置并不连续，数据之间的关系通过节点中的指针域中的地址来表明。一些要点：<ol><li>链表中的最后一个节点的指针为空， 我们常常将其置为 <code>null</code></li><li>为了更方便的对于链表进行操作， 我们在第一个节点之前设置一个头节点，这个节点的指针指向第一个节点， 节点中的数据可以包含有链表的长度等信息。</li><li>头指针不为空，是链表的必要元素</li></ol>链表中节点之间的逻辑关系如图所示：<img src="/2019/09/21/数据结构：线性表/image-20190921231032685-9078632.png"><img src="image-20190921231032685-9078632.png" loading="lazy"><h5 id="单链表的读取">单链表的读取</h5>链表中数据的关系是通过指针来表示的，想要读取单链表的数据，我们需要通过指针来操作， 比如读取程序如下:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的链表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">linkList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> list = &#123;</span><br><span class="line">    data: &#123; <span class="attr">length</span>: <span class="number">0</span> &#125;,</span><br><span class="line">    next: <span class="literal">null</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> headNodeData = list.data;</span><br><span class="line">  <span class="keyword">const</span> headNode = list;</span><br><span class="line">  <span class="comment">// 链表新增节点</span></span><br><span class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> node = &#123; <span class="attr">data</span>: value, <span class="attr">next</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> next = list.next;</span><br><span class="line">    <span class="keyword">let</span> currentNode = list;</span><br><span class="line">    <span class="keyword">while</span> (next) &#123;</span><br><span class="line">      currentNode = next;</span><br><span class="line">      next = next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    currentNode.next = node;</span><br><span class="line">    headNodeData.length ++;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取链表中的某个节点</span></span><br><span class="line">  <span class="keyword">this</span>.get = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; headNodeData.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> next = list.next;</span><br><span class="line">    <span class="keyword">let</span> nodeIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (next) &#123;</span><br><span class="line">      nodeIndex ++;</span><br><span class="line">      <span class="keyword">if</span> (i === nodeIndex) <span class="keyword">break</span>;</span><br><span class="line">      next = next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> linkedList = linkList();</span><br><span class="line">linkedList.add(<span class="number">1</span>)；</span><br><span class="line"><span class="comment">// &#123; data: &#123; length: 1 &#125;, next: &#123; data: 1, next: null &#125; &#125;</span></span><br><span class="line">linkedList.get(<span class="number">1</span>)；</span><br><span class="line"><span class="comment">// &#123; data: 1, next: null &#125;</span></span><br></pre></td></tr></table></figure>单链表的查找数据的核心思想是<strong>工作指针后移</strong>；<h5 id="单链表的插入和删除">单链表的插入和删除</h5>代码如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在第 i 个数据后插入元素, 元素值为 value</span></span><br><span class="line"><span class="keyword">this</span>.append = <span class="function"><span class="keyword">function</span> (<span class="params">i, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">this</span>.get(i);</span><br><span class="line">  <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'node not exist'</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> newNode = &#123; <span class="attr">data</span>: value, <span class="attr">next</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">  newNode.next = node.next;</span><br><span class="line">  node.next = newNode;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> linkedList = linkList();</span><br><span class="line">linkedList.add(<span class="number">1</span>);</span><br><span class="line">linkedList.append(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// &#123; data: &#123; length: 1 &#125;,</span></span><br><span class="line"><span class="comment">// next: &#123; data: 1, next: &#123; data: 2, next: null &#125; &#125; &#125;</span></span><br></pre></td></tr></table></figure>对于单链表的插入数据项， 我们要做的仅仅是改变相应节点的指针的指向，原理如图所示：<img src="/2019/09/21/数据结构：线性表/image-20190922101043201-9118243.png"><img src="image-20190922101043201-9118243.png" loading="lazy">我们想要在<code>p</code> 节点之后插入节点 <code>s</code>, 我们要做的是将 p 节点的指针 <code>next</code> 指向要插入的节点， 同时将要插入的节点的指针指向插入前的下一个节点。注意： 这里的顺序是：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.next --&gt; p.next;</span><br><span class="line">p.next --&gt; s;</span><br></pre></td></tr></table></figure>顺序不可以更换；插入成功之后的效果如下图所示：<img src="/2019/09/21/数据结构：线性表/image-20190922101526386-9118526.png"><img src="image-20190922101526386-9118526.png" loading="lazy">单链表的删除：实现单链表的删除功能也是通过指针来完成的，实现原理如下图所示：<img src="/2019/09/21/数据结构：线性表/image-20190922102047839-9118847.png"><img src="image-20190922102047839-9118847.png" loading="lazy">代码如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除第 i 个节点的元素</span></span><br><span class="line"><span class="keyword">this</span>.delete = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> nodeNext = ((i - <span class="number">1</span> === <span class="number">0</span>) ? headNode : <span class="keyword">this</span>.get(i - <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (!nodeNext || !nodeNext.next) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> deleteNode = nodeNext.next;</span><br><span class="line">  nodeNext.next =  nodeNext.next.next;</span><br><span class="line">  headNodeData.length --;</span><br><span class="line">  deleteNode = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> linkedList = linkList();</span><br><span class="line">linkedList.add(<span class="number">1</span>);</span><br><span class="line">linkedList.add(<span class="number">2</span>);</span><br><span class="line">linkedList.delete(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// &#123; data: &#123; length: 1 &#125;, next: &#123; data: 2, next: null &#125; &#125;</span></span><br><span class="line">linkedList.delete(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// &#123; data: &#123; length: 0 &#125;, next: null &#125;</span></span><br></pre></td></tr></table></figure><h5 id="单链表的整表删除">单链表的整表删除</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.deleteAll = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> deleteNode = headNode</span><br><span class="line">  <span class="keyword">let</span> freeNode;</span><br><span class="line">  <span class="keyword">while</span> (deleteNode &amp;&amp; deleteNode.next) &#123;</span><br><span class="line">    freeNode = deleteNode.next;</span><br><span class="line">    deleteNode.next = <span class="literal">null</span>;</span><br><span class="line">    deleteNode = freeNode;</span><br><span class="line">    headNodeData.length --;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> linkedList = linkList();</span><br><span class="line">linkedList.add(<span class="number">1</span>);</span><br><span class="line">linkedList.add(<span class="number">2</span>);</span><br><span class="line">linkedList.deleteAll();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'list'</span>, linkedList.list);</span><br><span class="line"><span class="comment">// &#123; data: &#123; length: 0 &#125;, next: null &#125;</span></span><br></pre></td></tr></table></figure><h4 id="循环链表">循环链表</h4><blockquote>在单链表中终端节点的指针端由空指针指向头节点，就使得整个单链表形成一个环，这种头尾相接的链表称为循环链表</blockquote>循环链表如下图所示：<img src="/2019/09/21/数据结构：线性表/image-20190923224009682-9249609.png"><img src="image-20190923224009682-9249609.png" loading="lazy">循环链表相比于单链表不同的地方在于终端节点的指针指向不同的，使用循环链表的作用是可以从一个节点出发，查找到列表中的所有节点。<h4 id="双向链表">双向链表</h4>双向链表和单链表的区别在于： 实现双向链表的节点中存在两个指针域，在单链表的基础上，创建另外一个指针指向上一个节点，如下图所示：<img src="/2019/09/21/数据结构：线性表/image-20190923224650271-9250010.png"><img src="image-20190923224650271-9250010.png" loading="lazy">相比于单链表而言， 使用双向链表可以实现在前后两个方向上面的节点查找， 比单链表相比，双向链表可以实现在前后两个方向上面的数据节点查找， 当然缺点是会多出一个指针域来指向上一个节点。<h3 id="对比">对比</h3>如果线性表需要频繁的查找， 很少进行插入和删除工作时， 适合采用顺序存储结构；如果涉及到频繁的插入和删除数据工作， 那么适合采用链式存储结构]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据结构简介&quot;&gt;数据结构简介&lt;/h2&gt;
&lt;blockquote&gt;
数据结构是相互之间存在一种或者多种特定关系的数据元素的集合&lt;/blockquote&gt;
数据结构分为&lt;strong&gt;逻辑结构&lt;/strong&gt;和&lt;strong&gt;物理结构&lt;/strong&gt;；数据对象中数
      
    
    </summary>
    
      <category term="数据结构" scheme="https://newpromise.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="线性表" scheme="https://newpromise.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>decode &amp; encode</title>
    <link href="https://newpromise.github.io/2019/09/15/encode%20&amp;%20decode/"/>
    <id>https://newpromise.github.io/2019/09/15/encode &amp; decode/</id>
    <published>2019-09-15T02:53:26.000Z</published>
    <updated>2021-03-04T07:57:25.610Z</updated>
    
    <content type="html"><![CDATA[<a href="https://github.com/dankogai/js-base64" target="_blank" rel="noopener">js-base64</a> 是用来对于字符编码和解码操作的一个包， 可以用这个包实现原始字符与 base64 编码后字符之间的转换；核心代码：获取base64 对应字符在字符表中十进制值：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b64chars = <span class="string">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'</span>;</span><br><span class="line"><span class="keyword">var</span> b64tab = <span class="function"><span class="keyword">function</span>(<span class="params">bin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> t = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = bin.length; i &lt; l; i++) t[bin.charAt(i)] = i;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;(b64chars);</span><br></pre></td></tr></table></figure>字符解码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cb_decode = <span class="function"><span class="keyword">function</span>(<span class="params">cccc</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = cccc.length,</span><br><span class="line">      padlen = len % <span class="number">4</span>,</span><br><span class="line">      <span class="comment">// 这里通过 &lt;&lt; 移位操作，可以直接操作二进制值</span></span><br><span class="line">      <span class="comment">// n : 将各个字符解码之后的二进制值对应的十进制</span></span><br><span class="line">      n = (len &gt; <span class="number">0</span> ? b64tab[cccc.charAt(<span class="number">0</span>)] &lt;&lt; <span class="number">18</span> : <span class="number">0</span>)</span><br><span class="line">  | (len &gt; <span class="number">1</span> ? b64tab[cccc.charAt(<span class="number">1</span>)] &lt;&lt; <span class="number">12</span> : <span class="number">0</span>)</span><br><span class="line">  | (len &gt; <span class="number">2</span> ? b64tab[cccc.charAt(<span class="number">2</span>)] &lt;&lt;  <span class="number">6</span> : <span class="number">0</span>)</span><br><span class="line">  | (len &gt; <span class="number">3</span> ? b64tab[cccc.charAt(<span class="number">3</span>)]       : <span class="number">0</span>),</span><br><span class="line">      <span class="comment">// 从二进制字符串中按照 8 位依次获取二进制的值</span></span><br><span class="line">      <span class="comment">// chars 即为解码之后的字符串原始值</span></span><br><span class="line">      chars = [</span><br><span class="line">        fromCharCode( n &gt;&gt;&gt; <span class="number">16</span>),</span><br><span class="line">        fromCharCode((n &gt;&gt;&gt;  <span class="number">8</span>) &amp; <span class="number">0xff</span>),</span><br><span class="line">        fromCharCode( n         &amp; <span class="number">0xff</span>)</span><br><span class="line">      ];</span><br><span class="line">  chars.length -= [<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>][padlen];</span><br><span class="line">  <span class="keyword">return</span> chars.join(<span class="string">''</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> _atob = global.atob ? <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> global.atob(a);</span><br><span class="line">&#125; : <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 将base64 字符串按照 4 个字符长度剪切</span></span><br><span class="line">  <span class="keyword">return</span> a.replace(<span class="regexp">/\S&#123;1,4&#125;/g</span>, cb_decode);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义在 atob 上的方法用于字符解码</span></span><br><span class="line"><span class="keyword">var</span> atob = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// replace 方法将不属于 base64 字符集内的字符清空</span></span><br><span class="line">  <span class="comment">// 比如 base64 编码字符串中最后一位可能为 =， 这个符号不代表任何含义</span></span><br><span class="line">  <span class="comment">// base64 字符集正则范围 A-Za-z0-9\+\/</span></span><br><span class="line">  <span class="keyword">return</span> _atob(<span class="built_in">String</span>(a).replace(<span class="regexp">/[^A-Za-z0-9\+\/]/g</span>, <span class="string">''</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="要点">要点</h2><h3 id="stringreplace--方法"><code>String.replace</code>  方法</h3>使用 <code>String.replace</code> 方法可以对于字符串中某些字符作替换操作：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.replace(searchStr | Regexp, replacedStr | replaceFn);</span><br><span class="line"><span class="comment">// searchStr: 匹配的字符</span></span><br><span class="line"><span class="comment">// Regexp: 正则表达式， 被正则表达式匹配到的都会被替换掉</span></span><br><span class="line"><span class="comment">// replacedStr: 用于替换的字符串</span></span><br><span class="line"><span class="comment">// replaceFn: 用于替换过程中的字符串</span></span><br><span class="line"><span class="comment">// return: 被替换掉的字符串</span></span><br></pre></td></tr></table></figure>例如上面的：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将非base64 的字符串清除</span></span><br><span class="line"><span class="built_in">String</span>(a).replace(<span class="regexp">/[^A-Za-z0-9\+\/]/g</span>, <span class="string">''</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 替换正则表达式匹配的字符串， 在替换过程中应用 cb_decode 方法</span></span><br><span class="line">a.replace(<span class="regexp">/\S&#123;1,4&#125;/g</span>, cb_decode);</span><br></pre></td></tr></table></figure><h3 id="正则表达式相关">正则表达式相关</h3><ul><li>在正则中使用限定符 <code>{}</code> 可以限定字符的长度范围<code>\S{1,4}</code>： 匹配字符长度为 1 - 4 的字符串<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 截取字符串按长度为 4 分段截取</span><br><span class="line">let strArr = [];</span><br><span class="line">str.replace(/\S&#123;1,4&#125;/g, (mStr) =&gt;&#123;</span><br><span class="line">  strArr.push(mStr);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><code>replace</code> 方法接受函数参数如下图：<img src="/2019/09/15/encode%20&%20decode/replaceFn.png"></li><li>正则中的描述符 <code>[]</code> 中使用 <code>^</code> 表示不匹配<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正则表示不匹配base64 字符的字符</span></span><br><span class="line"><span class="built_in">String</span>(a).replace(<span class="regexp">/[^A-Za-z0-9\+\/]/g</span>, <span class="string">''</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="按位操作符相关">按位操作符相关</h3>在 js 中， 包含下面几种操作符号， 它们用来在js 中操作二进制数据的位数各种操作符号的作用如下图：<img src="/2019/09/15/encode%20&%20decode/操作符.jpg">示例：对于十进制数 10 和 20:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="number">20</span>;</span><br><span class="line">s1 &amp; s2; <span class="comment">//  十进制 0 二进制 0</span></span><br><span class="line">s1 | s2; <span class="comment">//  30  11110</span></span><br><span class="line">s1 ^ s2; <span class="comment">//  30  11110</span></span><br><span class="line">~s1; <span class="comment">// -11 -1011</span></span><br><span class="line">s1 &lt;&lt; <span class="number">2</span> <span class="comment">// 40 101000</span></span><br><span class="line">s1 &gt;&gt; <span class="number">2</span>; <span class="comment">// 2 10</span></span><br><span class="line">s1 &gt;&gt;&gt; <span class="number">2</span>; <span class="comment">// 2 10</span></span><br></pre></td></tr></table></figure>位操作符在上面 base64 转换中的使用：<ul><li>使用 <code>|</code>来增加二进制字符串使用  <code>|</code> 可以用来存储信息，比如我们对于一组数据定义其存放位置， 将这组二进制数存入到一段二进制值中：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">let</span> str = s1 | s2 &lt;&lt; <span class="number">8</span> | s3 &lt;&lt; <span class="number">16</span>;</span><br><span class="line"><span class="comment">// s1: 1010, s2: 10100, s3: 11110 str: 111100001010000001010</span></span><br></pre></td></tr></table></figure></li><li>使用 <code>&amp;</code> 来保留相应位数如：我们想要保留8位二进制的高四位：<code>let str = s &amp; 0xf0</code> <code>0xf0</code>: 11110000<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s5 = <span class="number">0xf0</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> s4 = s2 &amp; s5;</span><br><span class="line"><span class="built_in">console</span>.log(s5.toString(<span class="number">2</span>), s2.toString(<span class="number">2</span>), s4.toString(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// 11110000 10100 10000</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="进制间的转换">进制间的转换</h3>在 js 中进制之间的相互转化方法如下：十进制转二进制：<code>numObj.toString(radix)</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">2</span>;</span><br><span class="line">num.toString(<span class="number">2</span>); <span class="comment">// '10'</span></span><br></pre></td></tr></table></figure>二进制十进制：<code>parseInt(string, radix)</code><blockquote>The <code>parseInt()</code> function parses a string argument and returns an integer of the specified <a href="https://en.wikipedia.org/wiki/Radix" target="_blank" rel="noopener">radix</a> (the base in mathematical numeral systems).</blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&apos;10&apos;, 2);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a href=&quot;https://github.com/dankogai/js-base64&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;js-base64&lt;/a&gt; 是用来对于字符编码和解码操作的一个包， 可以用这个包实现原始字符与 base64 编码后字符之
      
    
    </summary>
    
      <category term="Base64" scheme="https://newpromise.github.io/categories/Base64/"/>
    
    
      <category term="Base64" scheme="https://newpromise.github.io/tags/Base64/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程（一）</title>
    <link href="https://newpromise.github.io/2019/09/14/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%881%EF%BC%89/"/>
    <id>https://newpromise.github.io/2019/09/14/函数式编程（1）/</id>
    <published>2019-09-14T02:02:34.000Z</published>
    <updated>2021-03-03T10:09:11.254Z</updated>
    
    <content type="html"><![CDATA[函数式编程是一种编程范式， 与之相对应的是面向对象编程和指令式编程等。函数式编程（FP）要更加偏向于声明式而不是命令式；<blockquote>声明式关注于程序做什么， 命令式关注于程序怎样做</blockquote>在FP 中， 有下面几个关键词：<ul><li>纯函数</li><li>函数组合</li><li>避免状态共享</li><li>避免状态的变化</li><li>避免副作用</li></ul><ol><li>纯函数纯函数给定特定的输入值，将总会返回同样的输出值，且没有副作用， 纯函数具有引用透明性的特点，这使得我们更易追踪数据的变化， 减少问题的发生</li><li>函数组合函数组合可以根据我们传入的多个函数返回多个函数组合的新函数，或者根据传入的多个函数进行计算</li><li>避免状态共享状态共享的问题在于你需要了解某一个函数的功能时， 你需要知道函数中使用到的共享变量的调用历史记录， 另外， 使用共享的状态时， 调用函数的顺序不同会导致最终共享状态数据的不同</li><li>状态不变性当函数中的数据被创建之后将不会被更改，如果创建的数据在被创建之后可以被调用的函数更改，那么将会导致程序中的数据流混乱</li><li>避免副作用副作用指的是调用函数之后， 改变了函数之外的状态， 或者导致其他的可以被观测到的行为比如以下副作用：<ul><li>改变外部对象或者变量属性</li><li>写文件</li><li>错发任何外部的程序</li><li>调用其他含有副作用的函数</li></ul>避免上面的副作用可以使得我们易于扩展， 重构， debug 代码</li></ol>函数式编程中的一些其他应用：<h3 id="高阶函数">高阶函数</h3>高阶函数可以接受函数作为参数， 返回一种新的函数，高阶函数经常被用作：<ul><li>抽象或者隔离动作， 行为， 例如回调函数或者 promises</li><li>创造作用于范围广范的数据类型的工具方法</li><li>实现函数组合或者函数重用，通过将函数作为参数传递或者创建柯里化的函数</li><li>接口函数列表， 返回这些输入方法的组合</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        函数式编程是一种编程范式， 与之相对应的是面向对象编程和指令式编程等。函数式编程（FP）要更加偏向于声明式而不是命令式；&lt;blockquote&gt;
声明式关注于程序做什么， 命令式关注于程序怎样做&lt;/blockquote&gt;
在FP 中， 有下面几个关键词：&lt;ul&gt;
&lt;li&gt;纯函数&lt;
      
    
    </summary>
    
      <category term="笔记" scheme="https://newpromise.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="FP" scheme="https://newpromise.github.io/tags/FP/"/>
    
  </entry>
  
  <entry>
    <title>Base64 基础知识</title>
    <link href="https://newpromise.github.io/2019/09/13/base64/"/>
    <id>https://newpromise.github.io/2019/09/13/base64/</id>
    <published>2019-09-13T09:41:19.000Z</published>
    <updated>2021-03-04T07:57:54.779Z</updated>
    
    <content type="html"><![CDATA[Base64 作为一种编码方式， 可以将对于一些数据使用Base64 编码， 那么， 为什么使用 Base64 编码， 使用 Base64 编码的原理是什么以及 Base64 编码在前端的应用，下面的文章将会涉及这些内容：<h2 id="what-is-base64">what is Base64?</h2>在计算机中， 一个字节通常有8位字符， 这些字符使用二进制表示共有 256 种组合， 这些组合形成了 ascii（American Standard Code for Information Interchange，美国信息交换标准代码） 码：一种字节组合和字符的对应表,  基础的 ascii 码共有 128 种组合， 因为不同国家语言字符的需要， 现在很多是扩展的 ascii码，但不同的 扩展ascii 码的前 127 位是基本相同的， 这一部分称为基础 ascii 码： <img src="/2019/09/13/base64/ascii.png">假如我们不通过 Base64 编码， 而是直接向不同设备传输二进制数据，因为一些老旧设备或者软件对于某些二进制值字符的处理方式可能不同， 因就有可能被错误处理，为了解决这种问题， 我们使用Base64 编码将数据统一编码为可见字符，而可见字符在大多设备上的表现行为是一致的，这样就使得数据在不同设备之间的处理出错的可能被降低了。Base64 码共用 64 种对应字符， 对应字符如下:<img src="/2019/09/13/base64/base64.jpg">Base64 码由下面这些字符组成：<ol><li>0 - 25 为大写英文字符 A - Z</li><li>26 - 51 为小写英文字符 a - z</li><li>52 - 61 为数字 0 -9</li><li>另外两个字符 + 和 /</li></ol><h2 id="base64编码原理">Base64编码原理</h2>Base64 本质上是将二进制数据转为文本的形式， 当遇到十进制数据的时候， 需要将十进制转为二进制， 对于二进制数据以连续 6 比特计算其十进制值， 在根据这个值查找上图 Base64表中的字符， 最终我们得到的这段文本即是我们编码后的数据：比如我们对于 <code>myname</code> 进行Base64 编码：<table><thead><tr><th align="center">原始字符</th><th align="center">m</th><th align="center">y</th><th align="center">n</th><th align="center">a</th><th align="center">m</th><th align="center">e</th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">ASCII码十进制</td><td align="center">109</td><td align="center">121</td><td align="center">110</td><td align="center">97</td><td align="center">109</td><td align="center">101</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">二进制</td><td align="center">01101101</td><td align="center">01111001</td><td align="center">01101110</td><td align="center">01100001</td><td align="center">01101101</td><td align="center">01100101</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Base64码二进制</td><td align="center">011011</td><td align="center">010111</td><td align="center">100101</td><td align="center">101110</td><td align="center">011000</td><td align="center">010110</td><td align="center">110101</td><td align="center">100101</td></tr><tr><td align="center">Base64码十进制</td><td align="center">27</td><td align="center">23</td><td align="center">37</td><td align="center">46</td><td align="center">24</td><td align="center">22</td><td align="center">53</td><td align="center">37</td></tr><tr><td align="center">对应 Base64</td><td align="center">b</td><td align="center">X</td><td align="center">l</td><td align="center">u</td><td align="center">Y</td><td align="center">W</td><td align="center">1</td><td align="center">l</td></tr></tbody></table>最终使用 Base64 编码之后的字符串为  <code>bXluYW1l</code>在上面的编码过程中， 我们将六个字符的字符串编码为八个字符的字符串， 编码长度前后对比为 4 ：3， 也即是说， 当原始字符长度为 3 的倍数时， 编码之后长度为 4 的相应倍数， 如果， 原始字符长度不能被 3 整除怎么办？ 这时候， 我们需要对原始字符的二进制进行补零操作：例如， 我们对于 <code>my</code> 进行编码：<table><thead><tr><th>原始字符</th><th>m</th><th>y</th><th></th><th></th></tr></thead><tbody><tr><td>ASCII码十进制</td><td>109</td><td>121</td><td></td><td></td></tr><tr><td>二进制</td><td>01101101</td><td>01111001</td><td>00000000</td><td></td></tr><tr><td>Base64码二进制</td><td>011011</td><td>010111</td><td>100100</td><td>000000</td></tr><tr><td>Base64码十进制</td><td>27</td><td>23</td><td>36</td><td>0</td></tr><tr><td>对应 Base64</td><td>b</td><td>X</td><td>k</td><td>A</td></tr></tbody></table>因为原始字符中补充的 0 没有任何意义， 因此编码后的 A 不带有任何的意义，标准的 ascii 码中将 A 替换为 <code>=</code><code>my</code> 的编码字符串为 <code>bXk=</code>;对于解码过程， 首先观察编码字符串长度， 如果字符串长度不能被 4 整除，那么，需要给编码字符串补充 = 来使得字符串长度可以被 4 整除， 然后在进行解码操作。解码过程是编码过程的逆向操作，将编码字符串的 <code>=</code> 转为 <code>A</code>, 然后转为十进制的 Base64 码， 后转为二进制的6位比特值，将字符串末尾的相应 <code>A</code> 的二进制比特0值丢弃，因为他们不携带任何的信息。最后将8位二进制转为原始字符.<h2 id="前端应用-base64">前端应用 Base64</h2>Base64 在前端应用比较常见的是将图片的二进制数据转为 Base64， 嵌套入 html 中。现代浏览器对于图片的 src 属性支持一种 <code>dataUrl</code> 的特性，格式为：<code>url(data:文件类型;编码方式,编码后的文件内容)</code>例如百度搜索的dataURL：<img src="/2019/09/13/base64/image-20190914095537734.png">使用这种方式的优点是可以减少外部资源请求， 加快页面加载时间， 缺点是对于色彩丰富的图片， 二进制数据编码之后的 Base64 字符串会比较大， 会影响页面的加载速度<h2 id="其他：data-urls">其他：Data URLs</h2>Data URLs 是以 <code>data:</code> 协议为前缀的一种 url，使用 data url 实现了可以将一些小的文件嵌入到文档中的一种方法data url 的组成结构如下： <code>data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</code> data url 由下面三种结构组成: <code>mediatype</code> 表示当前文件的 <code>MIME type</code>, 例如： <code>image/jpeg</code>, <code>text/plain</code> 等当数据 <code>data</code> 为非文本的格式的时候， 使用一个 <code>base64</code> 标志表示当前的数据为使用 <code>base64</code> 编码之后的数据，对于文字格式， 也是可以使用 <code>base64</code> 进行编码操作<code>data</code>: 数据本身我们经常会遇到的是经过 <code>base64</code> 编码过后的图片，除了图片之外， 我们还可以对于文字进行转为 <code>data url</code> 的形式：<code>data:,Hello%2C%20World!</code><code>data:text/plain;base64,SGVsbG8sIFdvcmxkIQ%3D%3D</code>// 经过 base64 编码过的上面的文本： Hello World!<code>data:text/html,%3Ch1%3EHello%2C%20World!%3C%2Fh1%3E</code>// html 文本： <code>&lt;h1&gt;Hello World!&lt;h1&gt;</code>注意：在 data url 中数据本身是 <code>data</code>,当我们需要对于数据进行操作的时候， 我们需要获取到 <code>data urls</code> 中的数据：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 node 中下载 data urls 形式的图片</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">downloadImage</span>(<span class="params">dataUrl</span>) </span>&#123;</span><br><span class="line">  dataUrl = dataUrl.replace(<span class="regexp">/^data:image\/png;base64,/</span>, <span class="string">""</span>);</span><br><span class="line">  fs.writeSync(<span class="string">'image.jpg'</span>, dataUrl, &#123; <span class="attr">encoding</span>: <span class="string">'base64'</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>参考链接：<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs" target="_blank" rel="noopener">data urls</a>]]></content>
    
    <summary type="html">
    
      
      
        Base64 作为一种编码方式， 可以将对于一些数据使用Base64 编码， 那么， 为什么使用 Base64 编码， 使用 Base64 编码的原理是什么以及 Base64 编码在前端的应用，下面的文章将会涉及这些内容：&lt;h2 id=&quot;what-is-base64&quot;&gt;what 
      
    
    </summary>
    
      <category term="基础知识" scheme="https://newpromise.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Base64" scheme="https://newpromise.github.io/tags/Base64/"/>
    
  </entry>
  
  <entry>
    <title>node 中的 events 模块学习</title>
    <link href="https://newpromise.github.io/2019/09/08/event%20Emitter/"/>
    <id>https://newpromise.github.io/2019/09/08/event Emitter/</id>
    <published>2019-09-08T03:32:30.000Z</published>
    <updated>2021-03-03T10:09:11.243Z</updated>
    
    <content type="html"><![CDATA[<a href="https://link.zhihu.com/?target=https%3A//github.com/nodejs/node/blob/master/lib/events.js" target="_blank" rel="noopener">events 模块</a>模仿 events 模块的一些代码， 基本实现原 events 模块的一些功能：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneArray</span>(<span class="params">list, n, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> clonedArr = <span class="keyword">new</span> <span class="built_in">Array</span>(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; n; index++) &#123;</span><br><span class="line">    clonedArr[index] = fn ? fn(list[index]) : list[index];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clonedArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clonelisteners</span>(<span class="params">list, hasWrap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cloneArray(list, list.length, (listener) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> hasWrap ? listener : (listener.listener || listener);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getListeners</span>(<span class="params">target, type, hasWrap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> listenerList = target.events[type];</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> listenerList === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> hasWrap ? [listenerList] : [listenerList.listener || listenerList];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> clonelisteners(listenerList, hasWrap);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.maxListeners;</span><br><span class="line">    <span class="keyword">this</span>.defaultMaxlisteners = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">this</span>.events = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">this</span>.eventsCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">  &#125;</span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">this</span>.maxListeners = <span class="keyword">this</span>.maxListeners || <span class="keyword">this</span>.defaultMaxlisteners;</span><br><span class="line">    <span class="keyword">this</span>.events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  checkListener(listener) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'listener is not function type'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  listenerCount(emitter, type) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> emitter.listenerCount === <span class="string">'function'</span>) <span class="keyword">return</span> emitter.listenerCount(type);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">listenerCount</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> events = <span class="keyword">this</span>.events;</span><br><span class="line">      <span class="keyword">if</span> (events === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">const</span> eventList = <span class="keyword">this</span>.events[type];</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> eventList === <span class="string">'function'</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (eventList) &#123;</span><br><span class="line">        <span class="keyword">return</span> eventList.length;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;;</span><br><span class="line">    listenerCount.call(emitter, type);</span><br><span class="line">  &#125;</span><br><span class="line">  prependListener(type, listener) &#123;</span><br><span class="line">    <span class="keyword">this</span>.addListeners(type, listener, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  prependOnceListener(type, listener) &#123;</span><br><span class="line">    <span class="keyword">this</span>.once(type, listener, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  addListeners(type, listener, prepend) &#123;</span><br><span class="line">    <span class="keyword">this</span>.checkListener(listener);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.events) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.events.newListener) <span class="keyword">this</span>.emit(<span class="string">'newListener'</span>, listener.listener || listener);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> existlistener = <span class="keyword">this</span>.events[type];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> existlistener === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.events[type] = prepend ? [listener, existlistener] : [existlistener, listener];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> existlistener === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.events[type] = listener;</span><br><span class="line">      <span class="keyword">this</span>.eventsCount ++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prepend) &#123;</span><br><span class="line">      <span class="keyword">this</span>.events[type].unshift(listener);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.events[type].push(listener);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> maxlistenerLength = <span class="keyword">this</span>.getMaxlisteners();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.events[type].length &gt; maxlistenerLength) &#123;</span><br><span class="line">      <span class="keyword">let</span> w = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'memory leak'</span>);</span><br><span class="line">      process.emitWarning(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  on() &#123;</span><br><span class="line">    <span class="keyword">this</span>.addListeners(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">  off() &#123;</span><br><span class="line">    <span class="keyword">this</span>.removeListener(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">  once(type, listener, prepend) &#123;</span><br><span class="line">    <span class="keyword">this</span>.checkListener(listener);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">wrapFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.fired) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fired = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.emitter.removeListener(type, <span class="keyword">this</span>.wraplistenerFn);</span><br><span class="line">        <span class="keyword">this</span>.listener.apply(<span class="keyword">this</span>.emitter, <span class="built_in">arguments</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> listenerWrapStates = &#123; <span class="attr">fired</span>: <span class="literal">false</span>, listener, <span class="attr">wraplistenerFn</span>: <span class="literal">undefined</span>, <span class="attr">emitter</span>: <span class="keyword">this</span> &#125;;</span><br><span class="line">    <span class="keyword">const</span> wrapedlistener = wrapFn.bind(listenerWrapStates);</span><br><span class="line">    wrapedlistener.listener = listener;</span><br><span class="line">    listenerWrapStates.wraplistenerFn = wrapedlistener;</span><br><span class="line">    <span class="keyword">this</span>.on(type, wrapedlistener, prepend);</span><br><span class="line">  &#125;</span><br><span class="line">  emit(type, ...args) &#123;</span><br><span class="line">    <span class="keyword">const</span> existlistener = <span class="keyword">this</span>.events[type];</span><br><span class="line">    <span class="keyword">if</span> (existlistener === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> existlistener !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> existList = cloneArray(existlistener, existlistener.length);</span><br><span class="line">      existList.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> &#123;</span><br><span class="line">        listener.apply(<span class="keyword">this</span>, args);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      existlistener.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  removeAlllisteners(type) &#123;</span><br><span class="line">    <span class="keyword">const</span> listenerList = <span class="keyword">this</span>.events[type];</span><br><span class="line">    <span class="keyword">const</span> isRemoveAllEvens = <span class="built_in">arguments</span>.length === <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.events === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 移除全部的 listernr</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.events.removeListener === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isRemoveAllEvens) &#123;</span><br><span class="line">        <span class="keyword">this</span>.events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.eventsCount = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (listenerList) &#123;</span><br><span class="line">          <span class="keyword">delete</span> <span class="keyword">this</span>.events[type];</span><br><span class="line">          <span class="keyword">this</span>.eventsCount --;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.eventsCount === <span class="number">0</span>) <span class="keyword">this</span>.events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">        &#125; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isRemoveAllEvens) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="keyword">this</span>.events) &#123;</span><br><span class="line">          <span class="keyword">if</span> (key === <span class="string">'removeListener'</span>) <span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">this</span>.removeAlllisteners(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.removeAlllisteners(<span class="string">'removeListener'</span>);</span><br><span class="line">        <span class="keyword">this</span>.eventsCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> listenerList === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.removeListener(type, listenerList);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (listenerList) &#123;</span><br><span class="line">      listenerList.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.removeListener(type, listener);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  setMaxlisteners(num) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> num !== <span class="string">'number'</span> || num &lt; <span class="number">0</span> || <span class="built_in">Number</span>.isNaN(num)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'listernrs length is a number'</span>);</span><br><span class="line">    <span class="keyword">this</span>.maxListeners = num;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  getMaxlisteners() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.maxListeners;</span><br><span class="line">  &#125;</span><br><span class="line">  eventNames() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.events === <span class="literal">undefined</span> || <span class="keyword">this</span>.eventsCount === <span class="number">0</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.events);</span><br><span class="line">  &#125;</span><br><span class="line">  rawListeners(type) &#123;</span><br><span class="line">    <span class="keyword">const</span> eventList = <span class="keyword">this</span>.events[type];</span><br><span class="line">    <span class="keyword">if</span> (eventList === <span class="literal">undefined</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">return</span> getListeners(<span class="keyword">this</span>, type, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  listeners(type) &#123;</span><br><span class="line">    <span class="keyword">const</span> eventList = <span class="keyword">this</span>.events[type];</span><br><span class="line">    <span class="keyword">if</span> (eventList === <span class="literal">undefined</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">return</span> getListeners(<span class="keyword">this</span>, type, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  removeListener(type, listener) &#123;</span><br><span class="line">    <span class="keyword">this</span>.checkListener(listener);</span><br><span class="line">    <span class="keyword">const</span> eventListeners = <span class="keyword">this</span>.events[type];</span><br><span class="line">    <span class="keyword">if</span> (eventListeners === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> eventListeners === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (eventListeners === listener || eventListeners.listener === listener) &#123;</span><br><span class="line">        <span class="keyword">this</span>.eventsCount --;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.eventsCount === <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">delete</span> <span class="keyword">this</span>.events[type];</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.events.removeListener) &#123;</span><br><span class="line">            <span class="keyword">this</span>.emit(<span class="string">'removeListener'</span>, type, eventListeners || eventListeners.listener);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 当存放的事件是一个数组的时候</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> handlerIndex = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">let</span> originlistener;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; eventListeners.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventListeners[i] === listener || eventListeners[i].listener === listener) &#123;</span><br><span class="line">          handlerIndex = i;</span><br><span class="line">          originlistener = eventListeners[i].listener;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (handlerIndex &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">if</span> (handlerIndex === <span class="number">0</span>) &#123;</span><br><span class="line">        eventListeners.shift();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> spliceOne = <span class="function"><span class="keyword">function</span> (<span class="params">list, index</span>) </span>&#123;</span><br><span class="line">          list.splice(index, <span class="number">1</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        spliceOne(eventListeners, handlerIndex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (eventListeners.length === <span class="number">1</span>) <span class="keyword">this</span>.events[type] = eventListeners[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.events.removeListener) <span class="keyword">this</span>.emit(<span class="keyword">this</span>.removeListener, type, originlistener || listener); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = EventEmitter;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/nodejs/node/blob/master/lib/events.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;events 模块
      
    
    </summary>
    
      <category term="node module" scheme="https://newpromise.github.io/categories/node-module/"/>
    
    
      <category term="node" scheme="https://newpromise.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>prop in vue.js（prop 的初始化）</title>
    <link href="https://newpromise.github.io/2019/05/25/prop%20in%20vue%EF%BC%88prop%20%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%89/"/>
    <id>https://newpromise.github.io/2019/05/25/prop in vue（prop 的初始化）/</id>
    <published>2019-05-25T09:10:27.000Z</published>
    <updated>2021-03-03T10:09:11.250Z</updated>
    
    <content type="html"><![CDATA[<h3 id="prop">Prop</h3>在 vue.js 中, 使用 <code>prop</code> 可以实现父组件向子组件传递值，在子组件中的 <code>props</code> 中的数据将会和父组件中传递的相应的 <code>prop</code> 保持一致，在传递 <code>prop</code> 的时候，可以传递一个数组, 例如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">'data1'</span>, <span class="string">'data2'</span>, <span class="string">'data3'</span> ...]</span><br></pre></td></tr></table></figure> 或者可以传递一个对象，对象的键是要传递的 prop 名称， 对象的值可以是一个对象， 这个对象中 可以定义传递值的<code>type</code> 以及 <code>default</code> 属性：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  data1: &#123;</span><br><span class="line">    type: <span class="built_in">Boolean</span>, <span class="comment">// 传递值的类型， 可以是一个数组 [Boolean, String]</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="literal">true</span> <span class="comment">// 当父组件没有传递的时候， 子组件中使用的默认值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>当父组件中传递值的类型不符合子组件 props 中相应值的 type 的时候， vue 会在控制台进行报错。在源码中， 在初始化 prop 的时候， 会对prop 进行校验。<h4 id="初始化-props">初始化 <code>props</code></h4>在 <code>initState</code> 中：当当前组件中存在 <code>props</code> 的时候， 对于 <code>props</code> 执行 <code>initProps</code> 进行初始化：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm</span>) </span>&#123;</span><br><span class="line">    vm._watchers = [];</span><br><span class="line">    <span class="keyword">var</span> opts = vm.$options;</span><br><span class="line">    <span class="keyword">if</span> (opts.props) &#123; initProps(vm, opts.props); &#125;</span><br><span class="line">    <span class="keyword">if</span> (opts.methods) &#123; initMethods(vm, opts.methods); &#125;</span><br><span class="line">    <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">      initData(vm);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (opts.computed) &#123; initComputed(vm, opts.computed); &#125;</span><br><span class="line">    <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">      initWatch(vm, opts.watch);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>在 <code>initProps</code> 中接受两个参数： <code>vm</code> 当前 vue 的实例， <code>propsOptions</code> 在当前组件中规范化后的 <code>props</code> 对象<blockquote>在执行 <code>initProps</code> 方法之前， 在 <code>vm.$options</code> 属性中的  <code>props</code> 属性中已经对于传递的 <code>props</code> 进行了规范化处理为下面的这种形式：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;test: &#123;</span><br><span class="line">&gt;  type: sometype,</span><br><span class="line">&gt;  <span class="keyword">default</span>: <span class="comment">//  默认值， 如果没有传， 那么就没有</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><code>initProps</code>:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于初始化 props 对象  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initProps</span> (<span class="params">vm, propsOptions</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// vm.$options.propsData: 父组件中传递的 props 对象</span></span><br><span class="line">    <span class="keyword">var</span> propsData = vm.$options.propsData || &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> props = vm._props = &#123;&#125;;</span><br><span class="line">    <span class="comment">// cache prop keys so that future props updates can iterate using Array</span></span><br><span class="line">    <span class="comment">// instead of dynamic object key enumeration.</span></span><br><span class="line">    <span class="keyword">var</span> keys = vm.$options._propKeys = [];</span><br><span class="line">    <span class="keyword">var</span> isRoot = !vm.$parent;</span><br><span class="line">    <span class="comment">// root instance props should be converted</span></span><br><span class="line">    <span class="keyword">if</span> (!isRoot) &#123;</span><br><span class="line">      toggleObserving(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> loop = <span class="function"><span class="keyword">function</span> (<span class="params"> key </span>) </span>&#123;</span><br><span class="line">      keys.push(key);</span><br><span class="line">      <span class="keyword">var</span> value = validateProp(key, propsOptions, propsData, vm);</span><br><span class="line">      <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">var</span> hyphenatedKey = hyphenate(key);</span><br><span class="line">        <span class="keyword">if</span> (isReservedAttribute(hyphenatedKey) ||</span><br><span class="line">            config.isReservedAttr(hyphenatedKey)) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            (<span class="string">"\""</span> + hyphenatedKey + <span class="string">"\" is a reserved attribute and cannot be used as component prop."</span>),</span><br><span class="line">            vm</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">        defineReactive(props, key, value, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (!isRoot &amp;&amp; !isUpdatingChildComponent) &#123;</span><br><span class="line">            warn(</span><br><span class="line">              <span class="string">"Avoid mutating a prop directly since the value will be "</span> +</span><br><span class="line">              <span class="string">"overwritten whenever the parent component re-renders. "</span> +</span><br><span class="line">              <span class="string">"Instead, use a data or computed property based on the prop's "</span> +</span><br><span class="line">              <span class="string">"value. Prop being mutated: \""</span> + key + <span class="string">"\""</span>,</span><br><span class="line">              vm</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// static props are already proxied on the component's prototype</span></span><br><span class="line">      <span class="comment">// during Vue.extend(). We only need to proxy props defined at</span></span><br><span class="line">      <span class="comment">// instantiation here.</span></span><br><span class="line">      <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">        proxy(vm, <span class="string">"_props"</span>, key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> propsOptions) loop( key );</span><br><span class="line">    toggleObserving(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>在上面的函数中。我们传入了 vue 实例和 当前组件中传入的 props 中的数据， 在这个函数中， 我们定义了四个变量：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> propsData = vm.$options.propsData || &#123;&#125;; <span class="comment">// 获取到父组件传递到子组件中的值</span></span><br><span class="line"><span class="keyword">var</span> props = vm._props = &#123;&#125;; <span class="comment">// 在实例上的 _props 属性上定义空对象 &#123;&#125;</span></span><br><span class="line"><span class="comment">// cache prop keys so that future props updates can iterate using Array</span></span><br><span class="line"><span class="comment">// instead of dynamic object key enumeration.</span></span><br><span class="line"><span class="keyword">var</span> keys = vm.$options._propKeys = []; <span class="comment">// 在 实例的 $options 属性上定义 _propKeys 属性， 并初始化为数组</span></span><br><span class="line"><span class="keyword">var</span> isRoot = !vm.$parent; <span class="comment">// 判断是否为根元素， 因为对于根元素， 其实例上没有 `$parent` 属性， 这个时候 `isRoot` 为true</span></span><br></pre></td></tr></table></figure>上面的 <code>toggleObserving</code> 方法用来切换是否对与数据进行监听的开关函数：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * In some cases we may want to disable observation inside a component's</span></span><br><span class="line"><span class="comment"> * update computation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> shouldObserve = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 根据传递的 vue 属性来切换 `shouleObserve` 的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toggleObserving</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  shouldObserve = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>通过调用这个方法， 改变的是全局变量 <code>shouldObserve</code> 的值， 这个值的作用我们后面在说， 现在， 我们先看下在 <code>initProps</code> 中的 <code>for in </code> 中的 <code>loop</code> 方法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> propsOptions) loop(key);</span><br></pre></td></tr></table></figure>在上面的代码中， 对于当前组件内 prop 中的每一个 prop 值， 都执行 <code>loop</code> 方法：<code>loop</code> 方法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// key prop 值</span></span><br><span class="line"><span class="keyword">var</span> loop = <span class="function"><span class="keyword">function</span> (<span class="params"> key </span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将当前组件内所有的 prop 值存入到 keys 中</span></span><br><span class="line">  keys.push(key);</span><br><span class="line">  <span class="comment">// 根据定义的 prop 规则判断传入的 prop 值是否有效</span></span><br><span class="line">  <span class="keyword">var</span> value = validateProp(key, propsOptions, propsData, vm);</span><br><span class="line">  <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> hyphenatedKey = hyphenate(key);</span><br><span class="line">    <span class="keyword">if</span> (isReservedAttribute(hyphenatedKey) ||</span><br><span class="line">        config.isReservedAttr(hyphenatedKey)) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        (<span class="string">"\""</span> + hyphenatedKey + <span class="string">"\" is a reserved attribute and cannot be used as component prop."</span>),</span><br><span class="line">        vm</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    defineReactive(props, key, value, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!isRoot &amp;&amp; !isUpdatingChildComponent) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">"Avoid mutating a prop directly since the value will be "</span> +</span><br><span class="line">          <span class="string">"overwritten whenever the parent component re-renders. "</span> +</span><br><span class="line">          <span class="string">"Instead, use a data or computed property based on the prop's "</span> +</span><br><span class="line">          <span class="string">"value. Prop being mutated: \""</span> + key + <span class="string">"\""</span>,</span><br><span class="line">          vm</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// static props are already proxied on the component's prototype</span></span><br><span class="line">  <span class="comment">// during Vue.extend(). We only need to proxy props defined at</span></span><br><span class="line">  <span class="comment">// instantiation here.</span></span><br><span class="line">  <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">    proxy(vm, <span class="string">"_props"</span>, key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>在上面的 loop 方法中， 当传入 key 之后， 执行了 <code>validateProp</code> 方法， 这个方法定义如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;key&#125;</span> </span>在 props 中定义的 prop 值 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;propOptions&#125;</span> </span>propOptions : 所有的 prop 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;propsData&#125;</span> </span>propsData 从上层组件传入的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;vm&#125;</span> </span>vue 实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validateProp</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  key,</span></span></span><br><span class="line"><span class="function"><span class="params">  propOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">  propsData,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取当前 prop 值的规则</span></span><br><span class="line">  <span class="keyword">var</span> prop = propOptions[key];</span><br><span class="line">  <span class="comment">// 判断这个 prop 值有没有被传入到</span></span><br><span class="line">  <span class="keyword">var</span> absent = !hasOwn(propsData, key);</span><br><span class="line">  <span class="keyword">var</span> value = propsData[key];</span><br><span class="line">  <span class="comment">// boolean casting</span></span><br><span class="line">  <span class="keyword">var</span> booleanIndex = getTypeIndex(<span class="built_in">Boolean</span>, prop.type);</span><br><span class="line">  <span class="keyword">if</span> (booleanIndex &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (absent &amp;&amp; !hasOwn(prop, <span class="string">'default'</span>)) &#123;</span><br><span class="line">      value = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value === <span class="string">''</span> || value === hyphenate(key)) &#123;</span><br><span class="line">      <span class="comment">// only cast empty string / same name to boolean if</span></span><br><span class="line">      <span class="comment">// boolean has higher priority</span></span><br><span class="line">      <span class="keyword">var</span> stringIndex = getTypeIndex(<span class="built_in">String</span>, prop.type);</span><br><span class="line">      <span class="keyword">if</span> (stringIndex &lt; <span class="number">0</span> || booleanIndex &lt; stringIndex) &#123;</span><br><span class="line">        value = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// check default value</span></span><br><span class="line">  <span class="keyword">if</span> (value === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    value = getPropDefaultValue(vm, prop, key);</span><br><span class="line">    <span class="comment">// since the default value is a fresh copy,</span></span><br><span class="line">    <span class="comment">// make sure to observe it.</span></span><br><span class="line">    <span class="keyword">var</span> prevShouldObserve = shouldObserve;</span><br><span class="line">    toggleObserving(<span class="literal">true</span>);</span><br><span class="line">    observe(value);</span><br><span class="line">    toggleObserving(prevShouldObserve);</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    assertProp(prop, key, value, vm, absent);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在这个方法内部 定义了四个变量：<code>prop</code>: 当前传入 prop 值的对象<code>absent</code>:  布尔值， 当前 prop 有没有被父组件传入<code>value</code>:  父组件传入的 prop 的值， 如果没有传入，为 <code>undefined</code><code>booleanIndex</code>:  是通过 <code>getTypeIndex</code> 方法返回的， 这个方法的作用是：当 prop 中声明的 type 中包含有布尔值的时候， 如果 type 为 String， 返回 0， 如果 type 为数组， 返回这个 Boolean 值在 type 数组中的顺序 index， 如果不包含布尔值， 那么返回 -1<code>getTypeIndex</code>:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// expectedTypes： prop 中声明的 type</span></span><br><span class="line"><span class="comment">// type: 相应的 type 类型， 例如： Boolean, String</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTypeIndex</span> (<span class="params">type, expectedTypes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(expectedTypes)) &#123;</span><br><span class="line">    <span class="keyword">return</span> isSameType(expectedTypes, type) ? <span class="number">0</span> : <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = expectedTypes.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isSameType(expectedTypes[i], type)) &#123;</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这里， 使用了 <code>isSameType</code> 方法来进行比较者两个 type 是否相等：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Use function string name to check built-in types,</span></span><br><span class="line"><span class="comment">  * because a simple equality check will fail when running</span></span><br><span class="line"><span class="comment">  * across different vms / iframes.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">getType</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> match = fn &amp;&amp; fn.toString().match(<span class="regexp">/^\s*function (\w+)/</span>);</span><br><span class="line">   <span class="keyword">return</span> match ? match[<span class="number">1</span>] : <span class="string">''</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">isSameType</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> getType(a) === getType(b)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>在上面的 <code>getType</code> 中， 调用 <code>fn.toString()</code> 方法， 再通过正则表达式获取到 <code>(\w+) </code> 内的内容，例如：<blockquote>因为， 在 js 中例如 <code>Boolean</code>, <code>String</code> 之类的类型， 都是代表着一个个的函数方法， 对于这个函数， 可以调用 toString</blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Boolean</span><br><span class="line"><span class="comment">// ƒ Boolean() &#123; [native code] &#125;</span></span><br><span class="line">Boolean.toString()</span><br><span class="line"><span class="comment">//"function Boolean() &#123; [native code] &#125;"</span></span><br></pre></td></tr></table></figure>接来下， 对于数据进行初始化：针对需要校验的 type 中包含有 <code>Boolean</code> 字段的时候<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当 prop 的type中包含有 “Boolean” 的时候  </span></span><br><span class="line"><span class="keyword">if</span> (booleanIndex &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="comment">// 当没有传入的 prop 的时候， 并且没有 default 属性的时候</span></span><br><span class="line">      <span class="keyword">if</span> (absent &amp;&amp; !hasOwn(prop, <span class="string">'default'</span>)) &#123;</span><br><span class="line">        <span class="comment">// 将 prop 值置为 false</span></span><br><span class="line">        value = <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value === <span class="string">''</span> || value === hyphenate(key)) &#123;</span><br><span class="line">        <span class="comment">// 当 boolean 有更高优先级的时候， 将空字符串或者和 prop 中名字相同的值转化为 布尔值</span></span><br><span class="line">        <span class="comment">// only cast empty string / same name to boolean if</span></span><br><span class="line">        <span class="comment">// boolean has higher priority</span></span><br><span class="line">        <span class="keyword">var</span> stringIndex = getTypeIndex(<span class="built_in">String</span>, prop.type);</span><br><span class="line">        <span class="keyword">if</span> (stringIndex &lt; <span class="number">0</span> || booleanIndex &lt; stringIndex) &#123;</span><br><span class="line">          value = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>例如：有以下子组件： child.vue<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    propData: &#123;</span><br><span class="line">      type: [Boolean, String],</span><br><span class="line">default: &apos;&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在父组件中如下定义：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;child prop-data=&quot;&quot;&gt;&lt;/child&gt;</span><br></pre></td></tr></table></figure>那么在子组件中， 获得到的 <code>propData</code> 值为 <code>true</code>;或者， 当在父组件中如下定义的时候：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;child prop-data=&quot;propData&quot;&gt;&lt;/child&gt;</span><br></pre></td></tr></table></figure>和上面相同， 也是为 <code>true</code>,总之：当定义的 prop 接受值的类型，<code>Boolean</code> 值类型优先级要高于 <code>String</code> 的时候（在 type 中  <code>Boolean</code> 在 <code>String</code> 前面 <code>[Boolean, String]</code>）:<ul><li>当传递的值为空字符串的时候， 接受到的prop 值变为 <code>true</code></li><li>当传递的值为字符串并且和驼峰后的 prop 名相同的时候， 接受的值也将转为 <code>true</code></li></ul>另外， 当在父组件中没有传入 prop 值， 并且， 没有声明 <code>default</code> 属性， 当校验 <code>type</code> 中包含有<code>Boolean</code> 的时候， 这个时候， 获取这个  <code>prop</code> 的值将为 <code>false</code><code>child.vue</code> 组件中：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    propData: &#123;</span><br><span class="line">      type: [Boolean, String]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>父组件中：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;child&gt;&lt;/child&gt;</span><br></pre></td></tr></table></figure>在 <code>child.vue</code> 组件中获取到 <code>propData</code> 的值为 <code>false</code>;]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;prop&quot;&gt;Prop&lt;/h3&gt;
在 vue.js 中, 使用 &lt;code&gt;prop&lt;/code&gt; 可以实现父组件向子组件传递值，在子组件中的 &lt;code&gt;props&lt;/code&gt; 中的数据将会和父组件中传递的相应的 &lt;code&gt;prop&lt;/code&gt; 保持一致，在
      
    
    </summary>
    
      <category term="vue 源码阅读" scheme="https://newpromise.github.io/categories/vue-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="vue 源码" scheme="https://newpromise.github.io/tags/vue-%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>watch in vue.js</title>
    <link href="https://newpromise.github.io/2019/05/13/watch%20in%20vue/"/>
    <id>https://newpromise.github.io/2019/05/13/watch in vue/</id>
    <published>2019-05-13T09:10:27.000Z</published>
    <updated>2021-03-03T10:09:11.253Z</updated>
    
    <content type="html"><![CDATA[<h3 id="watch-方法">watch 方法</h3>vue 的 watch 方法用来监听 vue 中 data 的变动, 可以接受一个函数， 对象， 字符串， 或者数组。<code>watch</code> 方法接受两个参数： <code>deep</code>  &amp; <code>immediate</code>,  <code>immediate</code>  表明是否立即进行函数调用， <code>deep</code> 表示是否监听更深一级的对象；例如在vue 组件中：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">    data: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// some code... </span></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="keyword">this</span>.data = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>当 <code>this.data</code> 发生重新赋值的时候， 就会调用 <code>watch</code>  中 <code>data</code> 后面跟的匿名函数：在 <code>vue.js</code> 中， 调用流程如下：首先， 因为在 vue <code>watch</code> 中的名称是先写在 <code>data</code> 中的，在初始化 <code>watch</code> 方法之前， 首先对于 <code>data</code> 中的数据进行了初始化，调用了 <code>defineReactive</code>  方法， 将其数据设为响应式的数据<ol><li><h5 id="初始化-watch-方法：">初始化 <code>watch</code> 方法：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化状态</span></span><br><span class="line"><span class="comment">// vm： vue 实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm</span>) </span>&#123;</span><br><span class="line">  vm._watchers = [];</span><br><span class="line">  <span class="keyword">var</span> opts = vm.$options;</span><br><span class="line">  <span class="keyword">if</span> (opts.props) &#123; initProps(vm, opts.props); &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.methods) &#123; initMethods(vm, opts.methods); &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.computed) &#123; initComputed(vm, opts.computed); &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    <span class="comment">// 初始化 watch</span></span><br><span class="line">    initWatch(vm, opts.watch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><code>initWatch</code> 为如下方法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于 vue watch 方法中的每一个键都创建一个 watcher  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initWatch</span> (<span class="params">vm, watch</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> watch) &#123;</span><br><span class="line">      <span class="keyword">var</span> handler = watch[key];</span><br><span class="line">      <span class="comment">// 当watch 键后面跟着一个数组的时候， 对于数组里面的每一个函数， 都调用 createWatcher 方法</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(handler)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; handler.length; i++) &#123;</span><br><span class="line">          createWatcher(vm, key, handler[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createWatcher(vm, key, handler);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><code>createWatcher</code> 方法： 用于在 <code>watch</code> 中某个键的相关字段进行解析：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vm: vue 实例</span></span><br><span class="line"><span class="comment">// expOrFn: 创建 watcher 的一些数据名称</span></span><br><span class="line"><span class="comment">// hander 回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWatcher</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    vm,</span></span></span><br><span class="line"><span class="function"><span class="params">    expOrFn,</span></span></span><br><span class="line"><span class="function"><span class="params">    handler,</span></span></span><br><span class="line"><span class="function"><span class="params">    options</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当执行函数是一个对象的时候， 这个时候是将 handler 的 handler调用给执行函数</span></span><br><span class="line">    <span class="comment">// 这里的 options 是 watch 函数的配置信息</span></span><br><span class="line">    <span class="keyword">if</span> (isPlainObject(handler)) &#123;</span><br><span class="line">      options = handler;</span><br><span class="line">      handler = handler.handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当 handler 是一个字符串的时候， 会调用 vm 中相应的方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> handler === <span class="string">'string'</span>) &#123;</span><br><span class="line">      handler = vm[handler];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用在 vue 实例 vm 上面的 $watch 方法</span></span><br><span class="line">    <span class="keyword">return</span> vm.$watch(expOrFn, handler, options)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="调用-vue-实例上面的-watch-方法，-这个方法会对于当前的方法创建一个观察者-watcher">调用 vue 实例上面的 <code>$watch</code> 方法， 这个方法会对于当前的方法创建一个观察者 <code>watcher</code></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  Vue.prototype.$watch = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    expOrFn,</span></span></span><br><span class="line"><span class="function"><span class="params">    cb,</span></span></span><br><span class="line"><span class="function"><span class="params">    options</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (isPlainObject(cb)) &#123;</span><br><span class="line">      <span class="keyword">return</span> createWatcher(vm, expOrFn, cb, options)</span><br><span class="line">    &#125;</span><br><span class="line">    options = options || &#123;&#125;;</span><br><span class="line">    options.user = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 创建一个新的观察者</span></span><br><span class="line">    <span class="keyword">var</span> watcher = <span class="keyword">new</span> Watcher(vm, expOrFn, cb, options);</span><br><span class="line">    <span class="comment">// 当可选项中包含有 immediate 属性的时候</span></span><br><span class="line">    <span class="keyword">if</span> (options.immediate) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 立即执行当前 watch 函数</span></span><br><span class="line">        cb.call(vm, watcher.value);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        handleError(error, vm, (<span class="string">"callback for immediate watcher \""</span> + (watcher.expression) + <span class="string">"\""</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一个取消 watch 的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unwatchFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      watcher.teardown();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="当-调用-watch-方法的时候，-将当前-watch-内-data-的回调函数作为依赖进行收集。">当 调用 watch 方法的时候， 将当前 <code>watch</code> 内 <code>data</code> 的回调函数作为依赖进行收集。</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Watcher = <span class="function"><span class="keyword">function</span> <span class="title">Watcher</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    vm,</span></span></span><br><span class="line"><span class="function"><span class="params">    expOrFn,</span></span></span><br><span class="line"><span class="function"><span class="params">    cb,</span></span></span><br><span class="line"><span class="function"><span class="params">    options,</span></span></span><br><span class="line"><span class="function"><span class="params">    isRenderWatcher</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.vm = vm;</span><br><span class="line">    <span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">      vm._watcher = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vm._watchers.push(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// options</span></span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">      <span class="keyword">this</span>.deep = !!options.deep;</span><br><span class="line">      <span class="keyword">this</span>.user = !!options.user;</span><br><span class="line">      <span class="keyword">this</span>.lazy = !!options.lazy;</span><br><span class="line">      <span class="keyword">this</span>.sync = !!options.sync;</span><br><span class="line">      <span class="keyword">this</span>.before = options.before;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.deep = <span class="keyword">this</span>.user = <span class="keyword">this</span>.lazy = <span class="keyword">this</span>.sync = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回调函数被绑定到 Watcher 观察者上面的 cb 属性上面</span></span><br><span class="line">    <span class="keyword">this</span>.cb = cb;</span><br><span class="line">    <span class="keyword">this</span>.id = ++uid$<span class="number">1</span>; <span class="comment">// uid for batching</span></span><br><span class="line">    <span class="keyword">this</span>.active = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="keyword">this</span>.lazy; <span class="comment">// for lazy watchers</span></span><br><span class="line">    <span class="keyword">this</span>.deps = [];</span><br><span class="line">    <span class="keyword">this</span>.newDeps = [];</span><br><span class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">new</span> _Set();</span><br><span class="line">    <span class="keyword">this</span>.newDepIds = <span class="keyword">new</span> _Set();</span><br><span class="line">    <span class="keyword">this</span>.expression = expOrFn.toString();</span><br><span class="line">    <span class="comment">// parse expression for getter</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.getter = expOrFn;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 这里对于监听的变量值进行解析</span></span><br><span class="line">      <span class="keyword">this</span>.getter = parsePath(expOrFn);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'this.getter'</span>, <span class="keyword">this</span>.getter);</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.getter) &#123;</span><br><span class="line">        <span class="keyword">this</span>.getter = noop;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">"Failed watching path: \""</span> + expOrFn + <span class="string">"\" "</span> +</span><br><span class="line">          <span class="string">'Watcher only accepts simple dot-delimited paths. '</span> +</span><br><span class="line">          <span class="string">'For full control, use a function instead.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy</span><br><span class="line">      ? <span class="literal">undefined</span></span><br><span class="line">      : <span class="keyword">this</span>.get();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Evaluate the getter, and re-collect dependencies.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Watcher.prototype.get = <span class="function"><span class="keyword">function</span> <span class="title">get</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将当前的 Watcher 赋值给 Dep.target</span></span><br><span class="line">    pushTarget(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">var</span> value;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="keyword">this</span>.vm;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 调用 getter 方法， 触发响应式数据的 get 属性， 进行依赖搜集</span></span><br><span class="line">      value = <span class="keyword">this</span>.getter.call(vm, vm);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'this.value'</span>, value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">        handleError(e, vm, (<span class="string">"getter for watcher \""</span> + (<span class="keyword">this</span>.expression) + <span class="string">"\""</span>));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// "touch" every property so they are all tracked as</span></span><br><span class="line">      <span class="comment">// dependencies for deep watching</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">        traverse(value);</span><br><span class="line">      &#125;</span><br><span class="line">      popTarget();</span><br><span class="line">      <span class="keyword">this</span>.cleanupDeps();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><code>parsePath</code> 方法用于监听的字段进行解析：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bailRE = <span class="keyword">new</span> <span class="built_in">RegExp</span>((<span class="string">"[^"</span> + (unicodeRegExp.source) + <span class="string">".$_\\d]"</span>));</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parsePath</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bailRE.test(path)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 按照 . 号进行分割为数组， 适用于我们想要监听一个对象下面的某一个属性的时候</span></span><br><span class="line">  <span class="keyword">var</span> segments = path.split(<span class="string">'.'</span>);</span><br><span class="line">  <span class="comment">// 返回的函数作为 上面代码中的 this.getter</span></span><br><span class="line">  <span class="comment">// 当调用 this.getter 函数的时候， 会触发在当前数据上面的响应式数据的 get 方法， 搜集依赖</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; segments.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!obj) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">      obj = obj[segments[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>当触发响应式数据的 <code>getter</code> 属性的时候，在 <code>defineReactive</code> 中, 会进行依赖收集<img src="/2019/05/13/watch%20in%20vue/image-20190514150916088.png">当调用<code>dep.depend()</code> 的时候， 调用了 <code>Dep</code> 类的<code>depend</code> 方法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Dep.prototype.depend = <span class="function"><span class="keyword">function</span> <span class="title">depend</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">    Dep.target.addDep(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>这里的<code>Dep.target</code> 是我们之前将<code>watcher</code> 赋值的那一个， 当调用 <code>Watcher</code> 上面的 <code>addDep</code> 方法的时候， 是将当前的<code>dep</code> 传入  <code>watcher</code> 实例中的 <code>newDeps</code> 属性， 并且， 当前<code>dep</code> 实例上面的 <code>addSub</code> 方法将会将 <code>Watcher</code> 存放到 这个实例的 <code>subs</code> 属性上面。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Watcher.prototype.addDep = <span class="function"><span class="keyword">function</span> <span class="title">addDep</span> (<span class="params">dep</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> id = dep.id;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.newDepIds.add(id);</span><br><span class="line">    <span class="keyword">this</span>.newDeps.push(dep);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</span><br><span class="line">      dep.addSub(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h5 id="当依赖收集完毕之后，-当监听的值发生变化的时候，通知依赖发生变化：">当依赖收集完毕之后， 当监听的值发生变化的时候，通知依赖发生变化：</h5>当监听的数据发生变化的时候， 会调用这个数据的 <code>set</code> 属性：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line">  <span class="comment">//  获取到原来的值</span></span><br><span class="line">  <span class="keyword">var</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">  <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">  <span class="comment">// 当要监听的数据没有发生变化的时候， 返回</span></span><br><span class="line">  <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">  <span class="keyword">if</span> (customSetter) &#123;</span><br><span class="line">    customSetter();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">  <span class="keyword">if</span> (getter &amp;&amp; !setter) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">    setter.call(obj, newVal);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    val = newVal;</span><br><span class="line">  &#125;</span><br><span class="line">  childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">  <span class="comment">//  通知依赖发生变化</span></span><br><span class="line">  dep.notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><code>dep.notify()</code> 是用来通知依赖发生变化的,  调用了 <code>dep</code> 实例上面的 <code>notify</code>  方法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Dep.prototype.notify = <span class="function"><span class="keyword">function</span> <span class="title">notify</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">  <span class="keyword">var</span> subs = <span class="keyword">this</span>.subs.slice();</span><br><span class="line">  <span class="keyword">if</span> (!config.async) &#123;</span><br><span class="line">    <span class="comment">// subs aren't sorted in scheduler if not running async</span></span><br><span class="line">    <span class="comment">// we need to sort them now to make sure they fire in correct</span></span><br><span class="line">    <span class="comment">// order</span></span><br><span class="line">    subs.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a.id - b.id; &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// subs 中存放的是 watcher ， 调用了 watcher 实例的  update 方法。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">    subs[i].update();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Watcher.prototype.update = <span class="function"><span class="keyword">function</span> <span class="title">update</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">    <span class="keyword">this</span>.run();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 调用  queueWatcher </span></span><br><span class="line">    queueWatcher(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>在 <code>queueWatcher</code> 方法中， 将当前变动的所有 <code>watcher</code> 存放数组 <code>queue</code>  中：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Push a watcher into the watcher queue.</span></span><br><span class="line"><span class="comment">  * Jobs with duplicate IDs will be skipped unless it's</span></span><br><span class="line"><span class="comment">  * pushed when the queue is being flushed.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span> (<span class="params">watcher</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> id = watcher.id;</span><br><span class="line">   <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">     has[id] = <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">       <span class="comment">// 将 watcher 存入</span></span><br><span class="line">       queue.push(watcher);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// if already flushing, splice the watcher based on its id</span></span><br><span class="line">       <span class="comment">// if already past its id, it will be run next immediately.</span></span><br><span class="line">       <span class="keyword">var</span> i = queue.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">         i--;</span><br><span class="line">       &#125;</span><br><span class="line">       queue.splice(i + <span class="number">1</span>, <span class="number">0</span>, watcher);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// queue the flush</span></span><br><span class="line">     <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">       waiting = <span class="literal">true</span>;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">if</span> (!config.async) &#123;</span><br><span class="line">         flushSchedulerQueue();</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">       &#125;</span><br><span class="line">       nextTick(flushSchedulerQueue);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="执行-watch-中数据变动之后的函数回调：调用。flushschedulerqueue">执行 <code>watch</code> 中数据变动之后的函数回调：调用。<code>flushSchedulerQueue</code></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushSchedulerQueue</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  currentFlushTimestamp = getNow();</span><br><span class="line">  flushing = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">var</span> watcher, id;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// Sort queue before flush.</span></span><br><span class="line">  <span class="comment">// This ensures that:</span></span><br><span class="line">  <span class="comment">// 1. Components are updated from parent to child. (because parent is always</span></span><br><span class="line">  <span class="comment">//    created before the child)</span></span><br><span class="line">  <span class="comment">// 2. A component's user watchers are run before its render watcher (because</span></span><br><span class="line">  <span class="comment">//    user watchers are created before the render watcher)</span></span><br><span class="line">  <span class="comment">// 3. If a component is destroyed during a parent component's watcher run,</span></span><br><span class="line">  <span class="comment">//    its watchers can be skipped.</span></span><br><span class="line">  queue.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a.id - b.id; &#125;);</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// do not cache length because more watchers might be pushed</span></span><br><span class="line">  <span class="comment">// as we run existing watchers</span></span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; queue.length; index++) &#123;</span><br><span class="line">    watcher = queue[index];</span><br><span class="line">    <span class="keyword">if</span> (watcher.before) &#123;</span><br><span class="line">      watcher.before();</span><br><span class="line">    &#125;</span><br><span class="line">    id = watcher.id;</span><br><span class="line">    has[id] = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 调用 watcher 实例上面的  run 方法</span></span><br><span class="line">    watcher.run();</span><br><span class="line">    <span class="comment">// in dev build, check and stop circular updates.</span></span><br><span class="line">    <span class="keyword">if</span> (has[id] != <span class="literal">null</span>) &#123;</span><br><span class="line">      circular[id] = (circular[id] || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (circular[id] &gt; MAX_UPDATE_COUNT) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'You may have an infinite update loop '</span> + (</span><br><span class="line">            watcher.user</span><br><span class="line">              ? (<span class="string">"in watcher with expression \""</span> + (watcher.expression) + <span class="string">"\""</span>)</span><br><span class="line">              : <span class="string">"in a component render function."</span></span><br><span class="line">          ),</span><br><span class="line">          watcher.vm</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>调用 <code>watcher.run</code>  方法之后， 如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Watcher.prototype.run = <span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">      <span class="keyword">var</span> value = <span class="keyword">this</span>.get();</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        value !== <span class="keyword">this</span>.value ||</span><br><span class="line">        <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">        <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">        <span class="comment">// have mutated.</span></span><br><span class="line">        isObject(value) ||</span><br><span class="line">        <span class="keyword">this</span>.deep</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// set new value</span></span><br><span class="line">        <span class="keyword">var</span> oldValue = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            handleError(e, <span class="keyword">this</span>.vm, (<span class="string">"callback for watcher \""</span> + (<span class="keyword">this</span>.expression) + <span class="string">"\""</span>));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 调用 watch 之后的函数方法， 传入的两个值， 当前变动的值和之前的值</span></span><br><span class="line">          <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>最终， 调用<code>this.cb.call(this.vm, value, oldValue);</code>执行当监听的数据发生变化时候的回调函数， 调用的时候传入两个参数： value &amp;&amp; oldValue, 表示当前的值和变化之前的值。</li></ol>补充： deep 方法是如何起作用的：当我们设定 <code>deep</code> 为 true 的时候， 这个时候， 当对象中的某个属性发生变化的时候， 也会被监听到变动， 关于  <code>deep</code> 为 true 的代码在下面：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Watcher.prototype.get = <span class="function"><span class="keyword">function</span> <span class="title">get</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   pushTarget(<span class="keyword">this</span>);</span><br><span class="line">   <span class="keyword">var</span> value;</span><br><span class="line">   <span class="keyword">var</span> vm = <span class="keyword">this</span>.vm;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// 调用 getter, 搜集依赖</span></span><br><span class="line">     value = <span class="keyword">this</span>.getter.call(vm, vm);</span><br><span class="line">     <span class="comment">// console.log('this.value', value);</span></span><br><span class="line">   &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">       handleError(e, vm, (<span class="string">"getter for watcher \""</span> + (<span class="keyword">this</span>.expression) + <span class="string">"\""</span>));</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">throw</span> e</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="comment">// "touch" every property so they are all tracked as</span></span><br><span class="line">     <span class="comment">// dependencies for deep watching</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">       traverse(value);</span><br><span class="line">     &#125;</span><br><span class="line">     popTarget();</span><br><span class="line">     <span class="keyword">this</span>.cleanupDeps();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> value</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>正如上面注释写明的一样， 当  <code>deep</code> 为 true 的时候， 调用 <code>traverse </code>   方法， 这个方法的作用是出发对象中每一个属性的  <code>get</code> 方法， 从而让他们的依赖得以收集：traverse. 方法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归调用对象中的属性， 通过 val[i]  或者  val[key[i]] 触发 get 方法  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverse</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    _traverse(val, seenObjects);</span><br><span class="line">    seenObjects.clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_traverse</span> (<span class="params">val, seen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i, keys;</span><br><span class="line">    <span class="keyword">var</span> isA = <span class="built_in">Array</span>.isArray(val);</span><br><span class="line">    <span class="keyword">if</span> ((!isA &amp;&amp; !isObject(val)) || <span class="built_in">Object</span>.isFrozen(val) || val <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (val.__ob__) &#123;</span><br><span class="line">      <span class="keyword">var</span> depId = val.__ob__.dep.id;</span><br><span class="line">      <span class="keyword">if</span> (seen.has(depId)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      seen.add(depId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isA) &#123;</span><br><span class="line">      i = val.length;</span><br><span class="line">      <span class="keyword">while</span> (i--) &#123; _traverse(val[i], seen); &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      keys = <span class="built_in">Object</span>.keys(val);</span><br><span class="line">      i = keys.length;</span><br><span class="line">      <span class="comment">// val[key[i]] 这里是关键</span></span><br><span class="line">      <span class="keyword">while</span> (i--) &#123; _traverse(val[keys[i]], seen); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;watch-方法&quot;&gt;watch 方法&lt;/h3&gt;
vue 的 watch 方法用来监听 vue 中 data 的变动, 可以接受一个函数， 对象， 字符串， 或者数组。&lt;code&gt;watch&lt;/code&gt; 方法接受两个参数： &lt;code&gt;deep&lt;/code&gt;  &amp;
      
    
    </summary>
    
      <category term="vue 源码阅读" scheme="https://newpromise.github.io/categories/vue-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="vue 源码" scheme="https://newpromise.github.io/tags/vue-%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
</feed>
